
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001e0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	; (800027c <endfiniloop+0x6>)
                msr     PSP, r0
 80001e4:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001e8:	4825      	ldr	r0, [pc, #148]	; (8000280 <endfiniloop+0xa>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001ea:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001ee:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80001fe:	f000 f86f 	bl	80002e0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f007 f8d5 	bl	80073b0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	491e      	ldr	r1, [pc, #120]	; (8000284 <endfiniloop+0xe>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1e      	ldr	r2, [pc, #120]	; (8000288 <endfiniloop+0x12>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491c      	ldr	r1, [pc, #112]	; (800028c <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 800021a:	4a18      	ldr	r2, [pc, #96]	; (800027c <endfiniloop+0x6>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000226:	491a      	ldr	r1, [pc, #104]	; (8000290 <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8000228:	4a1a      	ldr	r2, [pc, #104]	; (8000294 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 800022a:	4b1b      	ldr	r3, [pc, #108]	; (8000298 <endfiniloop+0x22>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 800023c:	4917      	ldr	r1, [pc, #92]	; (800029c <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 800023e:	4a18      	ldr	r2, [pc, #96]	; (80002a0 <endfiniloop+0x2a>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f000 f869 	bl	8000320 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f000 f857 	bl	8000300 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000252:	4c14      	ldr	r4, [pc, #80]	; (80002a4 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 8000254:	4d14      	ldr	r5, [pc, #80]	; (80002a8 <endfiniloop+0x32>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f00d fa45 	bl	800d6f0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000266:	4c11      	ldr	r4, [pc, #68]	; (80002ac <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000268:	4d11      	ldr	r5, [pc, #68]	; (80002b0 <endfiniloop+0x3a>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f000 b84b 	b.w	8000310 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 800027c:	20000800 	.word	0x20000800
                msr     PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 8000280:	08000000 	.word	0x08000000
#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000284:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 8000288:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800028c:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000290:	0800fb88 	.word	0x0800fb88
                ldr     r2, =_data_start
 8000294:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 8000298:	200008b8 	.word	0x200008b8

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 800029c:	200008b8 	.word	0x200008b8
                ldr     r2, =_bss_end
 80002a0:	20001350 	.word	0x20001350
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002a4:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002a8:	080001e0 	.word	0x080001e0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end
 80002b0:	080001e0 	.word	0x080001e0

080002b4 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002b8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002bc:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002be:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c4 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002c4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002c6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002ca:	4628      	mov	r0, r5
                blx     r4
 80002cc:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002ce:	2000      	movs	r0, #0
                bl      chThdExit
 80002d0:	f001 f966 	bl	80015a0 <chThdExit>

080002d4 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002d4:	f000 fec4 	bl	8001060 <chSchDoReschedule>

080002d8 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002d8:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002da:	e7fe      	b.n	80002da <_port_exit_from_isr+0x2>
 80002dc:	0000      	movs	r0, r0
	...

080002e0 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80002e0:	4770      	bx	lr
 80002e2:	bf00      	nop
 80002e4:	f3af 8000 	nop.w
 80002e8:	f3af 8000 	nop.w
 80002ec:	f3af 8000 	nop.w
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __early_init(void) {}
 80002f0:	4770      	bx	lr
 80002f2:	bf00      	nop
 80002f4:	f3af 8000 	nop.w
 80002f8:	f3af 8000 	nop.w
 80002fc:	f3af 8000 	nop.w

08000300 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000300:	4770      	bx	lr
 8000302:	bf00      	nop
 8000304:	f3af 8000 	nop.w
 8000308:	f3af 8000 	nop.w
 800030c:	f3af 8000 	nop.w

08000310 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000310:	e7fe      	b.n	8000310 <__default_exit>
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w

08000320 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000320:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000322:	4b16      	ldr	r3, [pc, #88]	; (800037c <__init_ram_areas+0x5c>)
 8000324:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000326:	9b03      	ldr	r3, [sp, #12]
 8000328:	681b      	ldr	r3, [r3, #0]
 800032a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800032c:	9b03      	ldr	r3, [sp, #12]
 800032e:	685b      	ldr	r3, [r3, #4]
 8000330:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000332:	e009      	b.n	8000348 <__init_ram_areas+0x28>
      *p = *tp;
 8000334:	9b02      	ldr	r3, [sp, #8]
 8000336:	681a      	ldr	r2, [r3, #0]
 8000338:	9b01      	ldr	r3, [sp, #4]
 800033a:	601a      	str	r2, [r3, #0]
      p++;
 800033c:	9b01      	ldr	r3, [sp, #4]
 800033e:	3304      	adds	r3, #4
 8000340:	9301      	str	r3, [sp, #4]
      tp++;
 8000342:	9b02      	ldr	r3, [sp, #8]
 8000344:	3304      	adds	r3, #4
 8000346:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000348:	9b03      	ldr	r3, [sp, #12]
 800034a:	689a      	ldr	r2, [r3, #8]
 800034c:	9b01      	ldr	r3, [sp, #4]
 800034e:	429a      	cmp	r2, r3
 8000350:	d8f0      	bhi.n	8000334 <__init_ram_areas+0x14>
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000352:	e005      	b.n	8000360 <__init_ram_areas+0x40>
      *p = 0;
 8000354:	9b01      	ldr	r3, [sp, #4]
 8000356:	2200      	movs	r2, #0
 8000358:	601a      	str	r2, [r3, #0]
      p++;
 800035a:	9b01      	ldr	r3, [sp, #4]
 800035c:	3304      	adds	r3, #4
 800035e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000360:	9b03      	ldr	r3, [sp, #12]
 8000362:	68da      	ldr	r2, [r3, #12]
 8000364:	9b01      	ldr	r3, [sp, #4]
 8000366:	429a      	cmp	r2, r3
 8000368:	d8f4      	bhi.n	8000354 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800036a:	9b03      	ldr	r3, [sp, #12]
 800036c:	3310      	adds	r3, #16
 800036e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000370:	9b03      	ldr	r3, [sp, #12]
 8000372:	4a03      	ldr	r2, [pc, #12]	; (8000380 <__init_ram_areas+0x60>)
 8000374:	4293      	cmp	r3, r2
 8000376:	d3d6      	bcc.n	8000326 <__init_ram_areas+0x6>
#endif
}
 8000378:	b004      	add	sp, #16
 800037a:	4770      	bx	lr
 800037c:	0800de00 	.word	0x0800de00
 8000380:	0800de80 	.word	0x0800de80
	...

08000390 <BusFault_Handler>:
__attribute__((weak))
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 8000390:	e7fe      	b.n	8000390 <BusFault_Handler>
 8000392:	bf00      	nop
	...

080003a0 <NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80003a0:	b084      	sub	sp, #16
 80003a2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80003a4:	9b01      	ldr	r3, [sp, #4]
 80003a6:	f003 0307 	and.w	r3, r3, #7
 80003aa:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003ac:	4b0a      	ldr	r3, [pc, #40]	; (80003d8 <NVIC_SetPriorityGrouping+0x38>)
 80003ae:	68db      	ldr	r3, [r3, #12]
 80003b0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80003b2:	9a02      	ldr	r2, [sp, #8]
 80003b4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80003b8:	4013      	ands	r3, r2
 80003ba:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80003bc:	9b03      	ldr	r3, [sp, #12]
 80003be:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80003c0:	9b02      	ldr	r3, [sp, #8]
 80003c2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80003c4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80003c8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003cc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003ce:	4a02      	ldr	r2, [pc, #8]	; (80003d8 <NVIC_SetPriorityGrouping+0x38>)
 80003d0:	9b02      	ldr	r3, [sp, #8]
 80003d2:	60d3      	str	r3, [r2, #12]
}
 80003d4:	b004      	add	sp, #16
 80003d6:	4770      	bx	lr
 80003d8:	e000ed00 	.word	0xe000ed00
 80003dc:	f3af 8000 	nop.w

080003e0 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80003e0:	b082      	sub	sp, #8
 80003e2:	4603      	mov	r3, r0
 80003e4:	9100      	str	r1, [sp, #0]
 80003e6:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) < 0)
 80003ea:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 80003ee:	2b00      	cmp	r3, #0
 80003f0:	da0c      	bge.n	800040c <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003f2:	490c      	ldr	r1, [pc, #48]	; (8000424 <NVIC_SetPriority+0x44>)
 80003f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80003f8:	f003 030f 	and.w	r3, r3, #15
 80003fc:	3b04      	subs	r3, #4
 80003fe:	9a00      	ldr	r2, [sp, #0]
 8000400:	b2d2      	uxtb	r2, r2
 8000402:	0112      	lsls	r2, r2, #4
 8000404:	b2d2      	uxtb	r2, r2
 8000406:	440b      	add	r3, r1
 8000408:	761a      	strb	r2, [r3, #24]
 800040a:	e009      	b.n	8000420 <NVIC_SetPriority+0x40>
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800040c:	4906      	ldr	r1, [pc, #24]	; (8000428 <NVIC_SetPriority+0x48>)
 800040e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000412:	9a00      	ldr	r2, [sp, #0]
 8000414:	b2d2      	uxtb	r2, r2
 8000416:	0112      	lsls	r2, r2, #4
 8000418:	b2d2      	uxtb	r2, r2
 800041a:	440b      	add	r3, r1
 800041c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000420:	b002      	add	sp, #8
 8000422:	4770      	bx	lr
 8000424:	e000ed00 	.word	0xe000ed00
 8000428:	e000e100 	.word	0xe000e100
 800042c:	f3af 8000 	nop.w

08000430 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8000430:	b508      	push	{r3, lr}

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8000432:	2003      	movs	r0, #3
 8000434:	f7ff ffb4 	bl	80003a0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000438:	4a0b      	ldr	r2, [pc, #44]	; (8000468 <port_init+0x38>)
 800043a:	4b0b      	ldr	r3, [pc, #44]	; (8000468 <port_init+0x38>)
 800043c:	68db      	ldr	r3, [r3, #12]
 800043e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000442:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000444:	4a09      	ldr	r2, [pc, #36]	; (800046c <port_init+0x3c>)
 8000446:	4b09      	ldr	r3, [pc, #36]	; (800046c <port_init+0x3c>)
 8000448:	681b      	ldr	r3, [r3, #0]
 800044a:	f043 0301 	orr.w	r3, r3, #1
 800044e:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8000450:	f06f 0004 	mvn.w	r0, #4
 8000454:	2101      	movs	r1, #1
 8000456:	f7ff ffc3 	bl	80003e0 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800045a:	f06f 0001 	mvn.w	r0, #1
 800045e:	2102      	movs	r1, #2
 8000460:	f7ff ffbe 	bl	80003e0 <NVIC_SetPriority>

    /* MPU is enabled.*/
    mpuEnable(MPU_CTRL_PRIVDEFENA);
  }
#endif
}
 8000464:	bd08      	pop	{r3, pc}
 8000466:	bf00      	nop
 8000468:	e000edf0 	.word	0xe000edf0
 800046c:	e0001000 	.word	0xe0001000

08000470 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 8000470:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8000472:	f3ef 8311 	mrs	r3, BASEPRI
 8000476:	9300      	str	r3, [sp, #0]
  return(result);
 8000478:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800047a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800047c:	9b01      	ldr	r3, [sp, #4]
}
 800047e:	4618      	mov	r0, r3
 8000480:	b002      	add	sp, #8
 8000482:	4770      	bx	lr
 8000484:	f3af 8000 	nop.w
 8000488:	f3af 8000 	nop.w
 800048c:	f3af 8000 	nop.w

08000490 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retval false        the word specified a disabled interrupts status.
 * @retval true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 8000490:	b082      	sub	sp, #8
 8000492:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 8000494:	9b01      	ldr	r3, [sp, #4]
 8000496:	2b00      	cmp	r3, #0
 8000498:	bf0c      	ite	eq
 800049a:	2301      	moveq	r3, #1
 800049c:	2300      	movne	r3, #0
 800049e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004a0:	4618      	mov	r0, r3
 80004a2:	b002      	add	sp, #8
 80004a4:	4770      	bx	lr
 80004a6:	bf00      	nop
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 80004b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80004b2:	f3ef 8305 	mrs	r3, IPSR
 80004b6:	9301      	str	r3, [sp, #4]
  return(result);
 80004b8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80004ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80004be:	2b00      	cmp	r3, #0
 80004c0:	bf14      	ite	ne
 80004c2:	2301      	movne	r3, #1
 80004c4:	2300      	moveq	r3, #0
 80004c6:	b2db      	uxtb	r3, r3
}
 80004c8:	4618      	mov	r0, r3
 80004ca:	b002      	add	sp, #8
 80004cc:	4770      	bx	lr
 80004ce:	bf00      	nop

080004d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80004d0:	b082      	sub	sp, #8
 80004d2:	2320      	movs	r3, #32
 80004d4:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004d6:	9b01      	ldr	r3, [sp, #4]
 80004d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004dc:	b002      	add	sp, #8
 80004de:	4770      	bx	lr

080004e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80004e0:	b082      	sub	sp, #8
 80004e2:	2300      	movs	r3, #0
 80004e4:	9301      	str	r3, [sp, #4]
 80004e6:	9b01      	ldr	r3, [sp, #4]
 80004e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004ec:	b002      	add	sp, #8
 80004ee:	4770      	bx	lr

080004f0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80004f0:	b508      	push	{r3, lr}

  port_lock();
 80004f2:	f7ff ffed 	bl	80004d0 <port_lock>
}
 80004f6:	bd08      	pop	{r3, pc}
 80004f8:	f3af 8000 	nop.w
 80004fc:	f3af 8000 	nop.w

08000500 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000500:	b508      	push	{r3, lr}

  port_unlock();
 8000502:	f7ff ffed 	bl	80004e0 <port_unlock>
}
 8000506:	bd08      	pop	{r3, pc}
 8000508:	f3af 8000 	nop.w
 800050c:	f3af 8000 	nop.w

08000510 <port_disable>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000510:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000512:	4770      	bx	lr
 8000514:	f3af 8000 	nop.w
 8000518:	f3af 8000 	nop.w
 800051c:	f3af 8000 	nop.w

08000520 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000520:	b082      	sub	sp, #8
 8000522:	2300      	movs	r3, #0
 8000524:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800052c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800052e:	b002      	add	sp, #8
 8000530:	4770      	bx	lr
 8000532:	bf00      	nop
 8000534:	f3af 8000 	nop.w
 8000538:	f3af 8000 	nop.w
 800053c:	f3af 8000 	nop.w

08000540 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000540:	4770      	bx	lr
 8000542:	bf00      	nop
 8000544:	f3af 8000 	nop.w
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000550:	4b01      	ldr	r3, [pc, #4]	; (8000558 <port_rt_get_counter_value+0x8>)
 8000552:	685b      	ldr	r3, [r3, #4]
}
 8000554:	4618      	mov	r0, r3
 8000556:	4770      	bx	lr
 8000558:	e0001000 	.word	0xe0001000
 800055c:	f3af 8000 	nop.w

08000560 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000564:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8000566:	4618      	mov	r0, r3
 8000568:	4770      	bx	lr
 800056a:	bf00      	nop
 800056c:	f3af 8000 	nop.w

08000570 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8000570:	b508      	push	{r3, lr}

  stStopAlarm();
 8000572:	f003 fca5 	bl	8003ec0 <stStopAlarm>
}
 8000576:	bd08      	pop	{r3, pc}
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8000580:	b500      	push	{lr}
 8000582:	b083      	sub	sp, #12
 8000584:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8000586:	9801      	ldr	r0, [sp, #4]
 8000588:	f003 fca2 	bl	8003ed0 <stSetAlarm>
}
 800058c:	b003      	add	sp, #12
 800058e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000592:	bf00      	nop
 8000594:	f3af 8000 	nop.w
 8000598:	f3af 8000 	nop.w
 800059c:	f3af 8000 	nop.w

080005a0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80005a0:	b508      	push	{r3, lr}

  return stGetCounter();
 80005a2:	f7ff ffdd 	bl	8000560 <st_lld_get_counter>
 80005a6:	4603      	mov	r3, r0
}
 80005a8:	4618      	mov	r0, r3
 80005aa:	bd08      	pop	{r3, pc}
 80005ac:	f3af 8000 	nop.w

080005b0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80005b0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80005b2:	f7ff ffb5 	bl	8000520 <port_enable>
}
 80005b6:	bd08      	pop	{r3, pc}
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80005c0:	b508      	push	{r3, lr}

  port_lock();
 80005c2:	f7ff ff85 	bl	80004d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80005c6:	bd08      	pop	{r3, pc}
 80005c8:	f3af 8000 	nop.w
 80005cc:	f3af 8000 	nop.w

080005d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80005d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80005d2:	f7ff ff85 	bl	80004e0 <port_unlock>
}
 80005d6:	bd08      	pop	{r3, pc}
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80005e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80005e2:	f7ff ff85 	bl	80004f0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80005e6:	bd08      	pop	{r3, pc}
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80005f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80005f2:	f7ff ff85 	bl	8000500 <port_unlock_from_isr>
}
 80005f6:	bd08      	pop	{r3, pc}
 80005f8:	f3af 8000 	nop.w
 80005fc:	f3af 8000 	nop.w

08000600 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8000600:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8000602:	f7ff ffcd 	bl	80005a0 <port_timer_get_time>
 8000606:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000608:	4618      	mov	r0, r3
 800060a:	bd08      	pop	{r3, pc}
 800060c:	f3af 8000 	nop.w

08000610 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8000610:	b500      	push	{lr}
 8000612:	b085      	sub	sp, #20
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000614:	4b2a      	ldr	r3, [pc, #168]	; (80006c0 <chVTDoTickI+0xb0>)
 8000616:	69db      	ldr	r3, [r3, #28]
 8000618:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800061a:	f7ff fff1 	bl	8000600 <chVTGetSystemTimeX>
 800061e:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000620:	e02a      	b.n	8000678 <chVTDoTickI+0x68>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000622:	4b27      	ldr	r3, [pc, #156]	; (80006c0 <chVTDoTickI+0xb0>)
 8000624:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000626:	9b03      	ldr	r3, [sp, #12]
 8000628:	689b      	ldr	r3, [r3, #8]
 800062a:	4413      	add	r3, r2
 800062c:	4a24      	ldr	r2, [pc, #144]	; (80006c0 <chVTDoTickI+0xb0>)
 800062e:	6293      	str	r3, [r2, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000630:	9b03      	ldr	r3, [sp, #12]
 8000632:	681b      	ldr	r3, [r3, #0]
 8000634:	4a23      	ldr	r2, [pc, #140]	; (80006c4 <chVTDoTickI+0xb4>)
 8000636:	605a      	str	r2, [r3, #4]
    ch.vtlist.next = vtp->next;
 8000638:	9b03      	ldr	r3, [sp, #12]
 800063a:	681b      	ldr	r3, [r3, #0]
 800063c:	4a20      	ldr	r2, [pc, #128]	; (80006c0 <chVTDoTickI+0xb0>)
 800063e:	61d3      	str	r3, [r2, #28]
    fn = vtp->func;
 8000640:	9b03      	ldr	r3, [sp, #12]
 8000642:	68db      	ldr	r3, [r3, #12]
 8000644:	9300      	str	r3, [sp, #0]
    vtp->func = NULL;
 8000646:	9b03      	ldr	r3, [sp, #12]
 8000648:	2200      	movs	r2, #0
 800064a:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800064c:	4b1c      	ldr	r3, [pc, #112]	; (80006c0 <chVTDoTickI+0xb0>)
 800064e:	69db      	ldr	r3, [r3, #28]
 8000650:	4a1c      	ldr	r2, [pc, #112]	; (80006c4 <chVTDoTickI+0xb4>)
 8000652:	4293      	cmp	r3, r2
 8000654:	d101      	bne.n	800065a <chVTDoTickI+0x4a>
      port_timer_stop_alarm();
 8000656:	f7ff ff8b 	bl	8000570 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800065a:	f7ff ffc9 	bl	80005f0 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800065e:	9b03      	ldr	r3, [sp, #12]
 8000660:	691a      	ldr	r2, [r3, #16]
 8000662:	9b00      	ldr	r3, [sp, #0]
 8000664:	4610      	mov	r0, r2
 8000666:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8000668:	f7ff ffba 	bl	80005e0 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800066c:	4b14      	ldr	r3, [pc, #80]	; (80006c0 <chVTDoTickI+0xb0>)
 800066e:	69db      	ldr	r3, [r3, #28]
 8000670:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8000672:	f7ff ffc5 	bl	8000600 <chVTGetSystemTimeX>
 8000676:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000678:	9b03      	ldr	r3, [sp, #12]
 800067a:	689a      	ldr	r2, [r3, #8]
 800067c:	4b10      	ldr	r3, [pc, #64]	; (80006c0 <chVTDoTickI+0xb0>)
 800067e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000680:	9902      	ldr	r1, [sp, #8]
 8000682:	1acb      	subs	r3, r1, r3
 8000684:	429a      	cmp	r2, r3
 8000686:	d9cc      	bls.n	8000622 <chVTDoTickI+0x12>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000688:	4b0d      	ldr	r3, [pc, #52]	; (80006c0 <chVTDoTickI+0xb0>)
 800068a:	69db      	ldr	r3, [r3, #28]
 800068c:	4a0d      	ldr	r2, [pc, #52]	; (80006c4 <chVTDoTickI+0xb4>)
 800068e:	4293      	cmp	r3, r2
 8000690:	d100      	bne.n	8000694 <chVTDoTickI+0x84>
    return;
 8000692:	e012      	b.n	80006ba <chVTDoTickI+0xaa>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000694:	4b0a      	ldr	r3, [pc, #40]	; (80006c0 <chVTDoTickI+0xb0>)
 8000696:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000698:	9b03      	ldr	r3, [sp, #12]
 800069a:	689b      	ldr	r3, [r3, #8]
 800069c:	441a      	add	r2, r3
 800069e:	9b02      	ldr	r3, [sp, #8]
 80006a0:	1ad3      	subs	r3, r2, r3
 80006a2:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80006a4:	9b01      	ldr	r3, [sp, #4]
 80006a6:	2b01      	cmp	r3, #1
 80006a8:	d801      	bhi.n	80006ae <chVTDoTickI+0x9e>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80006aa:	2302      	movs	r3, #2
 80006ac:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 80006ae:	9a02      	ldr	r2, [sp, #8]
 80006b0:	9b01      	ldr	r3, [sp, #4]
 80006b2:	4413      	add	r3, r2
 80006b4:	4618      	mov	r0, r3
 80006b6:	f7ff ff63 	bl	8000580 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
              (now + delta - ch.vtlist.lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80006ba:	b005      	add	sp, #20
 80006bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80006c0:	20000af8 	.word	0x20000af8
 80006c4:	20000b14 	.word	0x20000b14
 80006c8:	f3af 8000 	nop.w
 80006cc:	f3af 8000 	nop.w

080006d0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80006d0:	b500      	push	{lr}
 80006d2:	b083      	sub	sp, #12
 80006d4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 80006d6:	f7ff ff33 	bl	8000540 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 80006da:	e7fc      	b.n	80006d6 <_idle_thread+0x6>
 80006dc:	f3af 8000 	nop.w

080006e0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80006e0:	b508      	push	{r3, lr}

  _scheduler_init();
 80006e2:	f000 fb2d 	bl	8000d40 <_scheduler_init>
  _vt_init();
 80006e6:	f000 f97b 	bl	80009e0 <_vt_init>
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
  ch.dbg.lock_cnt = (cnt_t)0;
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80006ea:	f001 f971 	bl	80019d0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80006ee:	f002 ff77 	bl	80035e0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80006f2:	f002 ffe5 	bl	80036c0 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80006f6:	480c      	ldr	r0, [pc, #48]	; (8000728 <chSysInit+0x48>)
 80006f8:	490c      	ldr	r1, [pc, #48]	; (800072c <chSysInit+0x4c>)
 80006fa:	2280      	movs	r2, #128	; 0x80
 80006fc:	f000 fe00 	bl	8001300 <_thread_init>
 8000700:	4602      	mov	r2, r0
 8000702:	4b0b      	ldr	r3, [pc, #44]	; (8000730 <chSysInit+0x50>)
 8000704:	619a      	str	r2, [r3, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8000706:	4b0a      	ldr	r3, [pc, #40]	; (8000730 <chSysInit+0x50>)
 8000708:	699b      	ldr	r3, [r3, #24]
 800070a:	2200      	movs	r2, #0
 800070c:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800070e:	4b08      	ldr	r3, [pc, #32]	; (8000730 <chSysInit+0x50>)
 8000710:	699b      	ldr	r3, [r3, #24]
 8000712:	2201      	movs	r2, #1
 8000714:	f883 2020 	strb.w	r2, [r3, #32]

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
 8000718:	f7ff fe8a 	bl	8000430 <port_init>
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->stats);
#endif

  /* It is alive now.*/
  chSysEnable();
 800071c:	f7ff ff48 	bl	80005b0 <chSysEnable>
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8000720:	4804      	ldr	r0, [pc, #16]	; (8000734 <chSysInit+0x54>)
 8000722:	f000 fe7d 	bl	8001420 <chThdCreate>
  }
#endif
}
 8000726:	bd08      	pop	{r3, pc}
 8000728:	20000b28 	.word	0x20000b28
 800072c:	0800dea8 	.word	0x0800dea8
 8000730:	20000af8 	.word	0x20000af8
 8000734:	0800de88 	.word	0x0800de88
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000740:	b500      	push	{lr}
 8000742:	b083      	sub	sp, #12
 8000744:	9001      	str	r0, [sp, #4]

  port_disable();
 8000746:	f7ff fee3 	bl	8000510 <port_disable>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800074a:	4a02      	ldr	r2, [pc, #8]	; (8000754 <chSysHalt+0x14>)
 800074c:	9b01      	ldr	r3, [sp, #4]
 800074e:	62d3      	str	r3, [r2, #44]	; 0x2c
  /* Halt hook code, usually empty.*/
  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000750:	e7fe      	b.n	8000750 <chSysHalt+0x10>
 8000752:	bf00      	nop
 8000754:	20000af8 	.word	0x20000af8
 8000758:	f3af 8000 	nop.w
 800075c:	f3af 8000 	nop.w

08000760 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000760:	b086      	sub	sp, #24
 8000762:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000764:	9b01      	ldr	r3, [sp, #4]
 8000766:	f003 0301 	and.w	r3, r3, #1
 800076a:	2b00      	cmp	r3, #0
 800076c:	d022      	beq.n	80007b4 <chSysIntegrityCheckI+0x54>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800076e:	2300      	movs	r3, #0
 8000770:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.queue.next;
 8000772:	4b3a      	ldr	r3, [pc, #232]	; (800085c <chSysIntegrityCheckI+0xfc>)
 8000774:	681b      	ldr	r3, [r3, #0]
 8000776:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000778:	e005      	b.n	8000786 <chSysIntegrityCheckI+0x26>
      n++;
 800077a:	9b05      	ldr	r3, [sp, #20]
 800077c:	3301      	adds	r3, #1
 800077e:	9305      	str	r3, [sp, #20]
      tp = tp->queue.next;
 8000780:	9b04      	ldr	r3, [sp, #16]
 8000782:	681b      	ldr	r3, [r3, #0]
 8000784:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000786:	9b04      	ldr	r3, [sp, #16]
 8000788:	4a34      	ldr	r2, [pc, #208]	; (800085c <chSysIntegrityCheckI+0xfc>)
 800078a:	4293      	cmp	r3, r2
 800078c:	d1f5      	bne.n	800077a <chSysIntegrityCheckI+0x1a>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800078e:	4b33      	ldr	r3, [pc, #204]	; (800085c <chSysIntegrityCheckI+0xfc>)
 8000790:	685b      	ldr	r3, [r3, #4]
 8000792:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000794:	e005      	b.n	80007a2 <chSysIntegrityCheckI+0x42>
      n--;
 8000796:	9b05      	ldr	r3, [sp, #20]
 8000798:	3b01      	subs	r3, #1
 800079a:	9305      	str	r3, [sp, #20]
      tp = tp->queue.prev;
 800079c:	9b04      	ldr	r3, [sp, #16]
 800079e:	685b      	ldr	r3, [r3, #4]
 80007a0:	9304      	str	r3, [sp, #16]
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80007a2:	9b04      	ldr	r3, [sp, #16]
 80007a4:	4a2d      	ldr	r2, [pc, #180]	; (800085c <chSysIntegrityCheckI+0xfc>)
 80007a6:	4293      	cmp	r3, r2
 80007a8:	d1f5      	bne.n	8000796 <chSysIntegrityCheckI+0x36>
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007aa:	9b05      	ldr	r3, [sp, #20]
 80007ac:	2b00      	cmp	r3, #0
 80007ae:	d001      	beq.n	80007b4 <chSysIntegrityCheckI+0x54>
      return true;
 80007b0:	2301      	movs	r3, #1
 80007b2:	e050      	b.n	8000856 <chSysIntegrityCheckI+0xf6>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80007b4:	9b01      	ldr	r3, [sp, #4]
 80007b6:	f003 0302 	and.w	r3, r3, #2
 80007ba:	2b00      	cmp	r3, #0
 80007bc:	d022      	beq.n	8000804 <chSysIntegrityCheckI+0xa4>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 80007be:	2300      	movs	r3, #0
 80007c0:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.next;
 80007c2:	4b26      	ldr	r3, [pc, #152]	; (800085c <chSysIntegrityCheckI+0xfc>)
 80007c4:	69db      	ldr	r3, [r3, #28]
 80007c6:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007c8:	e005      	b.n	80007d6 <chSysIntegrityCheckI+0x76>
      n++;
 80007ca:	9b05      	ldr	r3, [sp, #20]
 80007cc:	3301      	adds	r3, #1
 80007ce:	9305      	str	r3, [sp, #20]
      vtp = vtp->next;
 80007d0:	9b03      	ldr	r3, [sp, #12]
 80007d2:	681b      	ldr	r3, [r3, #0]
 80007d4:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007d6:	9b03      	ldr	r3, [sp, #12]
 80007d8:	4a21      	ldr	r2, [pc, #132]	; (8000860 <chSysIntegrityCheckI+0x100>)
 80007da:	4293      	cmp	r3, r2
 80007dc:	d1f5      	bne.n	80007ca <chSysIntegrityCheckI+0x6a>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 80007de:	4b1f      	ldr	r3, [pc, #124]	; (800085c <chSysIntegrityCheckI+0xfc>)
 80007e0:	6a1b      	ldr	r3, [r3, #32]
 80007e2:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007e4:	e005      	b.n	80007f2 <chSysIntegrityCheckI+0x92>
      n--;
 80007e6:	9b05      	ldr	r3, [sp, #20]
 80007e8:	3b01      	subs	r3, #1
 80007ea:	9305      	str	r3, [sp, #20]
      vtp = vtp->prev;
 80007ec:	9b03      	ldr	r3, [sp, #12]
 80007ee:	685b      	ldr	r3, [r3, #4]
 80007f0:	9303      	str	r3, [sp, #12]
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007f2:	9b03      	ldr	r3, [sp, #12]
 80007f4:	4a1a      	ldr	r2, [pc, #104]	; (8000860 <chSysIntegrityCheckI+0x100>)
 80007f6:	4293      	cmp	r3, r2
 80007f8:	d1f5      	bne.n	80007e6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007fa:	9b05      	ldr	r3, [sp, #20]
 80007fc:	2b00      	cmp	r3, #0
 80007fe:	d001      	beq.n	8000804 <chSysIntegrityCheckI+0xa4>
      return true;
 8000800:	2301      	movs	r3, #1
 8000802:	e028      	b.n	8000856 <chSysIntegrityCheckI+0xf6>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 8000804:	9b01      	ldr	r3, [sp, #4]
 8000806:	f003 0304 	and.w	r3, r3, #4
 800080a:	2b00      	cmp	r3, #0
 800080c:	d022      	beq.n	8000854 <chSysIntegrityCheckI+0xf4>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800080e:	2300      	movs	r3, #0
 8000810:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.newer;
 8000812:	4b12      	ldr	r3, [pc, #72]	; (800085c <chSysIntegrityCheckI+0xfc>)
 8000814:	691b      	ldr	r3, [r3, #16]
 8000816:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000818:	e005      	b.n	8000826 <chSysIntegrityCheckI+0xc6>
      n++;
 800081a:	9b05      	ldr	r3, [sp, #20]
 800081c:	3301      	adds	r3, #1
 800081e:	9305      	str	r3, [sp, #20]
      tp = tp->newer;
 8000820:	9b02      	ldr	r3, [sp, #8]
 8000822:	691b      	ldr	r3, [r3, #16]
 8000824:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000826:	9b02      	ldr	r3, [sp, #8]
 8000828:	4a0c      	ldr	r2, [pc, #48]	; (800085c <chSysIntegrityCheckI+0xfc>)
 800082a:	4293      	cmp	r3, r2
 800082c:	d1f5      	bne.n	800081a <chSysIntegrityCheckI+0xba>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 800082e:	4b0b      	ldr	r3, [pc, #44]	; (800085c <chSysIntegrityCheckI+0xfc>)
 8000830:	695b      	ldr	r3, [r3, #20]
 8000832:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000834:	e005      	b.n	8000842 <chSysIntegrityCheckI+0xe2>
      n--;
 8000836:	9b05      	ldr	r3, [sp, #20]
 8000838:	3b01      	subs	r3, #1
 800083a:	9305      	str	r3, [sp, #20]
      tp = tp->older;
 800083c:	9b02      	ldr	r3, [sp, #8]
 800083e:	695b      	ldr	r3, [r3, #20]
 8000840:	9302      	str	r3, [sp, #8]
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 8000842:	9b02      	ldr	r3, [sp, #8]
 8000844:	4a05      	ldr	r2, [pc, #20]	; (800085c <chSysIntegrityCheckI+0xfc>)
 8000846:	4293      	cmp	r3, r2
 8000848:	d1f5      	bne.n	8000836 <chSysIntegrityCheckI+0xd6>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800084a:	9b05      	ldr	r3, [sp, #20]
 800084c:	2b00      	cmp	r3, #0
 800084e:	d001      	beq.n	8000854 <chSysIntegrityCheckI+0xf4>
      return true;
 8000850:	2301      	movs	r3, #1
 8000852:	e000      	b.n	8000856 <chSysIntegrityCheckI+0xf6>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8000854:	2300      	movs	r3, #0
}
 8000856:	4618      	mov	r0, r3
 8000858:	b006      	add	sp, #24
 800085a:	4770      	bx	lr
 800085c:	20000af8 	.word	0x20000af8
 8000860:	20000b14 	.word	0x20000b14
 8000864:	f3af 8000 	nop.w
 8000868:	f3af 8000 	nop.w
 800086c:	f3af 8000 	nop.w

08000870 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000870:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
 8000872:	f7ff fecd 	bl	8000610 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8000876:	bd08      	pop	{r3, pc}
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8000880:	b500      	push	{lr}
 8000882:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 8000884:	f7ff fdf4 	bl	8000470 <port_get_irq_status>
 8000888:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800088a:	9801      	ldr	r0, [sp, #4]
 800088c:	f7ff fe00 	bl	8000490 <port_irq_enabled>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	d009      	beq.n	80008aa <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 8000896:	f7ff fe0b 	bl	80004b0 <port_is_isr_context>
 800089a:	4603      	mov	r3, r0
 800089c:	2b00      	cmp	r3, #0
 800089e:	d002      	beq.n	80008a6 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 80008a0:	f7ff fe9e 	bl	80005e0 <chSysLockFromISR>
 80008a4:	e001      	b.n	80008aa <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 80008a6:	f7ff fe8b 	bl	80005c0 <chSysLock>
    }
  }
  return sts;
 80008aa:	9b01      	ldr	r3, [sp, #4]
}
 80008ac:	4618      	mov	r0, r3
 80008ae:	b003      	add	sp, #12
 80008b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 80008c6:	9801      	ldr	r0, [sp, #4]
 80008c8:	f7ff fde2 	bl	8000490 <port_irq_enabled>
 80008cc:	4603      	mov	r3, r0
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d00b      	beq.n	80008ea <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 80008d2:	f7ff fded 	bl	80004b0 <port_is_isr_context>
 80008d6:	4603      	mov	r3, r0
 80008d8:	2b00      	cmp	r3, #0
 80008da:	d002      	beq.n	80008e2 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 80008dc:	f7ff fe88 	bl	80005f0 <chSysUnlockFromISR>
 80008e0:	e003      	b.n	80008ea <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 80008e2:	f000 fb55 	bl	8000f90 <chSchRescheduleS>
      chSysUnlock();
 80008e6:	f7ff fe73 	bl	80005d0 <chSysUnlock>
    }
  }
}
 80008ea:	b003      	add	sp, #12
 80008ec:	f85d fb04 	ldr.w	pc, [sp], #4

080008f0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80008f0:	b084      	sub	sp, #16
 80008f2:	9003      	str	r0, [sp, #12]
 80008f4:	9102      	str	r1, [sp, #8]
 80008f6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80008f8:	9a03      	ldr	r2, [sp, #12]
 80008fa:	9b02      	ldr	r3, [sp, #8]
 80008fc:	1ad2      	subs	r2, r2, r3
 80008fe:	9901      	ldr	r1, [sp, #4]
 8000900:	9b02      	ldr	r3, [sp, #8]
 8000902:	1acb      	subs	r3, r1, r3
 8000904:	429a      	cmp	r2, r3
 8000906:	bf34      	ite	cc
 8000908:	2301      	movcc	r3, #1
 800090a:	2300      	movcs	r3, #0
 800090c:	b2db      	uxtb	r3, r3
}
 800090e:	4618      	mov	r0, r3
 8000910:	b004      	add	sp, #16
 8000912:	4770      	bx	lr
 8000914:	f3af 8000 	nop.w
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000926:	f7ff fe13 	bl	8000550 <port_rt_get_counter_value>
 800092a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800092c:	9a03      	ldr	r2, [sp, #12]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	4413      	add	r3, r2
 8000932:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000934:	bf00      	nop
 8000936:	f7ff fe0b 	bl	8000550 <port_rt_get_counter_value>
 800093a:	4603      	mov	r3, r0
 800093c:	4618      	mov	r0, r3
 800093e:	9903      	ldr	r1, [sp, #12]
 8000940:	9a02      	ldr	r2, [sp, #8]
 8000942:	f7ff ffd5 	bl	80008f0 <chSysIsCounterWithinX>
 8000946:	4603      	mov	r3, r0
 8000948:	2b00      	cmp	r3, #0
 800094a:	d1f4      	bne.n	8000936 <chSysPolledDelayX+0x16>
  }
}
 800094c:	b005      	add	sp, #20
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
	...

08000960 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000960:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000964:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8000966:	4618      	mov	r0, r3
 8000968:	4770      	bx	lr
 800096a:	bf00      	nop
 800096c:	f3af 8000 	nop.w

08000970 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8000970:	b500      	push	{lr}
 8000972:	b083      	sub	sp, #12
 8000974:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8000976:	9801      	ldr	r0, [sp, #4]
 8000978:	f003 fa92 	bl	8003ea0 <stStartAlarm>
}
 800097c:	b003      	add	sp, #12
 800097e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000982:	bf00      	nop
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8000990:	b508      	push	{r3, lr}

  stStopAlarm();
 8000992:	f003 fa95 	bl	8003ec0 <stStopAlarm>
}
 8000996:	bd08      	pop	{r3, pc}
 8000998:	f3af 8000 	nop.w
 800099c:	f3af 8000 	nop.w

080009a0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80009a0:	b500      	push	{lr}
 80009a2:	b083      	sub	sp, #12
 80009a4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 80009a6:	9801      	ldr	r0, [sp, #4]
 80009a8:	f003 fa92 	bl	8003ed0 <stSetAlarm>
}
 80009ac:	b003      	add	sp, #12
 80009ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80009b2:	bf00      	nop
 80009b4:	f3af 8000 	nop.w
 80009b8:	f3af 8000 	nop.w
 80009bc:	f3af 8000 	nop.w

080009c0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80009c0:	b508      	push	{r3, lr}

  return stGetCounter();
 80009c2:	f7ff ffcd 	bl	8000960 <st_lld_get_counter>
 80009c6:	4603      	mov	r3, r0
}
 80009c8:	4618      	mov	r0, r3
 80009ca:	bd08      	pop	{r3, pc}
 80009cc:	f3af 8000 	nop.w

080009d0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80009d0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80009d2:	f7ff fff5 	bl	80009c0 <port_timer_get_time>
 80009d6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80009d8:	4618      	mov	r0, r3
 80009da:	bd08      	pop	{r3, pc}
 80009dc:	f3af 8000 	nop.w

080009e0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80009e0:	4b06      	ldr	r3, [pc, #24]	; (80009fc <_vt_init+0x1c>)
 80009e2:	4a07      	ldr	r2, [pc, #28]	; (8000a00 <_vt_init+0x20>)
 80009e4:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 80009e6:	4b05      	ldr	r3, [pc, #20]	; (80009fc <_vt_init+0x1c>)
 80009e8:	4a05      	ldr	r2, [pc, #20]	; (8000a00 <_vt_init+0x20>)
 80009ea:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 80009ec:	4b03      	ldr	r3, [pc, #12]	; (80009fc <_vt_init+0x1c>)
 80009ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80009f2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 80009f4:	4b01      	ldr	r3, [pc, #4]	; (80009fc <_vt_init+0x1c>)
 80009f6:	2200      	movs	r2, #0
 80009f8:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80009fa:	4770      	bx	lr
 80009fc:	20000af8 	.word	0x20000af8
 8000a00:	20000b14 	.word	0x20000b14
 8000a04:	f3af 8000 	nop.w
 8000a08:	f3af 8000 	nop.w
 8000a0c:	f3af 8000 	nop.w

08000a10 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000a10:	b500      	push	{lr}
 8000a12:	b089      	sub	sp, #36	; 0x24
 8000a14:	9003      	str	r0, [sp, #12]
 8000a16:	9102      	str	r1, [sp, #8]
 8000a18:	9201      	str	r2, [sp, #4]
 8000a1a:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8000a1c:	9b03      	ldr	r3, [sp, #12]
 8000a1e:	9a00      	ldr	r2, [sp, #0]
 8000a20:	611a      	str	r2, [r3, #16]
  vtp->func = vtfunc;
 8000a22:	9b03      	ldr	r3, [sp, #12]
 8000a24:	9a01      	ldr	r2, [sp, #4]
 8000a26:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8000a28:	f7ff ffd2 	bl	80009d0 <chVTGetSystemTimeX>
 8000a2c:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000a2e:	9b02      	ldr	r3, [sp, #8]
 8000a30:	2b01      	cmp	r3, #1
 8000a32:	d801      	bhi.n	8000a38 <chVTDoSetI+0x28>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000a34:	2302      	movs	r3, #2
 8000a36:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000a38:	4b38      	ldr	r3, [pc, #224]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a3a:	69db      	ldr	r3, [r3, #28]
 8000a3c:	4a38      	ldr	r2, [pc, #224]	; (8000b20 <chVTDoSetI+0x110>)
 8000a3e:	4293      	cmp	r3, r2
 8000a40:	d119      	bne.n	8000a76 <chVTDoSetI+0x66>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8000a42:	4a36      	ldr	r2, [pc, #216]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a44:	9b05      	ldr	r3, [sp, #20]
 8000a46:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.next = vtp;
 8000a48:	4a34      	ldr	r2, [pc, #208]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a4a:	9b03      	ldr	r3, [sp, #12]
 8000a4c:	61d3      	str	r3, [r2, #28]
      ch.vtlist.prev = vtp;
 8000a4e:	4a33      	ldr	r2, [pc, #204]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a50:	9b03      	ldr	r3, [sp, #12]
 8000a52:	6213      	str	r3, [r2, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000a54:	9b03      	ldr	r3, [sp, #12]
 8000a56:	4a32      	ldr	r2, [pc, #200]	; (8000b20 <chVTDoSetI+0x110>)
 8000a58:	601a      	str	r2, [r3, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000a5a:	9b03      	ldr	r3, [sp, #12]
 8000a5c:	4a30      	ldr	r2, [pc, #192]	; (8000b20 <chVTDoSetI+0x110>)
 8000a5e:	605a      	str	r2, [r3, #4]
      vtp->delta = delay;
 8000a60:	9b03      	ldr	r3, [sp, #12]
 8000a62:	9a02      	ldr	r2, [sp, #8]
 8000a64:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8000a66:	4b2d      	ldr	r3, [pc, #180]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a68:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000a6a:	9b02      	ldr	r3, [sp, #8]
 8000a6c:	4413      	add	r3, r2
 8000a6e:	4618      	mov	r0, r3
 8000a70:	f7ff ff7e 	bl	8000970 <port_timer_start_alarm>

      return;
 8000a74:	e04f      	b.n	8000b16 <chVTDoSetI+0x106>
    }

    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;
 8000a76:	4b29      	ldr	r3, [pc, #164]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a78:	69db      	ldr	r3, [r3, #28]
 8000a7a:	9307      	str	r3, [sp, #28]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8000a7c:	4b27      	ldr	r3, [pc, #156]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000a80:	9a05      	ldr	r2, [sp, #20]
 8000a82:	1ad2      	subs	r2, r2, r3
 8000a84:	9b02      	ldr	r3, [sp, #8]
 8000a86:	4413      	add	r3, r2
 8000a88:	9306      	str	r3, [sp, #24]

    if (delta < now - ch.vtlist.lasttime) {
 8000a8a:	4b24      	ldr	r3, [pc, #144]	; (8000b1c <chVTDoSetI+0x10c>)
 8000a8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000a8e:	9a05      	ldr	r2, [sp, #20]
 8000a90:	1ad2      	subs	r2, r2, r3
 8000a92:	9b06      	ldr	r3, [sp, #24]
 8000a94:	429a      	cmp	r2, r3
 8000a96:	d908      	bls.n	8000aaa <chVTDoSetI+0x9a>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000a98:	9b07      	ldr	r3, [sp, #28]
 8000a9a:	689b      	ldr	r3, [r3, #8]
 8000a9c:	9a06      	ldr	r2, [sp, #24]
 8000a9e:	1ad3      	subs	r3, r2, r3
 8000aa0:	9306      	str	r3, [sp, #24]
      p = p->next;
 8000aa2:	9b07      	ldr	r3, [sp, #28]
 8000aa4:	681b      	ldr	r3, [r3, #0]
 8000aa6:	9307      	str	r3, [sp, #28]
 8000aa8:	e00b      	b.n	8000ac2 <chVTDoSetI+0xb2>
    }
    else if (delta < p->delta) {
 8000aaa:	9b07      	ldr	r3, [sp, #28]
 8000aac:	689a      	ldr	r2, [r3, #8]
 8000aae:	9b06      	ldr	r3, [sp, #24]
 8000ab0:	429a      	cmp	r2, r3
 8000ab2:	d906      	bls.n	8000ac2 <chVTDoSetI+0xb2>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8000ab4:	4b19      	ldr	r3, [pc, #100]	; (8000b1c <chVTDoSetI+0x10c>)
 8000ab6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000ab8:	9b06      	ldr	r3, [sp, #24]
 8000aba:	4413      	add	r3, r2
 8000abc:	4618      	mov	r0, r3
 8000abe:	f7ff ff6f 	bl	80009a0 <port_timer_set_alarm>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000ac2:	e007      	b.n	8000ad4 <chVTDoSetI+0xc4>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8000ac4:	9b07      	ldr	r3, [sp, #28]
 8000ac6:	689b      	ldr	r3, [r3, #8]
 8000ac8:	9a06      	ldr	r2, [sp, #24]
 8000aca:	1ad3      	subs	r3, r2, r3
 8000acc:	9306      	str	r3, [sp, #24]
    p = p->next;
 8000ace:	9b07      	ldr	r3, [sp, #28]
 8000ad0:	681b      	ldr	r3, [r3, #0]
 8000ad2:	9307      	str	r3, [sp, #28]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000ad4:	9b07      	ldr	r3, [sp, #28]
 8000ad6:	689a      	ldr	r2, [r3, #8]
 8000ad8:	9b06      	ldr	r3, [sp, #24]
 8000ada:	429a      	cmp	r2, r3
 8000adc:	d3f2      	bcc.n	8000ac4 <chVTDoSetI+0xb4>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8000ade:	9b03      	ldr	r3, [sp, #12]
 8000ae0:	9a07      	ldr	r2, [sp, #28]
 8000ae2:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 8000ae4:	9b03      	ldr	r3, [sp, #12]
 8000ae6:	681b      	ldr	r3, [r3, #0]
 8000ae8:	685a      	ldr	r2, [r3, #4]
 8000aea:	9b03      	ldr	r3, [sp, #12]
 8000aec:	605a      	str	r2, [r3, #4]
  vtp->prev->next = vtp;
 8000aee:	9b03      	ldr	r3, [sp, #12]
 8000af0:	685b      	ldr	r3, [r3, #4]
 8000af2:	9a03      	ldr	r2, [sp, #12]
 8000af4:	601a      	str	r2, [r3, #0]
  p->prev = vtp;
 8000af6:	9b07      	ldr	r3, [sp, #28]
 8000af8:	9a03      	ldr	r2, [sp, #12]
 8000afa:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
 8000afc:	9b03      	ldr	r3, [sp, #12]
 8000afe:	9a06      	ldr	r2, [sp, #24]
 8000b00:	609a      	str	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000b02:	9b07      	ldr	r3, [sp, #28]
 8000b04:	689a      	ldr	r2, [r3, #8]
 8000b06:	9b06      	ldr	r3, [sp, #24]
 8000b08:	1ad2      	subs	r2, r2, r3
 8000b0a:	9b07      	ldr	r3, [sp, #28]
 8000b0c:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (systime_t)-1;
 8000b0e:	4b03      	ldr	r3, [pc, #12]	; (8000b1c <chVTDoSetI+0x10c>)
 8000b10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000b14:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000b16:	b009      	add	sp, #36	; 0x24
 8000b18:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b1c:	20000af8 	.word	0x20000af8
 8000b20:	20000b14 	.word	0x20000b14
 8000b24:	f3af 8000 	nop.w
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000b30:	b500      	push	{lr}
 8000b32:	b085      	sub	sp, #20
 8000b34:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000b36:	4b31      	ldr	r3, [pc, #196]	; (8000bfc <chVTDoResetI+0xcc>)
 8000b38:	69da      	ldr	r2, [r3, #28]
 8000b3a:	9b01      	ldr	r3, [sp, #4]
 8000b3c:	429a      	cmp	r2, r3
 8000b3e:	d01c      	beq.n	8000b7a <chVTDoResetI+0x4a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000b40:	9b01      	ldr	r3, [sp, #4]
 8000b42:	685b      	ldr	r3, [r3, #4]
 8000b44:	9a01      	ldr	r2, [sp, #4]
 8000b46:	6812      	ldr	r2, [r2, #0]
 8000b48:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8000b4a:	9b01      	ldr	r3, [sp, #4]
 8000b4c:	681b      	ldr	r3, [r3, #0]
 8000b4e:	9a01      	ldr	r2, [sp, #4]
 8000b50:	6852      	ldr	r2, [r2, #4]
 8000b52:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8000b54:	9b01      	ldr	r3, [sp, #4]
 8000b56:	2200      	movs	r2, #0
 8000b58:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b5a:	9b01      	ldr	r3, [sp, #4]
 8000b5c:	681b      	ldr	r3, [r3, #0]
 8000b5e:	4a28      	ldr	r2, [pc, #160]	; (8000c00 <chVTDoResetI+0xd0>)
 8000b60:	4293      	cmp	r3, r2
 8000b62:	d009      	beq.n	8000b78 <chVTDoResetI+0x48>
      vtp->next->delta += vtp->delta;
 8000b64:	9b01      	ldr	r3, [sp, #4]
 8000b66:	681b      	ldr	r3, [r3, #0]
 8000b68:	9a01      	ldr	r2, [sp, #4]
 8000b6a:	6812      	ldr	r2, [r2, #0]
 8000b6c:	6891      	ldr	r1, [r2, #8]
 8000b6e:	9a01      	ldr	r2, [sp, #4]
 8000b70:	6892      	ldr	r2, [r2, #8]
 8000b72:	440a      	add	r2, r1
 8000b74:	609a      	str	r2, [r3, #8]

    return;
 8000b76:	e03e      	b.n	8000bf6 <chVTDoResetI+0xc6>
 8000b78:	e03d      	b.n	8000bf6 <chVTDoResetI+0xc6>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000b7a:	9b01      	ldr	r3, [sp, #4]
 8000b7c:	681b      	ldr	r3, [r3, #0]
 8000b7e:	4a1f      	ldr	r2, [pc, #124]	; (8000bfc <chVTDoResetI+0xcc>)
 8000b80:	61d3      	str	r3, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000b82:	4b1e      	ldr	r3, [pc, #120]	; (8000bfc <chVTDoResetI+0xcc>)
 8000b84:	69db      	ldr	r3, [r3, #28]
 8000b86:	4a1e      	ldr	r2, [pc, #120]	; (8000c00 <chVTDoResetI+0xd0>)
 8000b88:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 8000b8a:	9b01      	ldr	r3, [sp, #4]
 8000b8c:	2200      	movs	r2, #0
 8000b8e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b90:	4b1a      	ldr	r3, [pc, #104]	; (8000bfc <chVTDoResetI+0xcc>)
 8000b92:	69db      	ldr	r3, [r3, #28]
 8000b94:	4a1a      	ldr	r2, [pc, #104]	; (8000c00 <chVTDoResetI+0xd0>)
 8000b96:	4293      	cmp	r3, r2
 8000b98:	d102      	bne.n	8000ba0 <chVTDoResetI+0x70>
    port_timer_stop_alarm();
 8000b9a:	f7ff fef9 	bl	8000990 <port_timer_stop_alarm>

    return;
 8000b9e:	e02a      	b.n	8000bf6 <chVTDoResetI+0xc6>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000ba0:	4b16      	ldr	r3, [pc, #88]	; (8000bfc <chVTDoResetI+0xcc>)
 8000ba2:	69db      	ldr	r3, [r3, #28]
 8000ba4:	4a15      	ldr	r2, [pc, #84]	; (8000bfc <chVTDoResetI+0xcc>)
 8000ba6:	69d2      	ldr	r2, [r2, #28]
 8000ba8:	6891      	ldr	r1, [r2, #8]
 8000baa:	9a01      	ldr	r2, [sp, #4]
 8000bac:	6892      	ldr	r2, [r2, #8]
 8000bae:	440a      	add	r2, r1
 8000bb0:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000bb2:	f7ff ff0d 	bl	80009d0 <chVTGetSystemTimeX>
 8000bb6:	4602      	mov	r2, r0
 8000bb8:	4b10      	ldr	r3, [pc, #64]	; (8000bfc <chVTDoResetI+0xcc>)
 8000bba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000bbc:	1ad3      	subs	r3, r2, r3
 8000bbe:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000bc0:	4b0e      	ldr	r3, [pc, #56]	; (8000bfc <chVTDoResetI+0xcc>)
 8000bc2:	69db      	ldr	r3, [r3, #28]
 8000bc4:	689a      	ldr	r2, [r3, #8]
 8000bc6:	9b02      	ldr	r3, [sp, #8]
 8000bc8:	429a      	cmp	r2, r3
 8000bca:	d800      	bhi.n	8000bce <chVTDoResetI+0x9e>
    return;
 8000bcc:	e013      	b.n	8000bf6 <chVTDoResetI+0xc6>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000bce:	4b0b      	ldr	r3, [pc, #44]	; (8000bfc <chVTDoResetI+0xcc>)
 8000bd0:	69db      	ldr	r3, [r3, #28]
 8000bd2:	689a      	ldr	r2, [r3, #8]
 8000bd4:	9b02      	ldr	r3, [sp, #8]
 8000bd6:	1ad3      	subs	r3, r2, r3
 8000bd8:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000bda:	9b03      	ldr	r3, [sp, #12]
 8000bdc:	2b01      	cmp	r3, #1
 8000bde:	d801      	bhi.n	8000be4 <chVTDoResetI+0xb4>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000be0:	2302      	movs	r3, #2
 8000be2:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8000be4:	4b05      	ldr	r3, [pc, #20]	; (8000bfc <chVTDoResetI+0xcc>)
 8000be6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000be8:	9b02      	ldr	r3, [sp, #8]
 8000bea:	441a      	add	r2, r3
 8000bec:	9b03      	ldr	r3, [sp, #12]
 8000bee:	4413      	add	r3, r2
 8000bf0:	4618      	mov	r0, r3
 8000bf2:	f7ff fed5 	bl	80009a0 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000bf6:	b005      	add	sp, #20
 8000bf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8000bfc:	20000af8 	.word	0x20000af8
 8000c00:	20000b14 	.word	0x20000b14
	...

08000c10 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000c10:	b082      	sub	sp, #8
 8000c12:	2320      	movs	r3, #32
 8000c14:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000c16:	9b01      	ldr	r3, [sp, #4]
 8000c18:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000c1c:	b002      	add	sp, #8
 8000c1e:	4770      	bx	lr

08000c20 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000c20:	b082      	sub	sp, #8
 8000c22:	2300      	movs	r3, #0
 8000c24:	9301      	str	r3, [sp, #4]
 8000c26:	9b01      	ldr	r3, [sp, #4]
 8000c28:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000c2c:	b002      	add	sp, #8
 8000c2e:	4770      	bx	lr

08000c30 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000c30:	b508      	push	{r3, lr}

  port_lock();
 8000c32:	f7ff ffed 	bl	8000c10 <port_lock>
}
 8000c36:	bd08      	pop	{r3, pc}
 8000c38:	f3af 8000 	nop.w
 8000c3c:	f3af 8000 	nop.w

08000c40 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000c40:	b508      	push	{r3, lr}

  port_unlock();
 8000c42:	f7ff ffed 	bl	8000c20 <port_unlock>
}
 8000c46:	bd08      	pop	{r3, pc}
 8000c48:	f3af 8000 	nop.w
 8000c4c:	f3af 8000 	nop.w

08000c50 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000c50:	b082      	sub	sp, #8
 8000c52:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8000c54:	9b01      	ldr	r3, [sp, #4]
 8000c56:	9a01      	ldr	r2, [sp, #4]
 8000c58:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000c5a:	9b01      	ldr	r3, [sp, #4]
 8000c5c:	9a01      	ldr	r2, [sp, #4]
 8000c5e:	605a      	str	r2, [r3, #4]
}
 8000c60:	b002      	add	sp, #8
 8000c62:	4770      	bx	lr
 8000c64:	f3af 8000 	nop.w
 8000c68:	f3af 8000 	nop.w
 8000c6c:	f3af 8000 	nop.w

08000c70 <queue_fifo_remove>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000c70:	b084      	sub	sp, #16
 8000c72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8000c74:	9b01      	ldr	r3, [sp, #4]
 8000c76:	681b      	ldr	r3, [r3, #0]
 8000c78:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8000c7a:	9b03      	ldr	r3, [sp, #12]
 8000c7c:	681a      	ldr	r2, [r3, #0]
 8000c7e:	9b01      	ldr	r3, [sp, #4]
 8000c80:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000c82:	9b01      	ldr	r3, [sp, #4]
 8000c84:	681b      	ldr	r3, [r3, #0]
 8000c86:	9a01      	ldr	r2, [sp, #4]
 8000c88:	605a      	str	r2, [r3, #4]

  return tp;
 8000c8a:	9b03      	ldr	r3, [sp, #12]
}
 8000c8c:	4618      	mov	r0, r3
 8000c8e:	b004      	add	sp, #16
 8000c90:	4770      	bx	lr
 8000c92:	bf00      	nop
 8000c94:	f3af 8000 	nop.w
 8000c98:	f3af 8000 	nop.w
 8000c9c:	f3af 8000 	nop.w

08000ca0 <queue_dequeue>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ca0:	b082      	sub	sp, #8
 8000ca2:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8000ca4:	9b01      	ldr	r3, [sp, #4]
 8000ca6:	685b      	ldr	r3, [r3, #4]
 8000ca8:	9a01      	ldr	r2, [sp, #4]
 8000caa:	6812      	ldr	r2, [r2, #0]
 8000cac:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000cae:	9b01      	ldr	r3, [sp, #4]
 8000cb0:	681b      	ldr	r3, [r3, #0]
 8000cb2:	9a01      	ldr	r2, [sp, #4]
 8000cb4:	6852      	ldr	r2, [r2, #4]
 8000cb6:	605a      	str	r2, [r3, #4]

  return tp;
 8000cb8:	9b01      	ldr	r3, [sp, #4]
}
 8000cba:	4618      	mov	r0, r3
 8000cbc:	b002      	add	sp, #8
 8000cbe:	4770      	bx	lr

08000cc0 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000cc0:	4b06      	ldr	r3, [pc, #24]	; (8000cdc <chSchIsRescRequiredI+0x1c>)
 8000cc2:	681b      	ldr	r3, [r3, #0]
 8000cc4:	689a      	ldr	r2, [r3, #8]
 8000cc6:	4b05      	ldr	r3, [pc, #20]	; (8000cdc <chSchIsRescRequiredI+0x1c>)
 8000cc8:	699b      	ldr	r3, [r3, #24]
 8000cca:	689b      	ldr	r3, [r3, #8]
 8000ccc:	429a      	cmp	r2, r3
 8000cce:	bf8c      	ite	hi
 8000cd0:	2301      	movhi	r3, #1
 8000cd2:	2300      	movls	r3, #0
 8000cd4:	b2db      	uxtb	r3, r3
}
 8000cd6:	4618      	mov	r0, r3
 8000cd8:	4770      	bx	lr
 8000cda:	bf00      	nop
 8000cdc:	20000af8 	.word	0x20000af8

08000ce0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000ce0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000ce2:	f7ff ffa5 	bl	8000c30 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000ce6:	bd08      	pop	{r3, pc}
 8000ce8:	f3af 8000 	nop.w
 8000cec:	f3af 8000 	nop.w

08000cf0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000cf0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000cf2:	f7ff ffa5 	bl	8000c40 <port_unlock_from_isr>
}
 8000cf6:	bd08      	pop	{r3, pc}
 8000cf8:	f3af 8000 	nop.w
 8000cfc:	f3af 8000 	nop.w

08000d00 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000d00:	b082      	sub	sp, #8
 8000d02:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
 8000d04:	9b01      	ldr	r3, [sp, #4]
 8000d06:	68db      	ldr	r3, [r3, #12]
 8000d08:	2b00      	cmp	r3, #0
 8000d0a:	bf14      	ite	ne
 8000d0c:	2301      	movne	r3, #1
 8000d0e:	2300      	moveq	r3, #0
 8000d10:	b2db      	uxtb	r3, r3
}
 8000d12:	4618      	mov	r0, r3
 8000d14:	b002      	add	sp, #8
 8000d16:	4770      	bx	lr
 8000d18:	f3af 8000 	nop.w
 8000d1c:	f3af 8000 	nop.w

08000d20 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000d20:	b082      	sub	sp, #8
 8000d22:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->cnt++;
 8000d24:	9b01      	ldr	r3, [sp, #4]
 8000d26:	689b      	ldr	r3, [r3, #8]
 8000d28:	1c5a      	adds	r2, r3, #1
 8000d2a:	9b01      	ldr	r3, [sp, #4]
 8000d2c:	609a      	str	r2, [r3, #8]
}
 8000d2e:	b002      	add	sp, #8
 8000d30:	4770      	bx	lr
 8000d32:	bf00      	nop
 8000d34:	f3af 8000 	nop.w
 8000d38:	f3af 8000 	nop.w
 8000d3c:	f3af 8000 	nop.w

08000d40 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000d40:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.queue);
 8000d42:	4806      	ldr	r0, [pc, #24]	; (8000d5c <_scheduler_init+0x1c>)
 8000d44:	f7ff ff84 	bl	8000c50 <queue_init>
  ch.rlist.prio = NOPRIO;
 8000d48:	4b04      	ldr	r3, [pc, #16]	; (8000d5c <_scheduler_init+0x1c>)
 8000d4a:	2200      	movs	r2, #0
 8000d4c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8000d4e:	4b03      	ldr	r3, [pc, #12]	; (8000d5c <_scheduler_init+0x1c>)
 8000d50:	4a02      	ldr	r2, [pc, #8]	; (8000d5c <_scheduler_init+0x1c>)
 8000d52:	611a      	str	r2, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8000d54:	4b01      	ldr	r3, [pc, #4]	; (8000d5c <_scheduler_init+0x1c>)
 8000d56:	4a01      	ldr	r2, [pc, #4]	; (8000d5c <_scheduler_init+0x1c>)
 8000d58:	615a      	str	r2, [r3, #20]
#endif
}
 8000d5a:	bd08      	pop	{r3, pc}
 8000d5c:	20000af8 	.word	0x20000af8

08000d60 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000d60:	b084      	sub	sp, #16
 8000d62:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000d64:	9b01      	ldr	r3, [sp, #4]
 8000d66:	2200      	movs	r2, #0
 8000d68:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000d6c:	4b0e      	ldr	r3, [pc, #56]	; (8000da8 <chSchReadyI+0x48>)
 8000d6e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8000d70:	9b03      	ldr	r3, [sp, #12]
 8000d72:	681b      	ldr	r3, [r3, #0]
 8000d74:	9303      	str	r3, [sp, #12]
  } while (cp->prio >= tp->prio);
 8000d76:	9b03      	ldr	r3, [sp, #12]
 8000d78:	689a      	ldr	r2, [r3, #8]
 8000d7a:	9b01      	ldr	r3, [sp, #4]
 8000d7c:	689b      	ldr	r3, [r3, #8]
 8000d7e:	429a      	cmp	r2, r3
 8000d80:	d2f6      	bcs.n	8000d70 <chSchReadyI+0x10>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000d82:	9b01      	ldr	r3, [sp, #4]
 8000d84:	9a03      	ldr	r2, [sp, #12]
 8000d86:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8000d88:	9b03      	ldr	r3, [sp, #12]
 8000d8a:	685a      	ldr	r2, [r3, #4]
 8000d8c:	9b01      	ldr	r3, [sp, #4]
 8000d8e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8000d90:	9b01      	ldr	r3, [sp, #4]
 8000d92:	685b      	ldr	r3, [r3, #4]
 8000d94:	9a01      	ldr	r2, [sp, #4]
 8000d96:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8000d98:	9b03      	ldr	r3, [sp, #12]
 8000d9a:	9a01      	ldr	r2, [sp, #4]
 8000d9c:	605a      	str	r2, [r3, #4]

  return tp;
 8000d9e:	9b01      	ldr	r3, [sp, #4]
}
 8000da0:	4618      	mov	r0, r3
 8000da2:	b004      	add	sp, #16
 8000da4:	4770      	bx	lr
 8000da6:	bf00      	nop
 8000da8:	20000af8 	.word	0x20000af8
 8000dac:	f3af 8000 	nop.w

08000db0 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8000db0:	b084      	sub	sp, #16
 8000db2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000db4:	9b01      	ldr	r3, [sp, #4]
 8000db6:	2200      	movs	r2, #0
 8000db8:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000dbc:	4b0e      	ldr	r3, [pc, #56]	; (8000df8 <chSchReadyAheadI+0x48>)
 8000dbe:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 8000dc0:	9b03      	ldr	r3, [sp, #12]
 8000dc2:	681b      	ldr	r3, [r3, #0]
 8000dc4:	9303      	str	r3, [sp, #12]
  } while (cp->prio > tp->prio);
 8000dc6:	9b03      	ldr	r3, [sp, #12]
 8000dc8:	689a      	ldr	r2, [r3, #8]
 8000dca:	9b01      	ldr	r3, [sp, #4]
 8000dcc:	689b      	ldr	r3, [r3, #8]
 8000dce:	429a      	cmp	r2, r3
 8000dd0:	d8f6      	bhi.n	8000dc0 <chSchReadyAheadI+0x10>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000dd2:	9b01      	ldr	r3, [sp, #4]
 8000dd4:	9a03      	ldr	r2, [sp, #12]
 8000dd6:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 8000dd8:	9b03      	ldr	r3, [sp, #12]
 8000dda:	685a      	ldr	r2, [r3, #4]
 8000ddc:	9b01      	ldr	r3, [sp, #4]
 8000dde:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8000de0:	9b01      	ldr	r3, [sp, #4]
 8000de2:	685b      	ldr	r3, [r3, #4]
 8000de4:	9a01      	ldr	r2, [sp, #4]
 8000de6:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 8000de8:	9b03      	ldr	r3, [sp, #12]
 8000dea:	9a01      	ldr	r2, [sp, #4]
 8000dec:	605a      	str	r2, [r3, #4]

  return tp;
 8000dee:	9b01      	ldr	r3, [sp, #4]
}
 8000df0:	4618      	mov	r0, r3
 8000df2:	b004      	add	sp, #16
 8000df4:	4770      	bx	lr
 8000df6:	bf00      	nop
 8000df8:	20000af8 	.word	0x20000af8
 8000dfc:	f3af 8000 	nop.w

08000e00 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000e00:	b500      	push	{lr}
 8000e02:	b085      	sub	sp, #20
 8000e04:	4603      	mov	r3, r0
 8000e06:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp = currp;
 8000e0a:	4b0e      	ldr	r3, [pc, #56]	; (8000e44 <chSchGoSleepS+0x44>)
 8000e0c:	699b      	ldr	r3, [r3, #24]
 8000e0e:	9303      	str	r3, [sp, #12]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000e10:	9b03      	ldr	r3, [sp, #12]
 8000e12:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000e16:	f883 2020 	strb.w	r2, [r3, #32]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000e1a:	480a      	ldr	r0, [pc, #40]	; (8000e44 <chSchGoSleepS+0x44>)
 8000e1c:	f7ff ff28 	bl	8000c70 <queue_fifo_remove>
 8000e20:	4602      	mov	r2, r0
 8000e22:	4b08      	ldr	r3, [pc, #32]	; (8000e44 <chSchGoSleepS+0x44>)
 8000e24:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8000e26:	4b07      	ldr	r3, [pc, #28]	; (8000e44 <chSchGoSleepS+0x44>)
 8000e28:	699b      	ldr	r3, [r3, #24]
 8000e2a:	2201      	movs	r2, #1
 8000e2c:	f883 2020 	strb.w	r2, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000e30:	4b04      	ldr	r3, [pc, #16]	; (8000e44 <chSchGoSleepS+0x44>)
 8000e32:	699b      	ldr	r3, [r3, #24]
 8000e34:	4618      	mov	r0, r3
 8000e36:	9903      	ldr	r1, [sp, #12]
 8000e38:	f7ff fa3c 	bl	80002b4 <_port_switch>
}
 8000e3c:	b005      	add	sp, #20
 8000e3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e42:	bf00      	nop
 8000e44:	20000af8 	.word	0x20000af8
 8000e48:	f3af 8000 	nop.w
 8000e4c:	f3af 8000 	nop.w

08000e50 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000e50:	b500      	push	{lr}
 8000e52:	b085      	sub	sp, #20
 8000e54:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000e56:	9b01      	ldr	r3, [sp, #4]
 8000e58:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000e5a:	f7ff ff41 	bl	8000ce0 <chSysLockFromISR>
  switch (tp->state) {
 8000e5e:	9b03      	ldr	r3, [sp, #12]
 8000e60:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000e64:	2b07      	cmp	r3, #7
 8000e66:	d824      	bhi.n	8000eb2 <wakeup+0x62>
 8000e68:	a201      	add	r2, pc, #4	; (adr r2, 8000e70 <wakeup+0x20>)
 8000e6a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000e6e:	bf00      	nop
 8000e70:	08000e91 	.word	0x08000e91
 8000e74:	08000eb3 	.word	0x08000eb3
 8000e78:	08000eb3 	.word	0x08000eb3
 8000e7c:	08000e97 	.word	0x08000e97
 8000e80:	08000eab 	.word	0x08000eab
 8000e84:	08000ea1 	.word	0x08000ea1
 8000e88:	08000eb3 	.word	0x08000eb3
 8000e8c:	08000eab 	.word	0x08000eab
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000e90:	f7ff ff2e 	bl	8000cf0 <chSysUnlockFromISR>
    return;
 8000e94:	e017      	b.n	8000ec6 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8000e96:	9b03      	ldr	r3, [sp, #12]
 8000e98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000e9a:	2200      	movs	r2, #0
 8000e9c:	601a      	str	r2, [r3, #0]
    break;
 8000e9e:	e009      	b.n	8000eb4 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8000ea0:	9b03      	ldr	r3, [sp, #12]
 8000ea2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ea4:	4618      	mov	r0, r3
 8000ea6:	f7ff ff3b 	bl	8000d20 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000eaa:	9803      	ldr	r0, [sp, #12]
 8000eac:	f7ff fef8 	bl	8000ca0 <queue_dequeue>
    break;
 8000eb0:	e000      	b.n	8000eb4 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
 8000eb2:	bf00      	nop
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000eb4:	9b03      	ldr	r3, [sp, #12]
 8000eb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000eba:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000ebc:	9803      	ldr	r0, [sp, #12]
 8000ebe:	f7ff ff4f 	bl	8000d60 <chSchReadyI>
  chSysUnlockFromISR();
 8000ec2:	f7ff ff15 	bl	8000cf0 <chSysUnlockFromISR>
}
 8000ec6:	b005      	add	sp, #20
 8000ec8:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ecc:	f3af 8000 	nop.w

08000ed0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000ed0:	b500      	push	{lr}
 8000ed2:	b089      	sub	sp, #36	; 0x24
 8000ed4:	4603      	mov	r3, r0
 8000ed6:	9100      	str	r1, [sp, #0]
 8000ed8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000edc:	9b00      	ldr	r3, [sp, #0]
 8000ede:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8000ee2:	d019      	beq.n	8000f18 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000ee4:	4b12      	ldr	r3, [pc, #72]	; (8000f30 <chSchGoSleepTimeoutS+0x60>)
 8000ee6:	699b      	ldr	r3, [r3, #24]
 8000ee8:	aa03      	add	r2, sp, #12
 8000eea:	4610      	mov	r0, r2
 8000eec:	9900      	ldr	r1, [sp, #0]
 8000eee:	4a11      	ldr	r2, [pc, #68]	; (8000f34 <chSchGoSleepTimeoutS+0x64>)
 8000ef0:	f7ff fd8e 	bl	8000a10 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000ef4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000ef8:	4618      	mov	r0, r3
 8000efa:	f7ff ff81 	bl	8000e00 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000efe:	ab03      	add	r3, sp, #12
 8000f00:	4618      	mov	r0, r3
 8000f02:	f7ff fefd 	bl	8000d00 <chVTIsArmedI>
 8000f06:	4603      	mov	r3, r0
 8000f08:	2b00      	cmp	r3, #0
 8000f0a:	d004      	beq.n	8000f16 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 8000f0c:	ab03      	add	r3, sp, #12
 8000f0e:	4618      	mov	r0, r3
 8000f10:	f7ff fe0e 	bl	8000b30 <chVTDoResetI>
 8000f14:	e005      	b.n	8000f22 <chSchGoSleepTimeoutS+0x52>
 8000f16:	e004      	b.n	8000f22 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000f18:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000f1c:	4618      	mov	r0, r3
 8000f1e:	f7ff ff6f 	bl	8000e00 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8000f22:	4b03      	ldr	r3, [pc, #12]	; (8000f30 <chSchGoSleepTimeoutS+0x60>)
 8000f24:	699b      	ldr	r3, [r3, #24]
 8000f26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8000f28:	4618      	mov	r0, r3
 8000f2a:	b009      	add	sp, #36	; 0x24
 8000f2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f30:	20000af8 	.word	0x20000af8
 8000f34:	08000e51 	.word	0x08000e51
 8000f38:	f3af 8000 	nop.w
 8000f3c:	f3af 8000 	nop.w

08000f40 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000f40:	b500      	push	{lr}
 8000f42:	b085      	sub	sp, #20
 8000f44:	9001      	str	r0, [sp, #4]
 8000f46:	9100      	str	r1, [sp, #0]
  thread_t *otp = currp;
 8000f48:	4b10      	ldr	r3, [pc, #64]	; (8000f8c <chSchWakeupS+0x4c>)
 8000f4a:	699b      	ldr	r3, [r3, #24]
 8000f4c:	9303      	str	r3, [sp, #12]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000f4e:	9b01      	ldr	r3, [sp, #4]
 8000f50:	9a00      	ldr	r2, [sp, #0]
 8000f52:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000f54:	9b01      	ldr	r3, [sp, #4]
 8000f56:	689a      	ldr	r2, [r3, #8]
 8000f58:	9b03      	ldr	r3, [sp, #12]
 8000f5a:	689b      	ldr	r3, [r3, #8]
 8000f5c:	429a      	cmp	r2, r3
 8000f5e:	d803      	bhi.n	8000f68 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
 8000f60:	9801      	ldr	r0, [sp, #4]
 8000f62:	f7ff fefd 	bl	8000d60 <chSchReadyI>
 8000f66:	e00e      	b.n	8000f86 <chSchWakeupS+0x46>
  }
  else {
    otp = chSchReadyI(otp);
 8000f68:	9803      	ldr	r0, [sp, #12]
 8000f6a:	f7ff fef9 	bl	8000d60 <chSchReadyI>
 8000f6e:	9003      	str	r0, [sp, #12]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8000f70:	4a06      	ldr	r2, [pc, #24]	; (8000f8c <chSchWakeupS+0x4c>)
 8000f72:	9b01      	ldr	r3, [sp, #4]
 8000f74:	6193      	str	r3, [r2, #24]
    ntp->state = CH_STATE_CURRENT;
 8000f76:	9b01      	ldr	r3, [sp, #4]
 8000f78:	2201      	movs	r2, #1
 8000f7a:	f883 2020 	strb.w	r2, [r3, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000f7e:	9801      	ldr	r0, [sp, #4]
 8000f80:	9903      	ldr	r1, [sp, #12]
 8000f82:	f7ff f997 	bl	80002b4 <_port_switch>
  }
}
 8000f86:	b005      	add	sp, #20
 8000f88:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f8c:	20000af8 	.word	0x20000af8

08000f90 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000f90:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000f92:	f7ff fe95 	bl	8000cc0 <chSchIsRescRequiredI>
 8000f96:	4603      	mov	r3, r0
 8000f98:	2b00      	cmp	r3, #0
 8000f9a:	d001      	beq.n	8000fa0 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8000f9c:	f000 f840 	bl	8001020 <chSchDoRescheduleAhead>
  }
}
 8000fa0:	bd08      	pop	{r3, pc}
 8000fa2:	bf00      	nop
 8000fa4:	f3af 8000 	nop.w
 8000fa8:	f3af 8000 	nop.w
 8000fac:	f3af 8000 	nop.w

08000fb0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8000fb0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000fb2:	4b09      	ldr	r3, [pc, #36]	; (8000fd8 <chSchIsPreemptionRequired+0x28>)
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	689b      	ldr	r3, [r3, #8]
 8000fb8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->prio;
 8000fba:	4b07      	ldr	r3, [pc, #28]	; (8000fd8 <chSchIsPreemptionRequired+0x28>)
 8000fbc:	699b      	ldr	r3, [r3, #24]
 8000fbe:	689b      	ldr	r3, [r3, #8]
 8000fc0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000fc2:	9a01      	ldr	r2, [sp, #4]
 8000fc4:	9b00      	ldr	r3, [sp, #0]
 8000fc6:	429a      	cmp	r2, r3
 8000fc8:	bf8c      	ite	hi
 8000fca:	2301      	movhi	r3, #1
 8000fcc:	2300      	movls	r3, #0
 8000fce:	b2db      	uxtb	r3, r3
#endif
}
 8000fd0:	4618      	mov	r0, r3
 8000fd2:	b002      	add	sp, #8
 8000fd4:	4770      	bx	lr
 8000fd6:	bf00      	nop
 8000fd8:	20000af8 	.word	0x20000af8
 8000fdc:	f3af 8000 	nop.w

08000fe0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8000fe0:	b500      	push	{lr}
 8000fe2:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8000fe4:	4b0d      	ldr	r3, [pc, #52]	; (800101c <chSchDoRescheduleBehind+0x3c>)
 8000fe6:	699b      	ldr	r3, [r3, #24]
 8000fe8:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000fea:	480c      	ldr	r0, [pc, #48]	; (800101c <chSchDoRescheduleBehind+0x3c>)
 8000fec:	f7ff fe40 	bl	8000c70 <queue_fifo_remove>
 8000ff0:	4602      	mov	r2, r0
 8000ff2:	4b0a      	ldr	r3, [pc, #40]	; (800101c <chSchDoRescheduleBehind+0x3c>)
 8000ff4:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8000ff6:	4b09      	ldr	r3, [pc, #36]	; (800101c <chSchDoRescheduleBehind+0x3c>)
 8000ff8:	699b      	ldr	r3, [r3, #24]
 8000ffa:	2201      	movs	r2, #1
 8000ffc:	f883 2020 	strb.w	r2, [r3, #32]
  /* It went behind peers so it gets a new time quantum.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);
 8001000:	9801      	ldr	r0, [sp, #4]
 8001002:	f7ff fead 	bl	8000d60 <chSchReadyI>
 8001006:	9001      	str	r0, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001008:	4b04      	ldr	r3, [pc, #16]	; (800101c <chSchDoRescheduleBehind+0x3c>)
 800100a:	699b      	ldr	r3, [r3, #24]
 800100c:	4618      	mov	r0, r3
 800100e:	9901      	ldr	r1, [sp, #4]
 8001010:	f7ff f950 	bl	80002b4 <_port_switch>
}
 8001014:	b003      	add	sp, #12
 8001016:	f85d fb04 	ldr.w	pc, [sp], #4
 800101a:	bf00      	nop
 800101c:	20000af8 	.word	0x20000af8

08001020 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001020:	b500      	push	{lr}
 8001022:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8001024:	4b0d      	ldr	r3, [pc, #52]	; (800105c <chSchDoRescheduleAhead+0x3c>)
 8001026:	699b      	ldr	r3, [r3, #24]
 8001028:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800102a:	480c      	ldr	r0, [pc, #48]	; (800105c <chSchDoRescheduleAhead+0x3c>)
 800102c:	f7ff fe20 	bl	8000c70 <queue_fifo_remove>
 8001030:	4602      	mov	r2, r0
 8001032:	4b0a      	ldr	r3, [pc, #40]	; (800105c <chSchDoRescheduleAhead+0x3c>)
 8001034:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8001036:	4b09      	ldr	r3, [pc, #36]	; (800105c <chSchDoRescheduleAhead+0x3c>)
 8001038:	699b      	ldr	r3, [r3, #24]
 800103a:	2201      	movs	r2, #1
 800103c:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8001040:	9801      	ldr	r0, [sp, #4]
 8001042:	f7ff feb5 	bl	8000db0 <chSchReadyAheadI>
 8001046:	9001      	str	r0, [sp, #4]

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001048:	4b04      	ldr	r3, [pc, #16]	; (800105c <chSchDoRescheduleAhead+0x3c>)
 800104a:	699b      	ldr	r3, [r3, #24]
 800104c:	4618      	mov	r0, r3
 800104e:	9901      	ldr	r1, [sp, #4]
 8001050:	f7ff f930 	bl	80002b4 <_port_switch>
}
 8001054:	b003      	add	sp, #12
 8001056:	f85d fb04 	ldr.w	pc, [sp], #4
 800105a:	bf00      	nop
 800105c:	20000af8 	.word	0x20000af8

08001060 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001060:	b500      	push	{lr}
 8001062:	b083      	sub	sp, #12
  thread_t *otp = currp;
 8001064:	4b0d      	ldr	r3, [pc, #52]	; (800109c <chSchDoReschedule+0x3c>)
 8001066:	699b      	ldr	r3, [r3, #24]
 8001068:	9301      	str	r3, [sp, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800106a:	480c      	ldr	r0, [pc, #48]	; (800109c <chSchDoReschedule+0x3c>)
 800106c:	f7ff fe00 	bl	8000c70 <queue_fifo_remove>
 8001070:	4602      	mov	r2, r0
 8001072:	4b0a      	ldr	r3, [pc, #40]	; (800109c <chSchDoReschedule+0x3c>)
 8001074:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8001076:	4b09      	ldr	r3, [pc, #36]	; (800109c <chSchDoReschedule+0x3c>)
 8001078:	699b      	ldr	r3, [r3, #24]
 800107a:	2201      	movs	r2, #1
 800107c:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8001080:	9801      	ldr	r0, [sp, #4]
 8001082:	f7ff fe95 	bl	8000db0 <chSchReadyAheadI>
 8001086:	9001      	str	r0, [sp, #4]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001088:	4b04      	ldr	r3, [pc, #16]	; (800109c <chSchDoReschedule+0x3c>)
 800108a:	699b      	ldr	r3, [r3, #24]
 800108c:	4618      	mov	r0, r3
 800108e:	9901      	ldr	r1, [sp, #4]
 8001090:	f7ff f910 	bl	80002b4 <_port_switch>
}
 8001094:	b003      	add	sp, #12
 8001096:	f85d fb04 	ldr.w	pc, [sp], #4
 800109a:	bf00      	nop
 800109c:	20000af8 	.word	0x20000af8

080010a0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80010a0:	b082      	sub	sp, #8
 80010a2:	2320      	movs	r3, #32
 80010a4:	9301      	str	r3, [sp, #4]
 80010a6:	9b01      	ldr	r3, [sp, #4]
 80010a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80010ac:	b002      	add	sp, #8
 80010ae:	4770      	bx	lr

080010b0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80010b0:	b082      	sub	sp, #8
 80010b2:	2300      	movs	r3, #0
 80010b4:	9301      	str	r3, [sp, #4]
 80010b6:	9b01      	ldr	r3, [sp, #4]
 80010b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80010bc:	b002      	add	sp, #8
 80010be:	4770      	bx	lr

080010c0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80010c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80010c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80010c6:	4618      	mov	r0, r3
 80010c8:	4770      	bx	lr
 80010ca:	bf00      	nop
 80010cc:	f3af 8000 	nop.w

080010d0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80010d0:	b508      	push	{r3, lr}

  return stGetCounter();
 80010d2:	f7ff fff5 	bl	80010c0 <st_lld_get_counter>
 80010d6:	4603      	mov	r3, r0
}
 80010d8:	4618      	mov	r0, r3
 80010da:	bd08      	pop	{r3, pc}
 80010dc:	f3af 8000 	nop.w

080010e0 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 80010e0:	b082      	sub	sp, #8
 80010e2:	9001      	str	r0, [sp, #4]

  tlp->next = (thread_t *)tlp;
 80010e4:	9b01      	ldr	r3, [sp, #4]
 80010e6:	9a01      	ldr	r2, [sp, #4]
 80010e8:	601a      	str	r2, [r3, #0]
}
 80010ea:	b002      	add	sp, #8
 80010ec:	4770      	bx	lr
 80010ee:	bf00      	nop

080010f0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 80010f0:	b082      	sub	sp, #8
 80010f2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->next != (thread_t *)tlp);
 80010f4:	9b01      	ldr	r3, [sp, #4]
 80010f6:	681a      	ldr	r2, [r3, #0]
 80010f8:	9b01      	ldr	r3, [sp, #4]
 80010fa:	429a      	cmp	r2, r3
 80010fc:	bf14      	ite	ne
 80010fe:	2301      	movne	r3, #1
 8001100:	2300      	moveq	r3, #0
 8001102:	b2db      	uxtb	r3, r3
}
 8001104:	4618      	mov	r0, r3
 8001106:	b002      	add	sp, #8
 8001108:	4770      	bx	lr
 800110a:	bf00      	nop
 800110c:	f3af 8000 	nop.w

08001110 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001110:	b082      	sub	sp, #8
 8001112:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8001114:	9b01      	ldr	r3, [sp, #4]
 8001116:	9a01      	ldr	r2, [sp, #4]
 8001118:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800111a:	9b01      	ldr	r3, [sp, #4]
 800111c:	9a01      	ldr	r2, [sp, #4]
 800111e:	605a      	str	r2, [r3, #4]
}
 8001120:	b002      	add	sp, #8
 8001122:	4770      	bx	lr
 8001124:	f3af 8000 	nop.w
 8001128:	f3af 8000 	nop.w
 800112c:	f3af 8000 	nop.w

08001130 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001130:	b082      	sub	sp, #8
 8001132:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001134:	9b01      	ldr	r3, [sp, #4]
 8001136:	681a      	ldr	r2, [r3, #0]
 8001138:	9b01      	ldr	r3, [sp, #4]
 800113a:	429a      	cmp	r2, r3
 800113c:	bf14      	ite	ne
 800113e:	2301      	movne	r3, #1
 8001140:	2300      	moveq	r3, #0
 8001142:	b2db      	uxtb	r3, r3
}
 8001144:	4618      	mov	r0, r3
 8001146:	b002      	add	sp, #8
 8001148:	4770      	bx	lr
 800114a:	bf00      	nop
 800114c:	f3af 8000 	nop.w

08001150 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8001150:	b082      	sub	sp, #8
 8001152:	9001      	str	r0, [sp, #4]
 8001154:	9100      	str	r1, [sp, #0]

  tp->queue.next = tlp->next;
 8001156:	9b00      	ldr	r3, [sp, #0]
 8001158:	681a      	ldr	r2, [r3, #0]
 800115a:	9b01      	ldr	r3, [sp, #4]
 800115c:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 800115e:	9b00      	ldr	r3, [sp, #0]
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	601a      	str	r2, [r3, #0]
}
 8001164:	b002      	add	sp, #8
 8001166:	4770      	bx	lr
 8001168:	f3af 8000 	nop.w
 800116c:	f3af 8000 	nop.w

08001170 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8001170:	b084      	sub	sp, #16
 8001172:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->next;
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	681b      	ldr	r3, [r3, #0]
 8001178:	9303      	str	r3, [sp, #12]
  tlp->next = tp->queue.next;
 800117a:	9b03      	ldr	r3, [sp, #12]
 800117c:	681a      	ldr	r2, [r3, #0]
 800117e:	9b01      	ldr	r3, [sp, #4]
 8001180:	601a      	str	r2, [r3, #0]

  return tp;
 8001182:	9b03      	ldr	r3, [sp, #12]
}
 8001184:	4618      	mov	r0, r3
 8001186:	b004      	add	sp, #16
 8001188:	4770      	bx	lr
 800118a:	bf00      	nop
 800118c:	f3af 8000 	nop.w

08001190 <queue_insert>:
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001190:	b082      	sub	sp, #8
 8001192:	9001      	str	r0, [sp, #4]
 8001194:	9100      	str	r1, [sp, #0]

  tp->queue.next             = (thread_t *)tqp;
 8001196:	9b01      	ldr	r3, [sp, #4]
 8001198:	9a00      	ldr	r2, [sp, #0]
 800119a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800119c:	9b00      	ldr	r3, [sp, #0]
 800119e:	685a      	ldr	r2, [r3, #4]
 80011a0:	9b01      	ldr	r3, [sp, #4]
 80011a2:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80011a4:	9b01      	ldr	r3, [sp, #4]
 80011a6:	685b      	ldr	r3, [r3, #4]
 80011a8:	9a01      	ldr	r2, [sp, #4]
 80011aa:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 80011ac:	9b00      	ldr	r3, [sp, #0]
 80011ae:	9a01      	ldr	r2, [sp, #4]
 80011b0:	605a      	str	r2, [r3, #4]
}
 80011b2:	b002      	add	sp, #8
 80011b4:	4770      	bx	lr
 80011b6:	bf00      	nop
 80011b8:	f3af 8000 	nop.w
 80011bc:	f3af 8000 	nop.w

080011c0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80011c0:	b084      	sub	sp, #16
 80011c2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80011c4:	9b01      	ldr	r3, [sp, #4]
 80011c6:	681b      	ldr	r3, [r3, #0]
 80011c8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 80011ca:	9b03      	ldr	r3, [sp, #12]
 80011cc:	681a      	ldr	r2, [r3, #0]
 80011ce:	9b01      	ldr	r3, [sp, #4]
 80011d0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80011d2:	9b01      	ldr	r3, [sp, #4]
 80011d4:	681b      	ldr	r3, [r3, #0]
 80011d6:	9a01      	ldr	r2, [sp, #4]
 80011d8:	605a      	str	r2, [r3, #4]

  return tp;
 80011da:	9b03      	ldr	r3, [sp, #12]
}
 80011dc:	4618      	mov	r0, r3
 80011de:	b004      	add	sp, #16
 80011e0:	4770      	bx	lr
 80011e2:	bf00      	nop
 80011e4:	f3af 8000 	nop.w
 80011e8:	f3af 8000 	nop.w
 80011ec:	f3af 8000 	nop.w

080011f0 <chSchCanYieldS>:
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80011f0:	4b06      	ldr	r3, [pc, #24]	; (800120c <chSchCanYieldS+0x1c>)
 80011f2:	681b      	ldr	r3, [r3, #0]
 80011f4:	689a      	ldr	r2, [r3, #8]
 80011f6:	4b05      	ldr	r3, [pc, #20]	; (800120c <chSchCanYieldS+0x1c>)
 80011f8:	699b      	ldr	r3, [r3, #24]
 80011fa:	689b      	ldr	r3, [r3, #8]
 80011fc:	429a      	cmp	r2, r3
 80011fe:	bf2c      	ite	cs
 8001200:	2301      	movcs	r3, #1
 8001202:	2300      	movcc	r3, #0
 8001204:	b2db      	uxtb	r3, r3
}
 8001206:	4618      	mov	r0, r3
 8001208:	4770      	bx	lr
 800120a:	bf00      	nop
 800120c:	20000af8 	.word	0x20000af8

08001210 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 8001210:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001212:	f7ff ffed 	bl	80011f0 <chSchCanYieldS>
 8001216:	4603      	mov	r3, r0
 8001218:	2b00      	cmp	r3, #0
 800121a:	d001      	beq.n	8001220 <chSchDoYieldS+0x10>
    chSchDoRescheduleBehind();
 800121c:	f7ff fee0 	bl	8000fe0 <chSchDoRescheduleBehind>
  }
}
 8001220:	bd08      	pop	{r3, pc}
 8001222:	bf00      	nop
 8001224:	f3af 8000 	nop.w
 8001228:	f3af 8000 	nop.w
 800122c:	f3af 8000 	nop.w

08001230 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001230:	b508      	push	{r3, lr}

  port_lock();
 8001232:	f7ff ff35 	bl	80010a0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001236:	bd08      	pop	{r3, pc}
 8001238:	f3af 8000 	nop.w
 800123c:	f3af 8000 	nop.w

08001240 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001240:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8001242:	f7ff ff35 	bl	80010b0 <port_unlock>
}
 8001246:	bd08      	pop	{r3, pc}
 8001248:	f3af 8000 	nop.w
 800124c:	f3af 8000 	nop.w

08001250 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001250:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001252:	f7ff ff3d 	bl	80010d0 <port_timer_get_time>
 8001256:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001258:	4618      	mov	r0, r3
 800125a:	bd08      	pop	{r3, pc}
 800125c:	f3af 8000 	nop.w

08001260 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8001260:	b084      	sub	sp, #16
 8001262:	9003      	str	r0, [sp, #12]
 8001264:	9102      	str	r1, [sp, #8]
 8001266:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001268:	9a03      	ldr	r2, [sp, #12]
 800126a:	9b02      	ldr	r3, [sp, #8]
 800126c:	1ad2      	subs	r2, r2, r3
 800126e:	9901      	ldr	r1, [sp, #4]
 8001270:	9b02      	ldr	r3, [sp, #8]
 8001272:	1acb      	subs	r3, r1, r3
 8001274:	429a      	cmp	r2, r3
 8001276:	bf34      	ite	cc
 8001278:	2301      	movcc	r3, #1
 800127a:	2300      	movcs	r3, #0
 800127c:	b2db      	uxtb	r3, r3
}
 800127e:	4618      	mov	r0, r3
 8001280:	b004      	add	sp, #16
 8001282:	4770      	bx	lr
 8001284:	f3af 8000 	nop.w
 8001288:	f3af 8000 	nop.w
 800128c:	f3af 8000 	nop.w

08001290 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001290:	4b01      	ldr	r3, [pc, #4]	; (8001298 <chThdGetSelfX+0x8>)
 8001292:	699b      	ldr	r3, [r3, #24]
}
 8001294:	4618      	mov	r0, r3
 8001296:	4770      	bx	lr
 8001298:	20000af8 	.word	0x20000af8
 800129c:	f3af 8000 	nop.w

080012a0 <chThdGetWorkingAreaX>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 80012a0:	b082      	sub	sp, #8
 80012a2:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 80012a4:	9b01      	ldr	r3, [sp, #4]
 80012a6:	69db      	ldr	r3, [r3, #28]
}
 80012a8:	4618      	mov	r0, r3
 80012aa:	b002      	add	sp, #8
 80012ac:	4770      	bx	lr
 80012ae:	bf00      	nop

080012b0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80012b0:	b500      	push	{lr}
 80012b2:	b083      	sub	sp, #12
 80012b4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80012b6:	2008      	movs	r0, #8
 80012b8:	9901      	ldr	r1, [sp, #4]
 80012ba:	f7ff fe09 	bl	8000ed0 <chSchGoSleepTimeoutS>
}
 80012be:	b003      	add	sp, #12
 80012c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80012d0:	b500      	push	{lr}
 80012d2:	b085      	sub	sp, #20
 80012d4:	9001      	str	r0, [sp, #4]
 80012d6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80012d8:	9801      	ldr	r0, [sp, #4]
 80012da:	f7ff ff71 	bl	80011c0 <queue_fifo_remove>
 80012de:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80012e0:	9b03      	ldr	r3, [sp, #12]
 80012e2:	9a00      	ldr	r2, [sp, #0]
 80012e4:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80012e6:	9803      	ldr	r0, [sp, #12]
 80012e8:	f7ff fd3a 	bl	8000d60 <chSchReadyI>
}
 80012ec:	b005      	add	sp, #20
 80012ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80012f2:	bf00      	nop
 80012f4:	f3af 8000 	nop.w
 80012f8:	f3af 8000 	nop.w
 80012fc:	f3af 8000 	nop.w

08001300 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8001300:	b500      	push	{lr}
 8001302:	b085      	sub	sp, #20
 8001304:	9003      	str	r0, [sp, #12]
 8001306:	9102      	str	r1, [sp, #8]
 8001308:	9201      	str	r2, [sp, #4]

  tp->prio      = prio;
 800130a:	9b03      	ldr	r3, [sp, #12]
 800130c:	9a01      	ldr	r2, [sp, #4]
 800130e:	609a      	str	r2, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8001310:	9b03      	ldr	r3, [sp, #12]
 8001312:	2202      	movs	r2, #2
 8001314:	f883 2020 	strb.w	r2, [r3, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001318:	9b03      	ldr	r3, [sp, #12]
 800131a:	2200      	movs	r2, #0
 800131c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001320:	9b03      	ldr	r3, [sp, #12]
 8001322:	9a01      	ldr	r2, [sp, #4]
 8001324:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8001326:	9b03      	ldr	r3, [sp, #12]
 8001328:	2200      	movs	r2, #0
 800132a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800132c:	9b03      	ldr	r3, [sp, #12]
 800132e:	2200      	movs	r2, #0
 8001330:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001332:	9b03      	ldr	r3, [sp, #12]
 8001334:	2201      	movs	r2, #1
 8001336:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  tp->name      = name;
 800133a:	9b03      	ldr	r3, [sp, #12]
 800133c:	9a02      	ldr	r2, [sp, #8]
 800133e:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8001340:	9b03      	ldr	r3, [sp, #12]
 8001342:	4a0e      	ldr	r2, [pc, #56]	; (800137c <_thread_init+0x7c>)
 8001344:	611a      	str	r2, [r3, #16]
 8001346:	4b0d      	ldr	r3, [pc, #52]	; (800137c <_thread_init+0x7c>)
 8001348:	695a      	ldr	r2, [r3, #20]
 800134a:	9b03      	ldr	r3, [sp, #12]
 800134c:	615a      	str	r2, [r3, #20]
 800134e:	9b03      	ldr	r3, [sp, #12]
 8001350:	695b      	ldr	r3, [r3, #20]
 8001352:	9a03      	ldr	r2, [sp, #12]
 8001354:	611a      	str	r2, [r3, #16]
 8001356:	4a09      	ldr	r2, [pc, #36]	; (800137c <_thread_init+0x7c>)
 8001358:	9b03      	ldr	r3, [sp, #12]
 800135a:	6153      	str	r3, [r2, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800135c:	9b03      	ldr	r3, [sp, #12]
 800135e:	3328      	adds	r3, #40	; 0x28
 8001360:	4618      	mov	r0, r3
 8001362:	f7ff febd 	bl	80010e0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8001366:	9b03      	ldr	r3, [sp, #12]
 8001368:	332c      	adds	r3, #44	; 0x2c
 800136a:	4618      	mov	r0, r3
 800136c:	f7ff fed0 	bl	8001110 <queue_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8001370:	9b03      	ldr	r3, [sp, #12]
}
 8001372:	4618      	mov	r0, r3
 8001374:	b005      	add	sp, #20
 8001376:	f85d fb04 	ldr.w	pc, [sp], #4
 800137a:	bf00      	nop
 800137c:	20000af8 	.word	0x20000af8

08001380 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001380:	b500      	push	{lr}
 8001382:	b085      	sub	sp, #20
 8001384:	9001      	str	r0, [sp, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001386:	9b01      	ldr	r3, [sp, #4]
 8001388:	689b      	ldr	r3, [r3, #8]
 800138a:	3b48      	subs	r3, #72	; 0x48
 800138c:	9303      	str	r3, [sp, #12]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800138e:	9b01      	ldr	r3, [sp, #4]
 8001390:	685a      	ldr	r2, [r3, #4]
 8001392:	9b03      	ldr	r3, [sp, #12]
 8001394:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001396:	9b03      	ldr	r3, [sp, #12]
 8001398:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	60da      	str	r2, [r3, #12]
 80013a0:	9b03      	ldr	r3, [sp, #12]
 80013a2:	68db      	ldr	r3, [r3, #12]
 80013a4:	9a01      	ldr	r2, [sp, #4]
 80013a6:	6912      	ldr	r2, [r2, #16]
 80013a8:	601a      	str	r2, [r3, #0]
 80013aa:	9b03      	ldr	r3, [sp, #12]
 80013ac:	68db      	ldr	r3, [r3, #12]
 80013ae:	9a01      	ldr	r2, [sp, #4]
 80013b0:	6952      	ldr	r2, [r2, #20]
 80013b2:	605a      	str	r2, [r3, #4]
 80013b4:	9b03      	ldr	r3, [sp, #12]
 80013b6:	68db      	ldr	r3, [r3, #12]
 80013b8:	4a07      	ldr	r2, [pc, #28]	; (80013d8 <chThdCreateSuspendedI+0x58>)
 80013ba:	621a      	str	r2, [r3, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 80013bc:	9b01      	ldr	r3, [sp, #4]
 80013be:	681a      	ldr	r2, [r3, #0]
 80013c0:	9b01      	ldr	r3, [sp, #4]
 80013c2:	68db      	ldr	r3, [r3, #12]
 80013c4:	9803      	ldr	r0, [sp, #12]
 80013c6:	4611      	mov	r1, r2
 80013c8:	461a      	mov	r2, r3
 80013ca:	f7ff ff99 	bl	8001300 <_thread_init>
 80013ce:	4603      	mov	r3, r0
}
 80013d0:	4618      	mov	r0, r3
 80013d2:	b005      	add	sp, #20
 80013d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80013d8:	080002c5 	.word	0x080002c5
 80013dc:	f3af 8000 	nop.w

080013e0 <chThdCreateSuspended>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateSuspended(const thread_descriptor_t *tdp) {
 80013e0:	b500      	push	{lr}
 80013e2:	b085      	sub	sp, #20
 80013e4:	9001      	str	r0, [sp, #4]
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80013e6:	f7ff ff23 	bl	8001230 <chSysLock>
  tp = chThdCreateSuspendedI(tdp);
 80013ea:	9801      	ldr	r0, [sp, #4]
 80013ec:	f7ff ffc8 	bl	8001380 <chThdCreateSuspendedI>
 80013f0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80013f2:	f7ff ff25 	bl	8001240 <chSysUnlock>

  return tp;
 80013f6:	9b03      	ldr	r3, [sp, #12]
}
 80013f8:	4618      	mov	r0, r3
 80013fa:	b005      	add	sp, #20
 80013fc:	f85d fb04 	ldr.w	pc, [sp], #4

08001400 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8001400:	b500      	push	{lr}
 8001402:	b083      	sub	sp, #12
 8001404:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8001406:	9801      	ldr	r0, [sp, #4]
 8001408:	f7ff ffba 	bl	8001380 <chThdCreateSuspendedI>
 800140c:	4603      	mov	r3, r0
 800140e:	4618      	mov	r0, r3
 8001410:	f7ff fca6 	bl	8000d60 <chSchReadyI>
 8001414:	4603      	mov	r3, r0
}
 8001416:	4618      	mov	r0, r3
 8001418:	b003      	add	sp, #12
 800141a:	f85d fb04 	ldr.w	pc, [sp], #4
 800141e:	bf00      	nop

08001420 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8001420:	b500      	push	{lr}
 8001422:	b085      	sub	sp, #20
 8001424:	9001      	str	r0, [sp, #4]
  _thread_memfill((uint8_t *)tdp->wbase,
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8001426:	f7ff ff03 	bl	8001230 <chSysLock>
  tp = chThdCreateSuspendedI(tdp);
 800142a:	9801      	ldr	r0, [sp, #4]
 800142c:	f7ff ffa8 	bl	8001380 <chThdCreateSuspendedI>
 8001430:	9003      	str	r0, [sp, #12]
  chSchWakeupS(tp, MSG_OK);
 8001432:	9803      	ldr	r0, [sp, #12]
 8001434:	2100      	movs	r1, #0
 8001436:	f7ff fd83 	bl	8000f40 <chSchWakeupS>
  chSysUnlock();
 800143a:	f7ff ff01 	bl	8001240 <chSysUnlock>

  return tp;
 800143e:	9b03      	ldr	r3, [sp, #12]
}
 8001440:	4618      	mov	r0, r3
 8001442:	b005      	add	sp, #20
 8001444:	f85d fb04 	ldr.w	pc, [sp], #4
 8001448:	f3af 8000 	nop.w
 800144c:	f3af 8000 	nop.w

08001450 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001450:	b500      	push	{lr}
 8001452:	b087      	sub	sp, #28
 8001454:	9003      	str	r0, [sp, #12]
 8001456:	9102      	str	r1, [sp, #8]
 8001458:	9201      	str	r2, [sp, #4]
 800145a:	9300      	str	r3, [sp, #0]
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800145c:	f7ff fee8 	bl	8001230 <chSysLock>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8001460:	9b02      	ldr	r3, [sp, #8]
 8001462:	3b48      	subs	r3, #72	; 0x48
 8001464:	9a03      	ldr	r2, [sp, #12]
 8001466:	4413      	add	r3, r2
 8001468:	9305      	str	r3, [sp, #20]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 800146a:	9b05      	ldr	r3, [sp, #20]
 800146c:	9a03      	ldr	r2, [sp, #12]
 800146e:	61da      	str	r2, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001470:	9b05      	ldr	r3, [sp, #20]
 8001472:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8001476:	9b05      	ldr	r3, [sp, #20]
 8001478:	60da      	str	r2, [r3, #12]
 800147a:	9b05      	ldr	r3, [sp, #20]
 800147c:	68db      	ldr	r3, [r3, #12]
 800147e:	9a00      	ldr	r2, [sp, #0]
 8001480:	601a      	str	r2, [r3, #0]
 8001482:	9b05      	ldr	r3, [sp, #20]
 8001484:	68db      	ldr	r3, [r3, #12]
 8001486:	9a08      	ldr	r2, [sp, #32]
 8001488:	605a      	str	r2, [r3, #4]
 800148a:	9b05      	ldr	r3, [sp, #20]
 800148c:	68db      	ldr	r3, [r3, #12]
 800148e:	4a09      	ldr	r2, [pc, #36]	; (80014b4 <chThdCreateStatic+0x64>)
 8001490:	621a      	str	r2, [r3, #32]

  tp = _thread_init(tp, "noname", prio);
 8001492:	9805      	ldr	r0, [sp, #20]
 8001494:	4908      	ldr	r1, [pc, #32]	; (80014b8 <chThdCreateStatic+0x68>)
 8001496:	9a01      	ldr	r2, [sp, #4]
 8001498:	f7ff ff32 	bl	8001300 <_thread_init>
 800149c:	9005      	str	r0, [sp, #20]

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800149e:	9805      	ldr	r0, [sp, #20]
 80014a0:	2100      	movs	r1, #0
 80014a2:	f7ff fd4d 	bl	8000f40 <chSchWakeupS>
  chSysUnlock();
 80014a6:	f7ff fecb 	bl	8001240 <chSysUnlock>

  return tp;
 80014aa:	9b05      	ldr	r3, [sp, #20]
}
 80014ac:	4618      	mov	r0, r3
 80014ae:	b007      	add	sp, #28
 80014b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80014b4:	080002c5 	.word	0x080002c5
 80014b8:	0800dea0 	.word	0x0800dea0
 80014bc:	f3af 8000 	nop.w

080014c0 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 80014c0:	b500      	push	{lr}
 80014c2:	b083      	sub	sp, #12
 80014c4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80014c6:	f7ff feb3 	bl	8001230 <chSysLock>
  chDbgAssert(tp->state == CH_STATE_WTSTART, "wrong state");
  chSchWakeupS(tp, MSG_OK);
 80014ca:	9801      	ldr	r0, [sp, #4]
 80014cc:	2100      	movs	r1, #0
 80014ce:	f7ff fd37 	bl	8000f40 <chSchWakeupS>
  chSysUnlock();
 80014d2:	f7ff feb5 	bl	8001240 <chSysUnlock>

  return tp;
 80014d6:	9b01      	ldr	r3, [sp, #4]
}
 80014d8:	4618      	mov	r0, r3
 80014da:	b003      	add	sp, #12
 80014dc:	f85d fb04 	ldr.w	pc, [sp], #4

080014e0 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 80014e0:	b500      	push	{lr}
 80014e2:	b083      	sub	sp, #12
 80014e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80014e6:	f7ff fea3 	bl	8001230 <chSysLock>
  chDbgAssert(tp->refs < (trefs_t)255, "too many references");
  tp->refs++;
 80014ea:	9b01      	ldr	r3, [sp, #4]
 80014ec:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80014f0:	3301      	adds	r3, #1
 80014f2:	b2da      	uxtb	r2, r3
 80014f4:	9b01      	ldr	r3, [sp, #4]
 80014f6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  chSysUnlock();
 80014fa:	f7ff fea1 	bl	8001240 <chSysUnlock>

  return tp;
 80014fe:	9b01      	ldr	r3, [sp, #4]
}
 8001500:	4618      	mov	r0, r3
 8001502:	b003      	add	sp, #12
 8001504:	f85d fb04 	ldr.w	pc, [sp], #4
 8001508:	f3af 8000 	nop.w
 800150c:	f3af 8000 	nop.w

08001510 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001510:	b510      	push	{r4, lr}
 8001512:	b082      	sub	sp, #8
 8001514:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001516:	f7ff fe8b 	bl	8001230 <chSysLock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 800151a:	9b01      	ldr	r3, [sp, #4]
 800151c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8001520:	3b01      	subs	r3, #1
 8001522:	b2da      	uxtb	r2, r3
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800152a:	9b01      	ldr	r3, [sp, #4]
 800152c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8001530:	2b00      	cmp	r3, #0
 8001532:	d12e      	bne.n	8001592 <chThdRelease+0x82>
 8001534:	9b01      	ldr	r3, [sp, #4]
 8001536:	f893 3020 	ldrb.w	r3, [r3, #32]
 800153a:	2b0f      	cmp	r3, #15
 800153c:	d129      	bne.n	8001592 <chThdRelease+0x82>
    REG_REMOVE(tp);
 800153e:	9b01      	ldr	r3, [sp, #4]
 8001540:	695b      	ldr	r3, [r3, #20]
 8001542:	9a01      	ldr	r2, [sp, #4]
 8001544:	6912      	ldr	r2, [r2, #16]
 8001546:	611a      	str	r2, [r3, #16]
 8001548:	9b01      	ldr	r3, [sp, #4]
 800154a:	691b      	ldr	r3, [r3, #16]
 800154c:	9a01      	ldr	r2, [sp, #4]
 800154e:	6952      	ldr	r2, [r2, #20]
 8001550:	615a      	str	r2, [r3, #20]
    chSysUnlock();
 8001552:	f7ff fe75 	bl	8001240 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001556:	9b01      	ldr	r3, [sp, #4]
 8001558:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800155c:	f003 0303 	and.w	r3, r3, #3
 8001560:	2b01      	cmp	r3, #1
 8001562:	d002      	beq.n	800156a <chThdRelease+0x5a>
 8001564:	2b02      	cmp	r3, #2
 8001566:	d008      	beq.n	800157a <chThdRelease+0x6a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
      break;
#endif
    default:
      /* Nothing else to do for static threads.*/
      break;
 8001568:	e012      	b.n	8001590 <chThdRelease+0x80>

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 800156a:	9801      	ldr	r0, [sp, #4]
 800156c:	f7ff fe98 	bl	80012a0 <chThdGetWorkingAreaX>
 8001570:	4603      	mov	r3, r0
 8001572:	4618      	mov	r0, r3
 8001574:	f002 f9c4 	bl	8003900 <chHeapFree>
      break;
 8001578:	e00a      	b.n	8001590 <chThdRelease+0x80>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800157a:	9b01      	ldr	r3, [sp, #4]
 800157c:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 800157e:	9801      	ldr	r0, [sp, #4]
 8001580:	f7ff fe8e 	bl	80012a0 <chThdGetWorkingAreaX>
 8001584:	4603      	mov	r3, r0
 8001586:	4620      	mov	r0, r4
 8001588:	4619      	mov	r1, r3
 800158a:	f002 fb21 	bl	8003bd0 <chPoolFree>
      break;
 800158e:	bf00      	nop
    default:
      /* Nothing else to do for static threads.*/
      break;
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
 8001590:	e001      	b.n	8001596 <chThdRelease+0x86>
  }
  chSysUnlock();
 8001592:	f7ff fe55 	bl	8001240 <chSysUnlock>
}
 8001596:	b002      	add	sp, #8
 8001598:	bd10      	pop	{r4, pc}
 800159a:	bf00      	nop
 800159c:	f3af 8000 	nop.w

080015a0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80015a0:	b500      	push	{lr}
 80015a2:	b083      	sub	sp, #12
 80015a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80015a6:	f7ff fe43 	bl	8001230 <chSysLock>
  chThdExitS(msg);
 80015aa:	9801      	ldr	r0, [sp, #4]
 80015ac:	f000 f808 	bl	80015c0 <chThdExitS>
  /* The thread never returns here.*/
}
 80015b0:	b003      	add	sp, #12
 80015b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80015b6:	bf00      	nop
 80015b8:	f3af 8000 	nop.w
 80015bc:	f3af 8000 	nop.w

080015c0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80015c0:	b500      	push	{lr}
 80015c2:	b085      	sub	sp, #20
 80015c4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80015c6:	4b1a      	ldr	r3, [pc, #104]	; (8001630 <chThdExitS+0x70>)
 80015c8:	699b      	ldr	r3, [r3, #24]
 80015ca:	9303      	str	r3, [sp, #12]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80015cc:	9b03      	ldr	r3, [sp, #12]
 80015ce:	9a01      	ldr	r2, [sp, #4]
 80015d0:	625a      	str	r2, [r3, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80015d2:	e008      	b.n	80015e6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->waiting));
 80015d4:	9b03      	ldr	r3, [sp, #12]
 80015d6:	3328      	adds	r3, #40	; 0x28
 80015d8:	4618      	mov	r0, r3
 80015da:	f7ff fdc9 	bl	8001170 <list_remove>
 80015de:	4603      	mov	r3, r0
 80015e0:	4618      	mov	r0, r3
 80015e2:	f7ff fbbd 	bl	8000d60 <chSchReadyI>
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80015e6:	9b03      	ldr	r3, [sp, #12]
 80015e8:	3328      	adds	r3, #40	; 0x28
 80015ea:	4618      	mov	r0, r3
 80015ec:	f7ff fd80 	bl	80010f0 <list_notempty>
 80015f0:	4603      	mov	r3, r0
 80015f2:	2b00      	cmp	r3, #0
 80015f4:	d1ee      	bne.n	80015d4 <chThdExitS+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80015f6:	9b03      	ldr	r3, [sp, #12]
 80015f8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80015fc:	2b00      	cmp	r3, #0
 80015fe:	d110      	bne.n	8001622 <chThdExitS+0x62>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8001600:	9b03      	ldr	r3, [sp, #12]
 8001602:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8001606:	f003 0303 	and.w	r3, r3, #3

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800160a:	2b00      	cmp	r3, #0
 800160c:	d109      	bne.n	8001622 <chThdExitS+0x62>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	695b      	ldr	r3, [r3, #20]
 8001612:	9a03      	ldr	r2, [sp, #12]
 8001614:	6912      	ldr	r2, [r2, #16]
 8001616:	611a      	str	r2, [r3, #16]
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	691b      	ldr	r3, [r3, #16]
 800161c:	9a03      	ldr	r2, [sp, #12]
 800161e:	6952      	ldr	r2, [r2, #20]
 8001620:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001622:	200f      	movs	r0, #15
 8001624:	f7ff fbec 	bl	8000e00 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001628:	b005      	add	sp, #20
 800162a:	f85d fb04 	ldr.w	pc, [sp], #4
 800162e:	bf00      	nop
 8001630:	20000af8 	.word	0x20000af8
 8001634:	f3af 8000 	nop.w
 8001638:	f3af 8000 	nop.w
 800163c:	f3af 8000 	nop.w

08001640 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001640:	b500      	push	{lr}
 8001642:	b085      	sub	sp, #20
 8001644:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8001646:	f7ff fdf3 	bl	8001230 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 800164a:	9b01      	ldr	r3, [sp, #4]
 800164c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001650:	2b0f      	cmp	r3, #15
 8001652:	d00a      	beq.n	800166a <chThdWait+0x2a>
    list_insert(currp, &tp->waiting);
 8001654:	4b0b      	ldr	r3, [pc, #44]	; (8001684 <chThdWait+0x44>)
 8001656:	699a      	ldr	r2, [r3, #24]
 8001658:	9b01      	ldr	r3, [sp, #4]
 800165a:	3328      	adds	r3, #40	; 0x28
 800165c:	4610      	mov	r0, r2
 800165e:	4619      	mov	r1, r3
 8001660:	f7ff fd76 	bl	8001150 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001664:	2009      	movs	r0, #9
 8001666:	f7ff fbcb 	bl	8000e00 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 800166a:	9b01      	ldr	r3, [sp, #4]
 800166c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800166e:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8001670:	f7ff fde6 	bl	8001240 <chSysUnlock>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8001674:	9801      	ldr	r0, [sp, #4]
 8001676:	f7ff ff4b 	bl	8001510 <chThdRelease>
#endif

  return msg;
 800167a:	9b03      	ldr	r3, [sp, #12]
}
 800167c:	4618      	mov	r0, r3
 800167e:	b005      	add	sp, #20
 8001680:	f85d fb04 	ldr.w	pc, [sp], #4
 8001684:	20000af8 	.word	0x20000af8
 8001688:	f3af 8000 	nop.w
 800168c:	f3af 8000 	nop.w

08001690 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001690:	b500      	push	{lr}
 8001692:	b085      	sub	sp, #20
 8001694:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
 8001696:	f7ff fdcb 	bl	8001230 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 800169a:	4b11      	ldr	r3, [pc, #68]	; (80016e0 <chThdSetPriority+0x50>)
 800169c:	699b      	ldr	r3, [r3, #24]
 800169e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80016a0:	9303      	str	r3, [sp, #12]
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 80016a2:	4b0f      	ldr	r3, [pc, #60]	; (80016e0 <chThdSetPriority+0x50>)
 80016a4:	699b      	ldr	r3, [r3, #24]
 80016a6:	689a      	ldr	r2, [r3, #8]
 80016a8:	4b0d      	ldr	r3, [pc, #52]	; (80016e0 <chThdSetPriority+0x50>)
 80016aa:	699b      	ldr	r3, [r3, #24]
 80016ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80016ae:	429a      	cmp	r2, r3
 80016b0:	d005      	beq.n	80016be <chThdSetPriority+0x2e>
 80016b2:	4b0b      	ldr	r3, [pc, #44]	; (80016e0 <chThdSetPriority+0x50>)
 80016b4:	699b      	ldr	r3, [r3, #24]
 80016b6:	689a      	ldr	r2, [r3, #8]
 80016b8:	9b01      	ldr	r3, [sp, #4]
 80016ba:	429a      	cmp	r2, r3
 80016bc:	d203      	bcs.n	80016c6 <chThdSetPriority+0x36>
    currp->prio = newprio;
 80016be:	4b08      	ldr	r3, [pc, #32]	; (80016e0 <chThdSetPriority+0x50>)
 80016c0:	699b      	ldr	r3, [r3, #24]
 80016c2:	9a01      	ldr	r2, [sp, #4]
 80016c4:	609a      	str	r2, [r3, #8]
  }
  currp->realprio = newprio;
 80016c6:	4b06      	ldr	r3, [pc, #24]	; (80016e0 <chThdSetPriority+0x50>)
 80016c8:	699b      	ldr	r3, [r3, #24]
 80016ca:	9a01      	ldr	r2, [sp, #4]
 80016cc:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 80016ce:	f7ff fc5f 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 80016d2:	f7ff fdb5 	bl	8001240 <chSysUnlock>

  return oldprio;
 80016d6:	9b03      	ldr	r3, [sp, #12]
}
 80016d8:	4618      	mov	r0, r3
 80016da:	b005      	add	sp, #20
 80016dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e0:	20000af8 	.word	0x20000af8
 80016e4:	f3af 8000 	nop.w
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80016f0:	b500      	push	{lr}
 80016f2:	b083      	sub	sp, #12
 80016f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80016f6:	f7ff fd9b 	bl	8001230 <chSysLock>
  tp->flags |= CH_FLAG_TERMINATE;
 80016fa:	9b01      	ldr	r3, [sp, #4]
 80016fc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8001700:	f043 0304 	orr.w	r3, r3, #4
 8001704:	b2da      	uxtb	r2, r3
 8001706:	9b01      	ldr	r3, [sp, #4]
 8001708:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSysUnlock();
 800170c:	f7ff fd98 	bl	8001240 <chSysUnlock>
}
 8001710:	b003      	add	sp, #12
 8001712:	f85d fb04 	ldr.w	pc, [sp], #4
 8001716:	bf00      	nop
 8001718:	f3af 8000 	nop.w
 800171c:	f3af 8000 	nop.w

08001720 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001726:	f7ff fd83 	bl	8001230 <chSysLock>
  chThdSleepS(time);
 800172a:	9801      	ldr	r0, [sp, #4]
 800172c:	f7ff fdc0 	bl	80012b0 <chThdSleepS>
  chSysUnlock();
 8001730:	f7ff fd86 	bl	8001240 <chSysUnlock>
}
 8001734:	b003      	add	sp, #12
 8001736:	f85d fb04 	ldr.w	pc, [sp], #4
 800173a:	bf00      	nop
 800173c:	f3af 8000 	nop.w

08001740 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8001740:	b500      	push	{lr}
 8001742:	b083      	sub	sp, #12
 8001744:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001746:	f7ff fd73 	bl	8001230 <chSysLock>
  time -= chVTGetSystemTimeX();
 800174a:	f7ff fd81 	bl	8001250 <chVTGetSystemTimeX>
 800174e:	4602      	mov	r2, r0
 8001750:	9b01      	ldr	r3, [sp, #4]
 8001752:	1a9b      	subs	r3, r3, r2
 8001754:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	2b00      	cmp	r3, #0
 800175a:	d002      	beq.n	8001762 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800175c:	9801      	ldr	r0, [sp, #4]
 800175e:	f7ff fda7 	bl	80012b0 <chThdSleepS>
  }
  chSysUnlock();
 8001762:	f7ff fd6d 	bl	8001240 <chSysUnlock>
}
 8001766:	b003      	add	sp, #12
 8001768:	f85d fb04 	ldr.w	pc, [sp], #4
 800176c:	f3af 8000 	nop.w

08001770 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return              the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 8001770:	b500      	push	{lr}
 8001772:	b085      	sub	sp, #20
 8001774:	9001      	str	r0, [sp, #4]
 8001776:	9100      	str	r1, [sp, #0]
  systime_t time;

  chSysLock();
 8001778:	f7ff fd5a 	bl	8001230 <chSysLock>
  time = chVTGetSystemTimeX();
 800177c:	f7ff fd68 	bl	8001250 <chVTGetSystemTimeX>
 8001780:	9003      	str	r0, [sp, #12]
  if (chVTIsTimeWithinX(time, prev, next)) {
 8001782:	9803      	ldr	r0, [sp, #12]
 8001784:	9901      	ldr	r1, [sp, #4]
 8001786:	9a00      	ldr	r2, [sp, #0]
 8001788:	f7ff fd6a 	bl	8001260 <chVTIsTimeWithinX>
 800178c:	4603      	mov	r3, r0
 800178e:	2b00      	cmp	r3, #0
 8001790:	d005      	beq.n	800179e <chThdSleepUntilWindowed+0x2e>
    chThdSleepS(next - time);
 8001792:	9a00      	ldr	r2, [sp, #0]
 8001794:	9b03      	ldr	r3, [sp, #12]
 8001796:	1ad3      	subs	r3, r2, r3
 8001798:	4618      	mov	r0, r3
 800179a:	f7ff fd89 	bl	80012b0 <chThdSleepS>
  }
  chSysUnlock();
 800179e:	f7ff fd4f 	bl	8001240 <chSysUnlock>

  return next;
 80017a2:	9b00      	ldr	r3, [sp, #0]
}
 80017a4:	4618      	mov	r0, r3
 80017a6:	b005      	add	sp, #20
 80017a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80017ac:	f3af 8000 	nop.w

080017b0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 80017b0:	b508      	push	{r3, lr}

  chSysLock();
 80017b2:	f7ff fd3d 	bl	8001230 <chSysLock>
  chSchDoYieldS();
 80017b6:	f7ff fd2b 	bl	8001210 <chSchDoYieldS>
  chSysUnlock();
 80017ba:	f7ff fd41 	bl	8001240 <chSysUnlock>
}
 80017be:	bd08      	pop	{r3, pc}

080017c0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 80017c0:	b500      	push	{lr}
 80017c2:	b085      	sub	sp, #20
 80017c4:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 80017c6:	f7ff fd63 	bl	8001290 <chThdGetSelfX>
 80017ca:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 80017cc:	9b01      	ldr	r3, [sp, #4]
 80017ce:	9a03      	ldr	r2, [sp, #12]
 80017d0:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 80017d2:	9b03      	ldr	r3, [sp, #12]
 80017d4:	9a01      	ldr	r2, [sp, #4]
 80017d6:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80017d8:	2003      	movs	r0, #3
 80017da:	f7ff fb11 	bl	8000e00 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
 80017de:	f7ff fd57 	bl	8001290 <chThdGetSelfX>
 80017e2:	4603      	mov	r3, r0
 80017e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80017e6:	4618      	mov	r0, r3
 80017e8:	b005      	add	sp, #20
 80017ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80017ee:	bf00      	nop

080017f0 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 80017f0:	b500      	push	{lr}
 80017f2:	b085      	sub	sp, #20
 80017f4:	9001      	str	r0, [sp, #4]
 80017f6:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 80017f8:	f7ff fd4a 	bl	8001290 <chThdGetSelfX>
 80017fc:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 80017fe:	9b00      	ldr	r3, [sp, #0]
 8001800:	2b00      	cmp	r3, #0
 8001802:	d102      	bne.n	800180a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8001804:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001808:	e00a      	b.n	8001820 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	9a03      	ldr	r2, [sp, #12]
 800180e:	601a      	str	r2, [r3, #0]
  tp->u.wttrp = trp;
 8001810:	9b03      	ldr	r3, [sp, #12]
 8001812:	9a01      	ldr	r2, [sp, #4]
 8001814:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001816:	2003      	movs	r0, #3
 8001818:	9900      	ldr	r1, [sp, #0]
 800181a:	f7ff fb59 	bl	8000ed0 <chSchGoSleepTimeoutS>
 800181e:	4603      	mov	r3, r0
}
 8001820:	4618      	mov	r0, r3
 8001822:	b005      	add	sp, #20
 8001824:	f85d fb04 	ldr.w	pc, [sp], #4
 8001828:	f3af 8000 	nop.w
 800182c:	f3af 8000 	nop.w

08001830 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8001830:	b500      	push	{lr}
 8001832:	b085      	sub	sp, #20
 8001834:	9001      	str	r0, [sp, #4]
 8001836:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	681b      	ldr	r3, [r3, #0]
 800183c:	2b00      	cmp	r3, #0
 800183e:	d00b      	beq.n	8001858 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 8001840:	9b01      	ldr	r3, [sp, #4]
 8001842:	681b      	ldr	r3, [r3, #0]
 8001844:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001846:	9b01      	ldr	r3, [sp, #4]
 8001848:	2200      	movs	r2, #0
 800184a:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800184c:	9b03      	ldr	r3, [sp, #12]
 800184e:	9a00      	ldr	r2, [sp, #0]
 8001850:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001852:	9803      	ldr	r0, [sp, #12]
 8001854:	f7ff fa84 	bl	8000d60 <chSchReadyI>
  }
}
 8001858:	b005      	add	sp, #20
 800185a:	f85d fb04 	ldr.w	pc, [sp], #4
 800185e:	bf00      	nop

08001860 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 8001860:	b500      	push	{lr}
 8001862:	b085      	sub	sp, #20
 8001864:	9001      	str	r0, [sp, #4]
 8001866:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8001868:	9b01      	ldr	r3, [sp, #4]
 800186a:	681b      	ldr	r3, [r3, #0]
 800186c:	2b00      	cmp	r3, #0
 800186e:	d009      	beq.n	8001884 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8001870:	9b01      	ldr	r3, [sp, #4]
 8001872:	681b      	ldr	r3, [r3, #0]
 8001874:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001876:	9b01      	ldr	r3, [sp, #4]
 8001878:	2200      	movs	r2, #0
 800187a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800187c:	9803      	ldr	r0, [sp, #12]
 800187e:	9900      	ldr	r1, [sp, #0]
 8001880:	f7ff fb5e 	bl	8000f40 <chSchWakeupS>
  }
}
 8001884:	b005      	add	sp, #20
 8001886:	f85d fb04 	ldr.w	pc, [sp], #4
 800188a:	bf00      	nop
 800188c:	f3af 8000 	nop.w

08001890 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8001890:	b500      	push	{lr}
 8001892:	b083      	sub	sp, #12
 8001894:	9001      	str	r0, [sp, #4]
 8001896:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001898:	f7ff fcca 	bl	8001230 <chSysLock>
  chThdResumeS(trp, msg);
 800189c:	9801      	ldr	r0, [sp, #4]
 800189e:	9900      	ldr	r1, [sp, #0]
 80018a0:	f7ff ffde 	bl	8001860 <chThdResumeS>
  chSysUnlock();
 80018a4:	f7ff fccc 	bl	8001240 <chSysUnlock>
}
 80018a8:	b003      	add	sp, #12
 80018aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80018ae:	bf00      	nop

080018b0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80018b0:	b500      	push	{lr}
 80018b2:	b083      	sub	sp, #12
 80018b4:	9001      	str	r0, [sp, #4]
 80018b6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 80018b8:	9b00      	ldr	r3, [sp, #0]
 80018ba:	2b00      	cmp	r3, #0
 80018bc:	d102      	bne.n	80018c4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 80018be:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80018c2:	e00a      	b.n	80018da <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 80018c4:	4b07      	ldr	r3, [pc, #28]	; (80018e4 <chThdEnqueueTimeoutS+0x34>)
 80018c6:	699b      	ldr	r3, [r3, #24]
 80018c8:	4618      	mov	r0, r3
 80018ca:	9901      	ldr	r1, [sp, #4]
 80018cc:	f7ff fc60 	bl	8001190 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80018d0:	2004      	movs	r0, #4
 80018d2:	9900      	ldr	r1, [sp, #0]
 80018d4:	f7ff fafc 	bl	8000ed0 <chSchGoSleepTimeoutS>
 80018d8:	4603      	mov	r3, r0
}
 80018da:	4618      	mov	r0, r3
 80018dc:	b003      	add	sp, #12
 80018de:	f85d fb04 	ldr.w	pc, [sp], #4
 80018e2:	bf00      	nop
 80018e4:	20000af8 	.word	0x20000af8
 80018e8:	f3af 8000 	nop.w
 80018ec:	f3af 8000 	nop.w

080018f0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80018f0:	b500      	push	{lr}
 80018f2:	b083      	sub	sp, #12
 80018f4:	9001      	str	r0, [sp, #4]
 80018f6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 80018f8:	9801      	ldr	r0, [sp, #4]
 80018fa:	f7ff fc19 	bl	8001130 <queue_notempty>
 80018fe:	4603      	mov	r3, r0
 8001900:	2b00      	cmp	r3, #0
 8001902:	d003      	beq.n	800190c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001904:	9801      	ldr	r0, [sp, #4]
 8001906:	9900      	ldr	r1, [sp, #0]
 8001908:	f7ff fce2 	bl	80012d0 <chThdDoDequeueNextI>
  }
}
 800190c:	b003      	add	sp, #12
 800190e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001912:	bf00      	nop
 8001914:	f3af 8000 	nop.w
 8001918:	f3af 8000 	nop.w
 800191c:	f3af 8000 	nop.w

08001920 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001920:	b500      	push	{lr}
 8001922:	b083      	sub	sp, #12
 8001924:	9001      	str	r0, [sp, #4]
 8001926:	9100      	str	r1, [sp, #0]

  while (queue_notempty(tqp)) {
 8001928:	e003      	b.n	8001932 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
 800192a:	9801      	ldr	r0, [sp, #4]
 800192c:	9900      	ldr	r1, [sp, #0]
 800192e:	f7ff fccf 	bl	80012d0 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 8001932:	9801      	ldr	r0, [sp, #4]
 8001934:	f7ff fbfc 	bl	8001130 <queue_notempty>
 8001938:	4603      	mov	r3, r0
 800193a:	2b00      	cmp	r3, #0
 800193c:	d1f5      	bne.n	800192a <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800193e:	b003      	add	sp, #12
 8001940:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001950 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001950:	4b01      	ldr	r3, [pc, #4]	; (8001958 <port_rt_get_counter_value+0x8>)
 8001952:	685b      	ldr	r3, [r3, #4]
}
 8001954:	4618      	mov	r0, r3
 8001956:	4770      	bx	lr
 8001958:	e0001000 	.word	0xe0001000
 800195c:	f3af 8000 	nop.w

08001960 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8001960:	b084      	sub	sp, #16
 8001962:	9003      	str	r0, [sp, #12]
 8001964:	9102      	str	r1, [sp, #8]
 8001966:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8001968:	9b03      	ldr	r3, [sp, #12]
 800196a:	68db      	ldr	r3, [r3, #12]
 800196c:	1c5a      	adds	r2, r3, #1
 800196e:	9b03      	ldr	r3, [sp, #12]
 8001970:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8001972:	9b03      	ldr	r3, [sp, #12]
 8001974:	689b      	ldr	r3, [r3, #8]
 8001976:	9a02      	ldr	r2, [sp, #8]
 8001978:	1ad2      	subs	r2, r2, r3
 800197a:	9b01      	ldr	r3, [sp, #4]
 800197c:	1ad2      	subs	r2, r2, r3
 800197e:	9b03      	ldr	r3, [sp, #12]
 8001980:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001982:	9b03      	ldr	r3, [sp, #12]
 8001984:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8001988:	9b03      	ldr	r3, [sp, #12]
 800198a:	689b      	ldr	r3, [r3, #8]
 800198c:	461a      	mov	r2, r3
 800198e:	f04f 0300 	mov.w	r3, #0
 8001992:	1812      	adds	r2, r2, r0
 8001994:	eb43 0301 	adc.w	r3, r3, r1
 8001998:	9903      	ldr	r1, [sp, #12]
 800199a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800199e:	9b03      	ldr	r3, [sp, #12]
 80019a0:	689a      	ldr	r2, [r3, #8]
 80019a2:	9b03      	ldr	r3, [sp, #12]
 80019a4:	685b      	ldr	r3, [r3, #4]
 80019a6:	429a      	cmp	r2, r3
 80019a8:	d903      	bls.n	80019b2 <tm_stop+0x52>
    tmp->worst = tmp->last;
 80019aa:	9b03      	ldr	r3, [sp, #12]
 80019ac:	689a      	ldr	r2, [r3, #8]
 80019ae:	9b03      	ldr	r3, [sp, #12]
 80019b0:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 80019b2:	9b03      	ldr	r3, [sp, #12]
 80019b4:	689a      	ldr	r2, [r3, #8]
 80019b6:	9b03      	ldr	r3, [sp, #12]
 80019b8:	681b      	ldr	r3, [r3, #0]
 80019ba:	429a      	cmp	r2, r3
 80019bc:	d203      	bcs.n	80019c6 <tm_stop+0x66>
    tmp->best = tmp->last;
 80019be:	9b03      	ldr	r3, [sp, #12]
 80019c0:	689a      	ldr	r2, [r3, #8]
 80019c2:	9b03      	ldr	r3, [sp, #12]
 80019c4:	601a      	str	r2, [r3, #0]
  }
}
 80019c6:	b004      	add	sp, #16
 80019c8:	4770      	bx	lr
 80019ca:	bf00      	nop
 80019cc:	f3af 8000 	nop.w

080019d0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 80019d0:	b500      	push	{lr}
 80019d2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80019d4:	4b0a      	ldr	r3, [pc, #40]	; (8001a00 <_tm_init+0x30>)
 80019d6:	2200      	movs	r2, #0
 80019d8:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 80019da:	466b      	mov	r3, sp
 80019dc:	4618      	mov	r0, r3
 80019de:	f000 f817 	bl	8001a10 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 80019e2:	466b      	mov	r3, sp
 80019e4:	4618      	mov	r0, r3
 80019e6:	f000 f82b 	bl	8001a40 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 80019ea:	466b      	mov	r3, sp
 80019ec:	4618      	mov	r0, r3
 80019ee:	f000 f837 	bl	8001a60 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 80019f2:	9b02      	ldr	r3, [sp, #8]
 80019f4:	4a02      	ldr	r2, [pc, #8]	; (8001a00 <_tm_init+0x30>)
 80019f6:	6753      	str	r3, [r2, #116]	; 0x74
}
 80019f8:	b007      	add	sp, #28
 80019fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80019fe:	bf00      	nop
 8001a00:	20000af8 	.word	0x20000af8
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8001a10:	b082      	sub	sp, #8
 8001a12:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8001a14:	9b01      	ldr	r3, [sp, #4]
 8001a16:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001a1a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8001a1c:	9b01      	ldr	r3, [sp, #4]
 8001a1e:	2200      	movs	r2, #0
 8001a20:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8001a22:	9b01      	ldr	r3, [sp, #4]
 8001a24:	2200      	movs	r2, #0
 8001a26:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8001a28:	9b01      	ldr	r3, [sp, #4]
 8001a2a:	2200      	movs	r2, #0
 8001a2c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8001a2e:	9901      	ldr	r1, [sp, #4]
 8001a30:	f04f 0200 	mov.w	r2, #0
 8001a34:	f04f 0300 	mov.w	r3, #0
 8001a38:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 8001a3c:	b002      	add	sp, #8
 8001a3e:	4770      	bx	lr

08001a40 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8001a40:	b500      	push	{lr}
 8001a42:	b083      	sub	sp, #12
 8001a44:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8001a46:	f7ff ff83 	bl	8001950 <port_rt_get_counter_value>
 8001a4a:	4602      	mov	r2, r0
 8001a4c:	9b01      	ldr	r3, [sp, #4]
 8001a4e:	609a      	str	r2, [r3, #8]
}
 8001a50:	b003      	add	sp, #12
 8001a52:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a56:	bf00      	nop
 8001a58:	f3af 8000 	nop.w
 8001a5c:	f3af 8000 	nop.w

08001a60 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001a60:	b500      	push	{lr}
 8001a62:	b083      	sub	sp, #12
 8001a64:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001a66:	f7ff ff73 	bl	8001950 <port_rt_get_counter_value>
 8001a6a:	4602      	mov	r2, r0
 8001a6c:	4b04      	ldr	r3, [pc, #16]	; (8001a80 <chTMStopMeasurementX+0x20>)
 8001a6e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001a70:	9801      	ldr	r0, [sp, #4]
 8001a72:	4611      	mov	r1, r2
 8001a74:	461a      	mov	r2, r3
 8001a76:	f7ff ff73 	bl	8001960 <tm_stop>
}
 8001a7a:	b003      	add	sp, #12
 8001a7c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a80:	20000af8 	.word	0x20000af8
 8001a84:	f3af 8000 	nop.w
 8001a88:	f3af 8000 	nop.w
 8001a8c:	f3af 8000 	nop.w

08001a90 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8001a90:	b500      	push	{lr}
 8001a92:	b083      	sub	sp, #12
 8001a94:	9001      	str	r0, [sp, #4]
 8001a96:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8001a98:	f7ff ff5a 	bl	8001950 <port_rt_get_counter_value>
 8001a9c:	4602      	mov	r2, r0
 8001a9e:	9b00      	ldr	r3, [sp, #0]
 8001aa0:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8001aa2:	9b00      	ldr	r3, [sp, #0]
 8001aa4:	689b      	ldr	r3, [r3, #8]
 8001aa6:	9801      	ldr	r0, [sp, #4]
 8001aa8:	4619      	mov	r1, r3
 8001aaa:	2200      	movs	r2, #0
 8001aac:	f7ff ff58 	bl	8001960 <tm_stop>
}
 8001ab0:	b003      	add	sp, #12
 8001ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ab6:	bf00      	nop
	...

08001ac0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001ac0:	b082      	sub	sp, #8
 8001ac2:	2320      	movs	r3, #32
 8001ac4:	9301      	str	r3, [sp, #4]
 8001ac6:	9b01      	ldr	r3, [sp, #4]
 8001ac8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001acc:	b002      	add	sp, #8
 8001ace:	4770      	bx	lr

08001ad0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001ad0:	b082      	sub	sp, #8
 8001ad2:	2300      	movs	r3, #0
 8001ad4:	9301      	str	r3, [sp, #4]
 8001ad6:	9b01      	ldr	r3, [sp, #4]
 8001ad8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001adc:	b002      	add	sp, #8
 8001ade:	4770      	bx	lr

08001ae0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001ae0:	b508      	push	{r3, lr}

  port_lock();
 8001ae2:	f7ff ffed 	bl	8001ac0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001ae6:	bd08      	pop	{r3, pc}
 8001ae8:	f3af 8000 	nop.w
 8001aec:	f3af 8000 	nop.w

08001af0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001af0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8001af2:	f7ff ffed 	bl	8001ad0 <port_unlock>
}
 8001af6:	bd08      	pop	{r3, pc}
 8001af8:	f3af 8000 	nop.w
 8001afc:	f3af 8000 	nop.w

08001b00 <chThdGetWorkingAreaX>:
 * @param[in] tp        pointer to the thread
 * @return              The working area base pointer.
 *
 * @xclass
 */
static inline stkalign_t *chThdGetWorkingAreaX(thread_t *tp) {
 8001b00:	b082      	sub	sp, #8
 8001b02:	9001      	str	r0, [sp, #4]

  return tp->wabase;
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	69db      	ldr	r3, [r3, #28]
}
 8001b08:	4618      	mov	r0, r3
 8001b0a:	b002      	add	sp, #8
 8001b0c:	4770      	bx	lr
 8001b0e:	bf00      	nop

08001b10 <chRegGetThreadNameX>:
 *
 * @return              Thread name as a zero terminated string.
 * @retval NULL         if the thread name has not been set.
 *
 */
static inline const char *chRegGetThreadNameX(thread_t *tp) {
 8001b10:	b082      	sub	sp, #8
 8001b12:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  return tp->name;
 8001b14:	9b01      	ldr	r3, [sp, #4]
 8001b16:	699b      	ldr	r3, [r3, #24]
#else
  (void)tp;
  return NULL;
#endif
}
 8001b18:	4618      	mov	r0, r3
 8001b1a:	b002      	add	sp, #8
 8001b1c:	4770      	bx	lr
 8001b1e:	bf00      	nop

08001b20 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001b20:	b500      	push	{lr}
 8001b22:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001b24:	f7ff ffdc 	bl	8001ae0 <chSysLock>
  tp = ch.rlist.newer;
 8001b28:	4b08      	ldr	r3, [pc, #32]	; (8001b4c <chRegFirstThread+0x2c>)
 8001b2a:	691b      	ldr	r3, [r3, #16]
 8001b2c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8001b2e:	9b01      	ldr	r3, [sp, #4]
 8001b30:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8001b34:	3301      	adds	r3, #1
 8001b36:	b2da      	uxtb	r2, r3
 8001b38:	9b01      	ldr	r3, [sp, #4]
 8001b3a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 8001b3e:	f7ff ffd7 	bl	8001af0 <chSysUnlock>

  return tp;
 8001b42:	9b01      	ldr	r3, [sp, #4]
}
 8001b44:	4618      	mov	r0, r3
 8001b46:	b003      	add	sp, #12
 8001b48:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b4c:	20000af8 	.word	0x20000af8

08001b50 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001b50:	b500      	push	{lr}
 8001b52:	b085      	sub	sp, #20
 8001b54:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001b56:	f7ff ffc3 	bl	8001ae0 <chSysLock>
  ntp = tp->newer;
 8001b5a:	9b01      	ldr	r3, [sp, #4]
 8001b5c:	691b      	ldr	r3, [r3, #16]
 8001b5e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001b60:	9b03      	ldr	r3, [sp, #12]
 8001b62:	4a0c      	ldr	r2, [pc, #48]	; (8001b94 <chRegNextThread+0x44>)
 8001b64:	4293      	cmp	r3, r2
 8001b66:	d102      	bne.n	8001b6e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001b68:	2300      	movs	r3, #0
 8001b6a:	9303      	str	r3, [sp, #12]
 8001b6c:	e007      	b.n	8001b7e <chRegNextThread+0x2e>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
 8001b6e:	9b03      	ldr	r3, [sp, #12]
 8001b70:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8001b74:	3301      	adds	r3, #1
 8001b76:	b2da      	uxtb	r2, r3
 8001b78:	9b03      	ldr	r3, [sp, #12]
 8001b7a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 8001b7e:	f7ff ffb7 	bl	8001af0 <chSysUnlock>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001b82:	9801      	ldr	r0, [sp, #4]
 8001b84:	f7ff fcc4 	bl	8001510 <chThdRelease>
#endif

  return ntp;
 8001b88:	9b03      	ldr	r3, [sp, #12]
}
 8001b8a:	4618      	mov	r0, r3
 8001b8c:	b005      	add	sp, #20
 8001b8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b92:	bf00      	nop
 8001b94:	20000af8 	.word	0x20000af8
 8001b98:	f3af 8000 	nop.w
 8001b9c:	f3af 8000 	nop.w

08001ba0 <chRegFindThreadByName>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByName(const char *name) {
 8001ba0:	b500      	push	{lr}
 8001ba2:	b085      	sub	sp, #20
 8001ba4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8001ba6:	f7ff ffbb 	bl	8001b20 <chRegFirstThread>
 8001baa:	9003      	str	r0, [sp, #12]
  do {
    if (strcmp(chRegGetThreadNameX(ctp), name) == 0) {
 8001bac:	9803      	ldr	r0, [sp, #12]
 8001bae:	f7ff ffaf 	bl	8001b10 <chRegGetThreadNameX>
 8001bb2:	4603      	mov	r3, r0
 8001bb4:	4618      	mov	r0, r3
 8001bb6:	9901      	ldr	r1, [sp, #4]
 8001bb8:	f00b ffb6 	bl	800db28 <strcmp>
 8001bbc:	4603      	mov	r3, r0
 8001bbe:	2b00      	cmp	r3, #0
 8001bc0:	d101      	bne.n	8001bc6 <chRegFindThreadByName+0x26>
      return ctp;
 8001bc2:	9b03      	ldr	r3, [sp, #12]
 8001bc4:	e007      	b.n	8001bd6 <chRegFindThreadByName+0x36>
    }
    ctp = chRegNextThread(ctp);
 8001bc6:	9803      	ldr	r0, [sp, #12]
 8001bc8:	f7ff ffc2 	bl	8001b50 <chRegNextThread>
 8001bcc:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8001bce:	9b03      	ldr	r3, [sp, #12]
 8001bd0:	2b00      	cmp	r3, #0
 8001bd2:	d1eb      	bne.n	8001bac <chRegFindThreadByName+0xc>

  return NULL;
 8001bd4:	2300      	movs	r3, #0
}
 8001bd6:	4618      	mov	r0, r3
 8001bd8:	b005      	add	sp, #20
 8001bda:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bde:	bf00      	nop

08001be0 <chRegFindThreadByPointer>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByPointer(thread_t *tp) {
 8001be0:	b500      	push	{lr}
 8001be2:	b085      	sub	sp, #20
 8001be4:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8001be6:	f7ff ff9b 	bl	8001b20 <chRegFirstThread>
 8001bea:	9003      	str	r0, [sp, #12]
  do {
    if (ctp == tp) {
 8001bec:	9a03      	ldr	r2, [sp, #12]
 8001bee:	9b01      	ldr	r3, [sp, #4]
 8001bf0:	429a      	cmp	r2, r3
 8001bf2:	d101      	bne.n	8001bf8 <chRegFindThreadByPointer+0x18>
      return ctp;
 8001bf4:	9b03      	ldr	r3, [sp, #12]
 8001bf6:	e007      	b.n	8001c08 <chRegFindThreadByPointer+0x28>
    }
    ctp = chRegNextThread(ctp);
 8001bf8:	9803      	ldr	r0, [sp, #12]
 8001bfa:	f7ff ffa9 	bl	8001b50 <chRegNextThread>
 8001bfe:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8001c00:	9b03      	ldr	r3, [sp, #12]
 8001c02:	2b00      	cmp	r3, #0
 8001c04:	d1f2      	bne.n	8001bec <chRegFindThreadByPointer+0xc>

  return NULL;
 8001c06:	2300      	movs	r3, #0
}
 8001c08:	4618      	mov	r0, r3
 8001c0a:	b005      	add	sp, #20
 8001c0c:	f85d fb04 	ldr.w	pc, [sp], #4

08001c10 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8001c10:	b500      	push	{lr}
 8001c12:	b085      	sub	sp, #20
 8001c14:	9001      	str	r0, [sp, #4]
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8001c16:	f7ff ff83 	bl	8001b20 <chRegFirstThread>
 8001c1a:	9003      	str	r0, [sp, #12]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8001c1c:	9803      	ldr	r0, [sp, #12]
 8001c1e:	f7ff ff6f 	bl	8001b00 <chThdGetWorkingAreaX>
 8001c22:	4602      	mov	r2, r0
 8001c24:	9b01      	ldr	r3, [sp, #4]
 8001c26:	429a      	cmp	r2, r3
 8001c28:	d101      	bne.n	8001c2e <chRegFindThreadByWorkingArea+0x1e>
      return ctp;
 8001c2a:	9b03      	ldr	r3, [sp, #12]
 8001c2c:	e007      	b.n	8001c3e <chRegFindThreadByWorkingArea+0x2e>
    }
    ctp = chRegNextThread(ctp);
 8001c2e:	9803      	ldr	r0, [sp, #12]
 8001c30:	f7ff ff8e 	bl	8001b50 <chRegNextThread>
 8001c34:	9003      	str	r0, [sp, #12]
  } while (ctp != NULL);
 8001c36:	9b03      	ldr	r3, [sp, #12]
 8001c38:	2b00      	cmp	r3, #0
 8001c3a:	d1ef      	bne.n	8001c1c <chRegFindThreadByWorkingArea+0xc>

  return NULL;
 8001c3c:	2300      	movs	r3, #0
}
 8001c3e:	4618      	mov	r0, r3
 8001c40:	b005      	add	sp, #20
 8001c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c46:	bf00      	nop
	...

08001c50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001c50:	b082      	sub	sp, #8
 8001c52:	2320      	movs	r3, #32
 8001c54:	9301      	str	r3, [sp, #4]
 8001c56:	9b01      	ldr	r3, [sp, #4]
 8001c58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001c5c:	b002      	add	sp, #8
 8001c5e:	4770      	bx	lr

08001c60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001c60:	b082      	sub	sp, #8
 8001c62:	2300      	movs	r3, #0
 8001c64:	9301      	str	r3, [sp, #4]
 8001c66:	9b01      	ldr	r3, [sp, #4]
 8001c68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001c6c:	b002      	add	sp, #8
 8001c6e:	4770      	bx	lr

08001c70 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001c70:	b082      	sub	sp, #8
 8001c72:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8001c74:	9b01      	ldr	r3, [sp, #4]
 8001c76:	9a01      	ldr	r2, [sp, #4]
 8001c78:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001c7a:	9b01      	ldr	r3, [sp, #4]
 8001c7c:	9a01      	ldr	r2, [sp, #4]
 8001c7e:	605a      	str	r2, [r3, #4]
}
 8001c80:	b002      	add	sp, #8
 8001c82:	4770      	bx	lr
 8001c84:	f3af 8000 	nop.w
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <queue_insert>:
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001c90:	b082      	sub	sp, #8
 8001c92:	9001      	str	r0, [sp, #4]
 8001c94:	9100      	str	r1, [sp, #0]

  tp->queue.next             = (thread_t *)tqp;
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	9a00      	ldr	r2, [sp, #0]
 8001c9a:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8001c9c:	9b00      	ldr	r3, [sp, #0]
 8001c9e:	685a      	ldr	r2, [r3, #4]
 8001ca0:	9b01      	ldr	r3, [sp, #4]
 8001ca2:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8001ca4:	9b01      	ldr	r3, [sp, #4]
 8001ca6:	685b      	ldr	r3, [r3, #4]
 8001ca8:	9a01      	ldr	r2, [sp, #4]
 8001caa:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 8001cac:	9b00      	ldr	r3, [sp, #0]
 8001cae:	9a01      	ldr	r2, [sp, #4]
 8001cb0:	605a      	str	r2, [r3, #4]
}
 8001cb2:	b002      	add	sp, #8
 8001cb4:	4770      	bx	lr
 8001cb6:	bf00      	nop
 8001cb8:	f3af 8000 	nop.w
 8001cbc:	f3af 8000 	nop.w

08001cc0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001cc0:	b084      	sub	sp, #16
 8001cc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8001cc4:	9b01      	ldr	r3, [sp, #4]
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8001cca:	9b03      	ldr	r3, [sp, #12]
 8001ccc:	681a      	ldr	r2, [r3, #0]
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001cd2:	9b01      	ldr	r3, [sp, #4]
 8001cd4:	681b      	ldr	r3, [r3, #0]
 8001cd6:	9a01      	ldr	r2, [sp, #4]
 8001cd8:	605a      	str	r2, [r3, #4]

  return tp;
 8001cda:	9b03      	ldr	r3, [sp, #12]
}
 8001cdc:	4618      	mov	r0, r3
 8001cde:	b004      	add	sp, #16
 8001ce0:	4770      	bx	lr
 8001ce2:	bf00      	nop
 8001ce4:	f3af 8000 	nop.w
 8001ce8:	f3af 8000 	nop.w
 8001cec:	f3af 8000 	nop.w

08001cf0 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8001cf0:	b084      	sub	sp, #16
 8001cf2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->prev;
 8001cf4:	9b01      	ldr	r3, [sp, #4]
 8001cf6:	685b      	ldr	r3, [r3, #4]
 8001cf8:	9303      	str	r3, [sp, #12]

  tqp->prev             = tp->queue.prev;
 8001cfa:	9b03      	ldr	r3, [sp, #12]
 8001cfc:	685a      	ldr	r2, [r3, #4]
 8001cfe:	9b01      	ldr	r3, [sp, #4]
 8001d00:	605a      	str	r2, [r3, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8001d02:	9b01      	ldr	r3, [sp, #4]
 8001d04:	685b      	ldr	r3, [r3, #4]
 8001d06:	9a01      	ldr	r2, [sp, #4]
 8001d08:	601a      	str	r2, [r3, #0]

  return tp;
 8001d0a:	9b03      	ldr	r3, [sp, #12]
}
 8001d0c:	4618      	mov	r0, r3
 8001d0e:	b004      	add	sp, #16
 8001d10:	4770      	bx	lr
 8001d12:	bf00      	nop
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001d20:	b508      	push	{r3, lr}

  port_lock();
 8001d22:	f7ff ff95 	bl	8001c50 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001d26:	bd08      	pop	{r3, pc}
 8001d28:	f3af 8000 	nop.w
 8001d2c:	f3af 8000 	nop.w

08001d30 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001d30:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8001d32:	f7ff ff95 	bl	8001c60 <port_unlock>
}
 8001d36:	bd08      	pop	{r3, pc}
 8001d38:	f3af 8000 	nop.w
 8001d3c:	f3af 8000 	nop.w

08001d40 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8001d40:	b500      	push	{lr}
 8001d42:	b083      	sub	sp, #12
 8001d44:	9001      	str	r0, [sp, #4]
 8001d46:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
 8001d48:	9b01      	ldr	r3, [sp, #4]
 8001d4a:	4618      	mov	r0, r3
 8001d4c:	f7ff ff90 	bl	8001c70 <queue_init>
  sp->cnt = n;
 8001d50:	9b01      	ldr	r3, [sp, #4]
 8001d52:	9a00      	ldr	r2, [sp, #0]
 8001d54:	609a      	str	r2, [r3, #8]
}
 8001d56:	b003      	add	sp, #12
 8001d58:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d5c:	f3af 8000 	nop.w

08001d60 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001d60:	b500      	push	{lr}
 8001d62:	b083      	sub	sp, #12
 8001d64:	9001      	str	r0, [sp, #4]
 8001d66:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001d68:	f7ff ffda 	bl	8001d20 <chSysLock>
  chSemResetI(sp, n);
 8001d6c:	9801      	ldr	r0, [sp, #4]
 8001d6e:	9900      	ldr	r1, [sp, #0]
 8001d70:	f000 f80e 	bl	8001d90 <chSemResetI>
  chSchRescheduleS();
 8001d74:	f7ff f90c 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8001d78:	f7ff ffda 	bl	8001d30 <chSysUnlock>
}
 8001d7c:	b003      	add	sp, #12
 8001d7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d82:	bf00      	nop
 8001d84:	f3af 8000 	nop.w
 8001d88:	f3af 8000 	nop.w
 8001d8c:	f3af 8000 	nop.w

08001d90 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001d90:	b500      	push	{lr}
 8001d92:	b085      	sub	sp, #20
 8001d94:	9001      	str	r0, [sp, #4]
 8001d96:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8001d98:	9b01      	ldr	r3, [sp, #4]
 8001d9a:	689b      	ldr	r3, [r3, #8]
 8001d9c:	9303      	str	r3, [sp, #12]
  sp->cnt = n;
 8001d9e:	9b01      	ldr	r3, [sp, #4]
 8001da0:	9a00      	ldr	r2, [sp, #0]
 8001da2:	609a      	str	r2, [r3, #8]
  while (++cnt <= (cnt_t)0) {
 8001da4:	e00b      	b.n	8001dbe <chSemResetI+0x2e>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8001da6:	9b01      	ldr	r3, [sp, #4]
 8001da8:	4618      	mov	r0, r3
 8001daa:	f7ff ffa1 	bl	8001cf0 <queue_lifo_remove>
 8001dae:	4603      	mov	r3, r0
 8001db0:	4618      	mov	r0, r3
 8001db2:	f7fe ffd5 	bl	8000d60 <chSchReadyI>
 8001db6:	4602      	mov	r2, r0
 8001db8:	f06f 0301 	mvn.w	r3, #1
 8001dbc:	6253      	str	r3, [r2, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001dbe:	9b03      	ldr	r3, [sp, #12]
 8001dc0:	3301      	adds	r3, #1
 8001dc2:	9303      	str	r3, [sp, #12]
 8001dc4:	9b03      	ldr	r3, [sp, #12]
 8001dc6:	2b00      	cmp	r3, #0
 8001dc8:	dded      	ble.n	8001da6 <chSemResetI+0x16>
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
  }
}
 8001dca:	b005      	add	sp, #20
 8001dcc:	f85d fb04 	ldr.w	pc, [sp], #4

08001dd0 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001dd0:	b500      	push	{lr}
 8001dd2:	b085      	sub	sp, #20
 8001dd4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8001dd6:	f7ff ffa3 	bl	8001d20 <chSysLock>
  msg = chSemWaitS(sp);
 8001dda:	9801      	ldr	r0, [sp, #4]
 8001ddc:	f000 f808 	bl	8001df0 <chSemWaitS>
 8001de0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001de2:	f7ff ffa5 	bl	8001d30 <chSysUnlock>

  return msg;
 8001de6:	9b03      	ldr	r3, [sp, #12]
}
 8001de8:	4618      	mov	r0, r3
 8001dea:	b005      	add	sp, #20
 8001dec:	f85d fb04 	ldr.w	pc, [sp], #4

08001df0 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8001df0:	b500      	push	{lr}
 8001df2:	b083      	sub	sp, #12
 8001df4:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8001df6:	9b01      	ldr	r3, [sp, #4]
 8001df8:	689b      	ldr	r3, [r3, #8]
 8001dfa:	1e5a      	subs	r2, r3, #1
 8001dfc:	9b01      	ldr	r3, [sp, #4]
 8001dfe:	609a      	str	r2, [r3, #8]
 8001e00:	9b01      	ldr	r3, [sp, #4]
 8001e02:	689b      	ldr	r3, [r3, #8]
 8001e04:	2b00      	cmp	r3, #0
 8001e06:	da11      	bge.n	8001e2c <chSemWaitS+0x3c>
    currp->u.wtsemp = sp;
 8001e08:	4b0b      	ldr	r3, [pc, #44]	; (8001e38 <chSemWaitS+0x48>)
 8001e0a:	699b      	ldr	r3, [r3, #24]
 8001e0c:	9a01      	ldr	r2, [sp, #4]
 8001e0e:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->queue);
 8001e10:	4b09      	ldr	r3, [pc, #36]	; (8001e38 <chSemWaitS+0x48>)
 8001e12:	699a      	ldr	r2, [r3, #24]
 8001e14:	9b01      	ldr	r3, [sp, #4]
 8001e16:	4610      	mov	r0, r2
 8001e18:	4619      	mov	r1, r3
 8001e1a:	f7ff ff39 	bl	8001c90 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 8001e1e:	2005      	movs	r0, #5
 8001e20:	f7fe ffee 	bl	8000e00 <chSchGoSleepS>

    return currp->u.rdymsg;
 8001e24:	4b04      	ldr	r3, [pc, #16]	; (8001e38 <chSemWaitS+0x48>)
 8001e26:	699b      	ldr	r3, [r3, #24]
 8001e28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e2a:	e000      	b.n	8001e2e <chSemWaitS+0x3e>
  }

  return MSG_OK;
 8001e2c:	2300      	movs	r3, #0
}
 8001e2e:	4618      	mov	r0, r3
 8001e30:	b003      	add	sp, #12
 8001e32:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e36:	bf00      	nop
 8001e38:	20000af8 	.word	0x20000af8
 8001e3c:	f3af 8000 	nop.w

08001e40 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001e40:	b500      	push	{lr}
 8001e42:	b085      	sub	sp, #20
 8001e44:	9001      	str	r0, [sp, #4]
 8001e46:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8001e48:	f7ff ff6a 	bl	8001d20 <chSysLock>
  msg = chSemWaitTimeoutS(sp, time);
 8001e4c:	9801      	ldr	r0, [sp, #4]
 8001e4e:	9900      	ldr	r1, [sp, #0]
 8001e50:	f000 f80e 	bl	8001e70 <chSemWaitTimeoutS>
 8001e54:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001e56:	f7ff ff6b 	bl	8001d30 <chSysUnlock>

  return msg;
 8001e5a:	9b03      	ldr	r3, [sp, #12]
}
 8001e5c:	4618      	mov	r0, r3
 8001e5e:	b005      	add	sp, #20
 8001e60:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e64:	f3af 8000 	nop.w
 8001e68:	f3af 8000 	nop.w
 8001e6c:	f3af 8000 	nop.w

08001e70 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001e70:	b500      	push	{lr}
 8001e72:	b083      	sub	sp, #12
 8001e74:	9001      	str	r0, [sp, #4]
 8001e76:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8001e78:	9b01      	ldr	r3, [sp, #4]
 8001e7a:	689b      	ldr	r3, [r3, #8]
 8001e7c:	1e5a      	subs	r2, r3, #1
 8001e7e:	9b01      	ldr	r3, [sp, #4]
 8001e80:	609a      	str	r2, [r3, #8]
 8001e82:	9b01      	ldr	r3, [sp, #4]
 8001e84:	689b      	ldr	r3, [r3, #8]
 8001e86:	2b00      	cmp	r3, #0
 8001e88:	da1b      	bge.n	8001ec2 <chSemWaitTimeoutS+0x52>
    if (TIME_IMMEDIATE == time) {
 8001e8a:	9b00      	ldr	r3, [sp, #0]
 8001e8c:	2b00      	cmp	r3, #0
 8001e8e:	d107      	bne.n	8001ea0 <chSemWaitTimeoutS+0x30>
      sp->cnt++;
 8001e90:	9b01      	ldr	r3, [sp, #4]
 8001e92:	689b      	ldr	r3, [r3, #8]
 8001e94:	1c5a      	adds	r2, r3, #1
 8001e96:	9b01      	ldr	r3, [sp, #4]
 8001e98:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8001e9a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001e9e:	e011      	b.n	8001ec4 <chSemWaitTimeoutS+0x54>
    }
    currp->u.wtsemp = sp;
 8001ea0:	4b0a      	ldr	r3, [pc, #40]	; (8001ecc <chSemWaitTimeoutS+0x5c>)
 8001ea2:	699b      	ldr	r3, [r3, #24]
 8001ea4:	9a01      	ldr	r2, [sp, #4]
 8001ea6:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->queue);
 8001ea8:	4b08      	ldr	r3, [pc, #32]	; (8001ecc <chSemWaitTimeoutS+0x5c>)
 8001eaa:	699a      	ldr	r2, [r3, #24]
 8001eac:	9b01      	ldr	r3, [sp, #4]
 8001eae:	4610      	mov	r0, r2
 8001eb0:	4619      	mov	r1, r3
 8001eb2:	f7ff feed 	bl	8001c90 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001eb6:	2005      	movs	r0, #5
 8001eb8:	9900      	ldr	r1, [sp, #0]
 8001eba:	f7ff f809 	bl	8000ed0 <chSchGoSleepTimeoutS>
 8001ebe:	4603      	mov	r3, r0
 8001ec0:	e000      	b.n	8001ec4 <chSemWaitTimeoutS+0x54>
  }

  return MSG_OK;
 8001ec2:	2300      	movs	r3, #0
}
 8001ec4:	4618      	mov	r0, r3
 8001ec6:	b003      	add	sp, #12
 8001ec8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ecc:	20000af8 	.word	0x20000af8

08001ed0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]

  chDbgCheck(sp != NULL);

  chSysLock();
 8001ed6:	f7ff ff23 	bl	8001d20 <chSysLock>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
 8001eda:	9b01      	ldr	r3, [sp, #4]
 8001edc:	689b      	ldr	r3, [r3, #8]
 8001ede:	1c5a      	adds	r2, r3, #1
 8001ee0:	9b01      	ldr	r3, [sp, #4]
 8001ee2:	609a      	str	r2, [r3, #8]
 8001ee4:	9b01      	ldr	r3, [sp, #4]
 8001ee6:	689b      	ldr	r3, [r3, #8]
 8001ee8:	2b00      	cmp	r3, #0
 8001eea:	dc08      	bgt.n	8001efe <chSemSignal+0x2e>
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8001eec:	9b01      	ldr	r3, [sp, #4]
 8001eee:	4618      	mov	r0, r3
 8001ef0:	f7ff fee6 	bl	8001cc0 <queue_fifo_remove>
 8001ef4:	4603      	mov	r3, r0
 8001ef6:	4618      	mov	r0, r3
 8001ef8:	2100      	movs	r1, #0
 8001efa:	f7ff f821 	bl	8000f40 <chSchWakeupS>
  }
  chSysUnlock();
 8001efe:	f7ff ff17 	bl	8001d30 <chSysUnlock>
}
 8001f02:	b003      	add	sp, #12
 8001f04:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f08:	f3af 8000 	nop.w
 8001f0c:	f3af 8000 	nop.w

08001f10 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b085      	sub	sp, #20
 8001f14:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001f16:	9b01      	ldr	r3, [sp, #4]
 8001f18:	689b      	ldr	r3, [r3, #8]
 8001f1a:	1c5a      	adds	r2, r3, #1
 8001f1c:	9b01      	ldr	r3, [sp, #4]
 8001f1e:	609a      	str	r2, [r3, #8]
 8001f20:	9b01      	ldr	r3, [sp, #4]
 8001f22:	689b      	ldr	r3, [r3, #8]
 8001f24:	2b00      	cmp	r3, #0
 8001f26:	dc0a      	bgt.n	8001f3e <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
 8001f28:	9b01      	ldr	r3, [sp, #4]
 8001f2a:	4618      	mov	r0, r3
 8001f2c:	f7ff fec8 	bl	8001cc0 <queue_fifo_remove>
 8001f30:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
 8001f32:	9b03      	ldr	r3, [sp, #12]
 8001f34:	2200      	movs	r2, #0
 8001f36:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001f38:	9803      	ldr	r0, [sp, #12]
 8001f3a:	f7fe ff11 	bl	8000d60 <chSchReadyI>
  }
}
 8001f3e:	b005      	add	sp, #20
 8001f40:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f44:	f3af 8000 	nop.w
 8001f48:	f3af 8000 	nop.w
 8001f4c:	f3af 8000 	nop.w

08001f50 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001f50:	b500      	push	{lr}
 8001f52:	b083      	sub	sp, #12
 8001f54:	9001      	str	r0, [sp, #4]
 8001f56:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001f58:	e016      	b.n	8001f88 <chSemAddCounterI+0x38>
    if (++sp->cnt <= (cnt_t)0) {
 8001f5a:	9b01      	ldr	r3, [sp, #4]
 8001f5c:	689b      	ldr	r3, [r3, #8]
 8001f5e:	1c5a      	adds	r2, r3, #1
 8001f60:	9b01      	ldr	r3, [sp, #4]
 8001f62:	609a      	str	r2, [r3, #8]
 8001f64:	9b01      	ldr	r3, [sp, #4]
 8001f66:	689b      	ldr	r3, [r3, #8]
 8001f68:	2b00      	cmp	r3, #0
 8001f6a:	dc0a      	bgt.n	8001f82 <chSemAddCounterI+0x32>
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8001f6c:	9b01      	ldr	r3, [sp, #4]
 8001f6e:	4618      	mov	r0, r3
 8001f70:	f7ff fea6 	bl	8001cc0 <queue_fifo_remove>
 8001f74:	4603      	mov	r3, r0
 8001f76:	4618      	mov	r0, r3
 8001f78:	f7fe fef2 	bl	8000d60 <chSchReadyI>
 8001f7c:	4602      	mov	r2, r0
 8001f7e:	2300      	movs	r3, #0
 8001f80:	6253      	str	r3, [r2, #36]	; 0x24
    }
    n--;
 8001f82:	9b00      	ldr	r3, [sp, #0]
 8001f84:	3b01      	subs	r3, #1
 8001f86:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001f88:	9b00      	ldr	r3, [sp, #0]
 8001f8a:	2b00      	cmp	r3, #0
 8001f8c:	dce5      	bgt.n	8001f5a <chSemAddCounterI+0xa>
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 8001f8e:	b003      	add	sp, #12
 8001f90:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f94:	f3af 8000 	nop.w
 8001f98:	f3af 8000 	nop.w
 8001f9c:	f3af 8000 	nop.w

08001fa0 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001fa0:	b500      	push	{lr}
 8001fa2:	b085      	sub	sp, #20
 8001fa4:	9001      	str	r0, [sp, #4]
 8001fa6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));

  chSysLock();
 8001fa8:	f7ff feba 	bl	8001d20 <chSysLock>
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 8001fac:	9b01      	ldr	r3, [sp, #4]
 8001fae:	689b      	ldr	r3, [r3, #8]
 8001fb0:	1c5a      	adds	r2, r3, #1
 8001fb2:	9b01      	ldr	r3, [sp, #4]
 8001fb4:	609a      	str	r2, [r3, #8]
 8001fb6:	9b01      	ldr	r3, [sp, #4]
 8001fb8:	689b      	ldr	r3, [r3, #8]
 8001fba:	2b00      	cmp	r3, #0
 8001fbc:	dc0a      	bgt.n	8001fd4 <chSemSignalWait+0x34>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8001fbe:	9b01      	ldr	r3, [sp, #4]
 8001fc0:	4618      	mov	r0, r3
 8001fc2:	f7ff fe7d 	bl	8001cc0 <queue_fifo_remove>
 8001fc6:	4603      	mov	r3, r0
 8001fc8:	4618      	mov	r0, r3
 8001fca:	f7fe fec9 	bl	8000d60 <chSchReadyI>
 8001fce:	4602      	mov	r2, r0
 8001fd0:	2300      	movs	r3, #0
 8001fd2:	6253      	str	r3, [r2, #36]	; 0x24
  }
  if (--spw->cnt < (cnt_t)0) {
 8001fd4:	9b00      	ldr	r3, [sp, #0]
 8001fd6:	689b      	ldr	r3, [r3, #8]
 8001fd8:	1e5a      	subs	r2, r3, #1
 8001fda:	9b00      	ldr	r3, [sp, #0]
 8001fdc:	609a      	str	r2, [r3, #8]
 8001fde:	9b00      	ldr	r3, [sp, #0]
 8001fe0:	689b      	ldr	r3, [r3, #8]
 8001fe2:	2b00      	cmp	r3, #0
 8001fe4:	da11      	bge.n	800200a <chSemSignalWait+0x6a>
    thread_t *ctp = currp;
 8001fe6:	4b0e      	ldr	r3, [pc, #56]	; (8002020 <chSemSignalWait+0x80>)
 8001fe8:	699b      	ldr	r3, [r3, #24]
 8001fea:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->queue);
 8001fec:	9b00      	ldr	r3, [sp, #0]
 8001fee:	9802      	ldr	r0, [sp, #8]
 8001ff0:	4619      	mov	r1, r3
 8001ff2:	f7ff fe4d 	bl	8001c90 <queue_insert>
    ctp->u.wtsemp = spw;
 8001ff6:	9b02      	ldr	r3, [sp, #8]
 8001ff8:	9a00      	ldr	r2, [sp, #0]
 8001ffa:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 8001ffc:	2005      	movs	r0, #5
 8001ffe:	f7fe feff 	bl	8000e00 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8002002:	9b02      	ldr	r3, [sp, #8]
 8002004:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002006:	9303      	str	r3, [sp, #12]
 8002008:	e003      	b.n	8002012 <chSemSignalWait+0x72>
  }
  else {
    chSchRescheduleS();
 800200a:	f7fe ffc1 	bl	8000f90 <chSchRescheduleS>
    msg = MSG_OK;
 800200e:	2300      	movs	r3, #0
 8002010:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 8002012:	f7ff fe8d 	bl	8001d30 <chSysUnlock>

  return msg;
 8002016:	9b03      	ldr	r3, [sp, #12]
}
 8002018:	4618      	mov	r0, r3
 800201a:	b005      	add	sp, #20
 800201c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002020:	20000af8 	.word	0x20000af8
	...

08002030 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002030:	b082      	sub	sp, #8
 8002032:	2320      	movs	r3, #32
 8002034:	9301      	str	r3, [sp, #4]
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800203c:	b002      	add	sp, #8
 800203e:	4770      	bx	lr

08002040 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002040:	b082      	sub	sp, #8
 8002042:	2300      	movs	r3, #0
 8002044:	9301      	str	r3, [sp, #4]
 8002046:	9b01      	ldr	r3, [sp, #4]
 8002048:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800204c:	b002      	add	sp, #8
 800204e:	4770      	bx	lr

08002050 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002050:	b082      	sub	sp, #8
 8002052:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8002054:	9b01      	ldr	r3, [sp, #4]
 8002056:	9a01      	ldr	r2, [sp, #4]
 8002058:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800205a:	9b01      	ldr	r3, [sp, #4]
 800205c:	9a01      	ldr	r2, [sp, #4]
 800205e:	605a      	str	r2, [r3, #4]
}
 8002060:	b002      	add	sp, #8
 8002062:	4770      	bx	lr
 8002064:	f3af 8000 	nop.w
 8002068:	f3af 8000 	nop.w
 800206c:	f3af 8000 	nop.w

08002070 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002070:	b082      	sub	sp, #8
 8002072:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002074:	9b01      	ldr	r3, [sp, #4]
 8002076:	681a      	ldr	r2, [r3, #0]
 8002078:	9b01      	ldr	r3, [sp, #4]
 800207a:	429a      	cmp	r2, r3
 800207c:	bf14      	ite	ne
 800207e:	2301      	movne	r3, #1
 8002080:	2300      	moveq	r3, #0
 8002082:	b2db      	uxtb	r3, r3
}
 8002084:	4618      	mov	r0, r3
 8002086:	b002      	add	sp, #8
 8002088:	4770      	bx	lr
 800208a:	bf00      	nop
 800208c:	f3af 8000 	nop.w

08002090 <queue_prio_insert>:
  tlp->next = tp->queue.next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002090:	b084      	sub	sp, #16
 8002092:	9001      	str	r0, [sp, #4]
 8002094:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002096:	9b00      	ldr	r3, [sp, #0]
 8002098:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 800209a:	9b03      	ldr	r3, [sp, #12]
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80020a0:	9a03      	ldr	r2, [sp, #12]
 80020a2:	9b00      	ldr	r3, [sp, #0]
 80020a4:	429a      	cmp	r2, r3
 80020a6:	d005      	beq.n	80020b4 <queue_prio_insert+0x24>
 80020a8:	9b03      	ldr	r3, [sp, #12]
 80020aa:	689a      	ldr	r2, [r3, #8]
 80020ac:	9b01      	ldr	r3, [sp, #4]
 80020ae:	689b      	ldr	r3, [r3, #8]
 80020b0:	429a      	cmp	r2, r3
 80020b2:	d2f2      	bcs.n	800209a <queue_prio_insert+0xa>
  tp->queue.next             = cp;
 80020b4:	9b01      	ldr	r3, [sp, #4]
 80020b6:	9a03      	ldr	r2, [sp, #12]
 80020b8:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 80020ba:	9b03      	ldr	r3, [sp, #12]
 80020bc:	685a      	ldr	r2, [r3, #4]
 80020be:	9b01      	ldr	r3, [sp, #4]
 80020c0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80020c2:	9b01      	ldr	r3, [sp, #4]
 80020c4:	685b      	ldr	r3, [r3, #4]
 80020c6:	9a01      	ldr	r2, [sp, #4]
 80020c8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 80020ca:	9b03      	ldr	r3, [sp, #12]
 80020cc:	9a01      	ldr	r2, [sp, #4]
 80020ce:	605a      	str	r2, [r3, #4]
}
 80020d0:	b004      	add	sp, #16
 80020d2:	4770      	bx	lr
 80020d4:	f3af 8000 	nop.w
 80020d8:	f3af 8000 	nop.w
 80020dc:	f3af 8000 	nop.w

080020e0 <queue_fifo_remove>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80020e0:	b084      	sub	sp, #16
 80020e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80020e4:	9b01      	ldr	r3, [sp, #4]
 80020e6:	681b      	ldr	r3, [r3, #0]
 80020e8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 80020ea:	9b03      	ldr	r3, [sp, #12]
 80020ec:	681a      	ldr	r2, [r3, #0]
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80020f2:	9b01      	ldr	r3, [sp, #4]
 80020f4:	681b      	ldr	r3, [r3, #0]
 80020f6:	9a01      	ldr	r2, [sp, #4]
 80020f8:	605a      	str	r2, [r3, #4]

  return tp;
 80020fa:	9b03      	ldr	r3, [sp, #12]
}
 80020fc:	4618      	mov	r0, r3
 80020fe:	b004      	add	sp, #16
 8002100:	4770      	bx	lr
 8002102:	bf00      	nop
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <queue_dequeue>:
  tqp->prev->queue.next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8002110:	b082      	sub	sp, #8
 8002112:	9001      	str	r0, [sp, #4]

  tp->queue.prev->queue.next = tp->queue.next;
 8002114:	9b01      	ldr	r3, [sp, #4]
 8002116:	685b      	ldr	r3, [r3, #4]
 8002118:	9a01      	ldr	r2, [sp, #4]
 800211a:	6812      	ldr	r2, [r2, #0]
 800211c:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800211e:	9b01      	ldr	r3, [sp, #4]
 8002120:	681b      	ldr	r3, [r3, #0]
 8002122:	9a01      	ldr	r2, [sp, #4]
 8002124:	6852      	ldr	r2, [r2, #4]
 8002126:	605a      	str	r2, [r3, #4]

  return tp;
 8002128:	9b01      	ldr	r3, [sp, #4]
}
 800212a:	4618      	mov	r0, r3
 800212c:	b002      	add	sp, #8
 800212e:	4770      	bx	lr

08002130 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002130:	b508      	push	{r3, lr}

  port_lock();
 8002132:	f7ff ff7d 	bl	8002030 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002136:	bd08      	pop	{r3, pc}
 8002138:	f3af 8000 	nop.w
 800213c:	f3af 8000 	nop.w

08002140 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002140:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8002142:	f7ff ff7d 	bl	8002040 <port_unlock>
}
 8002146:	bd08      	pop	{r3, pc}
 8002148:	f3af 8000 	nop.w
 800214c:	f3af 8000 	nop.w

08002150 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8002150:	b500      	push	{lr}
 8002152:	b083      	sub	sp, #12
 8002154:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->queue);
 8002156:	9b01      	ldr	r3, [sp, #4]
 8002158:	4618      	mov	r0, r3
 800215a:	f7ff ff89 	bl	8002070 <queue_notempty>
 800215e:	4603      	mov	r3, r0
}
 8002160:	4618      	mov	r0, r3
 8002162:	b003      	add	sp, #12
 8002164:	f85d fb04 	ldr.w	pc, [sp], #4
 8002168:	f3af 8000 	nop.w
 800216c:	f3af 8000 	nop.w

08002170 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
 8002174:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
 8002176:	9b01      	ldr	r3, [sp, #4]
 8002178:	4618      	mov	r0, r3
 800217a:	f7ff ff69 	bl	8002050 <queue_init>
  mp->owner = NULL;
 800217e:	9b01      	ldr	r3, [sp, #4]
 8002180:	2200      	movs	r2, #0
 8002182:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8002184:	b003      	add	sp, #12
 8002186:	f85d fb04 	ldr.w	pc, [sp], #4
 800218a:	bf00      	nop
 800218c:	f3af 8000 	nop.w

08002190 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8002190:	b500      	push	{lr}
 8002192:	b083      	sub	sp, #12
 8002194:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002196:	f7ff ffcb 	bl	8002130 <chSysLock>
  chMtxLockS(mp);
 800219a:	9801      	ldr	r0, [sp, #4]
 800219c:	f000 f808 	bl	80021b0 <chMtxLockS>
  chSysUnlock();
 80021a0:	f7ff ffce 	bl	8002140 <chSysUnlock>
}
 80021a4:	b003      	add	sp, #12
 80021a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80021aa:	bf00      	nop
 80021ac:	f3af 8000 	nop.w

080021b0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80021b0:	b500      	push	{lr}
 80021b2:	b085      	sub	sp, #20
 80021b4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80021b6:	4b2d      	ldr	r3, [pc, #180]	; (800226c <chMtxLockS+0xbc>)
 80021b8:	699b      	ldr	r3, [r3, #24]
 80021ba:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80021bc:	9b01      	ldr	r3, [sp, #4]
 80021be:	689b      	ldr	r3, [r3, #8]
 80021c0:	2b00      	cmp	r3, #0
 80021c2:	d046      	beq.n	8002252 <chMtxLockS+0xa2>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;
 80021c4:	9b01      	ldr	r3, [sp, #4]
 80021c6:	689b      	ldr	r3, [r3, #8]
 80021c8:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80021ca:	e030      	b.n	800222e <chMtxLockS+0x7e>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 80021cc:	9b02      	ldr	r3, [sp, #8]
 80021ce:	689a      	ldr	r2, [r3, #8]
 80021d0:	9b03      	ldr	r3, [sp, #12]
 80021d2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80021d4:	9b03      	ldr	r3, [sp, #12]
 80021d6:	f893 3020 	ldrb.w	r3, [r3, #32]
 80021da:	2b06      	cmp	r3, #6
 80021dc:	d004      	beq.n	80021e8 <chMtxLockS+0x38>
 80021de:	2b07      	cmp	r3, #7
 80021e0:	d011      	beq.n	8002206 <chMtxLockS+0x56>
 80021e2:	2b00      	cmp	r3, #0
 80021e4:	d01a      	beq.n	800221c <chMtxLockS+0x6c>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
 80021e6:	e021      	b.n	800222c <chMtxLockS+0x7c>

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80021e8:	9803      	ldr	r0, [sp, #12]
 80021ea:	f7ff ff91 	bl	8002110 <queue_dequeue>
 80021ee:	4602      	mov	r2, r0
 80021f0:	9b03      	ldr	r3, [sp, #12]
 80021f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80021f4:	4610      	mov	r0, r2
 80021f6:	4619      	mov	r1, r3
 80021f8:	f7ff ff4a 	bl	8002090 <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
 80021fc:	9b03      	ldr	r3, [sp, #12]
 80021fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002200:	689b      	ldr	r3, [r3, #8]
 8002202:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8002204:	e013      	b.n	800222e <chMtxLockS+0x7e>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002206:	9803      	ldr	r0, [sp, #12]
 8002208:	f7ff ff82 	bl	8002110 <queue_dequeue>
 800220c:	4602      	mov	r2, r0
 800220e:	9b03      	ldr	r3, [sp, #12]
 8002210:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002212:	4610      	mov	r0, r2
 8002214:	4619      	mov	r1, r3
 8002216:	f7ff ff3b 	bl	8002090 <queue_prio_insert>
          break;
 800221a:	e007      	b.n	800222c <chMtxLockS+0x7c>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800221c:	9803      	ldr	r0, [sp, #12]
 800221e:	f7ff ff77 	bl	8002110 <queue_dequeue>
 8002222:	4603      	mov	r3, r0
 8002224:	4618      	mov	r0, r3
 8002226:	f7fe fd9b 	bl	8000d60 <chSchReadyI>
          break;
 800222a:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
 800222c:	e005      	b.n	800223a <chMtxLockS+0x8a>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800222e:	9b03      	ldr	r3, [sp, #12]
 8002230:	689a      	ldr	r2, [r3, #8]
 8002232:	9b02      	ldr	r3, [sp, #8]
 8002234:	689b      	ldr	r3, [r3, #8]
 8002236:	429a      	cmp	r2, r3
 8002238:	d3c8      	bcc.n	80021cc <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	9802      	ldr	r0, [sp, #8]
 800223e:	4619      	mov	r1, r3
 8002240:	f7ff ff26 	bl	8002090 <queue_prio_insert>
      ctp->u.wtmtxp = mp;
 8002244:	9b02      	ldr	r3, [sp, #8]
 8002246:	9a01      	ldr	r2, [sp, #4]
 8002248:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800224a:	2006      	movs	r0, #6
 800224c:	f7fe fdd8 	bl	8000e00 <chSchGoSleepS>
 8002250:	e009      	b.n	8002266 <chMtxLockS+0xb6>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8002252:	9b01      	ldr	r3, [sp, #4]
 8002254:	9a02      	ldr	r2, [sp, #8]
 8002256:	609a      	str	r2, [r3, #8]
    mp->next = ctp->mtxlist;
 8002258:	9b02      	ldr	r3, [sp, #8]
 800225a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800225c:	9b01      	ldr	r3, [sp, #4]
 800225e:	60da      	str	r2, [r3, #12]
    ctp->mtxlist = mp;
 8002260:	9b02      	ldr	r3, [sp, #8]
 8002262:	9a01      	ldr	r2, [sp, #4]
 8002264:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8002266:	b005      	add	sp, #20
 8002268:	f85d fb04 	ldr.w	pc, [sp], #4
 800226c:	20000af8 	.word	0x20000af8

08002270 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8002270:	b500      	push	{lr}
 8002272:	b085      	sub	sp, #20
 8002274:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8002276:	f7ff ff5b 	bl	8002130 <chSysLock>
  b = chMtxTryLockS(mp);
 800227a:	9801      	ldr	r0, [sp, #4]
 800227c:	f000 f810 	bl	80022a0 <chMtxTryLockS>
 8002280:	4603      	mov	r3, r0
 8002282:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8002286:	f7ff ff5b 	bl	8002140 <chSysUnlock>

  return b;
 800228a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800228e:	4618      	mov	r0, r3
 8002290:	b005      	add	sp, #20
 8002292:	f85d fb04 	ldr.w	pc, [sp], #4
 8002296:	bf00      	nop
 8002298:	f3af 8000 	nop.w
 800229c:	f3af 8000 	nop.w

080022a0 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 80022a0:	b082      	sub	sp, #8
 80022a2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 80022a4:	9b01      	ldr	r3, [sp, #4]
 80022a6:	689b      	ldr	r3, [r3, #8]
 80022a8:	2b00      	cmp	r3, #0
 80022aa:	d001      	beq.n	80022b0 <chMtxTryLockS+0x10>
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 80022ac:	2300      	movs	r3, #0
 80022ae:	e00d      	b.n	80022cc <chMtxTryLockS+0x2c>

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 80022b0:	4b08      	ldr	r3, [pc, #32]	; (80022d4 <chMtxTryLockS+0x34>)
 80022b2:	699a      	ldr	r2, [r3, #24]
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 80022b8:	4b06      	ldr	r3, [pc, #24]	; (80022d4 <chMtxTryLockS+0x34>)
 80022ba:	699b      	ldr	r3, [r3, #24]
 80022bc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	60da      	str	r2, [r3, #12]
  currp->mtxlist = mp;
 80022c2:	4b04      	ldr	r3, [pc, #16]	; (80022d4 <chMtxTryLockS+0x34>)
 80022c4:	699b      	ldr	r3, [r3, #24]
 80022c6:	9a01      	ldr	r2, [sp, #4]
 80022c8:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 80022ca:	2301      	movs	r3, #1
}
 80022cc:	4618      	mov	r0, r3
 80022ce:	b002      	add	sp, #8
 80022d0:	4770      	bx	lr
 80022d2:	bf00      	nop
 80022d4:	20000af8 	.word	0x20000af8
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80022e0:	b500      	push	{lr}
 80022e2:	b087      	sub	sp, #28
 80022e4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80022e6:	4b26      	ldr	r3, [pc, #152]	; (8002380 <chMtxUnlock+0xa0>)
 80022e8:	699b      	ldr	r3, [r3, #24]
 80022ea:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 80022ec:	f7ff ff20 	bl	8002130 <chSysLock>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80022f0:	9b01      	ldr	r3, [sp, #4]
 80022f2:	68da      	ldr	r2, [r3, #12]
 80022f4:	9b03      	ldr	r3, [sp, #12]
 80022f6:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80022f8:	9801      	ldr	r0, [sp, #4]
 80022fa:	f7ff ff29 	bl	8002150 <chMtxQueueNotEmptyS>
 80022fe:	4603      	mov	r3, r0
 8002300:	2b00      	cmp	r3, #0
 8002302:	d034      	beq.n	800236e <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8002304:	9b03      	ldr	r3, [sp, #12]
 8002306:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002308:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 800230a:	9b03      	ldr	r3, [sp, #12]
 800230c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800230e:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8002310:	e012      	b.n	8002338 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002312:	9805      	ldr	r0, [sp, #20]
 8002314:	f7ff ff1c 	bl	8002150 <chMtxQueueNotEmptyS>
 8002318:	4603      	mov	r3, r0
 800231a:	2b00      	cmp	r3, #0
 800231c:	d009      	beq.n	8002332 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 800231e:	9b05      	ldr	r3, [sp, #20]
 8002320:	681b      	ldr	r3, [r3, #0]
 8002322:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002324:	9b04      	ldr	r3, [sp, #16]
 8002326:	429a      	cmp	r2, r3
 8002328:	d903      	bls.n	8002332 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 800232a:	9b05      	ldr	r3, [sp, #20]
 800232c:	681b      	ldr	r3, [r3, #0]
 800232e:	689b      	ldr	r3, [r3, #8]
 8002330:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 8002332:	9b05      	ldr	r3, [sp, #20]
 8002334:	68db      	ldr	r3, [r3, #12]
 8002336:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8002338:	9b05      	ldr	r3, [sp, #20]
 800233a:	2b00      	cmp	r3, #0
 800233c:	d1e9      	bne.n	8002312 <chMtxUnlock+0x32>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800233e:	9b03      	ldr	r3, [sp, #12]
 8002340:	9a04      	ldr	r2, [sp, #16]
 8002342:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 8002344:	9b01      	ldr	r3, [sp, #4]
 8002346:	4618      	mov	r0, r3
 8002348:	f7ff feca 	bl	80020e0 <queue_fifo_remove>
 800234c:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 800234e:	9b01      	ldr	r3, [sp, #4]
 8002350:	9a02      	ldr	r2, [sp, #8]
 8002352:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8002354:	9b02      	ldr	r3, [sp, #8]
 8002356:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002358:	9b01      	ldr	r3, [sp, #4]
 800235a:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800235c:	9b02      	ldr	r3, [sp, #8]
 800235e:	9a01      	ldr	r2, [sp, #4]
 8002360:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002362:	9802      	ldr	r0, [sp, #8]
 8002364:	f7fe fcfc 	bl	8000d60 <chSchReadyI>
      chSchRescheduleS();
 8002368:	f7fe fe12 	bl	8000f90 <chSchRescheduleS>
 800236c:	e002      	b.n	8002374 <chMtxUnlock+0x94>
    }
    else {
      mp->owner = NULL;
 800236e:	9b01      	ldr	r3, [sp, #4]
 8002370:	2200      	movs	r2, #0
 8002372:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8002374:	f7ff fee4 	bl	8002140 <chSysUnlock>
}
 8002378:	b007      	add	sp, #28
 800237a:	f85d fb04 	ldr.w	pc, [sp], #4
 800237e:	bf00      	nop
 8002380:	20000af8 	.word	0x20000af8
 8002384:	f3af 8000 	nop.w
 8002388:	f3af 8000 	nop.w
 800238c:	f3af 8000 	nop.w

08002390 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002390:	b500      	push	{lr}
 8002392:	b087      	sub	sp, #28
 8002394:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002396:	4b23      	ldr	r3, [pc, #140]	; (8002424 <chMtxUnlockS+0x94>)
 8002398:	699b      	ldr	r3, [r3, #24]
 800239a:	9303      	str	r3, [sp, #12]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800239c:	9b01      	ldr	r3, [sp, #4]
 800239e:	68da      	ldr	r2, [r3, #12]
 80023a0:	9b03      	ldr	r3, [sp, #12]
 80023a2:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80023a4:	9801      	ldr	r0, [sp, #4]
 80023a6:	f7ff fed3 	bl	8002150 <chMtxQueueNotEmptyS>
 80023aa:	4603      	mov	r3, r0
 80023ac:	2b00      	cmp	r3, #0
 80023ae:	d032      	beq.n	8002416 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80023b0:	9b03      	ldr	r3, [sp, #12]
 80023b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80023b4:	9304      	str	r3, [sp, #16]
      lmp = ctp->mtxlist;
 80023b6:	9b03      	ldr	r3, [sp, #12]
 80023b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80023ba:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 80023bc:	e012      	b.n	80023e4 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80023be:	9805      	ldr	r0, [sp, #20]
 80023c0:	f7ff fec6 	bl	8002150 <chMtxQueueNotEmptyS>
 80023c4:	4603      	mov	r3, r0
 80023c6:	2b00      	cmp	r3, #0
 80023c8:	d009      	beq.n	80023de <chMtxUnlockS+0x4e>
            (lmp->queue.next->prio > newprio)) {
 80023ca:	9b05      	ldr	r3, [sp, #20]
 80023cc:	681b      	ldr	r3, [r3, #0]
 80023ce:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80023d0:	9b04      	ldr	r3, [sp, #16]
 80023d2:	429a      	cmp	r2, r3
 80023d4:	d903      	bls.n	80023de <chMtxUnlockS+0x4e>
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
 80023d6:	9b05      	ldr	r3, [sp, #20]
 80023d8:	681b      	ldr	r3, [r3, #0]
 80023da:	689b      	ldr	r3, [r3, #8]
 80023dc:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->next;
 80023de:	9b05      	ldr	r3, [sp, #20]
 80023e0:	68db      	ldr	r3, [r3, #12]
 80023e2:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80023e4:	9b05      	ldr	r3, [sp, #20]
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d1e9      	bne.n	80023be <chMtxUnlockS+0x2e>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80023ea:	9b03      	ldr	r3, [sp, #12]
 80023ec:	9a04      	ldr	r2, [sp, #16]
 80023ee:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
 80023f0:	9b01      	ldr	r3, [sp, #4]
 80023f2:	4618      	mov	r0, r3
 80023f4:	f7ff fe74 	bl	80020e0 <queue_fifo_remove>
 80023f8:	9002      	str	r0, [sp, #8]
      mp->owner = tp;
 80023fa:	9b01      	ldr	r3, [sp, #4]
 80023fc:	9a02      	ldr	r2, [sp, #8]
 80023fe:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8002400:	9b02      	ldr	r3, [sp, #8]
 8002402:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002404:	9b01      	ldr	r3, [sp, #4]
 8002406:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 8002408:	9b02      	ldr	r3, [sp, #8]
 800240a:	9a01      	ldr	r2, [sp, #4]
 800240c:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 800240e:	9802      	ldr	r0, [sp, #8]
 8002410:	f7fe fca6 	bl	8000d60 <chSchReadyI>
 8002414:	e002      	b.n	800241c <chMtxUnlockS+0x8c>
    }
    else {
      mp->owner = NULL;
 8002416:	9b01      	ldr	r3, [sp, #4]
 8002418:	2200      	movs	r2, #0
 800241a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800241c:	b007      	add	sp, #28
 800241e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002422:	bf00      	nop
 8002424:	20000af8 	.word	0x20000af8
 8002428:	f3af 8000 	nop.w
 800242c:	f3af 8000 	nop.w

08002430 <chMtxUnlockAllS>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @sclass
 */
void chMtxUnlockAllS(void) {
 8002430:	b500      	push	{lr}
 8002432:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 8002434:	4b18      	ldr	r3, [pc, #96]	; (8002498 <chMtxUnlockAllS+0x68>)
 8002436:	699b      	ldr	r3, [r3, #24]
 8002438:	9303      	str	r3, [sp, #12]

  while (ctp->mtxlist != NULL) {
 800243a:	e022      	b.n	8002482 <chMtxUnlockAllS+0x52>
    mutex_t *mp = ctp->mtxlist;
 800243c:	9b03      	ldr	r3, [sp, #12]
 800243e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002440:	9302      	str	r3, [sp, #8]
    ctp->mtxlist = mp->next;
 8002442:	9b02      	ldr	r3, [sp, #8]
 8002444:	68da      	ldr	r2, [r3, #12]
 8002446:	9b03      	ldr	r3, [sp, #12]
 8002448:	639a      	str	r2, [r3, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
 800244a:	9802      	ldr	r0, [sp, #8]
 800244c:	f7ff fe80 	bl	8002150 <chMtxQueueNotEmptyS>
 8002450:	4603      	mov	r3, r0
 8002452:	2b00      	cmp	r3, #0
 8002454:	d012      	beq.n	800247c <chMtxUnlockAllS+0x4c>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      thread_t *tp = queue_fifo_remove(&mp->queue);
 8002456:	9b02      	ldr	r3, [sp, #8]
 8002458:	4618      	mov	r0, r3
 800245a:	f7ff fe41 	bl	80020e0 <queue_fifo_remove>
 800245e:	9001      	str	r0, [sp, #4]
      mp->owner = tp;
 8002460:	9b02      	ldr	r3, [sp, #8]
 8002462:	9a01      	ldr	r2, [sp, #4]
 8002464:	609a      	str	r2, [r3, #8]
      mp->next = tp->mtxlist;
 8002466:	9b01      	ldr	r3, [sp, #4]
 8002468:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800246a:	9b02      	ldr	r3, [sp, #8]
 800246c:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800246e:	9b01      	ldr	r3, [sp, #4]
 8002470:	9a02      	ldr	r2, [sp, #8]
 8002472:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 8002474:	9801      	ldr	r0, [sp, #4]
 8002476:	f7fe fc73 	bl	8000d60 <chSchReadyI>
 800247a:	e002      	b.n	8002482 <chMtxUnlockAllS+0x52>
    }
    else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)0;
#endif
      mp->owner = NULL;
 800247c:	9b02      	ldr	r3, [sp, #8]
 800247e:	2200      	movs	r2, #0
 8002480:	609a      	str	r2, [r3, #8]
 * @sclass
 */
void chMtxUnlockAllS(void) {
  thread_t *ctp = currp;

  while (ctp->mtxlist != NULL) {
 8002482:	9b03      	ldr	r3, [sp, #12]
 8002484:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002486:	2b00      	cmp	r3, #0
 8002488:	d1d8      	bne.n	800243c <chMtxUnlockAllS+0xc>
      mp->cnt = (cnt_t)0;
#endif
      mp->owner = NULL;
    }
  }
  ctp->prio = ctp->realprio;
 800248a:	9b03      	ldr	r3, [sp, #12]
 800248c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800248e:	9b03      	ldr	r3, [sp, #12]
 8002490:	609a      	str	r2, [r3, #8]
}
 8002492:	b005      	add	sp, #20
 8002494:	f85d fb04 	ldr.w	pc, [sp], #4
 8002498:	20000af8 	.word	0x20000af8
 800249c:	f3af 8000 	nop.w

080024a0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80024a0:	b500      	push	{lr}
 80024a2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80024a4:	4b1d      	ldr	r3, [pc, #116]	; (800251c <chMtxUnlockAll+0x7c>)
 80024a6:	699b      	ldr	r3, [r3, #24]
 80024a8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80024aa:	f7ff fe41 	bl	8002130 <chSysLock>
  if (ctp->mtxlist != NULL) {
 80024ae:	9b03      	ldr	r3, [sp, #12]
 80024b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80024b2:	2b00      	cmp	r3, #0
 80024b4:	d02c      	beq.n	8002510 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->mtxlist;
 80024b6:	9b03      	ldr	r3, [sp, #12]
 80024b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80024ba:	9302      	str	r3, [sp, #8]
      ctp->mtxlist = mp->next;
 80024bc:	9b02      	ldr	r3, [sp, #8]
 80024be:	68da      	ldr	r2, [r3, #12]
 80024c0:	9b03      	ldr	r3, [sp, #12]
 80024c2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80024c4:	9802      	ldr	r0, [sp, #8]
 80024c6:	f7ff fe43 	bl	8002150 <chMtxQueueNotEmptyS>
 80024ca:	4603      	mov	r3, r0
 80024cc:	2b00      	cmp	r3, #0
 80024ce:	d012      	beq.n	80024f6 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
 80024d0:	9b02      	ldr	r3, [sp, #8]
 80024d2:	4618      	mov	r0, r3
 80024d4:	f7ff fe04 	bl	80020e0 <queue_fifo_remove>
 80024d8:	9001      	str	r0, [sp, #4]
        mp->owner = tp;
 80024da:	9b02      	ldr	r3, [sp, #8]
 80024dc:	9a01      	ldr	r2, [sp, #4]
 80024de:	609a      	str	r2, [r3, #8]
        mp->next = tp->mtxlist;
 80024e0:	9b01      	ldr	r3, [sp, #4]
 80024e2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80024e4:	9b02      	ldr	r3, [sp, #8]
 80024e6:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
 80024e8:	9b01      	ldr	r3, [sp, #4]
 80024ea:	9a02      	ldr	r2, [sp, #8]
 80024ec:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 80024ee:	9801      	ldr	r0, [sp, #4]
 80024f0:	f7fe fc36 	bl	8000d60 <chSchReadyI>
 80024f4:	e002      	b.n	80024fc <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 80024f6:	9b02      	ldr	r3, [sp, #8]
 80024f8:	2200      	movs	r2, #0
 80024fa:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->mtxlist != NULL);
 80024fc:	9b03      	ldr	r3, [sp, #12]
 80024fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002500:	2b00      	cmp	r3, #0
 8002502:	d1d8      	bne.n	80024b6 <chMtxUnlockAll+0x16>
    ctp->prio = ctp->realprio;
 8002504:	9b03      	ldr	r3, [sp, #12]
 8002506:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002508:	9b03      	ldr	r3, [sp, #12]
 800250a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800250c:	f7fe fd40 	bl	8000f90 <chSchRescheduleS>
  }
  chSysUnlock();
 8002510:	f7ff fe16 	bl	8002140 <chSysUnlock>
}
 8002514:	b005      	add	sp, #20
 8002516:	f85d fb04 	ldr.w	pc, [sp], #4
 800251a:	bf00      	nop
 800251c:	20000af8 	.word	0x20000af8

08002520 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002520:	b082      	sub	sp, #8
 8002522:	2320      	movs	r3, #32
 8002524:	9301      	str	r3, [sp, #4]
 8002526:	9b01      	ldr	r3, [sp, #4]
 8002528:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800252c:	b002      	add	sp, #8
 800252e:	4770      	bx	lr

08002530 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002530:	b082      	sub	sp, #8
 8002532:	2300      	movs	r3, #0
 8002534:	9301      	str	r3, [sp, #4]
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr

08002540 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002540:	b082      	sub	sp, #8
 8002542:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8002544:	9b01      	ldr	r3, [sp, #4]
 8002546:	9a01      	ldr	r2, [sp, #4]
 8002548:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800254a:	9b01      	ldr	r3, [sp, #4]
 800254c:	9a01      	ldr	r2, [sp, #4]
 800254e:	605a      	str	r2, [r3, #4]
}
 8002550:	b002      	add	sp, #8
 8002552:	4770      	bx	lr
 8002554:	f3af 8000 	nop.w
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002560:	b082      	sub	sp, #8
 8002562:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002564:	9b01      	ldr	r3, [sp, #4]
 8002566:	681a      	ldr	r2, [r3, #0]
 8002568:	9b01      	ldr	r3, [sp, #4]
 800256a:	429a      	cmp	r2, r3
 800256c:	bf14      	ite	ne
 800256e:	2301      	movne	r3, #1
 8002570:	2300      	moveq	r3, #0
 8002572:	b2db      	uxtb	r3, r3
}
 8002574:	4618      	mov	r0, r3
 8002576:	b002      	add	sp, #8
 8002578:	4770      	bx	lr
 800257a:	bf00      	nop
 800257c:	f3af 8000 	nop.w

08002580 <queue_prio_insert>:
  tlp->next = tp->queue.next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002580:	b084      	sub	sp, #16
 8002582:	9001      	str	r0, [sp, #4]
 8002584:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002586:	9b00      	ldr	r3, [sp, #0]
 8002588:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->queue.next;
 800258a:	9b03      	ldr	r3, [sp, #12]
 800258c:	681b      	ldr	r3, [r3, #0]
 800258e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002590:	9a03      	ldr	r2, [sp, #12]
 8002592:	9b00      	ldr	r3, [sp, #0]
 8002594:	429a      	cmp	r2, r3
 8002596:	d005      	beq.n	80025a4 <queue_prio_insert+0x24>
 8002598:	9b03      	ldr	r3, [sp, #12]
 800259a:	689a      	ldr	r2, [r3, #8]
 800259c:	9b01      	ldr	r3, [sp, #4]
 800259e:	689b      	ldr	r3, [r3, #8]
 80025a0:	429a      	cmp	r2, r3
 80025a2:	d2f2      	bcs.n	800258a <queue_prio_insert+0xa>
  tp->queue.next             = cp;
 80025a4:	9b01      	ldr	r3, [sp, #4]
 80025a6:	9a03      	ldr	r2, [sp, #12]
 80025a8:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = cp->queue.prev;
 80025aa:	9b03      	ldr	r3, [sp, #12]
 80025ac:	685a      	ldr	r2, [r3, #4]
 80025ae:	9b01      	ldr	r3, [sp, #4]
 80025b0:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 80025b2:	9b01      	ldr	r3, [sp, #4]
 80025b4:	685b      	ldr	r3, [r3, #4]
 80025b6:	9a01      	ldr	r2, [sp, #4]
 80025b8:	601a      	str	r2, [r3, #0]
  cp->queue.prev             = tp;
 80025ba:	9b03      	ldr	r3, [sp, #12]
 80025bc:	9a01      	ldr	r2, [sp, #4]
 80025be:	605a      	str	r2, [r3, #4]
}
 80025c0:	b004      	add	sp, #16
 80025c2:	4770      	bx	lr
 80025c4:	f3af 8000 	nop.w
 80025c8:	f3af 8000 	nop.w
 80025cc:	f3af 8000 	nop.w

080025d0 <queue_fifo_remove>:
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80025d0:	b084      	sub	sp, #16
 80025d2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 80025d4:	9b01      	ldr	r3, [sp, #4]
 80025d6:	681b      	ldr	r3, [r3, #0]
 80025d8:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 80025da:	9b03      	ldr	r3, [sp, #12]
 80025dc:	681a      	ldr	r2, [r3, #0]
 80025de:	9b01      	ldr	r3, [sp, #4]
 80025e0:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80025e2:	9b01      	ldr	r3, [sp, #4]
 80025e4:	681b      	ldr	r3, [r3, #0]
 80025e6:	9a01      	ldr	r2, [sp, #4]
 80025e8:	605a      	str	r2, [r3, #4]

  return tp;
 80025ea:	9b03      	ldr	r3, [sp, #12]
}
 80025ec:	4618      	mov	r0, r3
 80025ee:	b004      	add	sp, #16
 80025f0:	4770      	bx	lr
 80025f2:	bf00      	nop
 80025f4:	f3af 8000 	nop.w
 80025f8:	f3af 8000 	nop.w
 80025fc:	f3af 8000 	nop.w

08002600 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002600:	b508      	push	{r3, lr}

  port_lock();
 8002602:	f7ff ff8d 	bl	8002520 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002606:	bd08      	pop	{r3, pc}
 8002608:	f3af 8000 	nop.w
 800260c:	f3af 8000 	nop.w

08002610 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002610:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8002612:	f7ff ff8d 	bl	8002530 <port_unlock>
}
 8002616:	bd08      	pop	{r3, pc}
 8002618:	f3af 8000 	nop.w
 800261c:	f3af 8000 	nop.w

08002620 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002620:	4b01      	ldr	r3, [pc, #4]	; (8002628 <chThdGetSelfX+0x8>)
 8002622:	699b      	ldr	r3, [r3, #24]
}
 8002624:	4618      	mov	r0, r3
 8002626:	4770      	bx	lr
 8002628:	20000af8 	.word	0x20000af8
 800262c:	f3af 8000 	nop.w

08002630 <chMtxGetNextMutexS>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 8002630:	b508      	push	{r3, lr}

  return chThdGetSelfX()->mtxlist;
 8002632:	f7ff fff5 	bl	8002620 <chThdGetSelfX>
 8002636:	4603      	mov	r3, r0
 8002638:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800263a:	4618      	mov	r0, r3
 800263c:	bd08      	pop	{r3, pc}
 800263e:	bf00      	nop

08002640 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  queue_init(&cp->queue);
 8002646:	9b01      	ldr	r3, [sp, #4]
 8002648:	4618      	mov	r0, r3
 800264a:	f7ff ff79 	bl	8002540 <queue_init>
}
 800264e:	b003      	add	sp, #12
 8002650:	f85d fb04 	ldr.w	pc, [sp], #4
 8002654:	f3af 8000 	nop.w
 8002658:	f3af 8000 	nop.w
 800265c:	f3af 8000 	nop.w

08002660 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002660:	b500      	push	{lr}
 8002662:	b083      	sub	sp, #12
 8002664:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
 8002666:	f7ff ffcb 	bl	8002600 <chSysLock>
  if (queue_notempty(&cp->queue)) {
 800266a:	9b01      	ldr	r3, [sp, #4]
 800266c:	4618      	mov	r0, r3
 800266e:	f7ff ff77 	bl	8002560 <queue_notempty>
 8002672:	4603      	mov	r3, r0
 8002674:	2b00      	cmp	r3, #0
 8002676:	d008      	beq.n	800268a <chCondSignal+0x2a>
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 8002678:	9b01      	ldr	r3, [sp, #4]
 800267a:	4618      	mov	r0, r3
 800267c:	f7ff ffa8 	bl	80025d0 <queue_fifo_remove>
 8002680:	4603      	mov	r3, r0
 8002682:	4618      	mov	r0, r3
 8002684:	2100      	movs	r1, #0
 8002686:	f7fe fc5b 	bl	8000f40 <chSchWakeupS>
  }
  chSysUnlock();
 800268a:	f7ff ffc1 	bl	8002610 <chSysUnlock>
}
 800268e:	b003      	add	sp, #12
 8002690:	f85d fb04 	ldr.w	pc, [sp], #4
 8002694:	f3af 8000 	nop.w
 8002698:	f3af 8000 	nop.w
 800269c:	f3af 8000 	nop.w

080026a0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80026a0:	b500      	push	{lr}
 80026a2:	b085      	sub	sp, #20
 80026a4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 80026a6:	9b01      	ldr	r3, [sp, #4]
 80026a8:	4618      	mov	r0, r3
 80026aa:	f7ff ff59 	bl	8002560 <queue_notempty>
 80026ae:	4603      	mov	r3, r0
 80026b0:	2b00      	cmp	r3, #0
 80026b2:	d00a      	beq.n	80026ca <chCondSignalI+0x2a>
    thread_t *tp = queue_fifo_remove(&cp->queue);
 80026b4:	9b01      	ldr	r3, [sp, #4]
 80026b6:	4618      	mov	r0, r3
 80026b8:	f7ff ff8a 	bl	80025d0 <queue_fifo_remove>
 80026bc:	9003      	str	r0, [sp, #12]
    tp->u.rdymsg = MSG_OK;
 80026be:	9b03      	ldr	r3, [sp, #12]
 80026c0:	2200      	movs	r2, #0
 80026c2:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80026c4:	9803      	ldr	r0, [sp, #12]
 80026c6:	f7fe fb4b 	bl	8000d60 <chSchReadyI>
  }
}
 80026ca:	b005      	add	sp, #20
 80026cc:	f85d fb04 	ldr.w	pc, [sp], #4

080026d0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80026d0:	b500      	push	{lr}
 80026d2:	b083      	sub	sp, #12
 80026d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80026d6:	f7ff ff93 	bl	8002600 <chSysLock>
  chCondBroadcastI(cp);
 80026da:	9801      	ldr	r0, [sp, #4]
 80026dc:	f000 f808 	bl	80026f0 <chCondBroadcastI>
  chSchRescheduleS();
 80026e0:	f7fe fc56 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 80026e4:	f7ff ff94 	bl	8002610 <chSysUnlock>
}
 80026e8:	b003      	add	sp, #12
 80026ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80026ee:	bf00      	nop

080026f0 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 80026f0:	b500      	push	{lr}
 80026f2:	b083      	sub	sp, #12
 80026f4:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 80026f6:	e00b      	b.n	8002710 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 80026f8:	9b01      	ldr	r3, [sp, #4]
 80026fa:	4618      	mov	r0, r3
 80026fc:	f7ff ff68 	bl	80025d0 <queue_fifo_remove>
 8002700:	4603      	mov	r3, r0
 8002702:	4618      	mov	r0, r3
 8002704:	f7fe fb2c 	bl	8000d60 <chSchReadyI>
 8002708:	4602      	mov	r2, r0
 800270a:	f06f 0301 	mvn.w	r3, #1
 800270e:	6253      	str	r3, [r2, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8002710:	9b01      	ldr	r3, [sp, #4]
 8002712:	4618      	mov	r0, r3
 8002714:	f7ff ff24 	bl	8002560 <queue_notempty>
 8002718:	4603      	mov	r3, r0
 800271a:	2b00      	cmp	r3, #0
 800271c:	d1ec      	bne.n	80026f8 <chCondBroadcastI+0x8>
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
  }
}
 800271e:	b003      	add	sp, #12
 8002720:	f85d fb04 	ldr.w	pc, [sp], #4
 8002724:	f3af 8000 	nop.w
 8002728:	f3af 8000 	nop.w
 800272c:	f3af 8000 	nop.w

08002730 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002730:	b500      	push	{lr}
 8002732:	b085      	sub	sp, #20
 8002734:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8002736:	f7ff ff63 	bl	8002600 <chSysLock>
  msg = chCondWaitS(cp);
 800273a:	9801      	ldr	r0, [sp, #4]
 800273c:	f000 f808 	bl	8002750 <chCondWaitS>
 8002740:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002742:	f7ff ff65 	bl	8002610 <chSysUnlock>
  return msg;
 8002746:	9b03      	ldr	r3, [sp, #12]
}
 8002748:	4618      	mov	r0, r3
 800274a:	b005      	add	sp, #20
 800274c:	f85d fb04 	ldr.w	pc, [sp], #4

08002750 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8002750:	b500      	push	{lr}
 8002752:	b087      	sub	sp, #28
 8002754:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002756:	4b0f      	ldr	r3, [pc, #60]	; (8002794 <chCondWaitS+0x44>)
 8002758:	699b      	ldr	r3, [r3, #24]
 800275a:	9305      	str	r3, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800275c:	f7ff ff68 	bl	8002630 <chMtxGetNextMutexS>
 8002760:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 8002762:	9804      	ldr	r0, [sp, #16]
 8002764:	f7ff fe14 	bl	8002390 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8002768:	9b05      	ldr	r3, [sp, #20]
 800276a:	9a01      	ldr	r2, [sp, #4]
 800276c:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(ctp, &cp->queue);
 800276e:	9b01      	ldr	r3, [sp, #4]
 8002770:	9805      	ldr	r0, [sp, #20]
 8002772:	4619      	mov	r1, r3
 8002774:	f7ff ff04 	bl	8002580 <queue_prio_insert>
  chSchGoSleepS(CH_STATE_WTCOND);
 8002778:	2007      	movs	r0, #7
 800277a:	f7fe fb41 	bl	8000e00 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 800277e:	9b05      	ldr	r3, [sp, #20]
 8002780:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002782:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8002784:	9804      	ldr	r0, [sp, #16]
 8002786:	f7ff fd13 	bl	80021b0 <chMtxLockS>

  return msg;
 800278a:	9b03      	ldr	r3, [sp, #12]
}
 800278c:	4618      	mov	r0, r3
 800278e:	b007      	add	sp, #28
 8002790:	f85d fb04 	ldr.w	pc, [sp], #4
 8002794:	20000af8 	.word	0x20000af8
 8002798:	f3af 8000 	nop.w
 800279c:	f3af 8000 	nop.w

080027a0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80027a0:	b500      	push	{lr}
 80027a2:	b085      	sub	sp, #20
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80027a8:	f7ff ff2a 	bl	8002600 <chSysLock>
  msg = chCondWaitTimeoutS(cp, time);
 80027ac:	9801      	ldr	r0, [sp, #4]
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	f000 f80e 	bl	80027d0 <chCondWaitTimeoutS>
 80027b4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80027b6:	f7ff ff2b 	bl	8002610 <chSysUnlock>

  return msg;
 80027ba:	9b03      	ldr	r3, [sp, #12]
}
 80027bc:	4618      	mov	r0, r3
 80027be:	b005      	add	sp, #20
 80027c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 80027d0:	b500      	push	{lr}
 80027d2:	b085      	sub	sp, #20
 80027d4:	9001      	str	r0, [sp, #4]
 80027d6:	9100      	str	r1, [sp, #0]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80027d8:	f7ff ff2a 	bl	8002630 <chMtxGetNextMutexS>
 80027dc:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 80027de:	9803      	ldr	r0, [sp, #12]
 80027e0:	f7ff fdd6 	bl	8002390 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 80027e4:	4b0d      	ldr	r3, [pc, #52]	; (800281c <chCondWaitTimeoutS+0x4c>)
 80027e6:	699b      	ldr	r3, [r3, #24]
 80027e8:	9a01      	ldr	r2, [sp, #4]
 80027ea:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(currp, &cp->queue);
 80027ec:	4b0b      	ldr	r3, [pc, #44]	; (800281c <chCondWaitTimeoutS+0x4c>)
 80027ee:	699a      	ldr	r2, [r3, #24]
 80027f0:	9b01      	ldr	r3, [sp, #4]
 80027f2:	4610      	mov	r0, r2
 80027f4:	4619      	mov	r1, r3
 80027f6:	f7ff fec3 	bl	8002580 <queue_prio_insert>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 80027fa:	2007      	movs	r0, #7
 80027fc:	9900      	ldr	r1, [sp, #0]
 80027fe:	f7fe fb67 	bl	8000ed0 <chSchGoSleepTimeoutS>
 8002802:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8002804:	9b02      	ldr	r3, [sp, #8]
 8002806:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800280a:	d002      	beq.n	8002812 <chCondWaitTimeoutS+0x42>
    chMtxLockS(mp);
 800280c:	9803      	ldr	r0, [sp, #12]
 800280e:	f7ff fccf 	bl	80021b0 <chMtxLockS>
  }

  return msg;
 8002812:	9b02      	ldr	r3, [sp, #8]
}
 8002814:	4618      	mov	r0, r3
 8002816:	b005      	add	sp, #20
 8002818:	f85d fb04 	ldr.w	pc, [sp], #4
 800281c:	20000af8 	.word	0x20000af8

08002820 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002820:	b082      	sub	sp, #8
 8002822:	2320      	movs	r3, #32
 8002824:	9301      	str	r3, [sp, #4]
 8002826:	9b01      	ldr	r3, [sp, #4]
 8002828:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800282c:	b002      	add	sp, #8
 800282e:	4770      	bx	lr

08002830 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002830:	b082      	sub	sp, #8
 8002832:	2300      	movs	r3, #0
 8002834:	9301      	str	r3, [sp, #4]
 8002836:	9b01      	ldr	r3, [sp, #4]
 8002838:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800283c:	b002      	add	sp, #8
 800283e:	4770      	bx	lr

08002840 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002840:	b508      	push	{r3, lr}

  port_lock();
 8002842:	f7ff ffed 	bl	8002820 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002846:	bd08      	pop	{r3, pc}
 8002848:	f3af 8000 	nop.w
 800284c:	f3af 8000 	nop.w

08002850 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002850:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8002852:	f7ff ffed 	bl	8002830 <port_unlock>
}
 8002856:	bd08      	pop	{r3, pc}
 8002858:	f3af 8000 	nop.w
 800285c:	f3af 8000 	nop.w

08002860 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002860:	b500      	push	{lr}
 8002862:	b085      	sub	sp, #20
 8002864:	9003      	str	r0, [sp, #12]
 8002866:	9102      	str	r1, [sp, #8]
 8002868:	9201      	str	r2, [sp, #4]
 800286a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800286c:	f7ff ffe8 	bl	8002840 <chSysLock>
  elp->next     = esp->next;
 8002870:	9b03      	ldr	r3, [sp, #12]
 8002872:	681a      	ldr	r2, [r3, #0]
 8002874:	9b02      	ldr	r3, [sp, #8]
 8002876:	601a      	str	r2, [r3, #0]
  esp->next     = elp;
 8002878:	9b03      	ldr	r3, [sp, #12]
 800287a:	9a02      	ldr	r2, [sp, #8]
 800287c:	601a      	str	r2, [r3, #0]
  elp->listener = currp;
 800287e:	4b09      	ldr	r3, [pc, #36]	; (80028a4 <chEvtRegisterMaskWithFlags+0x44>)
 8002880:	699a      	ldr	r2, [r3, #24]
 8002882:	9b02      	ldr	r3, [sp, #8]
 8002884:	605a      	str	r2, [r3, #4]
  elp->events   = events;
 8002886:	9b02      	ldr	r3, [sp, #8]
 8002888:	9a01      	ldr	r2, [sp, #4]
 800288a:	609a      	str	r2, [r3, #8]
  elp->flags    = (eventflags_t)0;
 800288c:	9b02      	ldr	r3, [sp, #8]
 800288e:	2200      	movs	r2, #0
 8002890:	60da      	str	r2, [r3, #12]
  elp->wflags   = wflags;
 8002892:	9b02      	ldr	r3, [sp, #8]
 8002894:	9a00      	ldr	r2, [sp, #0]
 8002896:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 8002898:	f7ff ffda 	bl	8002850 <chSysUnlock>
}
 800289c:	b005      	add	sp, #20
 800289e:	f85d fb04 	ldr.w	pc, [sp], #4
 80028a2:	bf00      	nop
 80028a4:	20000af8 	.word	0x20000af8
 80028a8:	f3af 8000 	nop.w
 80028ac:	f3af 8000 	nop.w

080028b0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80028b0:	b500      	push	{lr}
 80028b2:	b085      	sub	sp, #20
 80028b4:	9001      	str	r0, [sp, #4]
 80028b6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80028b8:	9b01      	ldr	r3, [sp, #4]
 80028ba:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 80028bc:	f7ff ffc0 	bl	8002840 <chSysLock>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 80028c0:	e00c      	b.n	80028dc <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->next == elp) {
 80028c2:	9b03      	ldr	r3, [sp, #12]
 80028c4:	681a      	ldr	r2, [r3, #0]
 80028c6:	9b00      	ldr	r3, [sp, #0]
 80028c8:	429a      	cmp	r2, r3
 80028ca:	d104      	bne.n	80028d6 <chEvtUnregister+0x26>
      p->next = elp->next;
 80028cc:	9b00      	ldr	r3, [sp, #0]
 80028ce:	681a      	ldr	r2, [r3, #0]
 80028d0:	9b03      	ldr	r3, [sp, #12]
 80028d2:	601a      	str	r2, [r3, #0]
      break;
 80028d4:	e007      	b.n	80028e6 <chEvtUnregister+0x36>
    }
    p = p->next;
 80028d6:	9b03      	ldr	r3, [sp, #12]
 80028d8:	681b      	ldr	r3, [r3, #0]
 80028da:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 80028dc:	9b03      	ldr	r3, [sp, #12]
 80028de:	681a      	ldr	r2, [r3, #0]
 80028e0:	9b01      	ldr	r3, [sp, #4]
 80028e2:	429a      	cmp	r2, r3
 80028e4:	d1ed      	bne.n	80028c2 <chEvtUnregister+0x12>
      p->next = elp->next;
      break;
    }
    p = p->next;
  }
  chSysUnlock();
 80028e6:	f7ff ffb3 	bl	8002850 <chSysUnlock>
}
 80028ea:	b005      	add	sp, #20
 80028ec:	f85d fb04 	ldr.w	pc, [sp], #4

080028f0 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 80028f0:	b500      	push	{lr}
 80028f2:	b085      	sub	sp, #20
 80028f4:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 80028f6:	f7ff ffa3 	bl	8002840 <chSysLock>
  m = currp->epending & events;
 80028fa:	4b0b      	ldr	r3, [pc, #44]	; (8002928 <chEvtGetAndClearEvents+0x38>)
 80028fc:	699b      	ldr	r3, [r3, #24]
 80028fe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002900:	9b01      	ldr	r3, [sp, #4]
 8002902:	4013      	ands	r3, r2
 8002904:	9303      	str	r3, [sp, #12]
  currp->epending &= ~events;
 8002906:	4b08      	ldr	r3, [pc, #32]	; (8002928 <chEvtGetAndClearEvents+0x38>)
 8002908:	699b      	ldr	r3, [r3, #24]
 800290a:	4a07      	ldr	r2, [pc, #28]	; (8002928 <chEvtGetAndClearEvents+0x38>)
 800290c:	6992      	ldr	r2, [r2, #24]
 800290e:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002910:	9a01      	ldr	r2, [sp, #4]
 8002912:	43d2      	mvns	r2, r2
 8002914:	400a      	ands	r2, r1
 8002916:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002918:	f7ff ff9a 	bl	8002850 <chSysUnlock>

  return m;
 800291c:	9b03      	ldr	r3, [sp, #12]
}
 800291e:	4618      	mov	r0, r3
 8002920:	b005      	add	sp, #20
 8002922:	f85d fb04 	ldr.w	pc, [sp], #4
 8002926:	bf00      	nop
 8002928:	20000af8 	.word	0x20000af8
 800292c:	f3af 8000 	nop.w

08002930 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The mask of currently pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8002930:	b500      	push	{lr}
 8002932:	b083      	sub	sp, #12
 8002934:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002936:	f7ff ff83 	bl	8002840 <chSysLock>
  currp->epending |= events;
 800293a:	4b09      	ldr	r3, [pc, #36]	; (8002960 <chEvtAddEvents+0x30>)
 800293c:	699b      	ldr	r3, [r3, #24]
 800293e:	4a08      	ldr	r2, [pc, #32]	; (8002960 <chEvtAddEvents+0x30>)
 8002940:	6992      	ldr	r2, [r2, #24]
 8002942:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002944:	9a01      	ldr	r2, [sp, #4]
 8002946:	430a      	orrs	r2, r1
 8002948:	635a      	str	r2, [r3, #52]	; 0x34
  events = currp->epending;
 800294a:	4b05      	ldr	r3, [pc, #20]	; (8002960 <chEvtAddEvents+0x30>)
 800294c:	699b      	ldr	r3, [r3, #24]
 800294e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002950:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8002952:	f7ff ff7d 	bl	8002850 <chSysUnlock>

  return events;
 8002956:	9b01      	ldr	r3, [sp, #4]
}
 8002958:	4618      	mov	r0, r3
 800295a:	b003      	add	sp, #12
 800295c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002960:	20000af8 	.word	0x20000af8
 8002964:	f3af 8000 	nop.w
 8002968:	f3af 8000 	nop.w
 800296c:	f3af 8000 	nop.w

08002970 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002970:	b500      	push	{lr}
 8002972:	b085      	sub	sp, #20
 8002974:	9001      	str	r0, [sp, #4]
 8002976:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8002978:	9b01      	ldr	r3, [sp, #4]
 800297a:	681b      	ldr	r3, [r3, #0]
 800297c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800297e:	e01a      	b.n	80029b6 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->flags |= flags;
 8002980:	9b03      	ldr	r3, [sp, #12]
 8002982:	68da      	ldr	r2, [r3, #12]
 8002984:	9b00      	ldr	r3, [sp, #0]
 8002986:	431a      	orrs	r2, r3
 8002988:	9b03      	ldr	r3, [sp, #12]
 800298a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800298c:	9b00      	ldr	r3, [sp, #0]
 800298e:	2b00      	cmp	r3, #0
 8002990:	d006      	beq.n	80029a0 <chEvtBroadcastFlagsI+0x30>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8002992:	9b03      	ldr	r3, [sp, #12]
 8002994:	68da      	ldr	r2, [r3, #12]
 8002996:	9b03      	ldr	r3, [sp, #12]
 8002998:	691b      	ldr	r3, [r3, #16]
 800299a:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800299c:	2b00      	cmp	r3, #0
 800299e:	d007      	beq.n	80029b0 <chEvtBroadcastFlagsI+0x40>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 80029a0:	9b03      	ldr	r3, [sp, #12]
 80029a2:	685a      	ldr	r2, [r3, #4]
 80029a4:	9b03      	ldr	r3, [sp, #12]
 80029a6:	689b      	ldr	r3, [r3, #8]
 80029a8:	4610      	mov	r0, r2
 80029aa:	4619      	mov	r1, r3
 80029ac:	f000 f840 	bl	8002a30 <chEvtSignalI>
    }
    elp = elp->next;
 80029b0:	9b03      	ldr	r3, [sp, #12]
 80029b2:	681b      	ldr	r3, [r3, #0]
 80029b4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80029b6:	9a03      	ldr	r2, [sp, #12]
 80029b8:	9b01      	ldr	r3, [sp, #4]
 80029ba:	429a      	cmp	r2, r3
 80029bc:	d1e0      	bne.n	8002980 <chEvtBroadcastFlagsI+0x10>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
 80029be:	b005      	add	sp, #20
 80029c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80029c4:	f3af 8000 	nop.w
 80029c8:	f3af 8000 	nop.w
 80029cc:	f3af 8000 	nop.w

080029d0 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @api
 */
eventflags_t chEvtGetAndClearFlags(event_listener_t *elp) {
 80029d0:	b500      	push	{lr}
 80029d2:	b085      	sub	sp, #20
 80029d4:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  chSysLock();
 80029d6:	f7ff ff33 	bl	8002840 <chSysLock>
  flags = elp->flags;
 80029da:	9b01      	ldr	r3, [sp, #4]
 80029dc:	68db      	ldr	r3, [r3, #12]
 80029de:	9303      	str	r3, [sp, #12]
  elp->flags = (eventflags_t)0;
 80029e0:	9b01      	ldr	r3, [sp, #4]
 80029e2:	2200      	movs	r2, #0
 80029e4:	60da      	str	r2, [r3, #12]
  chSysUnlock();
 80029e6:	f7ff ff33 	bl	8002850 <chSysUnlock>

  return flags;
 80029ea:	9b03      	ldr	r3, [sp, #12]
}
 80029ec:	4618      	mov	r0, r3
 80029ee:	b005      	add	sp, #20
 80029f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80029f4:	f3af 8000 	nop.w
 80029f8:	f3af 8000 	nop.w
 80029fc:	f3af 8000 	nop.w

08002a00 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002a00:	b500      	push	{lr}
 8002a02:	b083      	sub	sp, #12
 8002a04:	9001      	str	r0, [sp, #4]
 8002a06:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002a08:	f7ff ff1a 	bl	8002840 <chSysLock>
  chEvtSignalI(tp, events);
 8002a0c:	9801      	ldr	r0, [sp, #4]
 8002a0e:	9900      	ldr	r1, [sp, #0]
 8002a10:	f000 f80e 	bl	8002a30 <chEvtSignalI>
  chSchRescheduleS();
 8002a14:	f7fe fabc 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8002a18:	f7ff ff1a 	bl	8002850 <chSysUnlock>
}
 8002a1c:	b003      	add	sp, #12
 8002a1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a22:	bf00      	nop
 8002a24:	f3af 8000 	nop.w
 8002a28:	f3af 8000 	nop.w
 8002a2c:	f3af 8000 	nop.w

08002a30 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002a30:	b500      	push	{lr}
 8002a32:	b083      	sub	sp, #12
 8002a34:	9001      	str	r0, [sp, #4]
 8002a36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8002a38:	9b01      	ldr	r3, [sp, #4]
 8002a3a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a3c:	9b00      	ldr	r3, [sp, #0]
 8002a3e:	431a      	orrs	r2, r3
 8002a40:	9b01      	ldr	r3, [sp, #4]
 8002a42:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a44:	9b01      	ldr	r3, [sp, #4]
 8002a46:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002a4a:	2b0a      	cmp	r3, #10
 8002a4c:	d106      	bne.n	8002a5c <chEvtSignalI+0x2c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002a4e:	9b01      	ldr	r3, [sp, #4]
 8002a50:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a52:	9b01      	ldr	r3, [sp, #4]
 8002a54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002a56:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002a58:	2b00      	cmp	r3, #0
 8002a5a:	d10d      	bne.n	8002a78 <chEvtSignalI+0x48>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8002a5c:	9b01      	ldr	r3, [sp, #4]
 8002a5e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002a62:	2b0b      	cmp	r3, #11
 8002a64:	d10e      	bne.n	8002a84 <chEvtSignalI+0x54>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002a66:	9b01      	ldr	r3, [sp, #4]
 8002a68:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002a6e:	401a      	ands	r2, r3
 8002a70:	9b01      	ldr	r3, [sp, #4]
 8002a72:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8002a74:	429a      	cmp	r2, r3
 8002a76:	d105      	bne.n	8002a84 <chEvtSignalI+0x54>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8002a78:	9b01      	ldr	r3, [sp, #4]
 8002a7a:	2200      	movs	r2, #0
 8002a7c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002a7e:	9801      	ldr	r0, [sp, #4]
 8002a80:	f7fe f96e 	bl	8000d60 <chSchReadyI>
  }
}
 8002a84:	b003      	add	sp, #12
 8002a86:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a8a:	bf00      	nop
 8002a8c:	f3af 8000 	nop.w

08002a90 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 8002a90:	b500      	push	{lr}
 8002a92:	b083      	sub	sp, #12
 8002a94:	9001      	str	r0, [sp, #4]
 8002a96:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002a98:	f7ff fed2 	bl	8002840 <chSysLock>
  chEvtBroadcastFlagsI(esp, flags);
 8002a9c:	9801      	ldr	r0, [sp, #4]
 8002a9e:	9900      	ldr	r1, [sp, #0]
 8002aa0:	f7ff ff66 	bl	8002970 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8002aa4:	f7fe fa74 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8002aa8:	f7ff fed2 	bl	8002850 <chSysUnlock>
}
 8002aac:	b003      	add	sp, #12
 8002aae:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ab2:	bf00      	nop
 8002ab4:	f3af 8000 	nop.w
 8002ab8:	f3af 8000 	nop.w
 8002abc:	f3af 8000 	nop.w

08002ac0 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
eventflags_t chEvtGetAndClearFlagsI(event_listener_t *elp) {
 8002ac0:	b084      	sub	sp, #16
 8002ac2:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  flags = elp->flags;
 8002ac4:	9b01      	ldr	r3, [sp, #4]
 8002ac6:	68db      	ldr	r3, [r3, #12]
 8002ac8:	9303      	str	r3, [sp, #12]
  elp->flags = (eventflags_t)0;
 8002aca:	9b01      	ldr	r3, [sp, #4]
 8002acc:	2200      	movs	r2, #0
 8002ace:	60da      	str	r2, [r3, #12]

  return flags;
 8002ad0:	9b03      	ldr	r3, [sp, #12]
}
 8002ad2:	4618      	mov	r0, r3
 8002ad4:	b004      	add	sp, #16
 8002ad6:	4770      	bx	lr
 8002ad8:	f3af 8000 	nop.w
 8002adc:	f3af 8000 	nop.w

08002ae0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8002ae0:	b500      	push	{lr}
 8002ae2:	b085      	sub	sp, #20
 8002ae4:	9001      	str	r0, [sp, #4]
 8002ae6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8002ae8:	2300      	movs	r3, #0
 8002aea:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 8002aec:	e019      	b.n	8002b22 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002aee:	9a00      	ldr	r2, [sp, #0]
 8002af0:	9b03      	ldr	r3, [sp, #12]
 8002af2:	fa22 f303 	lsr.w	r3, r2, r3
 8002af6:	f003 0301 	and.w	r3, r3, #1
 8002afa:	2b00      	cmp	r3, #0
 8002afc:	d00e      	beq.n	8002b1c <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002afe:	2201      	movs	r2, #1
 8002b00:	9b03      	ldr	r3, [sp, #12]
 8002b02:	fa02 f303 	lsl.w	r3, r2, r3
 8002b06:	43db      	mvns	r3, r3
 8002b08:	9a00      	ldr	r2, [sp, #0]
 8002b0a:	4013      	ands	r3, r2
 8002b0c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 8002b0e:	9b03      	ldr	r3, [sp, #12]
 8002b10:	009b      	lsls	r3, r3, #2
 8002b12:	9a01      	ldr	r2, [sp, #4]
 8002b14:	4413      	add	r3, r2
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9803      	ldr	r0, [sp, #12]
 8002b1a:	4798      	blx	r3
    }
    eid++;
 8002b1c:	9b03      	ldr	r3, [sp, #12]
 8002b1e:	3301      	adds	r3, #1
 8002b20:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002b22:	9b00      	ldr	r3, [sp, #0]
 8002b24:	2b00      	cmp	r3, #0
 8002b26:	d1e2      	bne.n	8002aee <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8002b28:	b005      	add	sp, #20
 8002b2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b2e:	bf00      	nop

08002b30 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002b30:	b500      	push	{lr}
 8002b32:	b085      	sub	sp, #20
 8002b34:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002b36:	4b15      	ldr	r3, [pc, #84]	; (8002b8c <chEvtWaitOne+0x5c>)
 8002b38:	699b      	ldr	r3, [r3, #24]
 8002b3a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 8002b3c:	f7ff fe80 	bl	8002840 <chSysLock>
  m = ctp->epending & events;
 8002b40:	9b02      	ldr	r3, [sp, #8]
 8002b42:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002b44:	9b01      	ldr	r3, [sp, #4]
 8002b46:	4013      	ands	r3, r2
 8002b48:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 8002b4a:	9b03      	ldr	r3, [sp, #12]
 8002b4c:	2b00      	cmp	r3, #0
 8002b4e:	d10a      	bne.n	8002b66 <chEvtWaitOne+0x36>
    ctp->u.ewmask = events;
 8002b50:	9b02      	ldr	r3, [sp, #8]
 8002b52:	9a01      	ldr	r2, [sp, #4]
 8002b54:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002b56:	200a      	movs	r0, #10
 8002b58:	f7fe f952 	bl	8000e00 <chSchGoSleepS>
    m = ctp->epending & events;
 8002b5c:	9b02      	ldr	r3, [sp, #8]
 8002b5e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002b60:	9b01      	ldr	r3, [sp, #4]
 8002b62:	4013      	ands	r3, r2
 8002b64:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002b66:	9b03      	ldr	r3, [sp, #12]
 8002b68:	425b      	negs	r3, r3
 8002b6a:	9a03      	ldr	r2, [sp, #12]
 8002b6c:	4013      	ands	r3, r2
 8002b6e:	9303      	str	r3, [sp, #12]
  ctp->epending &= ~m;
 8002b70:	9b02      	ldr	r3, [sp, #8]
 8002b72:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002b74:	9b03      	ldr	r3, [sp, #12]
 8002b76:	43db      	mvns	r3, r3
 8002b78:	401a      	ands	r2, r3
 8002b7a:	9b02      	ldr	r3, [sp, #8]
 8002b7c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002b7e:	f7ff fe67 	bl	8002850 <chSysUnlock>

  return m;
 8002b82:	9b03      	ldr	r3, [sp, #12]
}
 8002b84:	4618      	mov	r0, r3
 8002b86:	b005      	add	sp, #20
 8002b88:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b8c:	20000af8 	.word	0x20000af8

08002b90 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002b90:	b500      	push	{lr}
 8002b92:	b085      	sub	sp, #20
 8002b94:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002b96:	4b13      	ldr	r3, [pc, #76]	; (8002be4 <chEvtWaitAny+0x54>)
 8002b98:	699b      	ldr	r3, [r3, #24]
 8002b9a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 8002b9c:	f7ff fe50 	bl	8002840 <chSysLock>
  m = ctp->epending & events;
 8002ba0:	9b02      	ldr	r3, [sp, #8]
 8002ba2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002ba4:	9b01      	ldr	r3, [sp, #4]
 8002ba6:	4013      	ands	r3, r2
 8002ba8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 8002baa:	9b03      	ldr	r3, [sp, #12]
 8002bac:	2b00      	cmp	r3, #0
 8002bae:	d10a      	bne.n	8002bc6 <chEvtWaitAny+0x36>
    ctp->u.ewmask = events;
 8002bb0:	9b02      	ldr	r3, [sp, #8]
 8002bb2:	9a01      	ldr	r2, [sp, #4]
 8002bb4:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002bb6:	200a      	movs	r0, #10
 8002bb8:	f7fe f922 	bl	8000e00 <chSchGoSleepS>
    m = ctp->epending & events;
 8002bbc:	9b02      	ldr	r3, [sp, #8]
 8002bbe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002bc0:	9b01      	ldr	r3, [sp, #4]
 8002bc2:	4013      	ands	r3, r2
 8002bc4:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 8002bc6:	9b02      	ldr	r3, [sp, #8]
 8002bc8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002bca:	9b03      	ldr	r3, [sp, #12]
 8002bcc:	43db      	mvns	r3, r3
 8002bce:	401a      	ands	r2, r3
 8002bd0:	9b02      	ldr	r3, [sp, #8]
 8002bd2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002bd4:	f7ff fe3c 	bl	8002850 <chSysUnlock>

  return m;
 8002bd8:	9b03      	ldr	r3, [sp, #12]
}
 8002bda:	4618      	mov	r0, r3
 8002bdc:	b005      	add	sp, #20
 8002bde:	f85d fb04 	ldr.w	pc, [sp], #4
 8002be2:	bf00      	nop
 8002be4:	20000af8 	.word	0x20000af8
 8002be8:	f3af 8000 	nop.w
 8002bec:	f3af 8000 	nop.w

08002bf0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002bf0:	b500      	push	{lr}
 8002bf2:	b085      	sub	sp, #20
 8002bf4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002bf6:	4b10      	ldr	r3, [pc, #64]	; (8002c38 <chEvtWaitAll+0x48>)
 8002bf8:	699b      	ldr	r3, [r3, #24]
 8002bfa:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002bfc:	f7ff fe20 	bl	8002840 <chSysLock>
  if ((ctp->epending & events) != events) {
 8002c00:	9b03      	ldr	r3, [sp, #12]
 8002c02:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002c04:	9b01      	ldr	r3, [sp, #4]
 8002c06:	401a      	ands	r2, r3
 8002c08:	9b01      	ldr	r3, [sp, #4]
 8002c0a:	429a      	cmp	r2, r3
 8002c0c:	d005      	beq.n	8002c1a <chEvtWaitAll+0x2a>
    ctp->u.ewmask = events;
 8002c0e:	9b03      	ldr	r3, [sp, #12]
 8002c10:	9a01      	ldr	r2, [sp, #4]
 8002c12:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002c14:	200b      	movs	r0, #11
 8002c16:	f7fe f8f3 	bl	8000e00 <chSchGoSleepS>
  }
  ctp->epending &= ~events;
 8002c1a:	9b03      	ldr	r3, [sp, #12]
 8002c1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002c1e:	9b01      	ldr	r3, [sp, #4]
 8002c20:	43db      	mvns	r3, r3
 8002c22:	401a      	ands	r2, r3
 8002c24:	9b03      	ldr	r3, [sp, #12]
 8002c26:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002c28:	f7ff fe12 	bl	8002850 <chSysUnlock>

  return events;
 8002c2c:	9b01      	ldr	r3, [sp, #4]
}
 8002c2e:	4618      	mov	r0, r3
 8002c30:	b005      	add	sp, #20
 8002c32:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c36:	bf00      	nop
 8002c38:	20000af8 	.word	0x20000af8
 8002c3c:	f3af 8000 	nop.w

08002c40 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002c40:	b500      	push	{lr}
 8002c42:	b085      	sub	sp, #20
 8002c44:	9001      	str	r0, [sp, #4]
 8002c46:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002c48:	4b1c      	ldr	r3, [pc, #112]	; (8002cbc <chEvtWaitOneTimeout+0x7c>)
 8002c4a:	699b      	ldr	r3, [r3, #24]
 8002c4c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 8002c4e:	f7ff fdf7 	bl	8002840 <chSysLock>
  m = ctp->epending & events;
 8002c52:	9b02      	ldr	r3, [sp, #8]
 8002c54:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002c56:	9b01      	ldr	r3, [sp, #4]
 8002c58:	4013      	ands	r3, r2
 8002c5a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 8002c5c:	9b03      	ldr	r3, [sp, #12]
 8002c5e:	2b00      	cmp	r3, #0
 8002c60:	d119      	bne.n	8002c96 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002c62:	9b00      	ldr	r3, [sp, #0]
 8002c64:	2b00      	cmp	r3, #0
 8002c66:	d103      	bne.n	8002c70 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8002c68:	f7ff fdf2 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002c6c:	2300      	movs	r3, #0
 8002c6e:	e021      	b.n	8002cb4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->u.ewmask = events;
 8002c70:	9b02      	ldr	r3, [sp, #8]
 8002c72:	9a01      	ldr	r2, [sp, #4]
 8002c74:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002c76:	200a      	movs	r0, #10
 8002c78:	9900      	ldr	r1, [sp, #0]
 8002c7a:	f7fe f929 	bl	8000ed0 <chSchGoSleepTimeoutS>
 8002c7e:	4603      	mov	r3, r0
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	da03      	bge.n	8002c8c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8002c84:	f7ff fde4 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002c88:	2300      	movs	r3, #0
 8002c8a:	e013      	b.n	8002cb4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->epending & events;
 8002c8c:	9b02      	ldr	r3, [sp, #8]
 8002c8e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002c90:	9b01      	ldr	r3, [sp, #4]
 8002c92:	4013      	ands	r3, r2
 8002c94:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002c96:	9b03      	ldr	r3, [sp, #12]
 8002c98:	425b      	negs	r3, r3
 8002c9a:	9a03      	ldr	r2, [sp, #12]
 8002c9c:	4013      	ands	r3, r2
 8002c9e:	9303      	str	r3, [sp, #12]
  ctp->epending &= ~m;
 8002ca0:	9b02      	ldr	r3, [sp, #8]
 8002ca2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002ca4:	9b03      	ldr	r3, [sp, #12]
 8002ca6:	43db      	mvns	r3, r3
 8002ca8:	401a      	ands	r2, r3
 8002caa:	9b02      	ldr	r3, [sp, #8]
 8002cac:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002cae:	f7ff fdcf 	bl	8002850 <chSysUnlock>

  return m;
 8002cb2:	9b03      	ldr	r3, [sp, #12]
}
 8002cb4:	4618      	mov	r0, r3
 8002cb6:	b005      	add	sp, #20
 8002cb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cbc:	20000af8 	.word	0x20000af8

08002cc0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8002cc0:	b500      	push	{lr}
 8002cc2:	b085      	sub	sp, #20
 8002cc4:	9001      	str	r0, [sp, #4]
 8002cc6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002cc8:	4b1a      	ldr	r3, [pc, #104]	; (8002d34 <chEvtWaitAnyTimeout+0x74>)
 8002cca:	699b      	ldr	r3, [r3, #24]
 8002ccc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 8002cce:	f7ff fdb7 	bl	8002840 <chSysLock>
  m = ctp->epending & events;
 8002cd2:	9b02      	ldr	r3, [sp, #8]
 8002cd4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002cd6:	9b01      	ldr	r3, [sp, #4]
 8002cd8:	4013      	ands	r3, r2
 8002cda:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 8002cdc:	9b03      	ldr	r3, [sp, #12]
 8002cde:	2b00      	cmp	r3, #0
 8002ce0:	d119      	bne.n	8002d16 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002ce2:	9b00      	ldr	r3, [sp, #0]
 8002ce4:	2b00      	cmp	r3, #0
 8002ce6:	d103      	bne.n	8002cf0 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 8002ce8:	f7ff fdb2 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002cec:	2300      	movs	r3, #0
 8002cee:	e01c      	b.n	8002d2a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->u.ewmask = events;
 8002cf0:	9b02      	ldr	r3, [sp, #8]
 8002cf2:	9a01      	ldr	r2, [sp, #4]
 8002cf4:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002cf6:	200a      	movs	r0, #10
 8002cf8:	9900      	ldr	r1, [sp, #0]
 8002cfa:	f7fe f8e9 	bl	8000ed0 <chSchGoSleepTimeoutS>
 8002cfe:	4603      	mov	r3, r0
 8002d00:	2b00      	cmp	r3, #0
 8002d02:	da03      	bge.n	8002d0c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8002d04:	f7ff fda4 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002d08:	2300      	movs	r3, #0
 8002d0a:	e00e      	b.n	8002d2a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->epending & events;
 8002d0c:	9b02      	ldr	r3, [sp, #8]
 8002d0e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002d10:	9b01      	ldr	r3, [sp, #4]
 8002d12:	4013      	ands	r3, r2
 8002d14:	9303      	str	r3, [sp, #12]
  }
  ctp->epending &= ~m;
 8002d16:	9b02      	ldr	r3, [sp, #8]
 8002d18:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002d1a:	9b03      	ldr	r3, [sp, #12]
 8002d1c:	43db      	mvns	r3, r3
 8002d1e:	401a      	ands	r2, r3
 8002d20:	9b02      	ldr	r3, [sp, #8]
 8002d22:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002d24:	f7ff fd94 	bl	8002850 <chSysUnlock>

  return m;
 8002d28:	9b03      	ldr	r3, [sp, #12]
}
 8002d2a:	4618      	mov	r0, r3
 8002d2c:	b005      	add	sp, #20
 8002d2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d32:	bf00      	nop
 8002d34:	20000af8 	.word	0x20000af8
 8002d38:	f3af 8000 	nop.w
 8002d3c:	f3af 8000 	nop.w

08002d40 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002d40:	b500      	push	{lr}
 8002d42:	b085      	sub	sp, #20
 8002d44:	9001      	str	r0, [sp, #4]
 8002d46:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002d48:	4b17      	ldr	r3, [pc, #92]	; (8002da8 <chEvtWaitAllTimeout+0x68>)
 8002d4a:	699b      	ldr	r3, [r3, #24]
 8002d4c:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002d4e:	f7ff fd77 	bl	8002840 <chSysLock>
  if ((ctp->epending & events) != events) {
 8002d52:	9b03      	ldr	r3, [sp, #12]
 8002d54:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	401a      	ands	r2, r3
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	429a      	cmp	r2, r3
 8002d5e:	d014      	beq.n	8002d8a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8002d60:	9b00      	ldr	r3, [sp, #0]
 8002d62:	2b00      	cmp	r3, #0
 8002d64:	d103      	bne.n	8002d6e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8002d66:	f7ff fd73 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002d6a:	2300      	movs	r3, #0
 8002d6c:	e017      	b.n	8002d9e <chEvtWaitAllTimeout+0x5e>
    }
    ctp->u.ewmask = events;
 8002d6e:	9b03      	ldr	r3, [sp, #12]
 8002d70:	9a01      	ldr	r2, [sp, #4]
 8002d72:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002d74:	200b      	movs	r0, #11
 8002d76:	9900      	ldr	r1, [sp, #0]
 8002d78:	f7fe f8aa 	bl	8000ed0 <chSchGoSleepTimeoutS>
 8002d7c:	4603      	mov	r3, r0
 8002d7e:	2b00      	cmp	r3, #0
 8002d80:	da03      	bge.n	8002d8a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8002d82:	f7ff fd65 	bl	8002850 <chSysUnlock>
      return (eventmask_t)0;
 8002d86:	2300      	movs	r3, #0
 8002d88:	e009      	b.n	8002d9e <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->epending &= ~events;
 8002d8a:	9b03      	ldr	r3, [sp, #12]
 8002d8c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002d8e:	9b01      	ldr	r3, [sp, #4]
 8002d90:	43db      	mvns	r3, r3
 8002d92:	401a      	ands	r2, r3
 8002d94:	9b03      	ldr	r3, [sp, #12]
 8002d96:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002d98:	f7ff fd5a 	bl	8002850 <chSysUnlock>

  return events;
 8002d9c:	9b01      	ldr	r3, [sp, #4]
}
 8002d9e:	4618      	mov	r0, r3
 8002da0:	b005      	add	sp, #20
 8002da2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002da6:	bf00      	nop
 8002da8:	20000af8 	.word	0x20000af8
 8002dac:	00000000 	.word	0x00000000

08002db0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002db0:	b082      	sub	sp, #8
 8002db2:	2320      	movs	r3, #32
 8002db4:	9301      	str	r3, [sp, #4]
 8002db6:	9b01      	ldr	r3, [sp, #4]
 8002db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002dbc:	b002      	add	sp, #8
 8002dbe:	4770      	bx	lr

08002dc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002dc0:	b082      	sub	sp, #8
 8002dc2:	2300      	movs	r3, #0
 8002dc4:	9301      	str	r3, [sp, #4]
 8002dc6:	9b01      	ldr	r3, [sp, #4]
 8002dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002dcc:	b002      	add	sp, #8
 8002dce:	4770      	bx	lr

08002dd0 <queue_insert>:
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8002dd0:	b082      	sub	sp, #8
 8002dd2:	9001      	str	r0, [sp, #4]
 8002dd4:	9100      	str	r1, [sp, #0]

  tp->queue.next             = (thread_t *)tqp;
 8002dd6:	9b01      	ldr	r3, [sp, #4]
 8002dd8:	9a00      	ldr	r2, [sp, #0]
 8002dda:	601a      	str	r2, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8002ddc:	9b00      	ldr	r3, [sp, #0]
 8002dde:	685a      	ldr	r2, [r3, #4]
 8002de0:	9b01      	ldr	r3, [sp, #4]
 8002de2:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8002de4:	9b01      	ldr	r3, [sp, #4]
 8002de6:	685b      	ldr	r3, [r3, #4]
 8002de8:	9a01      	ldr	r2, [sp, #4]
 8002dea:	601a      	str	r2, [r3, #0]
  tqp->prev                  = tp;
 8002dec:	9b00      	ldr	r3, [sp, #0]
 8002dee:	9a01      	ldr	r2, [sp, #4]
 8002df0:	605a      	str	r2, [r3, #4]
}
 8002df2:	b002      	add	sp, #8
 8002df4:	4770      	bx	lr
 8002df6:	bf00      	nop
 8002df8:	f3af 8000 	nop.w
 8002dfc:	f3af 8000 	nop.w

08002e00 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002e00:	b084      	sub	sp, #16
 8002e02:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->next;
 8002e04:	9b01      	ldr	r3, [sp, #4]
 8002e06:	681b      	ldr	r3, [r3, #0]
 8002e08:	9303      	str	r3, [sp, #12]

  tqp->next             = tp->queue.next;
 8002e0a:	9b03      	ldr	r3, [sp, #12]
 8002e0c:	681a      	ldr	r2, [r3, #0]
 8002e0e:	9b01      	ldr	r3, [sp, #4]
 8002e10:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002e12:	9b01      	ldr	r3, [sp, #4]
 8002e14:	681b      	ldr	r3, [r3, #0]
 8002e16:	9a01      	ldr	r2, [sp, #4]
 8002e18:	605a      	str	r2, [r3, #4]

  return tp;
 8002e1a:	9b03      	ldr	r3, [sp, #12]
}
 8002e1c:	4618      	mov	r0, r3
 8002e1e:	b004      	add	sp, #16
 8002e20:	4770      	bx	lr
 8002e22:	bf00      	nop
 8002e24:	f3af 8000 	nop.w
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002e30:	b508      	push	{r3, lr}

  port_lock();
 8002e32:	f7ff ffbd 	bl	8002db0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002e36:	bd08      	pop	{r3, pc}
 8002e38:	f3af 8000 	nop.w
 8002e3c:	f3af 8000 	nop.w

08002e40 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002e40:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8002e42:	f7ff ffbd 	bl	8002dc0 <port_unlock>
}
 8002e46:	bd08      	pop	{r3, pc}
 8002e48:	f3af 8000 	nop.w
 8002e4c:	f3af 8000 	nop.w

08002e50 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8002e50:	b082      	sub	sp, #8
 8002e52:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8002e54:	9b01      	ldr	r3, [sp, #4]
 8002e56:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	332c      	adds	r3, #44	; 0x2c
 8002e5c:	429a      	cmp	r2, r3
 8002e5e:	bf14      	ite	ne
 8002e60:	2301      	movne	r3, #1
 8002e62:	2300      	moveq	r3, #0
 8002e64:	b2db      	uxtb	r3, r3
}
 8002e66:	4618      	mov	r0, r3
 8002e68:	b002      	add	sp, #8
 8002e6a:	4770      	bx	lr
 8002e6c:	f3af 8000 	nop.w

08002e70 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8002e70:	b500      	push	{lr}
 8002e72:	b083      	sub	sp, #12
 8002e74:	9001      	str	r0, [sp, #4]
 8002e76:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002e78:	9801      	ldr	r0, [sp, #4]
 8002e7a:	9900      	ldr	r1, [sp, #0]
 8002e7c:	f7fe f860 	bl	8000f40 <chSchWakeupS>
}
 8002e80:	b003      	add	sp, #12
 8002e82:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e86:	bf00      	nop
 8002e88:	f3af 8000 	nop.w
 8002e8c:	f3af 8000 	nop.w

08002e90 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002e90:	b500      	push	{lr}
 8002e92:	b085      	sub	sp, #20
 8002e94:	9001      	str	r0, [sp, #4]
 8002e96:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002e98:	4b11      	ldr	r3, [pc, #68]	; (8002ee0 <chMsgSend+0x50>)
 8002e9a:	699b      	ldr	r3, [r3, #24]
 8002e9c:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002e9e:	f7ff ffc7 	bl	8002e30 <chSysLock>
  ctp->u.sentmsg = msg;
 8002ea2:	9b03      	ldr	r3, [sp, #12]
 8002ea4:	9a00      	ldr	r2, [sp, #0]
 8002ea6:	625a      	str	r2, [r3, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
 8002ea8:	9b01      	ldr	r3, [sp, #4]
 8002eaa:	332c      	adds	r3, #44	; 0x2c
 8002eac:	9803      	ldr	r0, [sp, #12]
 8002eae:	4619      	mov	r1, r3
 8002eb0:	f7ff ff8e 	bl	8002dd0 <queue_insert>
  if (tp->state == CH_STATE_WTMSG) {
 8002eb4:	9b01      	ldr	r3, [sp, #4]
 8002eb6:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002eba:	2b0e      	cmp	r3, #14
 8002ebc:	d102      	bne.n	8002ec4 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
 8002ebe:	9801      	ldr	r0, [sp, #4]
 8002ec0:	f7fd ff4e 	bl	8000d60 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002ec4:	200c      	movs	r0, #12
 8002ec6:	f7fd ff9b 	bl	8000e00 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002ece:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8002ed0:	f7ff ffb6 	bl	8002e40 <chSysUnlock>

  return msg;
 8002ed4:	9b00      	ldr	r3, [sp, #0]
}
 8002ed6:	4618      	mov	r0, r3
 8002ed8:	b005      	add	sp, #20
 8002eda:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ede:	bf00      	nop
 8002ee0:	20000af8 	.word	0x20000af8
 8002ee4:	f3af 8000 	nop.w
 8002ee8:	f3af 8000 	nop.w
 8002eec:	f3af 8000 	nop.w

08002ef0 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002ef0:	b500      	push	{lr}
 8002ef2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002ef4:	f7ff ff9c 	bl	8002e30 <chSysLock>
  if (!chMsgIsPendingI(currp)) {
 8002ef8:	4b0f      	ldr	r3, [pc, #60]	; (8002f38 <chMsgWait+0x48>)
 8002efa:	699b      	ldr	r3, [r3, #24]
 8002efc:	4618      	mov	r0, r3
 8002efe:	f7ff ffa7 	bl	8002e50 <chMsgIsPendingI>
 8002f02:	4603      	mov	r3, r0
 8002f04:	f083 0301 	eor.w	r3, r3, #1
 8002f08:	b2db      	uxtb	r3, r3
 8002f0a:	2b00      	cmp	r3, #0
 8002f0c:	d002      	beq.n	8002f14 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 8002f0e:	200e      	movs	r0, #14
 8002f10:	f7fd ff76 	bl	8000e00 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->msgqueue);
 8002f14:	4b08      	ldr	r3, [pc, #32]	; (8002f38 <chMsgWait+0x48>)
 8002f16:	699b      	ldr	r3, [r3, #24]
 8002f18:	332c      	adds	r3, #44	; 0x2c
 8002f1a:	4618      	mov	r0, r3
 8002f1c:	f7ff ff70 	bl	8002e00 <queue_fifo_remove>
 8002f20:	9001      	str	r0, [sp, #4]
  tp->state = CH_STATE_SNDMSG;
 8002f22:	9b01      	ldr	r3, [sp, #4]
 8002f24:	220d      	movs	r2, #13
 8002f26:	f883 2020 	strb.w	r2, [r3, #32]
  chSysUnlock();
 8002f2a:	f7ff ff89 	bl	8002e40 <chSysUnlock>

  return tp;
 8002f2e:	9b01      	ldr	r3, [sp, #4]
}
 8002f30:	4618      	mov	r0, r3
 8002f32:	b003      	add	sp, #12
 8002f34:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f38:	20000af8 	.word	0x20000af8
 8002f3c:	f3af 8000 	nop.w

08002f40 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002f40:	b500      	push	{lr}
 8002f42:	b083      	sub	sp, #12
 8002f44:	9001      	str	r0, [sp, #4]
 8002f46:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002f48:	f7ff ff72 	bl	8002e30 <chSysLock>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
 8002f4c:	9801      	ldr	r0, [sp, #4]
 8002f4e:	9900      	ldr	r1, [sp, #0]
 8002f50:	f7ff ff8e 	bl	8002e70 <chMsgReleaseS>
  chSysUnlock();
 8002f54:	f7ff ff74 	bl	8002e40 <chSysUnlock>
}
 8002f58:	b003      	add	sp, #12
 8002f5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f5e:	bf00      	nop

08002f60 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002f60:	b082      	sub	sp, #8
 8002f62:	2320      	movs	r3, #32
 8002f64:	9301      	str	r3, [sp, #4]
 8002f66:	9b01      	ldr	r3, [sp, #4]
 8002f68:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002f6c:	b002      	add	sp, #8
 8002f6e:	4770      	bx	lr

08002f70 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002f70:	b082      	sub	sp, #8
 8002f72:	2300      	movs	r3, #0
 8002f74:	9301      	str	r3, [sp, #4]
 8002f76:	9b01      	ldr	r3, [sp, #4]
 8002f78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002f7c:	b002      	add	sp, #8
 8002f7e:	4770      	bx	lr

08002f80 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002f80:	b508      	push	{r3, lr}

  port_lock();
 8002f82:	f7ff ffed 	bl	8002f60 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002f86:	bd08      	pop	{r3, pc}
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w

08002f90 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002f90:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8002f92:	f7ff ffed 	bl	8002f70 <port_unlock>
}
 8002f96:	bd08      	pop	{r3, pc}
 8002f98:	f3af 8000 	nop.w
 8002f9c:	f3af 8000 	nop.w

08002fa0 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
 8002fa0:	b500      	push	{lr}
 8002fa2:	b08d      	sub	sp, #52	; 0x34
 8002fa4:	9003      	str	r0, [sp, #12]
 8002fa6:	9102      	str	r1, [sp, #8]
 8002fa8:	9201      	str	r2, [sp, #4]
 8002faa:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002fac:	9803      	ldr	r0, [sp, #12]
 8002fae:	9902      	ldr	r1, [sp, #8]
 8002fb0:	2208      	movs	r2, #8
 8002fb2:	f000 fbcd 	bl	8003750 <chHeapAllocAligned>
 8002fb6:	900b      	str	r0, [sp, #44]	; 0x2c
  if (wsp == NULL) {
 8002fb8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002fba:	2b00      	cmp	r3, #0
 8002fbc:	d101      	bne.n	8002fc2 <chThdCreateFromHeap+0x22>
    return NULL;
 8002fbe:	2300      	movs	r3, #0
 8002fc0:	e01f      	b.n	8003002 <chThdCreateFromHeap+0x62>
  }

  thread_descriptor_t td = {
 8002fc2:	9b01      	ldr	r3, [sp, #4]
 8002fc4:	9304      	str	r3, [sp, #16]
 8002fc6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002fc8:	9305      	str	r3, [sp, #20]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 8002fca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8002fcc:	9b02      	ldr	r3, [sp, #8]
 8002fce:	4413      	add	r3, r2
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8002fd0:	9306      	str	r3, [sp, #24]
 8002fd2:	9b00      	ldr	r3, [sp, #0]
 8002fd4:	9307      	str	r3, [sp, #28]
 8002fd6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8002fd8:	9308      	str	r3, [sp, #32]
 8002fda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8002fdc:	9309      	str	r3, [sp, #36]	; 0x24
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8002fde:	f7ff ffcf 	bl	8002f80 <chSysLock>
  tp = chThdCreateSuspendedI(&td);
 8002fe2:	ab04      	add	r3, sp, #16
 8002fe4:	4618      	mov	r0, r3
 8002fe6:	f7fe f9cb 	bl	8001380 <chThdCreateSuspendedI>
 8002fea:	900a      	str	r0, [sp, #40]	; 0x28
  tp->flags = CH_FLAG_MODE_HEAP;
 8002fec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002fee:	2201      	movs	r2, #1
 8002ff0:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8002ff4:	980a      	ldr	r0, [sp, #40]	; 0x28
 8002ff6:	2100      	movs	r1, #0
 8002ff8:	f7fd ffa2 	bl	8000f40 <chSchWakeupS>
  chSysUnlock();
 8002ffc:	f7ff ffc8 	bl	8002f90 <chSysUnlock>

  return tp;
 8003000:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 8003002:	4618      	mov	r0, r3
 8003004:	b00d      	add	sp, #52	; 0x34
 8003006:	f85d fb04 	ldr.w	pc, [sp], #4
 800300a:	bf00      	nop
 800300c:	f3af 8000 	nop.w

08003010 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
                                    tprio_t prio, tfunc_t pf, void *arg) {
 8003010:	b500      	push	{lr}
 8003012:	b08d      	sub	sp, #52	; 0x34
 8003014:	9003      	str	r0, [sp, #12]
 8003016:	9102      	str	r1, [sp, #8]
 8003018:	9201      	str	r2, [sp, #4]
 800301a:	9300      	str	r3, [sp, #0]
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 800301c:	9803      	ldr	r0, [sp, #12]
 800301e:	f000 fdb7 	bl	8003b90 <chPoolAlloc>
 8003022:	900b      	str	r0, [sp, #44]	; 0x2c
  if (wsp == NULL) {
 8003024:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003026:	2b00      	cmp	r3, #0
 8003028:	d101      	bne.n	800302e <chThdCreateFromMemoryPool+0x1e>
    return NULL;
 800302a:	2300      	movs	r3, #0
 800302c:	e023      	b.n	8003076 <chThdCreateFromMemoryPool+0x66>
  }

  thread_descriptor_t td = {
 800302e:	9b02      	ldr	r3, [sp, #8]
 8003030:	9304      	str	r3, [sp, #16]
 8003032:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003034:	9305      	str	r3, [sp, #20]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8003036:	9b03      	ldr	r3, [sp, #12]
 8003038:	685b      	ldr	r3, [r3, #4]
 800303a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800303c:	4413      	add	r3, r2
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 800303e:	9306      	str	r3, [sp, #24]
 8003040:	9b01      	ldr	r3, [sp, #4]
 8003042:	9307      	str	r3, [sp, #28]
 8003044:	9b00      	ldr	r3, [sp, #0]
 8003046:	9308      	str	r3, [sp, #32]
 8003048:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800304a:	9309      	str	r3, [sp, #36]	; 0x24
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800304c:	f7ff ff98 	bl	8002f80 <chSysLock>
  tp = chThdCreateSuspendedI(&td);
 8003050:	ab04      	add	r3, sp, #16
 8003052:	4618      	mov	r0, r3
 8003054:	f7fe f994 	bl	8001380 <chThdCreateSuspendedI>
 8003058:	900a      	str	r0, [sp, #40]	; 0x28
  tp->flags = CH_FLAG_MODE_MPOOL;
 800305a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800305c:	2202      	movs	r2, #2
 800305e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  tp->mpool = mp;
 8003062:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003064:	9a03      	ldr	r2, [sp, #12]
 8003066:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8003068:	980a      	ldr	r0, [sp, #40]	; 0x28
 800306a:	2100      	movs	r1, #0
 800306c:	f7fd ff68 	bl	8000f40 <chSchWakeupS>
  chSysUnlock();
 8003070:	f7ff ff8e 	bl	8002f90 <chSysUnlock>

  return tp;
 8003074:	9b0a      	ldr	r3, [sp, #40]	; 0x28
}
 8003076:	4618      	mov	r0, r3
 8003078:	b00d      	add	sp, #52	; 0x34
 800307a:	f85d fb04 	ldr.w	pc, [sp], #4
 800307e:	bf00      	nop

08003080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003080:	b082      	sub	sp, #8
 8003082:	2320      	movs	r3, #32
 8003084:	9301      	str	r3, [sp, #4]
 8003086:	9b01      	ldr	r3, [sp, #4]
 8003088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800308c:	b002      	add	sp, #8
 800308e:	4770      	bx	lr

08003090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003090:	b082      	sub	sp, #8
 8003092:	2300      	movs	r3, #0
 8003094:	9301      	str	r3, [sp, #4]
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800309c:	b002      	add	sp, #8
 800309e:	4770      	bx	lr

080030a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80030a0:	b082      	sub	sp, #8
 80030a2:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	9a01      	ldr	r2, [sp, #4]
 80030ae:	605a      	str	r2, [r3, #4]
}
 80030b0:	b002      	add	sp, #8
 80030b2:	4770      	bx	lr
 80030b4:	f3af 8000 	nop.w
 80030b8:	f3af 8000 	nop.w
 80030bc:	f3af 8000 	nop.w

080030c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80030c0:	b508      	push	{r3, lr}

  port_lock();
 80030c2:	f7ff ffdd 	bl	8003080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80030d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80030d2:	f7ff ffdd 	bl	8003090 <port_unlock>
}
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80030e6:	9801      	ldr	r0, [sp, #4]
 80030e8:	f7ff ffda 	bl	80030a0 <queue_init>
}
 80030ec:	b003      	add	sp, #12
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	685b      	ldr	r3, [r3, #4]
 8003108:	461a      	mov	r2, r3
 800310a:	9b01      	ldr	r3, [sp, #4]
 800310c:	681b      	ldr	r3, [r3, #0]
 800310e:	1ad3      	subs	r3, r2, r3
 8003110:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 8003112:	4618      	mov	r0, r3
 8003114:	b002      	add	sp, #8
 8003116:	4770      	bx	lr
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <chMBGetUsedCountI>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 8003120:	b082      	sub	sp, #8
 8003122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return mbp->cnt;
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	691b      	ldr	r3, [r3, #16]
}
 8003128:	4618      	mov	r0, r3
 800312a:	b002      	add	sp, #8
 800312c:	4770      	bx	lr
 800312e:	bf00      	nop

08003130 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8003130:	b510      	push	{r4, lr}
 8003132:	b082      	sub	sp, #8
 8003134:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8003136:	9801      	ldr	r0, [sp, #4]
 8003138:	f7ff ffe2 	bl	8003100 <chMBGetSizeI>
 800313c:	4604      	mov	r4, r0
 800313e:	9801      	ldr	r0, [sp, #4]
 8003140:	f7ff ffee 	bl	8003120 <chMBGetUsedCountI>
 8003144:	4603      	mov	r3, r0
 8003146:	1ae3      	subs	r3, r4, r3
}
 8003148:	4618      	mov	r0, r3
 800314a:	b002      	add	sp, #8
 800314c:	bd10      	pop	{r4, pc}
 800314e:	bf00      	nop

08003150 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8003150:	b500      	push	{lr}
 8003152:	b085      	sub	sp, #20
 8003154:	9003      	str	r0, [sp, #12]
 8003156:	9102      	str	r1, [sp, #8]
 8003158:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 800315a:	9b03      	ldr	r3, [sp, #12]
 800315c:	9a02      	ldr	r2, [sp, #8]
 800315e:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 8003160:	9b03      	ldr	r3, [sp, #12]
 8003162:	9a02      	ldr	r2, [sp, #8]
 8003164:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 8003166:	9b03      	ldr	r3, [sp, #12]
 8003168:	9a02      	ldr	r2, [sp, #8]
 800316a:	609a      	str	r2, [r3, #8]
  mbp->top    = &buf[n];
 800316c:	9b01      	ldr	r3, [sp, #4]
 800316e:	009b      	lsls	r3, r3, #2
 8003170:	9a02      	ldr	r2, [sp, #8]
 8003172:	441a      	add	r2, r3
 8003174:	9b03      	ldr	r3, [sp, #12]
 8003176:	605a      	str	r2, [r3, #4]
  mbp->cnt    = (cnt_t)0;
 8003178:	9b03      	ldr	r3, [sp, #12]
 800317a:	2200      	movs	r2, #0
 800317c:	611a      	str	r2, [r3, #16]
  mbp->reset  = false;
 800317e:	9b03      	ldr	r3, [sp, #12]
 8003180:	2200      	movs	r2, #0
 8003182:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->qw);
 8003184:	9b03      	ldr	r3, [sp, #12]
 8003186:	3318      	adds	r3, #24
 8003188:	4618      	mov	r0, r3
 800318a:	f7ff ffa9 	bl	80030e0 <chThdQueueObjectInit>
  chThdQueueObjectInit(&mbp->qr);
 800318e:	9b03      	ldr	r3, [sp, #12]
 8003190:	3320      	adds	r3, #32
 8003192:	4618      	mov	r0, r3
 8003194:	f7ff ffa4 	bl	80030e0 <chThdQueueObjectInit>
}
 8003198:	b005      	add	sp, #20
 800319a:	f85d fb04 	ldr.w	pc, [sp], #4
 800319e:	bf00      	nop

080031a0 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 80031a0:	b500      	push	{lr}
 80031a2:	b083      	sub	sp, #12
 80031a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80031a6:	f7ff ff8b 	bl	80030c0 <chSysLock>
  chMBResetI(mbp);
 80031aa:	9801      	ldr	r0, [sp, #4]
 80031ac:	f000 f808 	bl	80031c0 <chMBResetI>
  chSchRescheduleS();
 80031b0:	f7fd feee 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 80031b4:	f7ff ff8c 	bl	80030d0 <chSysUnlock>
}
 80031b8:	b003      	add	sp, #12
 80031ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80031be:	bf00      	nop

080031c0 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 80031c0:	b500      	push	{lr}
 80031c2:	b083      	sub	sp, #12
 80031c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 80031c6:	9b01      	ldr	r3, [sp, #4]
 80031c8:	681a      	ldr	r2, [r3, #0]
 80031ca:	9b01      	ldr	r3, [sp, #4]
 80031cc:	609a      	str	r2, [r3, #8]
  mbp->rdptr = mbp->buffer;
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	681a      	ldr	r2, [r3, #0]
 80031d2:	9b01      	ldr	r3, [sp, #4]
 80031d4:	60da      	str	r2, [r3, #12]
  mbp->cnt   = (cnt_t)0;
 80031d6:	9b01      	ldr	r3, [sp, #4]
 80031d8:	2200      	movs	r2, #0
 80031da:	611a      	str	r2, [r3, #16]
  mbp->reset = true;
 80031dc:	9b01      	ldr	r3, [sp, #4]
 80031de:	2201      	movs	r2, #1
 80031e0:	751a      	strb	r2, [r3, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 80031e2:	9b01      	ldr	r3, [sp, #4]
 80031e4:	3318      	adds	r3, #24
 80031e6:	4618      	mov	r0, r3
 80031e8:	f06f 0101 	mvn.w	r1, #1
 80031ec:	f7fe fb98 	bl	8001920 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 80031f0:	9b01      	ldr	r3, [sp, #4]
 80031f2:	3320      	adds	r3, #32
 80031f4:	4618      	mov	r0, r3
 80031f6:	f06f 0101 	mvn.w	r1, #1
 80031fa:	f7fe fb91 	bl	8001920 <chThdDequeueAllI>
}
 80031fe:	b003      	add	sp, #12
 8003200:	f85d fb04 	ldr.w	pc, [sp], #4
 8003204:	f3af 8000 	nop.w
 8003208:	f3af 8000 	nop.w
 800320c:	f3af 8000 	nop.w

08003210 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8003210:	b500      	push	{lr}
 8003212:	b087      	sub	sp, #28
 8003214:	9003      	str	r0, [sp, #12]
 8003216:	9102      	str	r1, [sp, #8]
 8003218:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800321a:	f7ff ff51 	bl	80030c0 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
 800321e:	9803      	ldr	r0, [sp, #12]
 8003220:	9902      	ldr	r1, [sp, #8]
 8003222:	9a01      	ldr	r2, [sp, #4]
 8003224:	f000 f80c 	bl	8003240 <chMBPostS>
 8003228:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800322a:	f7ff ff51 	bl	80030d0 <chSysUnlock>

  return rdymsg;
 800322e:	9b05      	ldr	r3, [sp, #20]
}
 8003230:	4618      	mov	r0, r3
 8003232:	b007      	add	sp, #28
 8003234:	f85d fb04 	ldr.w	pc, [sp], #4
 8003238:	f3af 8000 	nop.w
 800323c:	f3af 8000 	nop.w

08003240 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8003240:	b500      	push	{lr}
 8003242:	b087      	sub	sp, #28
 8003244:	9003      	str	r0, [sp, #12]
 8003246:	9102      	str	r1, [sp, #8]
 8003248:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 800324a:	9b03      	ldr	r3, [sp, #12]
 800324c:	7d1b      	ldrb	r3, [r3, #20]
 800324e:	2b00      	cmp	r3, #0
 8003250:	d002      	beq.n	8003258 <chMBPostS+0x18>
      return MSG_RESET;
 8003252:	f06f 0301 	mvn.w	r3, #1
 8003256:	e030      	b.n	80032ba <chMBPostS+0x7a>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8003258:	9803      	ldr	r0, [sp, #12]
 800325a:	f7ff ff69 	bl	8003130 <chMBGetFreeCountI>
 800325e:	4603      	mov	r3, r0
 8003260:	2b00      	cmp	r3, #0
 8003262:	dd1f      	ble.n	80032a4 <chMBPostS+0x64>
      *mbp->wrptr++ = msg;
 8003264:	9b03      	ldr	r3, [sp, #12]
 8003266:	689b      	ldr	r3, [r3, #8]
 8003268:	1d19      	adds	r1, r3, #4
 800326a:	9a03      	ldr	r2, [sp, #12]
 800326c:	6091      	str	r1, [r2, #8]
 800326e:	9a02      	ldr	r2, [sp, #8]
 8003270:	601a      	str	r2, [r3, #0]
      if (mbp->wrptr >= mbp->top) {
 8003272:	9b03      	ldr	r3, [sp, #12]
 8003274:	689a      	ldr	r2, [r3, #8]
 8003276:	9b03      	ldr	r3, [sp, #12]
 8003278:	685b      	ldr	r3, [r3, #4]
 800327a:	429a      	cmp	r2, r3
 800327c:	d303      	bcc.n	8003286 <chMBPostS+0x46>
        mbp->wrptr = mbp->buffer;
 800327e:	9b03      	ldr	r3, [sp, #12]
 8003280:	681a      	ldr	r2, [r3, #0]
 8003282:	9b03      	ldr	r3, [sp, #12]
 8003284:	609a      	str	r2, [r3, #8]
      }
      mbp->cnt++;
 8003286:	9b03      	ldr	r3, [sp, #12]
 8003288:	691b      	ldr	r3, [r3, #16]
 800328a:	1c5a      	adds	r2, r3, #1
 800328c:	9b03      	ldr	r3, [sp, #12]
 800328e:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003290:	9b03      	ldr	r3, [sp, #12]
 8003292:	3320      	adds	r3, #32
 8003294:	4618      	mov	r0, r3
 8003296:	2100      	movs	r1, #0
 8003298:	f7fe fb2a 	bl	80018f0 <chThdDequeueNextI>
      chSchRescheduleS();
 800329c:	f7fd fe78 	bl	8000f90 <chSchRescheduleS>

      return MSG_OK;
 80032a0:	2300      	movs	r3, #0
 80032a2:	e00a      	b.n	80032ba <chMBPostS+0x7a>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80032a4:	9b03      	ldr	r3, [sp, #12]
 80032a6:	3318      	adds	r3, #24
 80032a8:	4618      	mov	r0, r3
 80032aa:	9901      	ldr	r1, [sp, #4]
 80032ac:	f7fe fb00 	bl	80018b0 <chThdEnqueueTimeoutS>
 80032b0:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 80032b2:	9b05      	ldr	r3, [sp, #20]
 80032b4:	2b00      	cmp	r3, #0
 80032b6:	d0c8      	beq.n	800324a <chMBPostS+0xa>

  return rdymsg;
 80032b8:	9b05      	ldr	r3, [sp, #20]
}
 80032ba:	4618      	mov	r0, r3
 80032bc:	b007      	add	sp, #28
 80032be:	f85d fb04 	ldr.w	pc, [sp], #4
 80032c2:	bf00      	nop
 80032c4:	f3af 8000 	nop.w
 80032c8:	f3af 8000 	nop.w
 80032cc:	f3af 8000 	nop.w

080032d0 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 80032d0:	b500      	push	{lr}
 80032d2:	b083      	sub	sp, #12
 80032d4:	9001      	str	r0, [sp, #4]
 80032d6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 80032d8:	9b01      	ldr	r3, [sp, #4]
 80032da:	7d1b      	ldrb	r3, [r3, #20]
 80032dc:	2b00      	cmp	r3, #0
 80032de:	d002      	beq.n	80032e6 <chMBPostI+0x16>
    return MSG_RESET;
 80032e0:	f06f 0301 	mvn.w	r3, #1
 80032e4:	e025      	b.n	8003332 <chMBPostI+0x62>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 80032e6:	9801      	ldr	r0, [sp, #4]
 80032e8:	f7ff ff22 	bl	8003130 <chMBGetFreeCountI>
 80032ec:	4603      	mov	r3, r0
 80032ee:	2b00      	cmp	r3, #0
 80032f0:	dd1d      	ble.n	800332e <chMBPostI+0x5e>
    *mbp->wrptr++ = msg;
 80032f2:	9b01      	ldr	r3, [sp, #4]
 80032f4:	689b      	ldr	r3, [r3, #8]
 80032f6:	1d19      	adds	r1, r3, #4
 80032f8:	9a01      	ldr	r2, [sp, #4]
 80032fa:	6091      	str	r1, [r2, #8]
 80032fc:	9a00      	ldr	r2, [sp, #0]
 80032fe:	601a      	str	r2, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 8003300:	9b01      	ldr	r3, [sp, #4]
 8003302:	689a      	ldr	r2, [r3, #8]
 8003304:	9b01      	ldr	r3, [sp, #4]
 8003306:	685b      	ldr	r3, [r3, #4]
 8003308:	429a      	cmp	r2, r3
 800330a:	d303      	bcc.n	8003314 <chMBPostI+0x44>
      mbp->wrptr = mbp->buffer;
 800330c:	9b01      	ldr	r3, [sp, #4]
 800330e:	681a      	ldr	r2, [r3, #0]
 8003310:	9b01      	ldr	r3, [sp, #4]
 8003312:	609a      	str	r2, [r3, #8]
    }
    mbp->cnt++;
 8003314:	9b01      	ldr	r3, [sp, #4]
 8003316:	691b      	ldr	r3, [r3, #16]
 8003318:	1c5a      	adds	r2, r3, #1
 800331a:	9b01      	ldr	r3, [sp, #4]
 800331c:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800331e:	9b01      	ldr	r3, [sp, #4]
 8003320:	3320      	adds	r3, #32
 8003322:	4618      	mov	r0, r3
 8003324:	2100      	movs	r1, #0
 8003326:	f7fe fae3 	bl	80018f0 <chThdDequeueNextI>

    return MSG_OK;
 800332a:	2300      	movs	r3, #0
 800332c:	e001      	b.n	8003332 <chMBPostI+0x62>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 800332e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8003332:	4618      	mov	r0, r3
 8003334:	b003      	add	sp, #12
 8003336:	f85d fb04 	ldr.w	pc, [sp], #4
 800333a:	bf00      	nop
 800333c:	f3af 8000 	nop.w

08003340 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8003340:	b500      	push	{lr}
 8003342:	b087      	sub	sp, #28
 8003344:	9003      	str	r0, [sp, #12]
 8003346:	9102      	str	r1, [sp, #8]
 8003348:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800334a:	f7ff feb9 	bl	80030c0 <chSysLock>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 800334e:	9803      	ldr	r0, [sp, #12]
 8003350:	9902      	ldr	r1, [sp, #8]
 8003352:	9a01      	ldr	r2, [sp, #4]
 8003354:	f000 f80c 	bl	8003370 <chMBPostAheadS>
 8003358:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800335a:	f7ff feb9 	bl	80030d0 <chSysUnlock>

  return rdymsg;
 800335e:	9b05      	ldr	r3, [sp, #20]
}
 8003360:	4618      	mov	r0, r3
 8003362:	b007      	add	sp, #28
 8003364:	f85d fb04 	ldr.w	pc, [sp], #4
 8003368:	f3af 8000 	nop.w
 800336c:	f3af 8000 	nop.w

08003370 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8003370:	b500      	push	{lr}
 8003372:	b087      	sub	sp, #28
 8003374:	9003      	str	r0, [sp, #12]
 8003376:	9102      	str	r1, [sp, #8]
 8003378:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 800337a:	9b03      	ldr	r3, [sp, #12]
 800337c:	7d1b      	ldrb	r3, [r3, #20]
 800337e:	2b00      	cmp	r3, #0
 8003380:	d002      	beq.n	8003388 <chMBPostAheadS+0x18>
      return MSG_RESET;
 8003382:	f06f 0301 	mvn.w	r3, #1
 8003386:	e033      	b.n	80033f0 <chMBPostAheadS+0x80>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8003388:	9803      	ldr	r0, [sp, #12]
 800338a:	f7ff fed1 	bl	8003130 <chMBGetFreeCountI>
 800338e:	4603      	mov	r3, r0
 8003390:	2b00      	cmp	r3, #0
 8003392:	dd22      	ble.n	80033da <chMBPostAheadS+0x6a>
      if (--mbp->rdptr < mbp->buffer) {
 8003394:	9b03      	ldr	r3, [sp, #12]
 8003396:	68db      	ldr	r3, [r3, #12]
 8003398:	1f1a      	subs	r2, r3, #4
 800339a:	9b03      	ldr	r3, [sp, #12]
 800339c:	60da      	str	r2, [r3, #12]
 800339e:	9b03      	ldr	r3, [sp, #12]
 80033a0:	68da      	ldr	r2, [r3, #12]
 80033a2:	9b03      	ldr	r3, [sp, #12]
 80033a4:	681b      	ldr	r3, [r3, #0]
 80033a6:	429a      	cmp	r2, r3
 80033a8:	d204      	bcs.n	80033b4 <chMBPostAheadS+0x44>
        mbp->rdptr = mbp->top - 1;
 80033aa:	9b03      	ldr	r3, [sp, #12]
 80033ac:	685b      	ldr	r3, [r3, #4]
 80033ae:	1f1a      	subs	r2, r3, #4
 80033b0:	9b03      	ldr	r3, [sp, #12]
 80033b2:	60da      	str	r2, [r3, #12]
      }
      *mbp->rdptr = msg;
 80033b4:	9b03      	ldr	r3, [sp, #12]
 80033b6:	68db      	ldr	r3, [r3, #12]
 80033b8:	9a02      	ldr	r2, [sp, #8]
 80033ba:	601a      	str	r2, [r3, #0]
      mbp->cnt++;
 80033bc:	9b03      	ldr	r3, [sp, #12]
 80033be:	691b      	ldr	r3, [r3, #16]
 80033c0:	1c5a      	adds	r2, r3, #1
 80033c2:	9b03      	ldr	r3, [sp, #12]
 80033c4:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80033c6:	9b03      	ldr	r3, [sp, #12]
 80033c8:	3320      	adds	r3, #32
 80033ca:	4618      	mov	r0, r3
 80033cc:	2100      	movs	r1, #0
 80033ce:	f7fe fa8f 	bl	80018f0 <chThdDequeueNextI>
      chSchRescheduleS();
 80033d2:	f7fd fddd 	bl	8000f90 <chSchRescheduleS>

      return MSG_OK;
 80033d6:	2300      	movs	r3, #0
 80033d8:	e00a      	b.n	80033f0 <chMBPostAheadS+0x80>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80033da:	9b03      	ldr	r3, [sp, #12]
 80033dc:	3318      	adds	r3, #24
 80033de:	4618      	mov	r0, r3
 80033e0:	9901      	ldr	r1, [sp, #4]
 80033e2:	f7fe fa65 	bl	80018b0 <chThdEnqueueTimeoutS>
 80033e6:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 80033e8:	9b05      	ldr	r3, [sp, #20]
 80033ea:	2b00      	cmp	r3, #0
 80033ec:	d0c5      	beq.n	800337a <chMBPostAheadS+0xa>

  return rdymsg;
 80033ee:	9b05      	ldr	r3, [sp, #20]
}
 80033f0:	4618      	mov	r0, r3
 80033f2:	b007      	add	sp, #28
 80033f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80033f8:	f3af 8000 	nop.w
 80033fc:	f3af 8000 	nop.w

08003400 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8003400:	b500      	push	{lr}
 8003402:	b083      	sub	sp, #12
 8003404:	9001      	str	r0, [sp, #4]
 8003406:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8003408:	9b01      	ldr	r3, [sp, #4]
 800340a:	7d1b      	ldrb	r3, [r3, #20]
 800340c:	2b00      	cmp	r3, #0
 800340e:	d002      	beq.n	8003416 <chMBPostAheadI+0x16>
    return MSG_RESET;
 8003410:	f06f 0301 	mvn.w	r3, #1
 8003414:	e028      	b.n	8003468 <chMBPostAheadI+0x68>
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8003416:	9801      	ldr	r0, [sp, #4]
 8003418:	f7ff fe8a 	bl	8003130 <chMBGetFreeCountI>
 800341c:	4603      	mov	r3, r0
 800341e:	2b00      	cmp	r3, #0
 8003420:	dd20      	ble.n	8003464 <chMBPostAheadI+0x64>
    if (--mbp->rdptr < mbp->buffer) {
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	68db      	ldr	r3, [r3, #12]
 8003426:	1f1a      	subs	r2, r3, #4
 8003428:	9b01      	ldr	r3, [sp, #4]
 800342a:	60da      	str	r2, [r3, #12]
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	68da      	ldr	r2, [r3, #12]
 8003430:	9b01      	ldr	r3, [sp, #4]
 8003432:	681b      	ldr	r3, [r3, #0]
 8003434:	429a      	cmp	r2, r3
 8003436:	d204      	bcs.n	8003442 <chMBPostAheadI+0x42>
      mbp->rdptr = mbp->top - 1;
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	685b      	ldr	r3, [r3, #4]
 800343c:	1f1a      	subs	r2, r3, #4
 800343e:	9b01      	ldr	r3, [sp, #4]
 8003440:	60da      	str	r2, [r3, #12]
    }
    *mbp->rdptr = msg;
 8003442:	9b01      	ldr	r3, [sp, #4]
 8003444:	68db      	ldr	r3, [r3, #12]
 8003446:	9a00      	ldr	r2, [sp, #0]
 8003448:	601a      	str	r2, [r3, #0]
    mbp->cnt++;
 800344a:	9b01      	ldr	r3, [sp, #4]
 800344c:	691b      	ldr	r3, [r3, #16]
 800344e:	1c5a      	adds	r2, r3, #1
 8003450:	9b01      	ldr	r3, [sp, #4]
 8003452:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8003454:	9b01      	ldr	r3, [sp, #4]
 8003456:	3320      	adds	r3, #32
 8003458:	4618      	mov	r0, r3
 800345a:	2100      	movs	r1, #0
 800345c:	f7fe fa48 	bl	80018f0 <chThdDequeueNextI>

    return MSG_OK;
 8003460:	2300      	movs	r3, #0
 8003462:	e001      	b.n	8003468 <chMBPostAheadI+0x68>
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8003464:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8003468:	4618      	mov	r0, r3
 800346a:	b003      	add	sp, #12
 800346c:	f85d fb04 	ldr.w	pc, [sp], #4

08003470 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8003470:	b500      	push	{lr}
 8003472:	b087      	sub	sp, #28
 8003474:	9003      	str	r0, [sp, #12]
 8003476:	9102      	str	r1, [sp, #8]
 8003478:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800347a:	f7ff fe21 	bl	80030c0 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 800347e:	9803      	ldr	r0, [sp, #12]
 8003480:	9902      	ldr	r1, [sp, #8]
 8003482:	9a01      	ldr	r2, [sp, #4]
 8003484:	f000 f80c 	bl	80034a0 <chMBFetchS>
 8003488:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800348a:	f7ff fe21 	bl	80030d0 <chSysUnlock>

  return rdymsg;
 800348e:	9b05      	ldr	r3, [sp, #20]
}
 8003490:	4618      	mov	r0, r3
 8003492:	b007      	add	sp, #28
 8003494:	f85d fb04 	ldr.w	pc, [sp], #4
 8003498:	f3af 8000 	nop.w
 800349c:	f3af 8000 	nop.w

080034a0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 80034a0:	b500      	push	{lr}
 80034a2:	b087      	sub	sp, #28
 80034a4:	9003      	str	r0, [sp, #12]
 80034a6:	9102      	str	r1, [sp, #8]
 80034a8:	9201      	str	r2, [sp, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 80034aa:	9b03      	ldr	r3, [sp, #12]
 80034ac:	7d1b      	ldrb	r3, [r3, #20]
 80034ae:	2b00      	cmp	r3, #0
 80034b0:	d002      	beq.n	80034b8 <chMBFetchS+0x18>
      return MSG_RESET;
 80034b2:	f06f 0301 	mvn.w	r3, #1
 80034b6:	e031      	b.n	800351c <chMBFetchS+0x7c>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 80034b8:	9803      	ldr	r0, [sp, #12]
 80034ba:	f7ff fe31 	bl	8003120 <chMBGetUsedCountI>
 80034be:	4603      	mov	r3, r0
 80034c0:	2b00      	cmp	r3, #0
 80034c2:	dd20      	ble.n	8003506 <chMBFetchS+0x66>
      *msgp = *mbp->rdptr++;
 80034c4:	9b03      	ldr	r3, [sp, #12]
 80034c6:	68db      	ldr	r3, [r3, #12]
 80034c8:	1d19      	adds	r1, r3, #4
 80034ca:	9a03      	ldr	r2, [sp, #12]
 80034cc:	60d1      	str	r1, [r2, #12]
 80034ce:	681a      	ldr	r2, [r3, #0]
 80034d0:	9b02      	ldr	r3, [sp, #8]
 80034d2:	601a      	str	r2, [r3, #0]
      if (mbp->rdptr >= mbp->top) {
 80034d4:	9b03      	ldr	r3, [sp, #12]
 80034d6:	68da      	ldr	r2, [r3, #12]
 80034d8:	9b03      	ldr	r3, [sp, #12]
 80034da:	685b      	ldr	r3, [r3, #4]
 80034dc:	429a      	cmp	r2, r3
 80034de:	d303      	bcc.n	80034e8 <chMBFetchS+0x48>
        mbp->rdptr = mbp->buffer;
 80034e0:	9b03      	ldr	r3, [sp, #12]
 80034e2:	681a      	ldr	r2, [r3, #0]
 80034e4:	9b03      	ldr	r3, [sp, #12]
 80034e6:	60da      	str	r2, [r3, #12]
      }
      mbp->cnt--;
 80034e8:	9b03      	ldr	r3, [sp, #12]
 80034ea:	691b      	ldr	r3, [r3, #16]
 80034ec:	1e5a      	subs	r2, r3, #1
 80034ee:	9b03      	ldr	r3, [sp, #12]
 80034f0:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 80034f2:	9b03      	ldr	r3, [sp, #12]
 80034f4:	3318      	adds	r3, #24
 80034f6:	4618      	mov	r0, r3
 80034f8:	2100      	movs	r1, #0
 80034fa:	f7fe f9f9 	bl	80018f0 <chThdDequeueNextI>
      chSchRescheduleS();
 80034fe:	f7fd fd47 	bl	8000f90 <chSchRescheduleS>

      return MSG_OK;
 8003502:	2300      	movs	r3, #0
 8003504:	e00a      	b.n	800351c <chMBFetchS+0x7c>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8003506:	9b03      	ldr	r3, [sp, #12]
 8003508:	3320      	adds	r3, #32
 800350a:	4618      	mov	r0, r3
 800350c:	9901      	ldr	r1, [sp, #4]
 800350e:	f7fe f9cf 	bl	80018b0 <chThdEnqueueTimeoutS>
 8003512:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 8003514:	9b05      	ldr	r3, [sp, #20]
 8003516:	2b00      	cmp	r3, #0
 8003518:	d0c7      	beq.n	80034aa <chMBFetchS+0xa>

  return rdymsg;
 800351a:	9b05      	ldr	r3, [sp, #20]
}
 800351c:	4618      	mov	r0, r3
 800351e:	b007      	add	sp, #28
 8003520:	f85d fb04 	ldr.w	pc, [sp], #4
 8003524:	f3af 8000 	nop.w
 8003528:	f3af 8000 	nop.w
 800352c:	f3af 8000 	nop.w

08003530 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003530:	b500      	push	{lr}
 8003532:	b083      	sub	sp, #12
 8003534:	9001      	str	r0, [sp, #4]
 8003536:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8003538:	9b01      	ldr	r3, [sp, #4]
 800353a:	7d1b      	ldrb	r3, [r3, #20]
 800353c:	2b00      	cmp	r3, #0
 800353e:	d002      	beq.n	8003546 <chMBFetchI+0x16>
    return MSG_RESET;
 8003540:	f06f 0301 	mvn.w	r3, #1
 8003544:	e026      	b.n	8003594 <chMBFetchI+0x64>
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8003546:	9801      	ldr	r0, [sp, #4]
 8003548:	f7ff fdea 	bl	8003120 <chMBGetUsedCountI>
 800354c:	4603      	mov	r3, r0
 800354e:	2b00      	cmp	r3, #0
 8003550:	dd1e      	ble.n	8003590 <chMBFetchI+0x60>
    *msgp = *mbp->rdptr++;
 8003552:	9b01      	ldr	r3, [sp, #4]
 8003554:	68db      	ldr	r3, [r3, #12]
 8003556:	1d19      	adds	r1, r3, #4
 8003558:	9a01      	ldr	r2, [sp, #4]
 800355a:	60d1      	str	r1, [r2, #12]
 800355c:	681a      	ldr	r2, [r3, #0]
 800355e:	9b00      	ldr	r3, [sp, #0]
 8003560:	601a      	str	r2, [r3, #0]
    if (mbp->rdptr >= mbp->top) {
 8003562:	9b01      	ldr	r3, [sp, #4]
 8003564:	68da      	ldr	r2, [r3, #12]
 8003566:	9b01      	ldr	r3, [sp, #4]
 8003568:	685b      	ldr	r3, [r3, #4]
 800356a:	429a      	cmp	r2, r3
 800356c:	d303      	bcc.n	8003576 <chMBFetchI+0x46>
      mbp->rdptr = mbp->buffer;
 800356e:	9b01      	ldr	r3, [sp, #4]
 8003570:	681a      	ldr	r2, [r3, #0]
 8003572:	9b01      	ldr	r3, [sp, #4]
 8003574:	60da      	str	r2, [r3, #12]
    }
    mbp->cnt--;
 8003576:	9b01      	ldr	r3, [sp, #4]
 8003578:	691b      	ldr	r3, [r3, #16]
 800357a:	1e5a      	subs	r2, r3, #1
 800357c:	9b01      	ldr	r3, [sp, #4]
 800357e:	611a      	str	r2, [r3, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8003580:	9b01      	ldr	r3, [sp, #4]
 8003582:	3318      	adds	r3, #24
 8003584:	4618      	mov	r0, r3
 8003586:	2100      	movs	r1, #0
 8003588:	f7fe f9b2 	bl	80018f0 <chThdDequeueNextI>

    return MSG_OK;
 800358c:	2300      	movs	r3, #0
 800358e:	e001      	b.n	8003594 <chMBFetchI+0x64>
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
 8003590:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8003594:	4618      	mov	r0, r3
 8003596:	b003      	add	sp, #12
 8003598:	f85d fb04 	ldr.w	pc, [sp], #4
 800359c:	0000      	movs	r0, r0
	...

080035a0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035a0:	b082      	sub	sp, #8
 80035a2:	2320      	movs	r3, #32
 80035a4:	9301      	str	r3, [sp, #4]
 80035a6:	9b01      	ldr	r3, [sp, #4]
 80035a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035ac:	b002      	add	sp, #8
 80035ae:	4770      	bx	lr

080035b0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80035b0:	b082      	sub	sp, #8
 80035b2:	2300      	movs	r3, #0
 80035b4:	9301      	str	r3, [sp, #4]
 80035b6:	9b01      	ldr	r3, [sp, #4]
 80035b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035bc:	b002      	add	sp, #8
 80035be:	4770      	bx	lr

080035c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80035c0:	b508      	push	{r3, lr}

  port_lock();
 80035c2:	f7ff ffed 	bl	80035a0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80035c6:	bd08      	pop	{r3, pc}
 80035c8:	f3af 8000 	nop.w
 80035cc:	f3af 8000 	nop.w

080035d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80035d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80035d2:	f7ff ffed 	bl	80035b0 <port_unlock>
}
 80035d6:	bd08      	pop	{r3, pc}
 80035d8:	f3af 8000 	nop.w
 80035dc:	f3af 8000 	nop.w

080035e0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 80035e0:	4b03      	ldr	r3, [pc, #12]	; (80035f0 <_core_init+0x10>)
 80035e2:	4a04      	ldr	r2, [pc, #16]	; (80035f4 <_core_init+0x14>)
 80035e4:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 80035e6:	4b02      	ldr	r3, [pc, #8]	; (80035f0 <_core_init+0x10>)
 80035e8:	4a03      	ldr	r2, [pc, #12]	; (80035f8 <_core_init+0x18>)
 80035ea:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 80035ec:	4770      	bx	lr
 80035ee:	bf00      	nop
 80035f0:	20000b70 	.word	0x20000b70
 80035f4:	20001350 	.word	0x20001350
 80035f8:	20020000 	.word	0x20020000
 80035fc:	f3af 8000 	nop.w

08003600 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8003600:	b086      	sub	sp, #24
 8003602:	9003      	str	r0, [sp, #12]
 8003604:	9102      	str	r1, [sp, #8]
 8003606:	9201      	str	r2, [sp, #4]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003608:	9a02      	ldr	r2, [sp, #8]
 800360a:	9b03      	ldr	r3, [sp, #12]
 800360c:	4413      	add	r3, r2
 800360e:	1e5a      	subs	r2, r3, #1
 8003610:	9b02      	ldr	r3, [sp, #8]
 8003612:	425b      	negs	r3, r3
 8003614:	4013      	ands	r3, r2
 8003616:	9303      	str	r3, [sp, #12]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8003618:	4b11      	ldr	r3, [pc, #68]	; (8003660 <chCoreAllocAlignedWithOffsetI+0x60>)
 800361a:	681a      	ldr	r2, [r3, #0]
 800361c:	9b01      	ldr	r3, [sp, #4]
 800361e:	4413      	add	r3, r2
 8003620:	461a      	mov	r2, r3
 8003622:	9b02      	ldr	r3, [sp, #8]
 8003624:	4413      	add	r3, r2
 8003626:	1e5a      	subs	r2, r3, #1
 8003628:	9b02      	ldr	r3, [sp, #8]
 800362a:	425b      	negs	r3, r3
 800362c:	4013      	ands	r3, r2
 800362e:	9305      	str	r3, [sp, #20]
  next = p + size;
 8003630:	9a05      	ldr	r2, [sp, #20]
 8003632:	9b03      	ldr	r3, [sp, #12]
 8003634:	4413      	add	r3, r2
 8003636:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8003638:	4b09      	ldr	r3, [pc, #36]	; (8003660 <chCoreAllocAlignedWithOffsetI+0x60>)
 800363a:	685a      	ldr	r2, [r3, #4]
 800363c:	9b04      	ldr	r3, [sp, #16]
 800363e:	429a      	cmp	r2, r3
 8003640:	d304      	bcc.n	800364c <chCoreAllocAlignedWithOffsetI+0x4c>
 8003642:	4b07      	ldr	r3, [pc, #28]	; (8003660 <chCoreAllocAlignedWithOffsetI+0x60>)
 8003644:	681a      	ldr	r2, [r3, #0]
 8003646:	9b04      	ldr	r3, [sp, #16]
 8003648:	429a      	cmp	r2, r3
 800364a:	d901      	bls.n	8003650 <chCoreAllocAlignedWithOffsetI+0x50>
    return NULL;
 800364c:	2300      	movs	r3, #0
 800364e:	e003      	b.n	8003658 <chCoreAllocAlignedWithOffsetI+0x58>
  }

  ch_memcore.nextmem = next;
 8003650:	4a03      	ldr	r2, [pc, #12]	; (8003660 <chCoreAllocAlignedWithOffsetI+0x60>)
 8003652:	9b04      	ldr	r3, [sp, #16]
 8003654:	6013      	str	r3, [r2, #0]

  return p;
 8003656:	9b05      	ldr	r3, [sp, #20]
}
 8003658:	4618      	mov	r0, r3
 800365a:	b006      	add	sp, #24
 800365c:	4770      	bx	lr
 800365e:	bf00      	nop
 8003660:	20000b70 	.word	0x20000b70
 8003664:	f3af 8000 	nop.w
 8003668:	f3af 8000 	nop.w
 800366c:	f3af 8000 	nop.w

08003670 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8003670:	b500      	push	{lr}
 8003672:	b087      	sub	sp, #28
 8003674:	9003      	str	r0, [sp, #12]
 8003676:	9102      	str	r1, [sp, #8]
 8003678:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 800367a:	f7ff ffa1 	bl	80035c0 <chSysLock>
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 800367e:	9803      	ldr	r0, [sp, #12]
 8003680:	9902      	ldr	r1, [sp, #8]
 8003682:	9a01      	ldr	r2, [sp, #4]
 8003684:	f7ff ffbc 	bl	8003600 <chCoreAllocAlignedWithOffsetI>
 8003688:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800368a:	f7ff ffa1 	bl	80035d0 <chSysUnlock>

  return p;
 800368e:	9b05      	ldr	r3, [sp, #20]
}
 8003690:	4618      	mov	r0, r3
 8003692:	b007      	add	sp, #28
 8003694:	f85d fb04 	ldr.w	pc, [sp], #4
 8003698:	f3af 8000 	nop.w
 800369c:	f3af 8000 	nop.w

080036a0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 80036a0:	4b03      	ldr	r3, [pc, #12]	; (80036b0 <chCoreGetStatusX+0x10>)
 80036a2:	685b      	ldr	r3, [r3, #4]
 80036a4:	461a      	mov	r2, r3
 80036a6:	4b02      	ldr	r3, [pc, #8]	; (80036b0 <chCoreGetStatusX+0x10>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 80036ac:	4618      	mov	r0, r3
 80036ae:	4770      	bx	lr
 80036b0:	20000b70 	.word	0x20000b70
	...

080036c0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80036c0:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80036c2:	4b06      	ldr	r3, [pc, #24]	; (80036dc <_heap_init+0x1c>)
 80036c4:	4a06      	ldr	r2, [pc, #24]	; (80036e0 <_heap_init+0x20>)
 80036c6:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80036c8:	4b04      	ldr	r3, [pc, #16]	; (80036dc <_heap_init+0x1c>)
 80036ca:	2200      	movs	r2, #0
 80036cc:	609a      	str	r2, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
 80036ce:	4b03      	ldr	r3, [pc, #12]	; (80036dc <_heap_init+0x1c>)
 80036d0:	2200      	movs	r2, #0
 80036d2:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80036d4:	4803      	ldr	r0, [pc, #12]	; (80036e4 <_heap_init+0x24>)
 80036d6:	f7fe fd4b 	bl	8002170 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 80036da:	bd08      	pop	{r3, pc}
 80036dc:	200008b8 	.word	0x200008b8
 80036e0:	08003671 	.word	0x08003671
 80036e4:	200008c8 	.word	0x200008c8
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 80036f0:	b500      	push	{lr}
 80036f2:	b087      	sub	sp, #28
 80036f4:	9003      	str	r0, [sp, #12]
 80036f6:	9102      	str	r1, [sp, #8]
 80036f8:	9201      	str	r2, [sp, #4]
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 80036fa:	9b02      	ldr	r3, [sp, #8]
 80036fc:	3307      	adds	r3, #7
 80036fe:	f023 0307 	bic.w	r3, r3, #7
 8003702:	9305      	str	r3, [sp, #20]

  chDbgCheck((heapp != NULL) && (size > 0U));

  /* Adjusting the size in case the initial block was not correctly
     aligned.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8003704:	9a02      	ldr	r2, [sp, #8]
 8003706:	9b05      	ldr	r3, [sp, #20]
 8003708:	1ad3      	subs	r3, r2, r3
 800370a:	461a      	mov	r2, r3
 800370c:	9b01      	ldr	r3, [sp, #4]
 800370e:	4413      	add	r3, r2
 8003710:	9301      	str	r3, [sp, #4]

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8003712:	9b03      	ldr	r3, [sp, #12]
 8003714:	2200      	movs	r2, #0
 8003716:	601a      	str	r2, [r3, #0]
  H_NEXT(&heapp->header) = hp;
 8003718:	9b03      	ldr	r3, [sp, #12]
 800371a:	9a05      	ldr	r2, [sp, #20]
 800371c:	609a      	str	r2, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 800371e:	9b03      	ldr	r3, [sp, #12]
 8003720:	2200      	movs	r2, #0
 8003722:	60da      	str	r2, [r3, #12]
  H_NEXT(hp) = NULL;
 8003724:	9b05      	ldr	r3, [sp, #20]
 8003726:	2200      	movs	r2, #0
 8003728:	601a      	str	r2, [r3, #0]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 800372a:	9b01      	ldr	r3, [sp, #4]
 800372c:	3b08      	subs	r3, #8
 800372e:	08da      	lsrs	r2, r3, #3
 8003730:	9b05      	ldr	r3, [sp, #20]
 8003732:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->mtx);
 8003734:	9b03      	ldr	r3, [sp, #12]
 8003736:	3310      	adds	r3, #16
 8003738:	4618      	mov	r0, r3
 800373a:	f7fe fd19 	bl	8002170 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->sem, (cnt_t)1);
#endif
}
 800373e:	b007      	add	sp, #28
 8003740:	f85d fb04 	ldr.w	pc, [sp], #4
 8003744:	f3af 8000 	nop.w
 8003748:	f3af 8000 	nop.w
 800374c:	f3af 8000 	nop.w

08003750 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8003750:	b500      	push	{lr}
 8003752:	b08d      	sub	sp, #52	; 0x34
 8003754:	9003      	str	r0, [sp, #12]
 8003756:	9102      	str	r1, [sp, #8]
 8003758:	9201      	str	r2, [sp, #4]
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
 800375a:	9b03      	ldr	r3, [sp, #12]
 800375c:	2b00      	cmp	r3, #0
 800375e:	d101      	bne.n	8003764 <chHeapAllocAligned+0x14>
    heapp = &default_heap;
 8003760:	4b65      	ldr	r3, [pc, #404]	; (80038f8 <chHeapAllocAligned+0x1a8>)
 8003762:	9303      	str	r3, [sp, #12]
  }

  /* Minimum alignment is constrained by the heap header structure size.*/
  if (align < CH_HEAP_ALIGNMENT) {
 8003764:	9b01      	ldr	r3, [sp, #4]
 8003766:	2b07      	cmp	r3, #7
 8003768:	d801      	bhi.n	800376e <chHeapAllocAligned+0x1e>
    align = CH_HEAP_ALIGNMENT;
 800376a:	2308      	movs	r3, #8
 800376c:	9301      	str	r3, [sp, #4]
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800376e:	9b02      	ldr	r3, [sp, #8]
 8003770:	3307      	adds	r3, #7
 8003772:	f023 0307 	bic.w	r3, r3, #7
 8003776:	08db      	lsrs	r3, r3, #3
 8003778:	9309      	str	r3, [sp, #36]	; 0x24

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800377a:	9b03      	ldr	r3, [sp, #12]
 800377c:	3310      	adds	r3, #16
 800377e:	4618      	mov	r0, r3
 8003780:	f7fe fd06 	bl	8002190 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8003784:	9b03      	ldr	r3, [sp, #12]
 8003786:	3308      	adds	r3, #8
 8003788:	930b      	str	r3, [sp, #44]	; 0x2c
  while (H_NEXT(qp) != NULL) {
 800378a:	e089      	b.n	80038a0 <chHeapAllocAligned+0x150>

    /* Next free block.*/
    hp = H_NEXT(qp);
 800378c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800378e:	681b      	ldr	r3, [r3, #0]
 8003790:	930a      	str	r3, [sp, #40]	; 0x28

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8003792:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003794:	3308      	adds	r3, #8
 8003796:	461a      	mov	r2, r3
 8003798:	9b01      	ldr	r3, [sp, #4]
 800379a:	4413      	add	r3, r2
 800379c:	1e5a      	subs	r2, r3, #1
 800379e:	9b01      	ldr	r3, [sp, #4]
 80037a0:	425b      	negs	r3, r3
 80037a2:	4013      	ands	r3, r2
 80037a4:	3b08      	subs	r3, #8
 80037a6:	9308      	str	r3, [sp, #32]

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80037a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80037aa:	685b      	ldr	r3, [r3, #4]
 80037ac:	3301      	adds	r3, #1
 80037ae:	00db      	lsls	r3, r3, #3
 80037b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80037b2:	441a      	add	r2, r3
 80037b4:	9b08      	ldr	r3, [sp, #32]
 80037b6:	429a      	cmp	r2, r3
 80037b8:	d970      	bls.n	800389c <chHeapAllocAligned+0x14c>
 80037ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80037bc:	9b08      	ldr	r3, [sp, #32]
 80037be:	1ad2      	subs	r2, r2, r3
 80037c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80037c2:	685b      	ldr	r3, [r3, #4]
 80037c4:	3301      	adds	r3, #1
 80037c6:	00db      	lsls	r3, r3, #3
 80037c8:	3b08      	subs	r3, #8
 80037ca:	4413      	add	r3, r2
 80037cc:	10db      	asrs	r3, r3, #3
 80037ce:	461a      	mov	r2, r3
 80037d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80037d2:	429a      	cmp	r2, r3
 80037d4:	d362      	bcc.n	800389c <chHeapAllocAligned+0x14c>
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 80037d6:	9a08      	ldr	r2, [sp, #32]
 80037d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80037da:	429a      	cmp	r2, r3
 80037dc:	d92c      	bls.n	8003838 <chHeapAllocAligned+0xe8>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
 80037de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80037e0:	9b08      	ldr	r3, [sp, #32]
 80037e2:	1ad2      	subs	r2, r2, r3
 80037e4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80037e6:	685b      	ldr	r3, [r3, #4]
 80037e8:	3301      	adds	r3, #1
 80037ea:	00db      	lsls	r3, r3, #3
 80037ec:	3b08      	subs	r3, #8
 80037ee:	4413      	add	r3, r2
 80037f0:	10db      	asrs	r3, r3, #3
 80037f2:	9307      	str	r3, [sp, #28]
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80037f4:	9b08      	ldr	r3, [sp, #32]
 80037f6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80037f8:	3208      	adds	r2, #8
 80037fa:	1a9b      	subs	r3, r3, r2
 80037fc:	10db      	asrs	r3, r3, #3
 80037fe:	461a      	mov	r2, r3
 8003800:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003802:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 8003804:	9a07      	ldr	r2, [sp, #28]
 8003806:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003808:	429a      	cmp	r2, r3
 800380a:	d912      	bls.n	8003832 <chHeapAllocAligned+0xe2>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800380c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800380e:	3301      	adds	r3, #1
 8003810:	00db      	lsls	r3, r3, #3
 8003812:	9a08      	ldr	r2, [sp, #32]
 8003814:	4413      	add	r3, r2
 8003816:	9306      	str	r3, [sp, #24]
          H_PAGES(fp) = (bpages - pages) - 1U;
 8003818:	9a07      	ldr	r2, [sp, #28]
 800381a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800381c:	1ad3      	subs	r3, r2, r3
 800381e:	1e5a      	subs	r2, r3, #1
 8003820:	9b06      	ldr	r3, [sp, #24]
 8003822:	605a      	str	r2, [r3, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8003824:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003826:	681a      	ldr	r2, [r3, #0]
 8003828:	9b06      	ldr	r3, [sp, #24]
 800382a:	601a      	str	r2, [r3, #0]
          H_NEXT(hp) = fp;
 800382c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800382e:	9a06      	ldr	r2, [sp, #24]
 8003830:	601a      	str	r2, [r3, #0]
        }

        hp = ahp;
 8003832:	9b08      	ldr	r3, [sp, #32]
 8003834:	930a      	str	r3, [sp, #40]	; 0x28
 8003836:	e023      	b.n	8003880 <chHeapAllocAligned+0x130>
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8003838:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800383a:	685a      	ldr	r2, [r3, #4]
 800383c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800383e:	429a      	cmp	r2, r3
 8003840:	d104      	bne.n	800384c <chHeapAllocAligned+0xfc>
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 8003842:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003844:	681a      	ldr	r2, [r3, #0]
 8003846:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003848:	601a      	str	r2, [r3, #0]
 800384a:	e019      	b.n	8003880 <chHeapAllocAligned+0x130>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 800384c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800384e:	3301      	adds	r3, #1
 8003850:	00db      	lsls	r3, r3, #3
 8003852:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8003854:	4413      	add	r3, r2
 8003856:	9305      	str	r3, [sp, #20]
          H_NEXT(fp) = H_NEXT(hp);
 8003858:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800385a:	681a      	ldr	r2, [r3, #0]
 800385c:	9b05      	ldr	r3, [sp, #20]
 800385e:	601a      	str	r2, [r3, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8003860:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8003862:	9b05      	ldr	r3, [sp, #20]
 8003864:	1ad2      	subs	r2, r2, r3
 8003866:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003868:	685b      	ldr	r3, [r3, #4]
 800386a:	3301      	adds	r3, #1
 800386c:	00db      	lsls	r3, r3, #3
 800386e:	3b08      	subs	r3, #8
 8003870:	4413      	add	r3, r2
 8003872:	10db      	asrs	r3, r3, #3
 8003874:	461a      	mov	r2, r3
 8003876:	9b05      	ldr	r3, [sp, #20]
 8003878:	605a      	str	r2, [r3, #4]
          H_NEXT(qp) = fp;
 800387a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800387c:	9a05      	ldr	r2, [sp, #20]
 800387e:	601a      	str	r2, [r3, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8003880:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003882:	9a02      	ldr	r2, [sp, #8]
 8003884:	605a      	str	r2, [r3, #4]
      H_HEAP(hp) = heapp;
 8003886:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003888:	9a03      	ldr	r2, [sp, #12]
 800388a:	601a      	str	r2, [r3, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800388c:	9b03      	ldr	r3, [sp, #12]
 800388e:	3310      	adds	r3, #16
 8003890:	4618      	mov	r0, r3
 8003892:	f7fe fd25 	bl	80022e0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8003896:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003898:	3308      	adds	r3, #8
 800389a:	e028      	b.n	80038ee <chHeapAllocAligned+0x19e>
      /*lint -restore*/
    }

    /* Next in the free blocks list.*/
    qp = hp;
 800389c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800389e:	930b      	str	r3, [sp, #44]	; 0x2c
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80038a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80038a2:	681b      	ldr	r3, [r3, #0]
 80038a4:	2b00      	cmp	r3, #0
 80038a6:	f47f af71 	bne.w	800378c <chHeapAllocAligned+0x3c>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80038aa:	9b03      	ldr	r3, [sp, #12]
 80038ac:	3310      	adds	r3, #16
 80038ae:	4618      	mov	r0, r3
 80038b0:	f7fe fd16 	bl	80022e0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 80038b4:	9b03      	ldr	r3, [sp, #12]
 80038b6:	681b      	ldr	r3, [r3, #0]
 80038b8:	2b00      	cmp	r3, #0
 80038ba:	d017      	beq.n	80038ec <chHeapAllocAligned+0x19c>
    ahp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT,
 80038bc:	9b03      	ldr	r3, [sp, #12]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80038c2:	3201      	adds	r2, #1
 80038c4:	00d2      	lsls	r2, r2, #3
 80038c6:	4610      	mov	r0, r2
 80038c8:	9901      	ldr	r1, [sp, #4]
 80038ca:	2208      	movs	r2, #8
 80038cc:	4798      	blx	r3
 80038ce:	9008      	str	r0, [sp, #32]
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 80038d0:	9b08      	ldr	r3, [sp, #32]
 80038d2:	2b00      	cmp	r3, #0
 80038d4:	d00a      	beq.n	80038ec <chHeapAllocAligned+0x19c>
      hp = ahp - 1U;
 80038d6:	9b08      	ldr	r3, [sp, #32]
 80038d8:	3b08      	subs	r3, #8
 80038da:	930a      	str	r3, [sp, #40]	; 0x28
      H_HEAP(hp) = heapp;
 80038dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80038de:	9a03      	ldr	r2, [sp, #12]
 80038e0:	601a      	str	r2, [r3, #0]
      H_SIZE(hp) = size;
 80038e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80038e4:	9a02      	ldr	r2, [sp, #8]
 80038e6:	605a      	str	r2, [r3, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)ahp;
 80038e8:	9b08      	ldr	r3, [sp, #32]
 80038ea:	e000      	b.n	80038ee <chHeapAllocAligned+0x19e>
      /*lint -restore*/
    }
  }

  return NULL;
 80038ec:	2300      	movs	r3, #0
}
 80038ee:	4618      	mov	r0, r3
 80038f0:	b00d      	add	sp, #52	; 0x34
 80038f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80038f6:	bf00      	nop
 80038f8:	200008b8 	.word	0x200008b8
 80038fc:	f3af 8000 	nop.w

08003900 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003900:	b500      	push	{lr}
 8003902:	b087      	sub	sp, #28
 8003904:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8003906:	9b01      	ldr	r3, [sp, #4]
 8003908:	3b08      	subs	r3, #8
 800390a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = H_HEAP(hp);
 800390c:	9b04      	ldr	r3, [sp, #16]
 800390e:	681b      	ldr	r3, [r3, #0]
 8003910:	9303      	str	r3, [sp, #12]
  qp = &heapp->header;
 8003912:	9b03      	ldr	r3, [sp, #12]
 8003914:	3308      	adds	r3, #8
 8003916:	9305      	str	r3, [sp, #20]

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8003918:	9b04      	ldr	r3, [sp, #16]
 800391a:	685b      	ldr	r3, [r3, #4]
 800391c:	3307      	adds	r3, #7
 800391e:	f023 0307 	bic.w	r3, r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8003922:	08da      	lsrs	r2, r3, #3
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8003924:	9b04      	ldr	r3, [sp, #16]
 8003926:	605a      	str	r2, [r3, #4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8003928:	9b03      	ldr	r3, [sp, #12]
 800392a:	3310      	adds	r3, #16
 800392c:	4618      	mov	r0, r3
 800392e:	f7fe fc2f 	bl	8002190 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8003932:	9b03      	ldr	r3, [sp, #12]
 8003934:	f103 0208 	add.w	r2, r3, #8
 8003938:	9b05      	ldr	r3, [sp, #20]
 800393a:	429a      	cmp	r2, r3
 800393c:	d003      	beq.n	8003946 <chHeapFree+0x46>
 800393e:	9a04      	ldr	r2, [sp, #16]
 8003940:	9b05      	ldr	r3, [sp, #20]
 8003942:	429a      	cmp	r2, r3
 8003944:	d93e      	bls.n	80039c4 <chHeapFree+0xc4>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8003946:	9b05      	ldr	r3, [sp, #20]
 8003948:	681b      	ldr	r3, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 800394a:	2b00      	cmp	r3, #0
 800394c:	d004      	beq.n	8003958 <chHeapFree+0x58>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800394e:	9b05      	ldr	r3, [sp, #20]
 8003950:	681a      	ldr	r2, [r3, #0]
 8003952:	9b04      	ldr	r3, [sp, #16]
 8003954:	429a      	cmp	r2, r3
 8003956:	d935      	bls.n	80039c4 <chHeapFree+0xc4>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8003958:	9b05      	ldr	r3, [sp, #20]
 800395a:	681a      	ldr	r2, [r3, #0]
 800395c:	9b04      	ldr	r3, [sp, #16]
 800395e:	601a      	str	r2, [r3, #0]
      H_NEXT(qp) = hp;
 8003960:	9b05      	ldr	r3, [sp, #20]
 8003962:	9a04      	ldr	r2, [sp, #16]
 8003964:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8003966:	9b04      	ldr	r3, [sp, #16]
 8003968:	685b      	ldr	r3, [r3, #4]
 800396a:	3301      	adds	r3, #1
 800396c:	00db      	lsls	r3, r3, #3
 800396e:	9a04      	ldr	r2, [sp, #16]
 8003970:	441a      	add	r2, r3
 8003972:	9b04      	ldr	r3, [sp, #16]
 8003974:	681b      	ldr	r3, [r3, #0]
 8003976:	429a      	cmp	r2, r3
 8003978:	d10d      	bne.n	8003996 <chHeapFree+0x96>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800397a:	9b04      	ldr	r3, [sp, #16]
 800397c:	685a      	ldr	r2, [r3, #4]
 800397e:	9b04      	ldr	r3, [sp, #16]
 8003980:	681b      	ldr	r3, [r3, #0]
 8003982:	685b      	ldr	r3, [r3, #4]
 8003984:	4413      	add	r3, r2
 8003986:	1c5a      	adds	r2, r3, #1
 8003988:	9b04      	ldr	r3, [sp, #16]
 800398a:	605a      	str	r2, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800398c:	9b04      	ldr	r3, [sp, #16]
 800398e:	681b      	ldr	r3, [r3, #0]
 8003990:	681a      	ldr	r2, [r3, #0]
 8003992:	9b04      	ldr	r3, [sp, #16]
 8003994:	601a      	str	r2, [r3, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8003996:	9b05      	ldr	r3, [sp, #20]
 8003998:	685b      	ldr	r3, [r3, #4]
 800399a:	3301      	adds	r3, #1
 800399c:	00db      	lsls	r3, r3, #3
 800399e:	9a05      	ldr	r2, [sp, #20]
 80039a0:	441a      	add	r2, r3
 80039a2:	9b04      	ldr	r3, [sp, #16]
 80039a4:	429a      	cmp	r2, r3
 80039a6:	d10c      	bne.n	80039c2 <chHeapFree+0xc2>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80039a8:	9b05      	ldr	r3, [sp, #20]
 80039aa:	685a      	ldr	r2, [r3, #4]
 80039ac:	9b04      	ldr	r3, [sp, #16]
 80039ae:	685b      	ldr	r3, [r3, #4]
 80039b0:	4413      	add	r3, r2
 80039b2:	1c5a      	adds	r2, r3, #1
 80039b4:	9b05      	ldr	r3, [sp, #20]
 80039b6:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80039b8:	9b04      	ldr	r3, [sp, #16]
 80039ba:	681a      	ldr	r2, [r3, #0]
 80039bc:	9b05      	ldr	r3, [sp, #20]
 80039be:	601a      	str	r2, [r3, #0]
      }
      break;
 80039c0:	e004      	b.n	80039cc <chHeapFree+0xcc>
 80039c2:	e003      	b.n	80039cc <chHeapFree+0xcc>
    }
    qp = H_NEXT(qp);
 80039c4:	9b05      	ldr	r3, [sp, #20]
 80039c6:	681b      	ldr	r3, [r3, #0]
 80039c8:	9305      	str	r3, [sp, #20]
  }
 80039ca:	e7b2      	b.n	8003932 <chHeapFree+0x32>

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80039cc:	9b03      	ldr	r3, [sp, #12]
 80039ce:	3310      	adds	r3, #16
 80039d0:	4618      	mov	r0, r3
 80039d2:	f7fe fc85 	bl	80022e0 <chMtxUnlock>

  return;
 80039d6:	bf00      	nop
}
 80039d8:	b007      	add	sp, #28
 80039da:	f85d fb04 	ldr.w	pc, [sp], #4
 80039de:	bf00      	nop

080039e0 <chHeapStatus>:
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80039e0:	b500      	push	{lr}
 80039e2:	b08b      	sub	sp, #44	; 0x2c
 80039e4:	9003      	str	r0, [sp, #12]
 80039e6:	9102      	str	r1, [sp, #8]
 80039e8:	9201      	str	r2, [sp, #4]
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
 80039ea:	9b03      	ldr	r3, [sp, #12]
 80039ec:	2b00      	cmp	r3, #0
 80039ee:	d101      	bne.n	80039f4 <chHeapStatus+0x14>
    heapp = &default_heap;
 80039f0:	4b20      	ldr	r3, [pc, #128]	; (8003a74 <chHeapStatus+0x94>)
 80039f2:	9303      	str	r3, [sp, #12]
  }

  H_LOCK(heapp);
 80039f4:	9b03      	ldr	r3, [sp, #12]
 80039f6:	3310      	adds	r3, #16
 80039f8:	4618      	mov	r0, r3
 80039fa:	f7fe fbc9 	bl	8002190 <chMtxLock>
  tpages = 0U;
 80039fe:	2300      	movs	r3, #0
 8003a00:	9307      	str	r3, [sp, #28]
  lpages = 0U;
 8003a02:	2300      	movs	r3, #0
 8003a04:	9306      	str	r3, [sp, #24]
  n = 0U;
 8003a06:	2300      	movs	r3, #0
 8003a08:	9308      	str	r3, [sp, #32]
  qp = &heapp->header;
 8003a0a:	9b03      	ldr	r3, [sp, #12]
 8003a0c:	3308      	adds	r3, #8
 8003a0e:	9309      	str	r3, [sp, #36]	; 0x24
  while (H_NEXT(qp) != NULL) {
 8003a10:	e013      	b.n	8003a3a <chHeapStatus+0x5a>
    size_t pages = H_PAGES(H_NEXT(qp));
 8003a12:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003a14:	681b      	ldr	r3, [r3, #0]
 8003a16:	685b      	ldr	r3, [r3, #4]
 8003a18:	9305      	str	r3, [sp, #20]

    /* Updating counters.*/
    n++;
 8003a1a:	9b08      	ldr	r3, [sp, #32]
 8003a1c:	3301      	adds	r3, #1
 8003a1e:	9308      	str	r3, [sp, #32]
    tpages += pages;
 8003a20:	9a07      	ldr	r2, [sp, #28]
 8003a22:	9b05      	ldr	r3, [sp, #20]
 8003a24:	4413      	add	r3, r2
 8003a26:	9307      	str	r3, [sp, #28]
    if (pages > lpages) {
 8003a28:	9a05      	ldr	r2, [sp, #20]
 8003a2a:	9b06      	ldr	r3, [sp, #24]
 8003a2c:	429a      	cmp	r2, r3
 8003a2e:	d901      	bls.n	8003a34 <chHeapStatus+0x54>
      lpages = pages;
 8003a30:	9b05      	ldr	r3, [sp, #20]
 8003a32:	9306      	str	r3, [sp, #24]
    }

    qp = H_NEXT(qp);
 8003a34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003a36:	681b      	ldr	r3, [r3, #0]
 8003a38:	9309      	str	r3, [sp, #36]	; 0x24
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8003a3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003a3c:	681b      	ldr	r3, [r3, #0]
 8003a3e:	2b00      	cmp	r3, #0
 8003a40:	d1e7      	bne.n	8003a12 <chHeapStatus+0x32>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 8003a42:	9b02      	ldr	r3, [sp, #8]
 8003a44:	2b00      	cmp	r3, #0
 8003a46:	d003      	beq.n	8003a50 <chHeapStatus+0x70>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8003a48:	9b07      	ldr	r3, [sp, #28]
 8003a4a:	00da      	lsls	r2, r3, #3
 8003a4c:	9b02      	ldr	r3, [sp, #8]
 8003a4e:	601a      	str	r2, [r3, #0]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8003a50:	9b01      	ldr	r3, [sp, #4]
 8003a52:	2b00      	cmp	r3, #0
 8003a54:	d003      	beq.n	8003a5e <chHeapStatus+0x7e>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 8003a56:	9b06      	ldr	r3, [sp, #24]
 8003a58:	00da      	lsls	r2, r3, #3
 8003a5a:	9b01      	ldr	r3, [sp, #4]
 8003a5c:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8003a5e:	9b03      	ldr	r3, [sp, #12]
 8003a60:	3310      	adds	r3, #16
 8003a62:	4618      	mov	r0, r3
 8003a64:	f7fe fc3c 	bl	80022e0 <chMtxUnlock>

  return n;
 8003a68:	9b08      	ldr	r3, [sp, #32]
}
 8003a6a:	4618      	mov	r0, r3
 8003a6c:	b00b      	add	sp, #44	; 0x2c
 8003a6e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a72:	bf00      	nop
 8003a74:	200008b8 	.word	0x200008b8
	...

08003a80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003a80:	b082      	sub	sp, #8
 8003a82:	2320      	movs	r3, #32
 8003a84:	9301      	str	r3, [sp, #4]
 8003a86:	9b01      	ldr	r3, [sp, #4]
 8003a88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003a8c:	b002      	add	sp, #8
 8003a8e:	4770      	bx	lr

08003a90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003a90:	b082      	sub	sp, #8
 8003a92:	2300      	movs	r3, #0
 8003a94:	9301      	str	r3, [sp, #4]
 8003a96:	9b01      	ldr	r3, [sp, #4]
 8003a98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003a9c:	b002      	add	sp, #8
 8003a9e:	4770      	bx	lr

08003aa0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003aa0:	b508      	push	{r3, lr}

  port_lock();
 8003aa2:	f7ff ffed 	bl	8003a80 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003aa6:	bd08      	pop	{r3, pc}
 8003aa8:	f3af 8000 	nop.w
 8003aac:	f3af 8000 	nop.w

08003ab0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003ab0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8003ab2:	f7ff ffed 	bl	8003a90 <port_unlock>
}
 8003ab6:	bd08      	pop	{r3, pc}
 8003ab8:	f3af 8000 	nop.w
 8003abc:	f3af 8000 	nop.w

08003ac0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 8003ac8:	9801      	ldr	r0, [sp, #4]
 8003aca:	9900      	ldr	r1, [sp, #0]
 8003acc:	f000 f880 	bl	8003bd0 <chPoolFree>
}
 8003ad0:	b003      	add	sp, #12
 8003ad2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ad6:	bf00      	nop
 8003ad8:	f3af 8000 	nop.w
 8003adc:	f3af 8000 	nop.w

08003ae0 <chGuardedPoolAdd>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {
 8003ae0:	b500      	push	{lr}
 8003ae2:	b083      	sub	sp, #12
 8003ae4:	9001      	str	r0, [sp, #4]
 8003ae6:	9100      	str	r1, [sp, #0]

  chGuardedPoolFree(gmp, objp);
 8003ae8:	9801      	ldr	r0, [sp, #4]
 8003aea:	9900      	ldr	r1, [sp, #0]
 8003aec:	f000 f900 	bl	8003cf0 <chGuardedPoolFree>
}
 8003af0:	b003      	add	sp, #12
 8003af2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003af6:	bf00      	nop
 8003af8:	f3af 8000 	nop.w
 8003afc:	f3af 8000 	nop.w

08003b00 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 8003b00:	b084      	sub	sp, #16
 8003b02:	9003      	str	r0, [sp, #12]
 8003b04:	9102      	str	r1, [sp, #8]
 8003b06:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8003b08:	9b03      	ldr	r3, [sp, #12]
 8003b0a:	2200      	movs	r2, #0
 8003b0c:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8003b0e:	9b03      	ldr	r3, [sp, #12]
 8003b10:	9a02      	ldr	r2, [sp, #8]
 8003b12:	605a      	str	r2, [r3, #4]
  mp->provider = provider;
 8003b14:	9b03      	ldr	r3, [sp, #12]
 8003b16:	9a01      	ldr	r2, [sp, #4]
 8003b18:	609a      	str	r2, [r3, #8]
}
 8003b1a:	b004      	add	sp, #16
 8003b1c:	4770      	bx	lr
 8003b1e:	bf00      	nop

08003b20 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003b20:	b500      	push	{lr}
 8003b22:	b085      	sub	sp, #20
 8003b24:	9003      	str	r0, [sp, #12]
 8003b26:	9102      	str	r1, [sp, #8]
 8003b28:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003b2a:	e00b      	b.n	8003b44 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
 8003b2c:	9803      	ldr	r0, [sp, #12]
 8003b2e:	9902      	ldr	r1, [sp, #8]
 8003b30:	f7ff ffc6 	bl	8003ac0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8003b34:	9b03      	ldr	r3, [sp, #12]
 8003b36:	685b      	ldr	r3, [r3, #4]
 8003b38:	9a02      	ldr	r2, [sp, #8]
 8003b3a:	4413      	add	r3, r2
 8003b3c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003b3e:	9b01      	ldr	r3, [sp, #4]
 8003b40:	3b01      	subs	r3, #1
 8003b42:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003b44:	9b01      	ldr	r3, [sp, #4]
 8003b46:	2b00      	cmp	r3, #0
 8003b48:	d1f0      	bne.n	8003b2c <chPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
    /*lint -restore*/
    n--;
  }
}
 8003b4a:	b005      	add	sp, #20
 8003b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08003b50 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8003b50:	b500      	push	{lr}
 8003b52:	b085      	sub	sp, #20
 8003b54:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 8003b56:	9b01      	ldr	r3, [sp, #4]
 8003b58:	681b      	ldr	r3, [r3, #0]
 8003b5a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003b5c:	9b03      	ldr	r3, [sp, #12]
 8003b5e:	2b00      	cmp	r3, #0
 8003b60:	d005      	beq.n	8003b6e <chPoolAllocI+0x1e>
    mp->next = mp->next->next;
 8003b62:	9b01      	ldr	r3, [sp, #4]
 8003b64:	681b      	ldr	r3, [r3, #0]
 8003b66:	681a      	ldr	r2, [r3, #0]
 8003b68:	9b01      	ldr	r3, [sp, #4]
 8003b6a:	601a      	str	r2, [r3, #0]
 8003b6c:	e00b      	b.n	8003b86 <chPoolAllocI+0x36>
  }
  else if (mp->provider != NULL) {
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	689b      	ldr	r3, [r3, #8]
 8003b72:	2b00      	cmp	r3, #0
 8003b74:	d007      	beq.n	8003b86 <chPoolAllocI+0x36>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8003b76:	9b01      	ldr	r3, [sp, #4]
 8003b78:	689b      	ldr	r3, [r3, #8]
 8003b7a:	9a01      	ldr	r2, [sp, #4]
 8003b7c:	6852      	ldr	r2, [r2, #4]
 8003b7e:	4610      	mov	r0, r2
 8003b80:	2104      	movs	r1, #4
 8003b82:	4798      	blx	r3
 8003b84:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8003b86:	9b03      	ldr	r3, [sp, #12]
}
 8003b88:	4618      	mov	r0, r3
 8003b8a:	b005      	add	sp, #20
 8003b8c:	f85d fb04 	ldr.w	pc, [sp], #4

08003b90 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003b90:	b500      	push	{lr}
 8003b92:	b085      	sub	sp, #20
 8003b94:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8003b96:	f7ff ff83 	bl	8003aa0 <chSysLock>
  objp = chPoolAllocI(mp);
 8003b9a:	9801      	ldr	r0, [sp, #4]
 8003b9c:	f7ff ffd8 	bl	8003b50 <chPoolAllocI>
 8003ba0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003ba2:	f7ff ff85 	bl	8003ab0 <chSysUnlock>

  return objp;
 8003ba6:	9b03      	ldr	r3, [sp, #12]
}
 8003ba8:	4618      	mov	r0, r3
 8003baa:	b005      	add	sp, #20
 8003bac:	f85d fb04 	ldr.w	pc, [sp], #4

08003bb0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8003bb0:	b084      	sub	sp, #16
 8003bb2:	9001      	str	r0, [sp, #4]
 8003bb4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8003bb6:	9b00      	ldr	r3, [sp, #0]
 8003bb8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003bba:	9b01      	ldr	r3, [sp, #4]
 8003bbc:	681a      	ldr	r2, [r3, #0]
 8003bbe:	9b03      	ldr	r3, [sp, #12]
 8003bc0:	601a      	str	r2, [r3, #0]
  mp->next = php;
 8003bc2:	9b01      	ldr	r3, [sp, #4]
 8003bc4:	9a03      	ldr	r2, [sp, #12]
 8003bc6:	601a      	str	r2, [r3, #0]
}
 8003bc8:	b004      	add	sp, #16
 8003bca:	4770      	bx	lr
 8003bcc:	f3af 8000 	nop.w

08003bd0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8003bd0:	b500      	push	{lr}
 8003bd2:	b083      	sub	sp, #12
 8003bd4:	9001      	str	r0, [sp, #4]
 8003bd6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003bd8:	f7ff ff62 	bl	8003aa0 <chSysLock>
  chPoolFreeI(mp, objp);
 8003bdc:	9801      	ldr	r0, [sp, #4]
 8003bde:	9900      	ldr	r1, [sp, #0]
 8003be0:	f7ff ffe6 	bl	8003bb0 <chPoolFreeI>
  chSysUnlock();
 8003be4:	f7ff ff64 	bl	8003ab0 <chSysUnlock>
}
 8003be8:	b003      	add	sp, #12
 8003bea:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bee:	bf00      	nop

08003bf0 <chGuardedPoolObjectInit>:
 *                      memory pool, the minimum accepted size is the size
 *                      of a pointer to void.
 *
 * @init
 */
void chGuardedPoolObjectInit(guarded_memory_pool_t *gmp, size_t size) {
 8003bf0:	b500      	push	{lr}
 8003bf2:	b083      	sub	sp, #12
 8003bf4:	9001      	str	r0, [sp, #4]
 8003bf6:	9100      	str	r1, [sp, #0]

  chPoolObjectInit(&gmp->pool, size, NULL);
 8003bf8:	9b01      	ldr	r3, [sp, #4]
 8003bfa:	330c      	adds	r3, #12
 8003bfc:	4618      	mov	r0, r3
 8003bfe:	9900      	ldr	r1, [sp, #0]
 8003c00:	2200      	movs	r2, #0
 8003c02:	f7ff ff7d 	bl	8003b00 <chPoolObjectInit>
  chSemObjectInit(&gmp->sem, (cnt_t)0);
 8003c06:	9b01      	ldr	r3, [sp, #4]
 8003c08:	4618      	mov	r0, r3
 8003c0a:	2100      	movs	r1, #0
 8003c0c:	f7fe f898 	bl	8001d40 <chSemObjectInit>
}
 8003c10:	b003      	add	sp, #12
 8003c12:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c16:	bf00      	nop
 8003c18:	f3af 8000 	nop.w
 8003c1c:	f3af 8000 	nop.w

08003c20 <chGuardedPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 8003c20:	b500      	push	{lr}
 8003c22:	b085      	sub	sp, #20
 8003c24:	9003      	str	r0, [sp, #12]
 8003c26:	9102      	str	r1, [sp, #8]
 8003c28:	9201      	str	r2, [sp, #4]

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8003c2a:	e00b      	b.n	8003c44 <chGuardedPoolLoadArray+0x24>
    chGuardedPoolAdd(gmp, p);
 8003c2c:	9803      	ldr	r0, [sp, #12]
 8003c2e:	9902      	ldr	r1, [sp, #8]
 8003c30:	f7ff ff56 	bl	8003ae0 <chGuardedPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8003c34:	9b03      	ldr	r3, [sp, #12]
 8003c36:	691b      	ldr	r3, [r3, #16]
 8003c38:	9a02      	ldr	r2, [sp, #8]
 8003c3a:	4413      	add	r3, r2
 8003c3c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003c3e:	9b01      	ldr	r3, [sp, #4]
 8003c40:	3b01      	subs	r3, #1
 8003c42:	9301      	str	r3, [sp, #4]
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8003c44:	9b01      	ldr	r3, [sp, #4]
 8003c46:	2b00      	cmp	r3, #0
 8003c48:	d1f0      	bne.n	8003c2c <chGuardedPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
    /*lint -restore*/
    n--;
  }
}
 8003c4a:	b005      	add	sp, #20
 8003c4c:	f85d fb04 	ldr.w	pc, [sp], #4

08003c50 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
 8003c50:	b500      	push	{lr}
 8003c52:	b085      	sub	sp, #20
 8003c54:	9001      	str	r0, [sp, #4]
 8003c56:	9100      	str	r1, [sp, #0]
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8003c58:	9b01      	ldr	r3, [sp, #4]
 8003c5a:	4618      	mov	r0, r3
 8003c5c:	9900      	ldr	r1, [sp, #0]
 8003c5e:	f7fe f907 	bl	8001e70 <chSemWaitTimeoutS>
 8003c62:	9003      	str	r0, [sp, #12]
  if (msg != MSG_OK) {
 8003c64:	9b03      	ldr	r3, [sp, #12]
 8003c66:	2b00      	cmp	r3, #0
 8003c68:	d001      	beq.n	8003c6e <chGuardedPoolAllocTimeoutS+0x1e>
    return NULL;
 8003c6a:	2300      	movs	r3, #0
 8003c6c:	e005      	b.n	8003c7a <chGuardedPoolAllocTimeoutS+0x2a>
  }

  return chPoolAllocI(&gmp->pool);
 8003c6e:	9b01      	ldr	r3, [sp, #4]
 8003c70:	330c      	adds	r3, #12
 8003c72:	4618      	mov	r0, r3
 8003c74:	f7ff ff6c 	bl	8003b50 <chPoolAllocI>
 8003c78:	4603      	mov	r3, r0
}
 8003c7a:	4618      	mov	r0, r3
 8003c7c:	b005      	add	sp, #20
 8003c7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c82:	bf00      	nop
 8003c84:	f3af 8000 	nop.w
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <chGuardedPoolAllocTimeout>:
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
                                systime_t timeout) {
 8003c90:	b500      	push	{lr}
 8003c92:	b085      	sub	sp, #20
 8003c94:	9001      	str	r0, [sp, #4]
 8003c96:	9100      	str	r1, [sp, #0]
  void *p;

  chSysLock();
 8003c98:	f7ff ff02 	bl	8003aa0 <chSysLock>
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
 8003c9c:	9801      	ldr	r0, [sp, #4]
 8003c9e:	9900      	ldr	r1, [sp, #0]
 8003ca0:	f7ff ffd6 	bl	8003c50 <chGuardedPoolAllocTimeoutS>
 8003ca4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003ca6:	f7ff ff03 	bl	8003ab0 <chSysUnlock>

  return p;
 8003caa:	9b03      	ldr	r3, [sp, #12]
}
 8003cac:	4618      	mov	r0, r3
 8003cae:	b005      	add	sp, #20
 8003cb0:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb4:	f3af 8000 	nop.w
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <chGuardedPoolFreeI>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {
 8003cc0:	b500      	push	{lr}
 8003cc2:	b083      	sub	sp, #12
 8003cc4:	9001      	str	r0, [sp, #4]
 8003cc6:	9100      	str	r1, [sp, #0]

  chPoolFreeI(&gmp->pool, objp);
 8003cc8:	9b01      	ldr	r3, [sp, #4]
 8003cca:	330c      	adds	r3, #12
 8003ccc:	4618      	mov	r0, r3
 8003cce:	9900      	ldr	r1, [sp, #0]
 8003cd0:	f7ff ff6e 	bl	8003bb0 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8003cd4:	9b01      	ldr	r3, [sp, #4]
 8003cd6:	4618      	mov	r0, r3
 8003cd8:	f7fe f91a 	bl	8001f10 <chSemSignalI>
}
 8003cdc:	b003      	add	sp, #12
 8003cde:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ce2:	bf00      	nop
 8003ce4:	f3af 8000 	nop.w
 8003ce8:	f3af 8000 	nop.w
 8003cec:	f3af 8000 	nop.w

08003cf0 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
 8003cf0:	b500      	push	{lr}
 8003cf2:	b083      	sub	sp, #12
 8003cf4:	9001      	str	r0, [sp, #4]
 8003cf6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003cf8:	f7ff fed2 	bl	8003aa0 <chSysLock>
  chGuardedPoolFreeI(gmp, objp);
 8003cfc:	9801      	ldr	r0, [sp, #4]
 8003cfe:	9900      	ldr	r1, [sp, #0]
 8003d00:	f7ff ffde 	bl	8003cc0 <chGuardedPoolFreeI>
  chSchRescheduleS();
 8003d04:	f7fd f944 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8003d08:	f7ff fed2 	bl	8003ab0 <chSysUnlock>
}
 8003d0c:	b003      	add	sp, #12
 8003d0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d12:	bf00      	nop
	...

08003d20 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003d20:	b082      	sub	sp, #8
 8003d22:	2320      	movs	r3, #32
 8003d24:	9301      	str	r3, [sp, #4]
 8003d26:	9b01      	ldr	r3, [sp, #4]
 8003d28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003d2c:	b002      	add	sp, #8
 8003d2e:	4770      	bx	lr

08003d30 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003d30:	b082      	sub	sp, #8
 8003d32:	2300      	movs	r3, #0
 8003d34:	9301      	str	r3, [sp, #4]
 8003d36:	9b01      	ldr	r3, [sp, #4]
 8003d38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003d3c:	b002      	add	sp, #8
 8003d3e:	4770      	bx	lr

08003d40 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003d40:	b508      	push	{r3, lr}

  port_lock();
 8003d42:	f7ff ffed 	bl	8003d20 <port_lock>
}
 8003d46:	bd08      	pop	{r3, pc}
 8003d48:	f3af 8000 	nop.w
 8003d4c:	f3af 8000 	nop.w

08003d50 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003d50:	b508      	push	{r3, lr}

  port_unlock();
 8003d52:	f7ff ffed 	bl	8003d30 <port_unlock>
}
 8003d56:	bd08      	pop	{r3, pc}
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003d60:	b510      	push	{r4, lr}
 8003d62:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003d64:	f3ef 8309 	mrs	r3, PSP
 8003d68:	461c      	mov	r4, r3
  return(result);
 8003d6a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8003d6c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003d6e:	9b01      	ldr	r3, [sp, #4]
 8003d70:	3320      	adds	r3, #32
 8003d72:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003d74:	9b01      	ldr	r3, [sp, #4]
 8003d76:	9300      	str	r3, [sp, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003d78:	9b00      	ldr	r3, [sp, #0]
 8003d7a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8003d7e:	f7ff ffe7 	bl	8003d50 <port_unlock_from_isr>
}
 8003d82:	b002      	add	sp, #8
 8003d84:	bd10      	pop	{r4, pc}
 8003d86:	bf00      	nop
 8003d88:	f3af 8000 	nop.w
 8003d8c:	f3af 8000 	nop.w

08003d90 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003d90:	b510      	push	{r4, lr}
 8003d92:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003d94:	f7ff ffd4 	bl	8003d40 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003d98:	4b13      	ldr	r3, [pc, #76]	; (8003de8 <_port_irq_epilogue+0x58>)
 8003d9a:	685b      	ldr	r3, [r3, #4]
 8003d9c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003da0:	2b00      	cmp	r3, #0
 8003da2:	d01d      	beq.n	8003de0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003da4:	f3ef 8309 	mrs	r3, PSP
 8003da8:	461c      	mov	r4, r3
  return(result);
 8003daa:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8003dac:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003dae:	9b01      	ldr	r3, [sp, #4]
 8003db0:	3b20      	subs	r3, #32
 8003db2:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003db4:	9b01      	ldr	r3, [sp, #4]
 8003db6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003dba:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8003dbc:	9b01      	ldr	r3, [sp, #4]
 8003dbe:	9300      	str	r3, [sp, #0]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003dc0:	9b00      	ldr	r3, [sp, #0]
 8003dc2:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003dc6:	f7fd f8f3 	bl	8000fb0 <chSchIsPreemptionRequired>
 8003dca:	4603      	mov	r3, r0
 8003dcc:	2b00      	cmp	r3, #0
 8003dce:	d003      	beq.n	8003dd8 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003dd0:	9b01      	ldr	r3, [sp, #4]
 8003dd2:	4a06      	ldr	r2, [pc, #24]	; (8003dec <_port_irq_epilogue+0x5c>)
 8003dd4:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003dd6:	e005      	b.n	8003de4 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003dd8:	9b01      	ldr	r3, [sp, #4]
 8003dda:	4a05      	ldr	r2, [pc, #20]	; (8003df0 <_port_irq_epilogue+0x60>)
 8003ddc:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003dde:	e001      	b.n	8003de4 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
 8003de0:	f7ff ffb6 	bl	8003d50 <port_unlock_from_isr>
}
 8003de4:	b002      	add	sp, #8
 8003de6:	bd10      	pop	{r4, pc}
 8003de8:	e000ed00 	.word	0xe000ed00
 8003dec:	080002d5 	.word	0x080002d5
 8003df0:	080002d8 	.word	0x080002d8
	...

08003e00 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8003e00:	4770      	bx	lr
 8003e02:	bf00      	nop
 8003e04:	f3af 8000 	nop.w
 8003e08:	f3af 8000 	nop.w
 8003e0c:	f3af 8000 	nop.w

08003e10 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003e10:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003e12:	f7ff fff5 	bl	8003e00 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003e16:	f001 fccb 	bl	80057b0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8003e1a:	4806      	ldr	r0, [pc, #24]	; (8003e34 <halInit+0x24>)
 8003e1c:	f002 f8b8 	bl	8005f90 <_pal_lld_init>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8003e20:	f001 f906 	bl	8005030 <i2cInit>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8003e24:	f001 fb3c 	bl	80054a0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003e28:	f003 faca 	bl	80073c0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003e2c:	f000 f830 	bl	8003e90 <stInit>
#endif
}
 8003e30:	bd08      	pop	{r3, pc}
 8003e32:	bf00      	nop
 8003e34:	0800dfb8 	.word	0x0800dfb8
	...

08003e40 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003e40:	b082      	sub	sp, #8
 8003e42:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003e44:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003e48:	9b01      	ldr	r3, [sp, #4]
 8003e4a:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003e4c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003e50:	2200      	movs	r2, #0
 8003e52:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003e54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003e58:	2202      	movs	r2, #2
 8003e5a:	60da      	str	r2, [r3, #12]
}
 8003e5c:	b002      	add	sp, #8
 8003e5e:	4770      	bx	lr

08003e60 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003e60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003e64:	2200      	movs	r2, #0
 8003e66:	60da      	str	r2, [r3, #12]
}
 8003e68:	4770      	bx	lr
 8003e6a:	bf00      	nop
 8003e6c:	f3af 8000 	nop.w

08003e70 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003e70:	b082      	sub	sp, #8
 8003e72:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003e74:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003e78:	9b01      	ldr	r3, [sp, #4]
 8003e7a:	6353      	str	r3, [r2, #52]	; 0x34
}
 8003e7c:	b002      	add	sp, #8
 8003e7e:	4770      	bx	lr

08003e80 <st_lld_get_alarm>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_alarm(void) {

  return (systime_t)STM32_ST_TIM->CCR[0];
 8003e80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003e84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8003e86:	4618      	mov	r0, r3
 8003e88:	4770      	bx	lr
 8003e8a:	bf00      	nop
 8003e8c:	f3af 8000 	nop.w

08003e90 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8003e90:	b508      	push	{r3, lr}

  st_lld_init();
 8003e92:	f002 ffd5 	bl	8006e40 <st_lld_init>
}
 8003e96:	bd08      	pop	{r3, pc}
 8003e98:	f3af 8000 	nop.w
 8003e9c:	f3af 8000 	nop.w

08003ea0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8003ea0:	b500      	push	{lr}
 8003ea2:	b083      	sub	sp, #12
 8003ea4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8003ea6:	9801      	ldr	r0, [sp, #4]
 8003ea8:	f7ff ffca 	bl	8003e40 <st_lld_start_alarm>
}
 8003eac:	b003      	add	sp, #12
 8003eae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eb2:	bf00      	nop
 8003eb4:	f3af 8000 	nop.w
 8003eb8:	f3af 8000 	nop.w
 8003ebc:	f3af 8000 	nop.w

08003ec0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8003ec0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8003ec2:	f7ff ffcd 	bl	8003e60 <st_lld_stop_alarm>
}
 8003ec6:	bd08      	pop	{r3, pc}
 8003ec8:	f3af 8000 	nop.w
 8003ecc:	f3af 8000 	nop.w

08003ed0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8003ed0:	b500      	push	{lr}
 8003ed2:	b083      	sub	sp, #12
 8003ed4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8003ed6:	9801      	ldr	r0, [sp, #4]
 8003ed8:	f7ff ffca 	bl	8003e70 <st_lld_set_alarm>
}
 8003edc:	b003      	add	sp, #12
 8003ede:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ee2:	bf00      	nop
 8003ee4:	f3af 8000 	nop.w
 8003ee8:	f3af 8000 	nop.w
 8003eec:	f3af 8000 	nop.w

08003ef0 <stGetAlarm>:
 *
 * @return              The currently set alarm time.
 *
 * @api
 */
systime_t stGetAlarm(void) {
 8003ef0:	b508      	push	{r3, lr}

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
 8003ef2:	f7ff ffc5 	bl	8003e80 <st_lld_get_alarm>
 8003ef6:	4603      	mov	r3, r0
}
 8003ef8:	4618      	mov	r0, r3
 8003efa:	bd08      	pop	{r3, pc}
 8003efc:	0000      	movs	r0, r0
	...

08003f00 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003f00:	b082      	sub	sp, #8
 8003f02:	2320      	movs	r3, #32
 8003f04:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f06:	9b01      	ldr	r3, [sp, #4]
 8003f08:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003f0c:	b002      	add	sp, #8
 8003f0e:	4770      	bx	lr

08003f10 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003f10:	b082      	sub	sp, #8
 8003f12:	2300      	movs	r3, #0
 8003f14:	9301      	str	r3, [sp, #4]
 8003f16:	9b01      	ldr	r3, [sp, #4]
 8003f18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003f1c:	b002      	add	sp, #8
 8003f1e:	4770      	bx	lr

08003f20 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003f20:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003f24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8003f26:	4618      	mov	r0, r3
 8003f28:	4770      	bx	lr
 8003f2a:	bf00      	nop
 8003f2c:	f3af 8000 	nop.w

08003f30 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003f30:	b508      	push	{r3, lr}

  return stGetCounter();
 8003f32:	f7ff fff5 	bl	8003f20 <st_lld_get_counter>
 8003f36:	4603      	mov	r3, r0
}
 8003f38:	4618      	mov	r0, r3
 8003f3a:	bd08      	pop	{r3, pc}
 8003f3c:	f3af 8000 	nop.w

08003f40 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003f40:	b082      	sub	sp, #8
 8003f42:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8003f44:	9b01      	ldr	r3, [sp, #4]
 8003f46:	9a01      	ldr	r2, [sp, #4]
 8003f48:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8003f4a:	9b01      	ldr	r3, [sp, #4]
 8003f4c:	9a01      	ldr	r2, [sp, #4]
 8003f4e:	605a      	str	r2, [r3, #4]
}
 8003f50:	b002      	add	sp, #8
 8003f52:	4770      	bx	lr
 8003f54:	f3af 8000 	nop.w
 8003f58:	f3af 8000 	nop.w
 8003f5c:	f3af 8000 	nop.w

08003f60 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003f60:	b508      	push	{r3, lr}

  port_lock();
 8003f62:	f7ff ffcd 	bl	8003f00 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003f66:	bd08      	pop	{r3, pc}
 8003f68:	f3af 8000 	nop.w
 8003f6c:	f3af 8000 	nop.w

08003f70 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003f70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8003f72:	f7ff ffcd 	bl	8003f10 <port_unlock>
}
 8003f76:	bd08      	pop	{r3, pc}
 8003f78:	f3af 8000 	nop.w
 8003f7c:	f3af 8000 	nop.w

08003f80 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003f80:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003f82:	f7ff ffd5 	bl	8003f30 <port_timer_get_time>
 8003f86:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003f88:	4618      	mov	r0, r3
 8003f8a:	bd08      	pop	{r3, pc}
 8003f8c:	f3af 8000 	nop.w

08003f90 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003f90:	b500      	push	{lr}
 8003f92:	b083      	sub	sp, #12
 8003f94:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003f96:	9801      	ldr	r0, [sp, #4]
 8003f98:	f7ff ffd2 	bl	8003f40 <queue_init>
}
 8003f9c:	b003      	add	sp, #12
 8003f9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fa2:	bf00      	nop
 8003fa4:	f3af 8000 	nop.w
 8003fa8:	f3af 8000 	nop.w
 8003fac:	f3af 8000 	nop.w

08003fb0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003fb0:	b508      	push	{r3, lr}

  chSysLock();
 8003fb2:	f7ff ffd5 	bl	8003f60 <chSysLock>
}
 8003fb6:	bd08      	pop	{r3, pc}
 8003fb8:	f3af 8000 	nop.w
 8003fbc:	f3af 8000 	nop.w

08003fc0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003fc0:	b508      	push	{r3, lr}

  chSysUnlock();
 8003fc2:	f7ff ffd5 	bl	8003f70 <chSysUnlock>
}
 8003fc6:	bd08      	pop	{r3, pc}
 8003fc8:	f3af 8000 	nop.w
 8003fcc:	f3af 8000 	nop.w

08003fd0 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8003fd0:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8003fd2:	f7ff ffd5 	bl	8003f80 <chVTGetSystemTimeX>
 8003fd6:	4603      	mov	r3, r0
}
 8003fd8:	4618      	mov	r0, r3
 8003fda:	bd08      	pop	{r3, pc}
 8003fdc:	f3af 8000 	nop.w

08003fe0 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b083      	sub	sp, #12
 8003fe4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8003fe6:	9801      	ldr	r0, [sp, #4]
 8003fe8:	f7ff ffd2 	bl	8003f90 <chThdQueueObjectInit>
}
 8003fec:	b003      	add	sp, #12
 8003fee:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ff2:	bf00      	nop
 8003ff4:	f3af 8000 	nop.w
 8003ff8:	f3af 8000 	nop.w
 8003ffc:	f3af 8000 	nop.w

08004000 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8004000:	b500      	push	{lr}
 8004002:	b083      	sub	sp, #12
 8004004:	9001      	str	r0, [sp, #4]
 8004006:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8004008:	9801      	ldr	r0, [sp, #4]
 800400a:	9900      	ldr	r1, [sp, #0]
 800400c:	f7fd fc50 	bl	80018b0 <chThdEnqueueTimeoutS>
 8004010:	4603      	mov	r3, r0
}
 8004012:	4618      	mov	r0, r3
 8004014:	b003      	add	sp, #12
 8004016:	f85d fb04 	ldr.w	pc, [sp], #4
 800401a:	bf00      	nop
 800401c:	f3af 8000 	nop.w

08004020 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004020:	b500      	push	{lr}
 8004022:	b083      	sub	sp, #12
 8004024:	9001      	str	r0, [sp, #4]
 8004026:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8004028:	9801      	ldr	r0, [sp, #4]
 800402a:	9900      	ldr	r1, [sp, #0]
 800402c:	f7fd fc60 	bl	80018f0 <chThdDequeueNextI>
}
 8004030:	b003      	add	sp, #12
 8004032:	f85d fb04 	ldr.w	pc, [sp], #4
 8004036:	bf00      	nop
 8004038:	f3af 8000 	nop.w
 800403c:	f3af 8000 	nop.w

08004040 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8004040:	b500      	push	{lr}
 8004042:	b083      	sub	sp, #12
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8004048:	9801      	ldr	r0, [sp, #4]
 800404a:	9900      	ldr	r1, [sp, #0]
 800404c:	f7fd fc68 	bl	8001920 <chThdDequeueAllI>
}
 8004050:	b003      	add	sp, #12
 8004052:	f85d fb04 	ldr.w	pc, [sp], #4
 8004056:	bf00      	nop
 8004058:	f3af 8000 	nop.w
 800405c:	f3af 8000 	nop.w

08004060 <ibqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t infy, void *link) {
 8004060:	b500      	push	{lr}
 8004062:	b085      	sub	sp, #20
 8004064:	9003      	str	r0, [sp, #12]
 8004066:	9201      	str	r2, [sp, #4]
 8004068:	9300      	str	r3, [sp, #0]
 800406a:	460b      	mov	r3, r1
 800406c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
 8004070:	9b03      	ldr	r3, [sp, #12]
 8004072:	4618      	mov	r0, r3
 8004074:	f7ff ffb4 	bl	8003fe0 <osalThreadQueueObjectInit>
  ibqp->suspended = suspended;
 8004078:	9b03      	ldr	r3, [sp, #12]
 800407a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800407e:	721a      	strb	r2, [r3, #8]
  ibqp->bcounter  = 0;
 8004080:	9b03      	ldr	r3, [sp, #12]
 8004082:	2200      	movs	r2, #0
 8004084:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = bp;
 8004086:	9b03      	ldr	r3, [sp, #12]
 8004088:	9a01      	ldr	r2, [sp, #4]
 800408a:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = bp;
 800408c:	9b03      	ldr	r3, [sp, #12]
 800408e:	9a01      	ldr	r2, [sp, #4]
 8004090:	611a      	str	r2, [r3, #16]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8004092:	9b00      	ldr	r3, [sp, #0]
 8004094:	3304      	adds	r3, #4
 8004096:	9a06      	ldr	r2, [sp, #24]
 8004098:	fb02 f303 	mul.w	r3, r2, r3
 800409c:	9a01      	ldr	r2, [sp, #4]
 800409e:	441a      	add	r2, r3
 80040a0:	9b03      	ldr	r3, [sp, #12]
 80040a2:	619a      	str	r2, [r3, #24]
  ibqp->bsize     = size + sizeof (size_t);
 80040a4:	9b00      	ldr	r3, [sp, #0]
 80040a6:	1d1a      	adds	r2, r3, #4
 80040a8:	9b03      	ldr	r3, [sp, #12]
 80040aa:	61da      	str	r2, [r3, #28]
  ibqp->bn        = n;
 80040ac:	9b03      	ldr	r3, [sp, #12]
 80040ae:	9a06      	ldr	r2, [sp, #24]
 80040b0:	621a      	str	r2, [r3, #32]
  ibqp->buffers   = bp;
 80040b2:	9b03      	ldr	r3, [sp, #12]
 80040b4:	9a01      	ldr	r2, [sp, #4]
 80040b6:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->ptr       = NULL;
 80040b8:	9b03      	ldr	r3, [sp, #12]
 80040ba:	2200      	movs	r2, #0
 80040bc:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 80040be:	9b03      	ldr	r3, [sp, #12]
 80040c0:	2200      	movs	r2, #0
 80040c2:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->notify    = infy;
 80040c4:	9b03      	ldr	r3, [sp, #12]
 80040c6:	9a07      	ldr	r2, [sp, #28]
 80040c8:	631a      	str	r2, [r3, #48]	; 0x30
  ibqp->link      = link;
 80040ca:	9b03      	ldr	r3, [sp, #12]
 80040cc:	9a08      	ldr	r2, [sp, #32]
 80040ce:	635a      	str	r2, [r3, #52]	; 0x34
}
 80040d0:	b005      	add	sp, #20
 80040d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80040d6:	bf00      	nop
 80040d8:	f3af 8000 	nop.w
 80040dc:	f3af 8000 	nop.w

080040e0 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 80040e0:	b500      	push	{lr}
 80040e2:	b083      	sub	sp, #12
 80040e4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  ibqp->bcounter  = 0;
 80040e6:	9b01      	ldr	r3, [sp, #4]
 80040e8:	2200      	movs	r2, #0
 80040ea:	60da      	str	r2, [r3, #12]
  ibqp->brdptr    = ibqp->buffers;
 80040ec:	9b01      	ldr	r3, [sp, #4]
 80040ee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80040f0:	9b01      	ldr	r3, [sp, #4]
 80040f2:	615a      	str	r2, [r3, #20]
  ibqp->bwrptr    = ibqp->buffers;
 80040f4:	9b01      	ldr	r3, [sp, #4]
 80040f6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80040f8:	9b01      	ldr	r3, [sp, #4]
 80040fa:	611a      	str	r2, [r3, #16]
  ibqp->ptr       = NULL;
 80040fc:	9b01      	ldr	r3, [sp, #4]
 80040fe:	2200      	movs	r2, #0
 8004100:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top       = NULL;
 8004102:	9b01      	ldr	r3, [sp, #4]
 8004104:	2200      	movs	r2, #0
 8004106:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8004108:	9b01      	ldr	r3, [sp, #4]
 800410a:	4618      	mov	r0, r3
 800410c:	f06f 0101 	mvn.w	r1, #1
 8004110:	f7ff ff96 	bl	8004040 <osalThreadDequeueAllI>
}
 8004114:	b003      	add	sp, #12
 8004116:	f85d fb04 	ldr.w	pc, [sp], #4
 800411a:	bf00      	nop
 800411c:	f3af 8000 	nop.w

08004120 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8004120:	b082      	sub	sp, #8
 8004122:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8004124:	9b01      	ldr	r3, [sp, #4]
 8004126:	691a      	ldr	r2, [r3, #16]
 8004128:	9b01      	ldr	r3, [sp, #4]
 800412a:	695b      	ldr	r3, [r3, #20]
 800412c:	429a      	cmp	r2, r3
 800412e:	d105      	bne.n	800413c <ibqGetEmptyBufferI+0x1c>
 8004130:	9b01      	ldr	r3, [sp, #4]
 8004132:	68db      	ldr	r3, [r3, #12]
 8004134:	2b00      	cmp	r3, #0
 8004136:	d001      	beq.n	800413c <ibqGetEmptyBufferI+0x1c>
 8004138:	2301      	movs	r3, #1
 800413a:	e000      	b.n	800413e <ibqGetEmptyBufferI+0x1e>
 800413c:	2300      	movs	r3, #0
 800413e:	f003 0301 	and.w	r3, r3, #1
 8004142:	b2db      	uxtb	r3, r3
 8004144:	2b00      	cmp	r3, #0
 8004146:	d001      	beq.n	800414c <ibqGetEmptyBufferI+0x2c>
    return NULL;
 8004148:	2300      	movs	r3, #0
 800414a:	e002      	b.n	8004152 <ibqGetEmptyBufferI+0x32>
  }

  return ibqp->bwrptr + sizeof (size_t);
 800414c:	9b01      	ldr	r3, [sp, #4]
 800414e:	691b      	ldr	r3, [r3, #16]
 8004150:	3304      	adds	r3, #4
}
 8004152:	4618      	mov	r0, r3
 8004154:	b002      	add	sp, #8
 8004156:	4770      	bx	lr
 8004158:	f3af 8000 	nop.w
 800415c:	f3af 8000 	nop.w

08004160 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8004160:	b500      	push	{lr}
 8004162:	b083      	sub	sp, #12
 8004164:	9001      	str	r0, [sp, #4]
 8004166:	9100      	str	r1, [sp, #0]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8004168:	9b01      	ldr	r3, [sp, #4]
 800416a:	691b      	ldr	r3, [r3, #16]
 800416c:	9a00      	ldr	r2, [sp, #0]
 800416e:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8004170:	9b01      	ldr	r3, [sp, #4]
 8004172:	68db      	ldr	r3, [r3, #12]
 8004174:	1c5a      	adds	r2, r3, #1
 8004176:	9b01      	ldr	r3, [sp, #4]
 8004178:	60da      	str	r2, [r3, #12]
  ibqp->bwrptr += ibqp->bsize;
 800417a:	9b01      	ldr	r3, [sp, #4]
 800417c:	691a      	ldr	r2, [r3, #16]
 800417e:	9b01      	ldr	r3, [sp, #4]
 8004180:	69db      	ldr	r3, [r3, #28]
 8004182:	441a      	add	r2, r3
 8004184:	9b01      	ldr	r3, [sp, #4]
 8004186:	611a      	str	r2, [r3, #16]
  if (ibqp->bwrptr >= ibqp->btop) {
 8004188:	9b01      	ldr	r3, [sp, #4]
 800418a:	691a      	ldr	r2, [r3, #16]
 800418c:	9b01      	ldr	r3, [sp, #4]
 800418e:	699b      	ldr	r3, [r3, #24]
 8004190:	429a      	cmp	r2, r3
 8004192:	d303      	bcc.n	800419c <ibqPostFullBufferI+0x3c>
    ibqp->bwrptr = ibqp->buffers;
 8004194:	9b01      	ldr	r3, [sp, #4]
 8004196:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004198:	9b01      	ldr	r3, [sp, #4]
 800419a:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 800419c:	9b01      	ldr	r3, [sp, #4]
 800419e:	4618      	mov	r0, r3
 80041a0:	2100      	movs	r1, #0
 80041a2:	f7ff ff3d 	bl	8004020 <osalThreadDequeueNextI>
}
 80041a6:	b003      	add	sp, #12
 80041a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80041ac:	f3af 8000 	nop.w

080041b0 <ibqGetFullBufferTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetFullBufferTimeout(input_buffers_queue_t *ibqp,
                              systime_t timeout) {
 80041b0:	b500      	push	{lr}
 80041b2:	b085      	sub	sp, #20
 80041b4:	9001      	str	r0, [sp, #4]
 80041b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 80041b8:	f7ff fefa 	bl	8003fb0 <osalSysLock>
  msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80041bc:	9801      	ldr	r0, [sp, #4]
 80041be:	9900      	ldr	r1, [sp, #0]
 80041c0:	f000 f80e 	bl	80041e0 <ibqGetFullBufferTimeoutS>
 80041c4:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 80041c6:	f7ff fefb 	bl	8003fc0 <osalSysUnlock>

  return msg;
 80041ca:	9b03      	ldr	r3, [sp, #12]
}
 80041cc:	4618      	mov	r0, r3
 80041ce:	b005      	add	sp, #20
 80041d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80041d4:	f3af 8000 	nop.w
 80041d8:	f3af 8000 	nop.w
 80041dc:	f3af 8000 	nop.w

080041e0 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 80041e0:	b500      	push	{lr}
 80041e2:	b085      	sub	sp, #20
 80041e4:	9001      	str	r0, [sp, #4]
 80041e6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 80041e8:	e011      	b.n	800420e <ibqGetFullBufferTimeoutS+0x2e>
    if (ibqp->suspended) {
 80041ea:	9b01      	ldr	r3, [sp, #4]
 80041ec:	7a1b      	ldrb	r3, [r3, #8]
 80041ee:	2b00      	cmp	r3, #0
 80041f0:	d002      	beq.n	80041f8 <ibqGetFullBufferTimeoutS+0x18>
      return MSG_RESET;
 80041f2:	f06f 0301 	mvn.w	r3, #1
 80041f6:	e01c      	b.n	8004232 <ibqGetFullBufferTimeoutS+0x52>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	4618      	mov	r0, r3
 80041fc:	9900      	ldr	r1, [sp, #0]
 80041fe:	f7ff feff 	bl	8004000 <osalThreadEnqueueTimeoutS>
 8004202:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004204:	9b03      	ldr	r3, [sp, #12]
 8004206:	2b00      	cmp	r3, #0
 8004208:	da01      	bge.n	800420e <ibqGetFullBufferTimeoutS+0x2e>
       return msg;
 800420a:	9b03      	ldr	r3, [sp, #12]
 800420c:	e011      	b.n	8004232 <ibqGetFullBufferTimeoutS+0x52>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 800420e:	9b01      	ldr	r3, [sp, #4]
 8004210:	68db      	ldr	r3, [r3, #12]
 8004212:	2b00      	cmp	r3, #0
 8004214:	d0e9      	beq.n	80041ea <ibqGetFullBufferTimeoutS+0xa>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8004216:	9b01      	ldr	r3, [sp, #4]
 8004218:	695b      	ldr	r3, [r3, #20]
 800421a:	1d1a      	adds	r2, r3, #4
 800421c:	9b01      	ldr	r3, [sp, #4]
 800421e:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8004220:	9b01      	ldr	r3, [sp, #4]
 8004222:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004224:	9b01      	ldr	r3, [sp, #4]
 8004226:	695b      	ldr	r3, [r3, #20]
 8004228:	681b      	ldr	r3, [r3, #0]
 800422a:	441a      	add	r2, r3
 800422c:	9b01      	ldr	r3, [sp, #4]
 800422e:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 8004230:	2300      	movs	r3, #0
}
 8004232:	4618      	mov	r0, r3
 8004234:	b005      	add	sp, #20
 8004236:	f85d fb04 	ldr.w	pc, [sp], #4
 800423a:	bf00      	nop
 800423c:	f3af 8000 	nop.w

08004240 <ibqReleaseEmptyBuffer>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @api
 */
void ibqReleaseEmptyBuffer(input_buffers_queue_t *ibqp) {
 8004240:	b500      	push	{lr}
 8004242:	b083      	sub	sp, #12
 8004244:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8004246:	f7ff feb3 	bl	8003fb0 <osalSysLock>
  ibqReleaseEmptyBufferS(ibqp);
 800424a:	9801      	ldr	r0, [sp, #4]
 800424c:	f000 f808 	bl	8004260 <ibqReleaseEmptyBufferS>
  osalSysUnlock();
 8004250:	f7ff feb6 	bl	8003fc0 <osalSysUnlock>
}
 8004254:	b003      	add	sp, #12
 8004256:	f85d fb04 	ldr.w	pc, [sp], #4
 800425a:	bf00      	nop
 800425c:	f3af 8000 	nop.w

08004260 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8004260:	b500      	push	{lr}
 8004262:	b083      	sub	sp, #12
 8004264:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8004266:	9b01      	ldr	r3, [sp, #4]
 8004268:	68db      	ldr	r3, [r3, #12]
 800426a:	1e5a      	subs	r2, r3, #1
 800426c:	9b01      	ldr	r3, [sp, #4]
 800426e:	60da      	str	r2, [r3, #12]
  ibqp->brdptr += ibqp->bsize;
 8004270:	9b01      	ldr	r3, [sp, #4]
 8004272:	695a      	ldr	r2, [r3, #20]
 8004274:	9b01      	ldr	r3, [sp, #4]
 8004276:	69db      	ldr	r3, [r3, #28]
 8004278:	441a      	add	r2, r3
 800427a:	9b01      	ldr	r3, [sp, #4]
 800427c:	615a      	str	r2, [r3, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 800427e:	9b01      	ldr	r3, [sp, #4]
 8004280:	695a      	ldr	r2, [r3, #20]
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	699b      	ldr	r3, [r3, #24]
 8004286:	429a      	cmp	r2, r3
 8004288:	d303      	bcc.n	8004292 <ibqReleaseEmptyBufferS+0x32>
    ibqp->brdptr = ibqp->buffers;
 800428a:	9b01      	ldr	r3, [sp, #4]
 800428c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800428e:	9b01      	ldr	r3, [sp, #4]
 8004290:	615a      	str	r2, [r3, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004292:	9b01      	ldr	r3, [sp, #4]
 8004294:	2200      	movs	r2, #0
 8004296:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004298:	9b01      	ldr	r3, [sp, #4]
 800429a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800429c:	2b00      	cmp	r3, #0
 800429e:	d003      	beq.n	80042a8 <ibqReleaseEmptyBufferS+0x48>
    ibqp->notify(ibqp);
 80042a0:	9b01      	ldr	r3, [sp, #4]
 80042a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80042a4:	9801      	ldr	r0, [sp, #4]
 80042a6:	4798      	blx	r3
  }
}
 80042a8:	b003      	add	sp, #12
 80042aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80042ae:	bf00      	nop

080042b0 <ibqGetTimeout>:
 * @retval MSG_RESET    if the queue has been reset or has been put in
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 80042b0:	b500      	push	{lr}
 80042b2:	b085      	sub	sp, #20
 80042b4:	9001      	str	r0, [sp, #4]
 80042b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 80042b8:	f7ff fe7a 	bl	8003fb0 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 80042bc:	9b01      	ldr	r3, [sp, #4]
 80042be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80042c0:	2b00      	cmp	r3, #0
 80042c2:	d10b      	bne.n	80042dc <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80042c4:	9801      	ldr	r0, [sp, #4]
 80042c6:	9900      	ldr	r1, [sp, #0]
 80042c8:	f7ff ff8a 	bl	80041e0 <ibqGetFullBufferTimeoutS>
 80042cc:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 80042ce:	9b03      	ldr	r3, [sp, #12]
 80042d0:	2b00      	cmp	r3, #0
 80042d2:	d003      	beq.n	80042dc <ibqGetTimeout+0x2c>
      osalSysUnlock();
 80042d4:	f7ff fe74 	bl	8003fc0 <osalSysUnlock>
      return msg;
 80042d8:	9b03      	ldr	r3, [sp, #12]
 80042da:	e014      	b.n	8004306 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 80042dc:	9b01      	ldr	r3, [sp, #4]
 80042de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80042e0:	781b      	ldrb	r3, [r3, #0]
 80042e2:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 80042e4:	9b01      	ldr	r3, [sp, #4]
 80042e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80042e8:	1c5a      	adds	r2, r3, #1
 80042ea:	9b01      	ldr	r3, [sp, #4]
 80042ec:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 80042ee:	9b01      	ldr	r3, [sp, #4]
 80042f0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80042f2:	9b01      	ldr	r3, [sp, #4]
 80042f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80042f6:	429a      	cmp	r2, r3
 80042f8:	d302      	bcc.n	8004300 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 80042fa:	9801      	ldr	r0, [sp, #4]
 80042fc:	f7ff ffb0 	bl	8004260 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8004300:	f7ff fe5e 	bl	8003fc0 <osalSysUnlock>
  return msg;
 8004304:	9b03      	ldr	r3, [sp, #12]
}
 8004306:	4618      	mov	r0, r3
 8004308:	b005      	add	sp, #20
 800430a:	f85d fb04 	ldr.w	pc, [sp], #4
 800430e:	bf00      	nop

08004310 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8004310:	b500      	push	{lr}
 8004312:	b08b      	sub	sp, #44	; 0x2c
 8004314:	9003      	str	r0, [sp, #12]
 8004316:	9102      	str	r1, [sp, #8]
 8004318:	9201      	str	r2, [sp, #4]
 800431a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 800431c:	2300      	movs	r3, #0
 800431e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8004320:	f7ff fe46 	bl	8003fb0 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004324:	f7ff fe54 	bl	8003fd0 <osalOsGetSystemTimeX>
 8004328:	4602      	mov	r2, r0
 800432a:	9b00      	ldr	r3, [sp, #0]
 800432c:	4413      	add	r3, r2
 800432e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8004330:	9b03      	ldr	r3, [sp, #12]
 8004332:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004334:	2b00      	cmp	r3, #0
 8004336:	d126      	bne.n	8004386 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004338:	9b00      	ldr	r3, [sp, #0]
 800433a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800433e:	d002      	beq.n	8004346 <ibqReadTimeout+0x36>
 8004340:	9b00      	ldr	r3, [sp, #0]
 8004342:	2b00      	cmp	r3, #0
 8004344:	d105      	bne.n	8004352 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004346:	9803      	ldr	r0, [sp, #12]
 8004348:	9900      	ldr	r1, [sp, #0]
 800434a:	f7ff ff49 	bl	80041e0 <ibqGetFullBufferTimeoutS>
 800434e:	9007      	str	r0, [sp, #28]
 8004350:	e012      	b.n	8004378 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004352:	f7ff fe3d 	bl	8003fd0 <osalOsGetSystemTimeX>
 8004356:	4602      	mov	r2, r0
 8004358:	9b06      	ldr	r3, [sp, #24]
 800435a:	1a9b      	subs	r3, r3, r2
 800435c:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800435e:	9a05      	ldr	r2, [sp, #20]
 8004360:	9b00      	ldr	r3, [sp, #0]
 8004362:	429a      	cmp	r2, r3
 8004364:	d903      	bls.n	800436e <ibqReadTimeout+0x5e>
          osalSysUnlock();
 8004366:	f7ff fe2b 	bl	8003fc0 <osalSysUnlock>
          return r;
 800436a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800436c:	e05c      	b.n	8004428 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800436e:	9803      	ldr	r0, [sp, #12]
 8004370:	9905      	ldr	r1, [sp, #20]
 8004372:	f7ff ff35 	bl	80041e0 <ibqGetFullBufferTimeoutS>
 8004376:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004378:	9b07      	ldr	r3, [sp, #28]
 800437a:	2b00      	cmp	r3, #0
 800437c:	d003      	beq.n	8004386 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800437e:	f7ff fe1f 	bl	8003fc0 <osalSysUnlock>
        return r;
 8004382:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004384:	e050      	b.n	8004428 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004386:	9b03      	ldr	r3, [sp, #12]
 8004388:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800438a:	461a      	mov	r2, r3
 800438c:	9b03      	ldr	r3, [sp, #12]
 800438e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004390:	1ad3      	subs	r3, r2, r3
 8004392:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004394:	9a01      	ldr	r2, [sp, #4]
 8004396:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004398:	1ad2      	subs	r2, r2, r3
 800439a:	9b08      	ldr	r3, [sp, #32]
 800439c:	429a      	cmp	r2, r3
 800439e:	d203      	bcs.n	80043a8 <ibqReadTimeout+0x98>
      size = n - r;
 80043a0:	9a01      	ldr	r2, [sp, #4]
 80043a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80043a4:	1ad3      	subs	r3, r2, r3
 80043a6:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 80043a8:	9b08      	ldr	r3, [sp, #32]
 80043aa:	2b40      	cmp	r3, #64	; 0x40
 80043ac:	d913      	bls.n	80043d6 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 80043ae:	9b03      	ldr	r3, [sp, #12]
 80043b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043b2:	9802      	ldr	r0, [sp, #8]
 80043b4:	4619      	mov	r1, r3
 80043b6:	2240      	movs	r2, #64	; 0x40
 80043b8:	f009 fb12 	bl	800d9e0 <memcpy>
      bp        += 64U;
 80043bc:	9b02      	ldr	r3, [sp, #8]
 80043be:	3340      	adds	r3, #64	; 0x40
 80043c0:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 80043c2:	9b03      	ldr	r3, [sp, #12]
 80043c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043c6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80043ca:	9b03      	ldr	r3, [sp, #12]
 80043cc:	629a      	str	r2, [r3, #40]	; 0x28
      r         += 64U;
 80043ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80043d0:	3340      	adds	r3, #64	; 0x40
 80043d2:	9309      	str	r3, [sp, #36]	; 0x24
 80043d4:	e014      	b.n	8004400 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 80043d6:	9b03      	ldr	r3, [sp, #12]
 80043d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043da:	9802      	ldr	r0, [sp, #8]
 80043dc:	4619      	mov	r1, r3
 80043de:	9a08      	ldr	r2, [sp, #32]
 80043e0:	f009 fafe 	bl	800d9e0 <memcpy>
      bp        += size;
 80043e4:	9a02      	ldr	r2, [sp, #8]
 80043e6:	9b08      	ldr	r3, [sp, #32]
 80043e8:	4413      	add	r3, r2
 80043ea:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 80043ec:	9b03      	ldr	r3, [sp, #12]
 80043ee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80043f0:	9b08      	ldr	r3, [sp, #32]
 80043f2:	441a      	add	r2, r3
 80043f4:	9b03      	ldr	r3, [sp, #12]
 80043f6:	629a      	str	r2, [r3, #40]	; 0x28
      r         += size;
 80043f8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80043fa:	9b08      	ldr	r3, [sp, #32]
 80043fc:	4413      	add	r3, r2
 80043fe:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8004400:	9b03      	ldr	r3, [sp, #12]
 8004402:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004404:	9b03      	ldr	r3, [sp, #12]
 8004406:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004408:	429a      	cmp	r2, r3
 800440a:	d302      	bcc.n	8004412 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800440c:	9803      	ldr	r0, [sp, #12]
 800440e:	f7ff ff27 	bl	8004260 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8004412:	f7ff fdd5 	bl	8003fc0 <osalSysUnlock>
    if (r >= n) {
 8004416:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004418:	9b01      	ldr	r3, [sp, #4]
 800441a:	429a      	cmp	r2, r3
 800441c:	d301      	bcc.n	8004422 <ibqReadTimeout+0x112>
      return r;
 800441e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004420:	e002      	b.n	8004428 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 8004422:	f7ff fdc5 	bl	8003fb0 <osalSysLock>
  }
 8004426:	e783      	b.n	8004330 <ibqReadTimeout+0x20>
}
 8004428:	4618      	mov	r0, r3
 800442a:	b00b      	add	sp, #44	; 0x2c
 800442c:	f85d fb04 	ldr.w	pc, [sp], #4

08004430 <obqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t onfy, void *link) {
 8004430:	b500      	push	{lr}
 8004432:	b085      	sub	sp, #20
 8004434:	9003      	str	r0, [sp, #12]
 8004436:	9201      	str	r2, [sp, #4]
 8004438:	9300      	str	r3, [sp, #0]
 800443a:	460b      	mov	r3, r1
 800443c:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
 8004440:	9b03      	ldr	r3, [sp, #12]
 8004442:	4618      	mov	r0, r3
 8004444:	f7ff fdcc 	bl	8003fe0 <osalThreadQueueObjectInit>
  obqp->suspended = suspended;
 8004448:	9b03      	ldr	r3, [sp, #12]
 800444a:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800444e:	721a      	strb	r2, [r3, #8]
  obqp->bcounter  = n;
 8004450:	9b03      	ldr	r3, [sp, #12]
 8004452:	9a06      	ldr	r2, [sp, #24]
 8004454:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = bp;
 8004456:	9b03      	ldr	r3, [sp, #12]
 8004458:	9a01      	ldr	r2, [sp, #4]
 800445a:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = bp;
 800445c:	9b03      	ldr	r3, [sp, #12]
 800445e:	9a01      	ldr	r2, [sp, #4]
 8004460:	611a      	str	r2, [r3, #16]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8004462:	9b00      	ldr	r3, [sp, #0]
 8004464:	3304      	adds	r3, #4
 8004466:	9a06      	ldr	r2, [sp, #24]
 8004468:	fb02 f303 	mul.w	r3, r2, r3
 800446c:	9a01      	ldr	r2, [sp, #4]
 800446e:	441a      	add	r2, r3
 8004470:	9b03      	ldr	r3, [sp, #12]
 8004472:	619a      	str	r2, [r3, #24]
  obqp->bsize     = size + sizeof (size_t);
 8004474:	9b00      	ldr	r3, [sp, #0]
 8004476:	1d1a      	adds	r2, r3, #4
 8004478:	9b03      	ldr	r3, [sp, #12]
 800447a:	61da      	str	r2, [r3, #28]
  obqp->bn        = n;
 800447c:	9b03      	ldr	r3, [sp, #12]
 800447e:	9a06      	ldr	r2, [sp, #24]
 8004480:	621a      	str	r2, [r3, #32]
  obqp->buffers   = bp;
 8004482:	9b03      	ldr	r3, [sp, #12]
 8004484:	9a01      	ldr	r2, [sp, #4]
 8004486:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->ptr       = NULL;
 8004488:	9b03      	ldr	r3, [sp, #12]
 800448a:	2200      	movs	r2, #0
 800448c:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 800448e:	9b03      	ldr	r3, [sp, #12]
 8004490:	2200      	movs	r2, #0
 8004492:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->notify    = onfy;
 8004494:	9b03      	ldr	r3, [sp, #12]
 8004496:	9a07      	ldr	r2, [sp, #28]
 8004498:	631a      	str	r2, [r3, #48]	; 0x30
  obqp->link      = link;
 800449a:	9b03      	ldr	r3, [sp, #12]
 800449c:	9a08      	ldr	r2, [sp, #32]
 800449e:	635a      	str	r2, [r3, #52]	; 0x34
}
 80044a0:	b005      	add	sp, #20
 80044a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80044a6:	bf00      	nop
 80044a8:	f3af 8000 	nop.w
 80044ac:	f3af 8000 	nop.w

080044b0 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 80044b0:	b500      	push	{lr}
 80044b2:	b083      	sub	sp, #12
 80044b4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  obqp->bcounter  = bqSizeX(obqp);
 80044b6:	9b01      	ldr	r3, [sp, #4]
 80044b8:	6a1a      	ldr	r2, [r3, #32]
 80044ba:	9b01      	ldr	r3, [sp, #4]
 80044bc:	60da      	str	r2, [r3, #12]
  obqp->brdptr    = obqp->buffers;
 80044be:	9b01      	ldr	r3, [sp, #4]
 80044c0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80044c2:	9b01      	ldr	r3, [sp, #4]
 80044c4:	615a      	str	r2, [r3, #20]
  obqp->bwrptr    = obqp->buffers;
 80044c6:	9b01      	ldr	r3, [sp, #4]
 80044c8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80044ca:	9b01      	ldr	r3, [sp, #4]
 80044cc:	611a      	str	r2, [r3, #16]
  obqp->ptr       = NULL;
 80044ce:	9b01      	ldr	r3, [sp, #4]
 80044d0:	2200      	movs	r2, #0
 80044d2:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top       = NULL;
 80044d4:	9b01      	ldr	r3, [sp, #4]
 80044d6:	2200      	movs	r2, #0
 80044d8:	62da      	str	r2, [r3, #44]	; 0x2c
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 80044da:	9b01      	ldr	r3, [sp, #4]
 80044dc:	4618      	mov	r0, r3
 80044de:	f06f 0101 	mvn.w	r1, #1
 80044e2:	f7ff fdad 	bl	8004040 <osalThreadDequeueAllI>
}
 80044e6:	b003      	add	sp, #12
 80044e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80044ec:	f3af 8000 	nop.w

080044f0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80044f0:	b082      	sub	sp, #8
 80044f2:	9001      	str	r0, [sp, #4]
 80044f4:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 80044f6:	9b01      	ldr	r3, [sp, #4]
 80044f8:	691a      	ldr	r2, [r3, #16]
 80044fa:	9b01      	ldr	r3, [sp, #4]
 80044fc:	695b      	ldr	r3, [r3, #20]
 80044fe:	429a      	cmp	r2, r3
 8004500:	d105      	bne.n	800450e <obqGetFullBufferI+0x1e>
 8004502:	9b01      	ldr	r3, [sp, #4]
 8004504:	68db      	ldr	r3, [r3, #12]
 8004506:	2b00      	cmp	r3, #0
 8004508:	d001      	beq.n	800450e <obqGetFullBufferI+0x1e>
 800450a:	2301      	movs	r3, #1
 800450c:	e000      	b.n	8004510 <obqGetFullBufferI+0x20>
 800450e:	2300      	movs	r3, #0
 8004510:	f003 0301 	and.w	r3, r3, #1
 8004514:	b2db      	uxtb	r3, r3
 8004516:	2b00      	cmp	r3, #0
 8004518:	d001      	beq.n	800451e <obqGetFullBufferI+0x2e>
    return NULL;
 800451a:	2300      	movs	r3, #0
 800451c:	e007      	b.n	800452e <obqGetFullBufferI+0x3e>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800451e:	9b01      	ldr	r3, [sp, #4]
 8004520:	695b      	ldr	r3, [r3, #20]
 8004522:	681a      	ldr	r2, [r3, #0]
 8004524:	9b00      	ldr	r3, [sp, #0]
 8004526:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 8004528:	9b01      	ldr	r3, [sp, #4]
 800452a:	695b      	ldr	r3, [r3, #20]
 800452c:	3304      	adds	r3, #4
}
 800452e:	4618      	mov	r0, r3
 8004530:	b002      	add	sp, #8
 8004532:	4770      	bx	lr
 8004534:	f3af 8000 	nop.w
 8004538:	f3af 8000 	nop.w
 800453c:	f3af 8000 	nop.w

08004540 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8004540:	b500      	push	{lr}
 8004542:	b083      	sub	sp, #12
 8004544:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8004546:	9b01      	ldr	r3, [sp, #4]
 8004548:	68db      	ldr	r3, [r3, #12]
 800454a:	1c5a      	adds	r2, r3, #1
 800454c:	9b01      	ldr	r3, [sp, #4]
 800454e:	60da      	str	r2, [r3, #12]
  obqp->brdptr += obqp->bsize;
 8004550:	9b01      	ldr	r3, [sp, #4]
 8004552:	695a      	ldr	r2, [r3, #20]
 8004554:	9b01      	ldr	r3, [sp, #4]
 8004556:	69db      	ldr	r3, [r3, #28]
 8004558:	441a      	add	r2, r3
 800455a:	9b01      	ldr	r3, [sp, #4]
 800455c:	615a      	str	r2, [r3, #20]
  if (obqp->brdptr >= obqp->btop) {
 800455e:	9b01      	ldr	r3, [sp, #4]
 8004560:	695a      	ldr	r2, [r3, #20]
 8004562:	9b01      	ldr	r3, [sp, #4]
 8004564:	699b      	ldr	r3, [r3, #24]
 8004566:	429a      	cmp	r2, r3
 8004568:	d303      	bcc.n	8004572 <obqReleaseEmptyBufferI+0x32>
    obqp->brdptr = obqp->buffers;
 800456a:	9b01      	ldr	r3, [sp, #4]
 800456c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800456e:	9b01      	ldr	r3, [sp, #4]
 8004570:	615a      	str	r2, [r3, #20]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8004572:	9b01      	ldr	r3, [sp, #4]
 8004574:	4618      	mov	r0, r3
 8004576:	2100      	movs	r1, #0
 8004578:	f7ff fd52 	bl	8004020 <osalThreadDequeueNextI>
}
 800457c:	b003      	add	sp, #12
 800457e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004582:	bf00      	nop
 8004584:	f3af 8000 	nop.w
 8004588:	f3af 8000 	nop.w
 800458c:	f3af 8000 	nop.w

08004590 <obqGetEmptyBufferTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqGetEmptyBufferTimeout(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8004590:	b500      	push	{lr}
 8004592:	b085      	sub	sp, #20
 8004594:	9001      	str	r0, [sp, #4]
 8004596:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004598:	f7ff fd0a 	bl	8003fb0 <osalSysLock>
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800459c:	9801      	ldr	r0, [sp, #4]
 800459e:	9900      	ldr	r1, [sp, #0]
 80045a0:	f000 f80e 	bl	80045c0 <obqGetEmptyBufferTimeoutS>
 80045a4:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 80045a6:	f7ff fd0b 	bl	8003fc0 <osalSysUnlock>

  return msg;
 80045aa:	9b03      	ldr	r3, [sp, #12]
}
 80045ac:	4618      	mov	r0, r3
 80045ae:	b005      	add	sp, #20
 80045b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80045b4:	f3af 8000 	nop.w
 80045b8:	f3af 8000 	nop.w
 80045bc:	f3af 8000 	nop.w

080045c0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 80045c0:	b500      	push	{lr}
 80045c2:	b085      	sub	sp, #20
 80045c4:	9001      	str	r0, [sp, #4]
 80045c6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 80045c8:	e011      	b.n	80045ee <obqGetEmptyBufferTimeoutS+0x2e>
    if (obqp->suspended) {
 80045ca:	9b01      	ldr	r3, [sp, #4]
 80045cc:	7a1b      	ldrb	r3, [r3, #8]
 80045ce:	2b00      	cmp	r3, #0
 80045d0:	d002      	beq.n	80045d8 <obqGetEmptyBufferTimeoutS+0x18>
      return MSG_RESET;
 80045d2:	f06f 0301 	mvn.w	r3, #1
 80045d6:	e01b      	b.n	8004610 <obqGetEmptyBufferTimeoutS+0x50>
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	4618      	mov	r0, r3
 80045dc:	9900      	ldr	r1, [sp, #0]
 80045de:	f7ff fd0f 	bl	8004000 <osalThreadEnqueueTimeoutS>
 80045e2:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 80045e4:	9b03      	ldr	r3, [sp, #12]
 80045e6:	2b00      	cmp	r3, #0
 80045e8:	da01      	bge.n	80045ee <obqGetEmptyBufferTimeoutS+0x2e>
      return msg;
 80045ea:	9b03      	ldr	r3, [sp, #12]
 80045ec:	e010      	b.n	8004610 <obqGetEmptyBufferTimeoutS+0x50>
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 80045ee:	9b01      	ldr	r3, [sp, #4]
 80045f0:	68db      	ldr	r3, [r3, #12]
 80045f2:	2b00      	cmp	r3, #0
 80045f4:	d0e9      	beq.n	80045ca <obqGetEmptyBufferTimeoutS+0xa>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80045f6:	9b01      	ldr	r3, [sp, #4]
 80045f8:	691b      	ldr	r3, [r3, #16]
 80045fa:	1d1a      	adds	r2, r3, #4
 80045fc:	9b01      	ldr	r3, [sp, #4]
 80045fe:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004600:	9b01      	ldr	r3, [sp, #4]
 8004602:	691a      	ldr	r2, [r3, #16]
 8004604:	9b01      	ldr	r3, [sp, #4]
 8004606:	69db      	ldr	r3, [r3, #28]
 8004608:	441a      	add	r2, r3
 800460a:	9b01      	ldr	r3, [sp, #4]
 800460c:	62da      	str	r2, [r3, #44]	; 0x2c

  return MSG_OK;
 800460e:	2300      	movs	r3, #0
}
 8004610:	4618      	mov	r0, r3
 8004612:	b005      	add	sp, #20
 8004614:	f85d fb04 	ldr.w	pc, [sp], #4
 8004618:	f3af 8000 	nop.w
 800461c:	f3af 8000 	nop.w

08004620 <obqPostFullBuffer>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @api
 */
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 8004620:	b500      	push	{lr}
 8004622:	b083      	sub	sp, #12
 8004624:	9001      	str	r0, [sp, #4]
 8004626:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8004628:	f7ff fcc2 	bl	8003fb0 <osalSysLock>
  obqPostFullBufferS(obqp, size);
 800462c:	9801      	ldr	r0, [sp, #4]
 800462e:	9900      	ldr	r1, [sp, #0]
 8004630:	f000 f806 	bl	8004640 <obqPostFullBufferS>
  osalSysUnlock();
 8004634:	f7ff fcc4 	bl	8003fc0 <osalSysUnlock>
}
 8004638:	b003      	add	sp, #12
 800463a:	f85d fb04 	ldr.w	pc, [sp], #4
 800463e:	bf00      	nop

08004640 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8004640:	b500      	push	{lr}
 8004642:	b083      	sub	sp, #12
 8004644:	9001      	str	r0, [sp, #4]
 8004646:	9100      	str	r1, [sp, #0]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8004648:	9b01      	ldr	r3, [sp, #4]
 800464a:	691b      	ldr	r3, [r3, #16]
 800464c:	9a00      	ldr	r2, [sp, #0]
 800464e:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8004650:	9b01      	ldr	r3, [sp, #4]
 8004652:	68db      	ldr	r3, [r3, #12]
 8004654:	1e5a      	subs	r2, r3, #1
 8004656:	9b01      	ldr	r3, [sp, #4]
 8004658:	60da      	str	r2, [r3, #12]
  obqp->bwrptr += obqp->bsize;
 800465a:	9b01      	ldr	r3, [sp, #4]
 800465c:	691a      	ldr	r2, [r3, #16]
 800465e:	9b01      	ldr	r3, [sp, #4]
 8004660:	69db      	ldr	r3, [r3, #28]
 8004662:	441a      	add	r2, r3
 8004664:	9b01      	ldr	r3, [sp, #4]
 8004666:	611a      	str	r2, [r3, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8004668:	9b01      	ldr	r3, [sp, #4]
 800466a:	691a      	ldr	r2, [r3, #16]
 800466c:	9b01      	ldr	r3, [sp, #4]
 800466e:	699b      	ldr	r3, [r3, #24]
 8004670:	429a      	cmp	r2, r3
 8004672:	d303      	bcc.n	800467c <obqPostFullBufferS+0x3c>
    obqp->bwrptr = obqp->buffers;
 8004674:	9b01      	ldr	r3, [sp, #4]
 8004676:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004678:	9b01      	ldr	r3, [sp, #4]
 800467a:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 800467c:	9b01      	ldr	r3, [sp, #4]
 800467e:	2200      	movs	r2, #0
 8004680:	629a      	str	r2, [r3, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8004682:	9b01      	ldr	r3, [sp, #4]
 8004684:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004686:	2b00      	cmp	r3, #0
 8004688:	d003      	beq.n	8004692 <obqPostFullBufferS+0x52>
    obqp->notify(obqp);
 800468a:	9b01      	ldr	r3, [sp, #4]
 800468c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800468e:	9801      	ldr	r0, [sp, #4]
 8004690:	4798      	blx	r3
  }
}
 8004692:	b003      	add	sp, #12
 8004694:	f85d fb04 	ldr.w	pc, [sp], #4
 8004698:	f3af 8000 	nop.w
 800469c:	f3af 8000 	nop.w

080046a0 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 80046a0:	b500      	push	{lr}
 80046a2:	b087      	sub	sp, #28
 80046a4:	9003      	str	r0, [sp, #12]
 80046a6:	460b      	mov	r3, r1
 80046a8:	9201      	str	r2, [sp, #4]
 80046aa:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 80046ae:	f7ff fc7f 	bl	8003fb0 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80046b2:	9b03      	ldr	r3, [sp, #12]
 80046b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80046b6:	2b00      	cmp	r3, #0
 80046b8:	d10b      	bne.n	80046d2 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80046ba:	9803      	ldr	r0, [sp, #12]
 80046bc:	9901      	ldr	r1, [sp, #4]
 80046be:	f7ff ff7f 	bl	80045c0 <obqGetEmptyBufferTimeoutS>
 80046c2:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 80046c4:	9b05      	ldr	r3, [sp, #20]
 80046c6:	2b00      	cmp	r3, #0
 80046c8:	d003      	beq.n	80046d2 <obqPutTimeout+0x32>
      osalSysUnlock();
 80046ca:	f7ff fc79 	bl	8003fc0 <osalSysUnlock>
      return msg;
 80046ce:	9b05      	ldr	r3, [sp, #20]
 80046d0:	e019      	b.n	8004706 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 80046d2:	9b03      	ldr	r3, [sp, #12]
 80046d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80046d6:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80046da:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 80046dc:	9b03      	ldr	r3, [sp, #12]
 80046de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80046e0:	1c5a      	adds	r2, r3, #1
 80046e2:	9b03      	ldr	r3, [sp, #12]
 80046e4:	629a      	str	r2, [r3, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 80046e6:	9b03      	ldr	r3, [sp, #12]
 80046e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80046ea:	9b03      	ldr	r3, [sp, #12]
 80046ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80046ee:	429a      	cmp	r2, r3
 80046f0:	d306      	bcc.n	8004700 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80046f2:	9b03      	ldr	r3, [sp, #12]
 80046f4:	69db      	ldr	r3, [r3, #28]
 80046f6:	3b04      	subs	r3, #4
 80046f8:	9803      	ldr	r0, [sp, #12]
 80046fa:	4619      	mov	r1, r3
 80046fc:	f7ff ffa0 	bl	8004640 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8004700:	f7ff fc5e 	bl	8003fc0 <osalSysUnlock>
  return MSG_OK;
 8004704:	2300      	movs	r3, #0
}
 8004706:	4618      	mov	r0, r3
 8004708:	b007      	add	sp, #28
 800470a:	f85d fb04 	ldr.w	pc, [sp], #4
 800470e:	bf00      	nop

08004710 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004710:	b500      	push	{lr}
 8004712:	b08b      	sub	sp, #44	; 0x2c
 8004714:	9003      	str	r0, [sp, #12]
 8004716:	9102      	str	r1, [sp, #8]
 8004718:	9201      	str	r2, [sp, #4]
 800471a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800471c:	2300      	movs	r3, #0
 800471e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8004720:	f7ff fc46 	bl	8003fb0 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004724:	f7ff fc54 	bl	8003fd0 <osalOsGetSystemTimeX>
 8004728:	4602      	mov	r2, r0
 800472a:	9b00      	ldr	r3, [sp, #0]
 800472c:	4413      	add	r3, r2
 800472e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8004730:	9b03      	ldr	r3, [sp, #12]
 8004732:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004734:	2b00      	cmp	r3, #0
 8004736:	d126      	bne.n	8004786 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004738:	9b00      	ldr	r3, [sp, #0]
 800473a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800473e:	d002      	beq.n	8004746 <obqWriteTimeout+0x36>
 8004740:	9b00      	ldr	r3, [sp, #0]
 8004742:	2b00      	cmp	r3, #0
 8004744:	d105      	bne.n	8004752 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8004746:	9803      	ldr	r0, [sp, #12]
 8004748:	9900      	ldr	r1, [sp, #0]
 800474a:	f7ff ff39 	bl	80045c0 <obqGetEmptyBufferTimeoutS>
 800474e:	9007      	str	r0, [sp, #28]
 8004750:	e012      	b.n	8004778 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004752:	f7ff fc3d 	bl	8003fd0 <osalOsGetSystemTimeX>
 8004756:	4602      	mov	r2, r0
 8004758:	9b06      	ldr	r3, [sp, #24]
 800475a:	1a9b      	subs	r3, r3, r2
 800475c:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800475e:	9a05      	ldr	r2, [sp, #20]
 8004760:	9b00      	ldr	r3, [sp, #0]
 8004762:	429a      	cmp	r2, r3
 8004764:	d903      	bls.n	800476e <obqWriteTimeout+0x5e>
          osalSysUnlock();
 8004766:	f7ff fc2b 	bl	8003fc0 <osalSysUnlock>
          return w;
 800476a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800476c:	e060      	b.n	8004830 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 800476e:	9803      	ldr	r0, [sp, #12]
 8004770:	9905      	ldr	r1, [sp, #20]
 8004772:	f7ff ff25 	bl	80045c0 <obqGetEmptyBufferTimeoutS>
 8004776:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004778:	9b07      	ldr	r3, [sp, #28]
 800477a:	2b00      	cmp	r3, #0
 800477c:	d003      	beq.n	8004786 <obqWriteTimeout+0x76>
        osalSysUnlock();
 800477e:	f7ff fc1f 	bl	8003fc0 <osalSysUnlock>
        return w;
 8004782:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004784:	e054      	b.n	8004830 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8004786:	9b03      	ldr	r3, [sp, #12]
 8004788:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800478a:	461a      	mov	r2, r3
 800478c:	9b03      	ldr	r3, [sp, #12]
 800478e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004790:	1ad3      	subs	r3, r2, r3
 8004792:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8004794:	9a01      	ldr	r2, [sp, #4]
 8004796:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004798:	1ad2      	subs	r2, r2, r3
 800479a:	9b08      	ldr	r3, [sp, #32]
 800479c:	429a      	cmp	r2, r3
 800479e:	d203      	bcs.n	80047a8 <obqWriteTimeout+0x98>
      size = n - w;
 80047a0:	9a01      	ldr	r2, [sp, #4]
 80047a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80047a4:	1ad3      	subs	r3, r2, r3
 80047a6:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 80047a8:	9b08      	ldr	r3, [sp, #32]
 80047aa:	2b40      	cmp	r3, #64	; 0x40
 80047ac:	d913      	bls.n	80047d6 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 80047ae:	9b03      	ldr	r3, [sp, #12]
 80047b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047b2:	4618      	mov	r0, r3
 80047b4:	9902      	ldr	r1, [sp, #8]
 80047b6:	2240      	movs	r2, #64	; 0x40
 80047b8:	f009 f912 	bl	800d9e0 <memcpy>
      bp        += 64U;
 80047bc:	9b02      	ldr	r3, [sp, #8]
 80047be:	3340      	adds	r3, #64	; 0x40
 80047c0:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 80047c2:	9b03      	ldr	r3, [sp, #12]
 80047c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047c6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80047ca:	9b03      	ldr	r3, [sp, #12]
 80047cc:	629a      	str	r2, [r3, #40]	; 0x28
      w         += 64U;
 80047ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80047d0:	3340      	adds	r3, #64	; 0x40
 80047d2:	9309      	str	r3, [sp, #36]	; 0x24
 80047d4:	e014      	b.n	8004800 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 80047d6:	9b03      	ldr	r3, [sp, #12]
 80047d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047da:	4618      	mov	r0, r3
 80047dc:	9902      	ldr	r1, [sp, #8]
 80047de:	9a08      	ldr	r2, [sp, #32]
 80047e0:	f009 f8fe 	bl	800d9e0 <memcpy>
      bp        += size;
 80047e4:	9a02      	ldr	r2, [sp, #8]
 80047e6:	9b08      	ldr	r3, [sp, #32]
 80047e8:	4413      	add	r3, r2
 80047ea:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 80047ec:	9b03      	ldr	r3, [sp, #12]
 80047ee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80047f0:	9b08      	ldr	r3, [sp, #32]
 80047f2:	441a      	add	r2, r3
 80047f4:	9b03      	ldr	r3, [sp, #12]
 80047f6:	629a      	str	r2, [r3, #40]	; 0x28
      w         += size;
 80047f8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80047fa:	9b08      	ldr	r3, [sp, #32]
 80047fc:	4413      	add	r3, r2
 80047fe:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004800:	9b03      	ldr	r3, [sp, #12]
 8004802:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004804:	9b03      	ldr	r3, [sp, #12]
 8004806:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004808:	429a      	cmp	r2, r3
 800480a:	d306      	bcc.n	800481a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800480c:	9b03      	ldr	r3, [sp, #12]
 800480e:	69db      	ldr	r3, [r3, #28]
 8004810:	3b04      	subs	r3, #4
 8004812:	9803      	ldr	r0, [sp, #12]
 8004814:	4619      	mov	r1, r3
 8004816:	f7ff ff13 	bl	8004640 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800481a:	f7ff fbd1 	bl	8003fc0 <osalSysUnlock>
    if (w >= n) {
 800481e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004820:	9b01      	ldr	r3, [sp, #4]
 8004822:	429a      	cmp	r2, r3
 8004824:	d301      	bcc.n	800482a <obqWriteTimeout+0x11a>
      return w;
 8004826:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004828:	e002      	b.n	8004830 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800482a:	f7ff fbc1 	bl	8003fb0 <osalSysLock>
  }
 800482e:	e77f      	b.n	8004730 <obqWriteTimeout+0x20>
}
 8004830:	4618      	mov	r0, r3
 8004832:	b00b      	add	sp, #44	; 0x2c
 8004834:	f85d fb04 	ldr.w	pc, [sp], #4
 8004838:	f3af 8000 	nop.w
 800483c:	f3af 8000 	nop.w

08004840 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8004840:	b084      	sub	sp, #16
 8004842:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8004844:	9b01      	ldr	r3, [sp, #4]
 8004846:	691a      	ldr	r2, [r3, #16]
 8004848:	9b01      	ldr	r3, [sp, #4]
 800484a:	695b      	ldr	r3, [r3, #20]
 800484c:	429a      	cmp	r2, r3
 800484e:	d105      	bne.n	800485c <obqTryFlushI+0x1c>
 8004850:	9b01      	ldr	r3, [sp, #4]
 8004852:	68db      	ldr	r3, [r3, #12]
 8004854:	2b00      	cmp	r3, #0
 8004856:	d001      	beq.n	800485c <obqTryFlushI+0x1c>
 8004858:	2301      	movs	r3, #1
 800485a:	e000      	b.n	800485e <obqTryFlushI+0x1e>
 800485c:	2300      	movs	r3, #0
 800485e:	f003 0301 	and.w	r3, r3, #1
 8004862:	b2db      	uxtb	r3, r3
 8004864:	2b00      	cmp	r3, #0
 8004866:	d02d      	beq.n	80048c4 <obqTryFlushI+0x84>
 8004868:	9b01      	ldr	r3, [sp, #4]
 800486a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800486c:	2b00      	cmp	r3, #0
 800486e:	d029      	beq.n	80048c4 <obqTryFlushI+0x84>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8004870:	9b01      	ldr	r3, [sp, #4]
 8004872:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004874:	461a      	mov	r2, r3
 8004876:	9b01      	ldr	r3, [sp, #4]
 8004878:	691b      	ldr	r3, [r3, #16]
 800487a:	1ad3      	subs	r3, r2, r3
 800487c:	3b04      	subs	r3, #4
 800487e:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004880:	9b03      	ldr	r3, [sp, #12]
 8004882:	2b00      	cmp	r3, #0
 8004884:	d01e      	beq.n	80048c4 <obqTryFlushI+0x84>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8004886:	9b01      	ldr	r3, [sp, #4]
 8004888:	691b      	ldr	r3, [r3, #16]
 800488a:	9a03      	ldr	r2, [sp, #12]
 800488c:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 800488e:	9b01      	ldr	r3, [sp, #4]
 8004890:	68db      	ldr	r3, [r3, #12]
 8004892:	1e5a      	subs	r2, r3, #1
 8004894:	9b01      	ldr	r3, [sp, #4]
 8004896:	60da      	str	r2, [r3, #12]
      obqp->bwrptr += obqp->bsize;
 8004898:	9b01      	ldr	r3, [sp, #4]
 800489a:	691a      	ldr	r2, [r3, #16]
 800489c:	9b01      	ldr	r3, [sp, #4]
 800489e:	69db      	ldr	r3, [r3, #28]
 80048a0:	441a      	add	r2, r3
 80048a2:	9b01      	ldr	r3, [sp, #4]
 80048a4:	611a      	str	r2, [r3, #16]
      if (obqp->bwrptr >= obqp->btop) {
 80048a6:	9b01      	ldr	r3, [sp, #4]
 80048a8:	691a      	ldr	r2, [r3, #16]
 80048aa:	9b01      	ldr	r3, [sp, #4]
 80048ac:	699b      	ldr	r3, [r3, #24]
 80048ae:	429a      	cmp	r2, r3
 80048b0:	d303      	bcc.n	80048ba <obqTryFlushI+0x7a>
        obqp->bwrptr = obqp->buffers;
 80048b2:	9b01      	ldr	r3, [sp, #4]
 80048b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80048b6:	9b01      	ldr	r3, [sp, #4]
 80048b8:	611a      	str	r2, [r3, #16]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80048ba:	9b01      	ldr	r3, [sp, #4]
 80048bc:	2200      	movs	r2, #0
 80048be:	629a      	str	r2, [r3, #40]	; 0x28

      return true;
 80048c0:	2301      	movs	r3, #1
 80048c2:	e000      	b.n	80048c6 <obqTryFlushI+0x86>
    }
  }
  return false;
 80048c4:	2300      	movs	r3, #0
}
 80048c6:	4618      	mov	r0, r3
 80048c8:	b004      	add	sp, #16
 80048ca:	4770      	bx	lr
 80048cc:	f3af 8000 	nop.w

080048d0 <obqFlush>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @api
 */
void obqFlush(output_buffers_queue_t *obqp) {
 80048d0:	b500      	push	{lr}
 80048d2:	b085      	sub	sp, #20
 80048d4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 80048d6:	f7ff fb6b 	bl	8003fb0 <osalSysLock>

  /* If there is a buffer partially filled and not being written.*/
  if (obqp->ptr != NULL) {
 80048da:	9b01      	ldr	r3, [sp, #4]
 80048dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80048de:	2b00      	cmp	r3, #0
 80048e0:	d00e      	beq.n	8004900 <obqFlush+0x30>
    size_t size = ((size_t)obqp->ptr - (size_t)obqp->bwrptr) - sizeof (size_t);
 80048e2:	9b01      	ldr	r3, [sp, #4]
 80048e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80048e6:	461a      	mov	r2, r3
 80048e8:	9b01      	ldr	r3, [sp, #4]
 80048ea:	691b      	ldr	r3, [r3, #16]
 80048ec:	1ad3      	subs	r3, r2, r3
 80048ee:	3b04      	subs	r3, #4
 80048f0:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80048f2:	9b03      	ldr	r3, [sp, #12]
 80048f4:	2b00      	cmp	r3, #0
 80048f6:	d003      	beq.n	8004900 <obqFlush+0x30>
      obqPostFullBufferS(obqp, size);
 80048f8:	9801      	ldr	r0, [sp, #4]
 80048fa:	9903      	ldr	r1, [sp, #12]
 80048fc:	f7ff fea0 	bl	8004640 <obqPostFullBufferS>
    }
  }

  osalSysUnlock();
 8004900:	f7ff fb5e 	bl	8003fc0 <osalSysUnlock>
}
 8004904:	b005      	add	sp, #20
 8004906:	f85d fb04 	ldr.w	pc, [sp], #4
 800490a:	bf00      	nop
 800490c:	0000      	movs	r0, r0
	...

08004910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004910:	b082      	sub	sp, #8
 8004912:	2320      	movs	r3, #32
 8004914:	9301      	str	r3, [sp, #4]
 8004916:	9b01      	ldr	r3, [sp, #4]
 8004918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800491c:	b002      	add	sp, #8
 800491e:	4770      	bx	lr

08004920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004920:	b082      	sub	sp, #8
 8004922:	2300      	movs	r3, #0
 8004924:	9301      	str	r3, [sp, #4]
 8004926:	9b01      	ldr	r3, [sp, #4]
 8004928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800492c:	b002      	add	sp, #8
 800492e:	4770      	bx	lr

08004930 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004930:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004934:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004936:	4618      	mov	r0, r3
 8004938:	4770      	bx	lr
 800493a:	bf00      	nop
 800493c:	f3af 8000 	nop.w

08004940 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8004940:	b508      	push	{r3, lr}

  return stGetCounter();
 8004942:	f7ff fff5 	bl	8004930 <st_lld_get_counter>
 8004946:	4603      	mov	r3, r0
}
 8004948:	4618      	mov	r0, r3
 800494a:	bd08      	pop	{r3, pc}
 800494c:	f3af 8000 	nop.w

08004950 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8004950:	b082      	sub	sp, #8
 8004952:	9001      	str	r0, [sp, #4]

  tqp->next = (thread_t *)tqp;
 8004954:	9b01      	ldr	r3, [sp, #4]
 8004956:	9a01      	ldr	r2, [sp, #4]
 8004958:	601a      	str	r2, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800495a:	9b01      	ldr	r3, [sp, #4]
 800495c:	9a01      	ldr	r2, [sp, #4]
 800495e:	605a      	str	r2, [r3, #4]
}
 8004960:	b002      	add	sp, #8
 8004962:	4770      	bx	lr
 8004964:	f3af 8000 	nop.w
 8004968:	f3af 8000 	nop.w
 800496c:	f3af 8000 	nop.w

08004970 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004970:	b508      	push	{r3, lr}

  port_lock();
 8004972:	f7ff ffcd 	bl	8004910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004976:	bd08      	pop	{r3, pc}
 8004978:	f3af 8000 	nop.w
 800497c:	f3af 8000 	nop.w

08004980 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004980:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8004982:	f7ff ffcd 	bl	8004920 <port_unlock>
}
 8004986:	bd08      	pop	{r3, pc}
 8004988:	f3af 8000 	nop.w
 800498c:	f3af 8000 	nop.w

08004990 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8004990:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8004992:	f7ff ffd5 	bl	8004940 <port_timer_get_time>
 8004996:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004998:	4618      	mov	r0, r3
 800499a:	bd08      	pop	{r3, pc}
 800499c:	f3af 8000 	nop.w

080049a0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80049a0:	b500      	push	{lr}
 80049a2:	b083      	sub	sp, #12
 80049a4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80049a6:	9801      	ldr	r0, [sp, #4]
 80049a8:	f7ff ffd2 	bl	8004950 <queue_init>
}
 80049ac:	b003      	add	sp, #12
 80049ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80049b2:	bf00      	nop
 80049b4:	f3af 8000 	nop.w
 80049b8:	f3af 8000 	nop.w
 80049bc:	f3af 8000 	nop.w

080049c0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80049c0:	b508      	push	{r3, lr}

  chSysLock();
 80049c2:	f7ff ffd5 	bl	8004970 <chSysLock>
}
 80049c6:	bd08      	pop	{r3, pc}
 80049c8:	f3af 8000 	nop.w
 80049cc:	f3af 8000 	nop.w

080049d0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80049d0:	b508      	push	{r3, lr}

  chSysUnlock();
 80049d2:	f7ff ffd5 	bl	8004980 <chSysUnlock>
}
 80049d6:	bd08      	pop	{r3, pc}
 80049d8:	f3af 8000 	nop.w
 80049dc:	f3af 8000 	nop.w

080049e0 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 80049e0:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 80049e2:	f7ff ffd5 	bl	8004990 <chVTGetSystemTimeX>
 80049e6:	4603      	mov	r3, r0
}
 80049e8:	4618      	mov	r0, r3
 80049ea:	bd08      	pop	{r3, pc}
 80049ec:	f3af 8000 	nop.w

080049f0 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80049f0:	b500      	push	{lr}
 80049f2:	b083      	sub	sp, #12
 80049f4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 80049f6:	9801      	ldr	r0, [sp, #4]
 80049f8:	f7ff ffd2 	bl	80049a0 <chThdQueueObjectInit>
}
 80049fc:	b003      	add	sp, #12
 80049fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a02:	bf00      	nop
 8004a04:	f3af 8000 	nop.w
 8004a08:	f3af 8000 	nop.w
 8004a0c:	f3af 8000 	nop.w

08004a10 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8004a10:	b500      	push	{lr}
 8004a12:	b083      	sub	sp, #12
 8004a14:	9001      	str	r0, [sp, #4]
 8004a16:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8004a18:	9801      	ldr	r0, [sp, #4]
 8004a1a:	9900      	ldr	r1, [sp, #0]
 8004a1c:	f7fc ff48 	bl	80018b0 <chThdEnqueueTimeoutS>
 8004a20:	4603      	mov	r3, r0
}
 8004a22:	4618      	mov	r0, r3
 8004a24:	b003      	add	sp, #12
 8004a26:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a2a:	bf00      	nop
 8004a2c:	f3af 8000 	nop.w

08004a30 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004a30:	b500      	push	{lr}
 8004a32:	b083      	sub	sp, #12
 8004a34:	9001      	str	r0, [sp, #4]
 8004a36:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8004a38:	9801      	ldr	r0, [sp, #4]
 8004a3a:	9900      	ldr	r1, [sp, #0]
 8004a3c:	f7fc ff58 	bl	80018f0 <chThdDequeueNextI>
}
 8004a40:	b003      	add	sp, #12
 8004a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a46:	bf00      	nop
 8004a48:	f3af 8000 	nop.w
 8004a4c:	f3af 8000 	nop.w

08004a50 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8004a50:	b500      	push	{lr}
 8004a52:	b083      	sub	sp, #12
 8004a54:	9001      	str	r0, [sp, #4]
 8004a56:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8004a58:	9801      	ldr	r0, [sp, #4]
 8004a5a:	9900      	ldr	r1, [sp, #0]
 8004a5c:	f7fc ff60 	bl	8001920 <chThdDequeueAllI>
}
 8004a60:	b003      	add	sp, #12
 8004a62:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a66:	bf00      	nop
 8004a68:	f3af 8000 	nop.w
 8004a6c:	f3af 8000 	nop.w

08004a70 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8004a70:	b500      	push	{lr}
 8004a72:	b085      	sub	sp, #20
 8004a74:	9003      	str	r0, [sp, #12]
 8004a76:	9102      	str	r1, [sp, #8]
 8004a78:	9201      	str	r2, [sp, #4]
 8004a7a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8004a7c:	9b03      	ldr	r3, [sp, #12]
 8004a7e:	4618      	mov	r0, r3
 8004a80:	f7ff ffb6 	bl	80049f0 <osalThreadQueueObjectInit>
  iqp->q_counter = 0;
 8004a84:	9b03      	ldr	r3, [sp, #12]
 8004a86:	2200      	movs	r2, #0
 8004a88:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8004a8a:	9b03      	ldr	r3, [sp, #12]
 8004a8c:	9a02      	ldr	r2, [sp, #8]
 8004a8e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8004a90:	9b03      	ldr	r3, [sp, #12]
 8004a92:	9a02      	ldr	r2, [sp, #8]
 8004a94:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8004a96:	9b03      	ldr	r3, [sp, #12]
 8004a98:	9a02      	ldr	r2, [sp, #8]
 8004a9a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8004a9c:	9a02      	ldr	r2, [sp, #8]
 8004a9e:	9b01      	ldr	r3, [sp, #4]
 8004aa0:	441a      	add	r2, r3
 8004aa2:	9b03      	ldr	r3, [sp, #12]
 8004aa4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8004aa6:	9b03      	ldr	r3, [sp, #12]
 8004aa8:	9a00      	ldr	r2, [sp, #0]
 8004aaa:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8004aac:	9b03      	ldr	r3, [sp, #12]
 8004aae:	9a06      	ldr	r2, [sp, #24]
 8004ab0:	621a      	str	r2, [r3, #32]
}
 8004ab2:	b005      	add	sp, #20
 8004ab4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ab8:	f3af 8000 	nop.w
 8004abc:	f3af 8000 	nop.w

08004ac0 <iqResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void iqResetI(input_queue_t *iqp) {
 8004ac0:	b500      	push	{lr}
 8004ac2:	b083      	sub	sp, #12
 8004ac4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8004ac6:	9b01      	ldr	r3, [sp, #4]
 8004ac8:	68da      	ldr	r2, [r3, #12]
 8004aca:	9b01      	ldr	r3, [sp, #4]
 8004acc:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8004ace:	9b01      	ldr	r3, [sp, #4]
 8004ad0:	68da      	ldr	r2, [r3, #12]
 8004ad2:	9b01      	ldr	r3, [sp, #4]
 8004ad4:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8004ad6:	9b01      	ldr	r3, [sp, #4]
 8004ad8:	2200      	movs	r2, #0
 8004ada:	609a      	str	r2, [r3, #8]
  osalThreadDequeueAllI(&iqp->q_waiting, MSG_RESET);
 8004adc:	9b01      	ldr	r3, [sp, #4]
 8004ade:	4618      	mov	r0, r3
 8004ae0:	f06f 0101 	mvn.w	r1, #1
 8004ae4:	f7ff ffb4 	bl	8004a50 <osalThreadDequeueAllI>
}
 8004ae8:	b003      	add	sp, #12
 8004aea:	f85d fb04 	ldr.w	pc, [sp], #4
 8004aee:	bf00      	nop

08004af0 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8004af0:	b500      	push	{lr}
 8004af2:	b083      	sub	sp, #12
 8004af4:	9001      	str	r0, [sp, #4]
 8004af6:	460b      	mov	r3, r1
 8004af8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8004afc:	9b01      	ldr	r3, [sp, #4]
 8004afe:	695a      	ldr	r2, [r3, #20]
 8004b00:	9b01      	ldr	r3, [sp, #4]
 8004b02:	699b      	ldr	r3, [r3, #24]
 8004b04:	429a      	cmp	r2, r3
 8004b06:	d105      	bne.n	8004b14 <iqPutI+0x24>
 8004b08:	9b01      	ldr	r3, [sp, #4]
 8004b0a:	689b      	ldr	r3, [r3, #8]
 8004b0c:	2b00      	cmp	r3, #0
 8004b0e:	d001      	beq.n	8004b14 <iqPutI+0x24>
 8004b10:	2301      	movs	r3, #1
 8004b12:	e000      	b.n	8004b16 <iqPutI+0x26>
 8004b14:	2300      	movs	r3, #0
 8004b16:	f003 0301 	and.w	r3, r3, #1
 8004b1a:	b2db      	uxtb	r3, r3
 8004b1c:	2b00      	cmp	r3, #0
 8004b1e:	d002      	beq.n	8004b26 <iqPutI+0x36>
    return MSG_TIMEOUT;
 8004b20:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004b24:	e01c      	b.n	8004b60 <iqPutI+0x70>
  }

  iqp->q_counter++;
 8004b26:	9b01      	ldr	r3, [sp, #4]
 8004b28:	689b      	ldr	r3, [r3, #8]
 8004b2a:	1c5a      	adds	r2, r3, #1
 8004b2c:	9b01      	ldr	r3, [sp, #4]
 8004b2e:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8004b30:	9b01      	ldr	r3, [sp, #4]
 8004b32:	695b      	ldr	r3, [r3, #20]
 8004b34:	1c59      	adds	r1, r3, #1
 8004b36:	9a01      	ldr	r2, [sp, #4]
 8004b38:	6151      	str	r1, [r2, #20]
 8004b3a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004b3e:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8004b40:	9b01      	ldr	r3, [sp, #4]
 8004b42:	695a      	ldr	r2, [r3, #20]
 8004b44:	9b01      	ldr	r3, [sp, #4]
 8004b46:	691b      	ldr	r3, [r3, #16]
 8004b48:	429a      	cmp	r2, r3
 8004b4a:	d303      	bcc.n	8004b54 <iqPutI+0x64>
    iqp->q_wrptr = iqp->q_buffer;
 8004b4c:	9b01      	ldr	r3, [sp, #4]
 8004b4e:	68da      	ldr	r2, [r3, #12]
 8004b50:	9b01      	ldr	r3, [sp, #4]
 8004b52:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8004b54:	9b01      	ldr	r3, [sp, #4]
 8004b56:	4618      	mov	r0, r3
 8004b58:	2100      	movs	r1, #0
 8004b5a:	f7ff ff69 	bl	8004a30 <osalThreadDequeueNextI>

  return MSG_OK;
 8004b5e:	2300      	movs	r3, #0
}
 8004b60:	4618      	mov	r0, r3
 8004b62:	b003      	add	sp, #12
 8004b64:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b68:	f3af 8000 	nop.w
 8004b6c:	f3af 8000 	nop.w

08004b70 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8004b70:	b500      	push	{lr}
 8004b72:	b085      	sub	sp, #20
 8004b74:	9001      	str	r0, [sp, #4]
 8004b76:	9100      	str	r1, [sp, #0]
  uint8_t b;

  osalSysLock();
 8004b78:	f7ff ff22 	bl	80049c0 <osalSysLock>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8004b7c:	e00c      	b.n	8004b98 <iqGetTimeout+0x28>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8004b7e:	9b01      	ldr	r3, [sp, #4]
 8004b80:	4618      	mov	r0, r3
 8004b82:	9900      	ldr	r1, [sp, #0]
 8004b84:	f7ff ff44 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004b88:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004b8a:	9b03      	ldr	r3, [sp, #12]
 8004b8c:	2b00      	cmp	r3, #0
 8004b8e:	da03      	bge.n	8004b98 <iqGetTimeout+0x28>
      osalSysUnlock();
 8004b90:	f7ff ff1e 	bl	80049d0 <osalSysUnlock>
      return msg;
 8004b94:	9b03      	ldr	r3, [sp, #12]
 8004b96:	e026      	b.n	8004be6 <iqGetTimeout+0x76>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8004b98:	9b01      	ldr	r3, [sp, #4]
 8004b9a:	689b      	ldr	r3, [r3, #8]
 8004b9c:	2b00      	cmp	r3, #0
 8004b9e:	d0ee      	beq.n	8004b7e <iqGetTimeout+0xe>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8004ba0:	9b01      	ldr	r3, [sp, #4]
 8004ba2:	689b      	ldr	r3, [r3, #8]
 8004ba4:	1e5a      	subs	r2, r3, #1
 8004ba6:	9b01      	ldr	r3, [sp, #4]
 8004ba8:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8004baa:	9b01      	ldr	r3, [sp, #4]
 8004bac:	699b      	ldr	r3, [r3, #24]
 8004bae:	1c59      	adds	r1, r3, #1
 8004bb0:	9a01      	ldr	r2, [sp, #4]
 8004bb2:	6191      	str	r1, [r2, #24]
 8004bb4:	781b      	ldrb	r3, [r3, #0]
 8004bb6:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 8004bba:	9b01      	ldr	r3, [sp, #4]
 8004bbc:	699a      	ldr	r2, [r3, #24]
 8004bbe:	9b01      	ldr	r3, [sp, #4]
 8004bc0:	691b      	ldr	r3, [r3, #16]
 8004bc2:	429a      	cmp	r2, r3
 8004bc4:	d303      	bcc.n	8004bce <iqGetTimeout+0x5e>
    iqp->q_rdptr = iqp->q_buffer;
 8004bc6:	9b01      	ldr	r3, [sp, #4]
 8004bc8:	68da      	ldr	r2, [r3, #12]
 8004bca:	9b01      	ldr	r3, [sp, #4]
 8004bcc:	619a      	str	r2, [r3, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8004bce:	9b01      	ldr	r3, [sp, #4]
 8004bd0:	69db      	ldr	r3, [r3, #28]
 8004bd2:	2b00      	cmp	r3, #0
 8004bd4:	d003      	beq.n	8004bde <iqGetTimeout+0x6e>
    iqp->q_notify(iqp);
 8004bd6:	9b01      	ldr	r3, [sp, #4]
 8004bd8:	69db      	ldr	r3, [r3, #28]
 8004bda:	9801      	ldr	r0, [sp, #4]
 8004bdc:	4798      	blx	r3
  }

  osalSysUnlock();
 8004bde:	f7ff fef7 	bl	80049d0 <osalSysUnlock>

  return (msg_t)b;
 8004be2:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8004be6:	4618      	mov	r0, r3
 8004be8:	b005      	add	sp, #20
 8004bea:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bee:	bf00      	nop

08004bf0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8004bf0:	b500      	push	{lr}
 8004bf2:	b08b      	sub	sp, #44	; 0x2c
 8004bf4:	9003      	str	r0, [sp, #12]
 8004bf6:	9102      	str	r1, [sp, #8]
 8004bf8:	9201      	str	r2, [sp, #4]
 8004bfa:	9300      	str	r3, [sp, #0]
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8004bfc:	9b03      	ldr	r3, [sp, #12]
 8004bfe:	69db      	ldr	r3, [r3, #28]
 8004c00:	9307      	str	r3, [sp, #28]
  size_t r = 0;
 8004c02:	2300      	movs	r3, #0
 8004c04:	9309      	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
 8004c06:	f7ff fedb 	bl	80049c0 <osalSysLock>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004c0a:	f7ff fee9 	bl	80049e0 <osalOsGetSystemTimeX>
 8004c0e:	4602      	mov	r2, r0
 8004c10:	9b00      	ldr	r3, [sp, #0]
 8004c12:	4413      	add	r3, r2
 8004c14:	9306      	str	r3, [sp, #24]

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8004c16:	e028      	b.n	8004c6a <iqReadTimeout+0x7a>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004c18:	9b00      	ldr	r3, [sp, #0]
 8004c1a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004c1e:	d002      	beq.n	8004c26 <iqReadTimeout+0x36>
 8004c20:	9b00      	ldr	r3, [sp, #0]
 8004c22:	2b00      	cmp	r3, #0
 8004c24:	d106      	bne.n	8004c34 <iqReadTimeout+0x44>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8004c26:	9b03      	ldr	r3, [sp, #12]
 8004c28:	4618      	mov	r0, r3
 8004c2a:	9900      	ldr	r1, [sp, #0]
 8004c2c:	f7ff fef0 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004c30:	9008      	str	r0, [sp, #32]
 8004c32:	e013      	b.n	8004c5c <iqReadTimeout+0x6c>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004c34:	f7ff fed4 	bl	80049e0 <osalOsGetSystemTimeX>
 8004c38:	4602      	mov	r2, r0
 8004c3a:	9b06      	ldr	r3, [sp, #24]
 8004c3c:	1a9b      	subs	r3, r3, r2
 8004c3e:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8004c40:	9a05      	ldr	r2, [sp, #20]
 8004c42:	9b00      	ldr	r3, [sp, #0]
 8004c44:	429a      	cmp	r2, r3
 8004c46:	d903      	bls.n	8004c50 <iqReadTimeout+0x60>
          osalSysUnlock();
 8004c48:	f7ff fec2 	bl	80049d0 <osalSysUnlock>
          return r;
 8004c4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c4e:	e03f      	b.n	8004cd0 <iqReadTimeout+0xe0>
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 8004c50:	9b03      	ldr	r3, [sp, #12]
 8004c52:	4618      	mov	r0, r3
 8004c54:	9905      	ldr	r1, [sp, #20]
 8004c56:	f7ff fedb 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004c5a:	9008      	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8004c5c:	9b08      	ldr	r3, [sp, #32]
 8004c5e:	2b00      	cmp	r3, #0
 8004c60:	d003      	beq.n	8004c6a <iqReadTimeout+0x7a>
        osalSysUnlock();
 8004c62:	f7ff feb5 	bl	80049d0 <osalSysUnlock>
        return r;
 8004c66:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c68:	e032      	b.n	8004cd0 <iqReadTimeout+0xe0>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8004c6a:	9b03      	ldr	r3, [sp, #12]
 8004c6c:	689b      	ldr	r3, [r3, #8]
 8004c6e:	2b00      	cmp	r3, #0
 8004c70:	d0d2      	beq.n	8004c18 <iqReadTimeout+0x28>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8004c72:	9b03      	ldr	r3, [sp, #12]
 8004c74:	689b      	ldr	r3, [r3, #8]
 8004c76:	1e5a      	subs	r2, r3, #1
 8004c78:	9b03      	ldr	r3, [sp, #12]
 8004c7a:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8004c7c:	9b02      	ldr	r3, [sp, #8]
 8004c7e:	1c5a      	adds	r2, r3, #1
 8004c80:	9202      	str	r2, [sp, #8]
 8004c82:	9a03      	ldr	r2, [sp, #12]
 8004c84:	6992      	ldr	r2, [r2, #24]
 8004c86:	1c50      	adds	r0, r2, #1
 8004c88:	9903      	ldr	r1, [sp, #12]
 8004c8a:	6188      	str	r0, [r1, #24]
 8004c8c:	7812      	ldrb	r2, [r2, #0]
 8004c8e:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8004c90:	9b03      	ldr	r3, [sp, #12]
 8004c92:	699a      	ldr	r2, [r3, #24]
 8004c94:	9b03      	ldr	r3, [sp, #12]
 8004c96:	691b      	ldr	r3, [r3, #16]
 8004c98:	429a      	cmp	r2, r3
 8004c9a:	d303      	bcc.n	8004ca4 <iqReadTimeout+0xb4>
      iqp->q_rdptr = iqp->q_buffer;
 8004c9c:	9b03      	ldr	r3, [sp, #12]
 8004c9e:	68da      	ldr	r2, [r3, #12]
 8004ca0:	9b03      	ldr	r3, [sp, #12]
 8004ca2:	619a      	str	r2, [r3, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8004ca4:	9b07      	ldr	r3, [sp, #28]
 8004ca6:	2b00      	cmp	r3, #0
 8004ca8:	d002      	beq.n	8004cb0 <iqReadTimeout+0xc0>
      nfy(iqp);
 8004caa:	9b07      	ldr	r3, [sp, #28]
 8004cac:	9803      	ldr	r0, [sp, #12]
 8004cae:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8004cb0:	f7ff fe8e 	bl	80049d0 <osalSysUnlock>

    r++;
 8004cb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004cb6:	3301      	adds	r3, #1
 8004cb8:	9309      	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
 8004cba:	9b01      	ldr	r3, [sp, #4]
 8004cbc:	3b01      	subs	r3, #1
 8004cbe:	9301      	str	r3, [sp, #4]
 8004cc0:	9b01      	ldr	r3, [sp, #4]
 8004cc2:	2b00      	cmp	r3, #0
 8004cc4:	d101      	bne.n	8004cca <iqReadTimeout+0xda>
      return r;
 8004cc6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004cc8:	e002      	b.n	8004cd0 <iqReadTimeout+0xe0>
    }

    osalSysLock();
 8004cca:	f7ff fe79 	bl	80049c0 <osalSysLock>
  }
 8004cce:	e7a2      	b.n	8004c16 <iqReadTimeout+0x26>
}
 8004cd0:	4618      	mov	r0, r3
 8004cd2:	b00b      	add	sp, #44	; 0x2c
 8004cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004cd8:	f3af 8000 	nop.w
 8004cdc:	f3af 8000 	nop.w

08004ce0 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8004ce0:	b500      	push	{lr}
 8004ce2:	b085      	sub	sp, #20
 8004ce4:	9003      	str	r0, [sp, #12]
 8004ce6:	9102      	str	r1, [sp, #8]
 8004ce8:	9201      	str	r2, [sp, #4]
 8004cea:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8004cec:	9b03      	ldr	r3, [sp, #12]
 8004cee:	4618      	mov	r0, r3
 8004cf0:	f7ff fe7e 	bl	80049f0 <osalThreadQueueObjectInit>
  oqp->q_counter = size;
 8004cf4:	9b03      	ldr	r3, [sp, #12]
 8004cf6:	9a01      	ldr	r2, [sp, #4]
 8004cf8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8004cfa:	9b03      	ldr	r3, [sp, #12]
 8004cfc:	9a02      	ldr	r2, [sp, #8]
 8004cfe:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8004d00:	9b03      	ldr	r3, [sp, #12]
 8004d02:	9a02      	ldr	r2, [sp, #8]
 8004d04:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8004d06:	9b03      	ldr	r3, [sp, #12]
 8004d08:	9a02      	ldr	r2, [sp, #8]
 8004d0a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8004d0c:	9a02      	ldr	r2, [sp, #8]
 8004d0e:	9b01      	ldr	r3, [sp, #4]
 8004d10:	441a      	add	r2, r3
 8004d12:	9b03      	ldr	r3, [sp, #12]
 8004d14:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8004d16:	9b03      	ldr	r3, [sp, #12]
 8004d18:	9a00      	ldr	r2, [sp, #0]
 8004d1a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8004d1c:	9b03      	ldr	r3, [sp, #12]
 8004d1e:	9a06      	ldr	r2, [sp, #24]
 8004d20:	621a      	str	r2, [r3, #32]
}
 8004d22:	b005      	add	sp, #20
 8004d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d28:	f3af 8000 	nop.w
 8004d2c:	f3af 8000 	nop.w

08004d30 <oqResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void oqResetI(output_queue_t *oqp) {
 8004d30:	b500      	push	{lr}
 8004d32:	b083      	sub	sp, #12
 8004d34:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8004d36:	9b01      	ldr	r3, [sp, #4]
 8004d38:	68da      	ldr	r2, [r3, #12]
 8004d3a:	9b01      	ldr	r3, [sp, #4]
 8004d3c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 8004d3e:	9b01      	ldr	r3, [sp, #4]
 8004d40:	68da      	ldr	r2, [r3, #12]
 8004d42:	9b01      	ldr	r3, [sp, #4]
 8004d44:	615a      	str	r2, [r3, #20]
  oqp->q_counter = qSizeX(oqp);
 8004d46:	9b01      	ldr	r3, [sp, #4]
 8004d48:	691b      	ldr	r3, [r3, #16]
 8004d4a:	461a      	mov	r2, r3
 8004d4c:	9b01      	ldr	r3, [sp, #4]
 8004d4e:	68db      	ldr	r3, [r3, #12]
 8004d50:	1ad3      	subs	r3, r2, r3
 8004d52:	461a      	mov	r2, r3
 8004d54:	9b01      	ldr	r3, [sp, #4]
 8004d56:	609a      	str	r2, [r3, #8]
  osalThreadDequeueAllI(&oqp->q_waiting, MSG_RESET);
 8004d58:	9b01      	ldr	r3, [sp, #4]
 8004d5a:	4618      	mov	r0, r3
 8004d5c:	f06f 0101 	mvn.w	r1, #1
 8004d60:	f7ff fe76 	bl	8004a50 <osalThreadDequeueAllI>
}
 8004d64:	b003      	add	sp, #12
 8004d66:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d6a:	bf00      	nop
 8004d6c:	f3af 8000 	nop.w

08004d70 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8004d70:	b500      	push	{lr}
 8004d72:	b087      	sub	sp, #28
 8004d74:	9003      	str	r0, [sp, #12]
 8004d76:	460b      	mov	r3, r1
 8004d78:	9201      	str	r2, [sp, #4]
 8004d7a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalSysLock();
 8004d7e:	f7ff fe1f 	bl	80049c0 <osalSysLock>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8004d82:	e00c      	b.n	8004d9e <oqPutTimeout+0x2e>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8004d84:	9b03      	ldr	r3, [sp, #12]
 8004d86:	4618      	mov	r0, r3
 8004d88:	9901      	ldr	r1, [sp, #4]
 8004d8a:	f7ff fe41 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004d8e:	9005      	str	r0, [sp, #20]
    if (msg < MSG_OK) {
 8004d90:	9b05      	ldr	r3, [sp, #20]
 8004d92:	2b00      	cmp	r3, #0
 8004d94:	da03      	bge.n	8004d9e <oqPutTimeout+0x2e>
      osalSysUnlock();
 8004d96:	f7ff fe1b 	bl	80049d0 <osalSysUnlock>
      return msg;
 8004d9a:	9b05      	ldr	r3, [sp, #20]
 8004d9c:	e025      	b.n	8004dea <oqPutTimeout+0x7a>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8004d9e:	9b03      	ldr	r3, [sp, #12]
 8004da0:	689b      	ldr	r3, [r3, #8]
 8004da2:	2b00      	cmp	r3, #0
 8004da4:	d0ee      	beq.n	8004d84 <oqPutTimeout+0x14>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8004da6:	9b03      	ldr	r3, [sp, #12]
 8004da8:	689b      	ldr	r3, [r3, #8]
 8004daa:	1e5a      	subs	r2, r3, #1
 8004dac:	9b03      	ldr	r3, [sp, #12]
 8004dae:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8004db0:	9b03      	ldr	r3, [sp, #12]
 8004db2:	695b      	ldr	r3, [r3, #20]
 8004db4:	1c59      	adds	r1, r3, #1
 8004db6:	9a03      	ldr	r2, [sp, #12]
 8004db8:	6151      	str	r1, [r2, #20]
 8004dba:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8004dbe:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8004dc0:	9b03      	ldr	r3, [sp, #12]
 8004dc2:	695a      	ldr	r2, [r3, #20]
 8004dc4:	9b03      	ldr	r3, [sp, #12]
 8004dc6:	691b      	ldr	r3, [r3, #16]
 8004dc8:	429a      	cmp	r2, r3
 8004dca:	d303      	bcc.n	8004dd4 <oqPutTimeout+0x64>
    oqp->q_wrptr = oqp->q_buffer;
 8004dcc:	9b03      	ldr	r3, [sp, #12]
 8004dce:	68da      	ldr	r2, [r3, #12]
 8004dd0:	9b03      	ldr	r3, [sp, #12]
 8004dd2:	615a      	str	r2, [r3, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8004dd4:	9b03      	ldr	r3, [sp, #12]
 8004dd6:	69db      	ldr	r3, [r3, #28]
 8004dd8:	2b00      	cmp	r3, #0
 8004dda:	d003      	beq.n	8004de4 <oqPutTimeout+0x74>
    oqp->q_notify(oqp);
 8004ddc:	9b03      	ldr	r3, [sp, #12]
 8004dde:	69db      	ldr	r3, [r3, #28]
 8004de0:	9803      	ldr	r0, [sp, #12]
 8004de2:	4798      	blx	r3
  }

  osalSysUnlock();
 8004de4:	f7ff fdf4 	bl	80049d0 <osalSysUnlock>

  return MSG_OK;
 8004de8:	2300      	movs	r3, #0
}
 8004dea:	4618      	mov	r0, r3
 8004dec:	b007      	add	sp, #28
 8004dee:	f85d fb04 	ldr.w	pc, [sp], #4
 8004df2:	bf00      	nop
 8004df4:	f3af 8000 	nop.w
 8004df8:	f3af 8000 	nop.w
 8004dfc:	f3af 8000 	nop.w

08004e00 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8004e00:	b500      	push	{lr}
 8004e02:	b085      	sub	sp, #20
 8004e04:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8004e06:	9b01      	ldr	r3, [sp, #4]
 8004e08:	695a      	ldr	r2, [r3, #20]
 8004e0a:	9b01      	ldr	r3, [sp, #4]
 8004e0c:	699b      	ldr	r3, [r3, #24]
 8004e0e:	429a      	cmp	r2, r3
 8004e10:	d105      	bne.n	8004e1e <oqGetI+0x1e>
 8004e12:	9b01      	ldr	r3, [sp, #4]
 8004e14:	689b      	ldr	r3, [r3, #8]
 8004e16:	2b00      	cmp	r3, #0
 8004e18:	d001      	beq.n	8004e1e <oqGetI+0x1e>
 8004e1a:	2301      	movs	r3, #1
 8004e1c:	e000      	b.n	8004e20 <oqGetI+0x20>
 8004e1e:	2300      	movs	r3, #0
 8004e20:	f003 0301 	and.w	r3, r3, #1
 8004e24:	b2db      	uxtb	r3, r3
 8004e26:	2b00      	cmp	r3, #0
 8004e28:	d002      	beq.n	8004e30 <oqGetI+0x30>
    return MSG_TIMEOUT;
 8004e2a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004e2e:	e01d      	b.n	8004e6c <oqGetI+0x6c>
  }

  oqp->q_counter++;
 8004e30:	9b01      	ldr	r3, [sp, #4]
 8004e32:	689b      	ldr	r3, [r3, #8]
 8004e34:	1c5a      	adds	r2, r3, #1
 8004e36:	9b01      	ldr	r3, [sp, #4]
 8004e38:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8004e3a:	9b01      	ldr	r3, [sp, #4]
 8004e3c:	699b      	ldr	r3, [r3, #24]
 8004e3e:	1c59      	adds	r1, r3, #1
 8004e40:	9a01      	ldr	r2, [sp, #4]
 8004e42:	6191      	str	r1, [r2, #24]
 8004e44:	781b      	ldrb	r3, [r3, #0]
 8004e46:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8004e4a:	9b01      	ldr	r3, [sp, #4]
 8004e4c:	699a      	ldr	r2, [r3, #24]
 8004e4e:	9b01      	ldr	r3, [sp, #4]
 8004e50:	691b      	ldr	r3, [r3, #16]
 8004e52:	429a      	cmp	r2, r3
 8004e54:	d303      	bcc.n	8004e5e <oqGetI+0x5e>
    oqp->q_rdptr = oqp->q_buffer;
 8004e56:	9b01      	ldr	r3, [sp, #4]
 8004e58:	68da      	ldr	r2, [r3, #12]
 8004e5a:	9b01      	ldr	r3, [sp, #4]
 8004e5c:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8004e5e:	9b01      	ldr	r3, [sp, #4]
 8004e60:	4618      	mov	r0, r3
 8004e62:	2100      	movs	r1, #0
 8004e64:	f7ff fde4 	bl	8004a30 <osalThreadDequeueNextI>

  return (msg_t)b;
 8004e68:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8004e6c:	4618      	mov	r0, r3
 8004e6e:	b005      	add	sp, #20
 8004e70:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e74:	f3af 8000 	nop.w
 8004e78:	f3af 8000 	nop.w
 8004e7c:	f3af 8000 	nop.w

08004e80 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8004e80:	b500      	push	{lr}
 8004e82:	b08b      	sub	sp, #44	; 0x2c
 8004e84:	9003      	str	r0, [sp, #12]
 8004e86:	9102      	str	r1, [sp, #8]
 8004e88:	9201      	str	r2, [sp, #4]
 8004e8a:	9300      	str	r3, [sp, #0]
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8004e8c:	9b03      	ldr	r3, [sp, #12]
 8004e8e:	69db      	ldr	r3, [r3, #28]
 8004e90:	9307      	str	r3, [sp, #28]
  size_t w = 0;
 8004e92:	2300      	movs	r3, #0
 8004e94:	9309      	str	r3, [sp, #36]	; 0x24

  osalDbgCheck(n > 0U);

  osalSysLock();
 8004e96:	f7ff fd93 	bl	80049c0 <osalSysLock>

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004e9a:	f7ff fda1 	bl	80049e0 <osalOsGetSystemTimeX>
 8004e9e:	4602      	mov	r2, r0
 8004ea0:	9b00      	ldr	r3, [sp, #0]
 8004ea2:	4413      	add	r3, r2
 8004ea4:	9306      	str	r3, [sp, #24]

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8004ea6:	e028      	b.n	8004efa <oqWriteTimeout+0x7a>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004ea8:	9b00      	ldr	r3, [sp, #0]
 8004eaa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004eae:	d002      	beq.n	8004eb6 <oqWriteTimeout+0x36>
 8004eb0:	9b00      	ldr	r3, [sp, #0]
 8004eb2:	2b00      	cmp	r3, #0
 8004eb4:	d106      	bne.n	8004ec4 <oqWriteTimeout+0x44>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8004eb6:	9b03      	ldr	r3, [sp, #12]
 8004eb8:	4618      	mov	r0, r3
 8004eba:	9900      	ldr	r1, [sp, #0]
 8004ebc:	f7ff fda8 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004ec0:	9008      	str	r0, [sp, #32]
 8004ec2:	e013      	b.n	8004eec <oqWriteTimeout+0x6c>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004ec4:	f7ff fd8c 	bl	80049e0 <osalOsGetSystemTimeX>
 8004ec8:	4602      	mov	r2, r0
 8004eca:	9b06      	ldr	r3, [sp, #24]
 8004ecc:	1a9b      	subs	r3, r3, r2
 8004ece:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8004ed0:	9a05      	ldr	r2, [sp, #20]
 8004ed2:	9b00      	ldr	r3, [sp, #0]
 8004ed4:	429a      	cmp	r2, r3
 8004ed6:	d903      	bls.n	8004ee0 <oqWriteTimeout+0x60>
          osalSysUnlock();
 8004ed8:	f7ff fd7a 	bl	80049d0 <osalSysUnlock>
          return w;
 8004edc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004ede:	e03f      	b.n	8004f60 <oqWriteTimeout+0xe0>
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8004ee0:	9b03      	ldr	r3, [sp, #12]
 8004ee2:	4618      	mov	r0, r3
 8004ee4:	9905      	ldr	r1, [sp, #20]
 8004ee6:	f7ff fd93 	bl	8004a10 <osalThreadEnqueueTimeoutS>
 8004eea:	9008      	str	r0, [sp, #32]
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8004eec:	9b08      	ldr	r3, [sp, #32]
 8004eee:	2b00      	cmp	r3, #0
 8004ef0:	d003      	beq.n	8004efa <oqWriteTimeout+0x7a>
        osalSysUnlock();
 8004ef2:	f7ff fd6d 	bl	80049d0 <osalSysUnlock>
        return w;
 8004ef6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004ef8:	e032      	b.n	8004f60 <oqWriteTimeout+0xe0>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8004efa:	9b03      	ldr	r3, [sp, #12]
 8004efc:	689b      	ldr	r3, [r3, #8]
 8004efe:	2b00      	cmp	r3, #0
 8004f00:	d0d2      	beq.n	8004ea8 <oqWriteTimeout+0x28>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8004f02:	9b03      	ldr	r3, [sp, #12]
 8004f04:	689b      	ldr	r3, [r3, #8]
 8004f06:	1e5a      	subs	r2, r3, #1
 8004f08:	9b03      	ldr	r3, [sp, #12]
 8004f0a:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8004f0c:	9b03      	ldr	r3, [sp, #12]
 8004f0e:	695b      	ldr	r3, [r3, #20]
 8004f10:	1c59      	adds	r1, r3, #1
 8004f12:	9a03      	ldr	r2, [sp, #12]
 8004f14:	6151      	str	r1, [r2, #20]
 8004f16:	9a02      	ldr	r2, [sp, #8]
 8004f18:	1c51      	adds	r1, r2, #1
 8004f1a:	9102      	str	r1, [sp, #8]
 8004f1c:	7812      	ldrb	r2, [r2, #0]
 8004f1e:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8004f20:	9b03      	ldr	r3, [sp, #12]
 8004f22:	695a      	ldr	r2, [r3, #20]
 8004f24:	9b03      	ldr	r3, [sp, #12]
 8004f26:	691b      	ldr	r3, [r3, #16]
 8004f28:	429a      	cmp	r2, r3
 8004f2a:	d303      	bcc.n	8004f34 <oqWriteTimeout+0xb4>
      oqp->q_wrptr = oqp->q_buffer;
 8004f2c:	9b03      	ldr	r3, [sp, #12]
 8004f2e:	68da      	ldr	r2, [r3, #12]
 8004f30:	9b03      	ldr	r3, [sp, #12]
 8004f32:	615a      	str	r2, [r3, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8004f34:	9b07      	ldr	r3, [sp, #28]
 8004f36:	2b00      	cmp	r3, #0
 8004f38:	d002      	beq.n	8004f40 <oqWriteTimeout+0xc0>
      nfy(oqp);
 8004f3a:	9b07      	ldr	r3, [sp, #28]
 8004f3c:	9803      	ldr	r0, [sp, #12]
 8004f3e:	4798      	blx	r3
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8004f40:	f7ff fd46 	bl	80049d0 <osalSysUnlock>

    w++;
 8004f44:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004f46:	3301      	adds	r3, #1
 8004f48:	9309      	str	r3, [sp, #36]	; 0x24
    if (--n == 0U) {
 8004f4a:	9b01      	ldr	r3, [sp, #4]
 8004f4c:	3b01      	subs	r3, #1
 8004f4e:	9301      	str	r3, [sp, #4]
 8004f50:	9b01      	ldr	r3, [sp, #4]
 8004f52:	2b00      	cmp	r3, #0
 8004f54:	d101      	bne.n	8004f5a <oqWriteTimeout+0xda>
      return w;
 8004f56:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004f58:	e002      	b.n	8004f60 <oqWriteTimeout+0xe0>
    }

    osalSysLock();
 8004f5a:	f7ff fd31 	bl	80049c0 <osalSysLock>
  }
 8004f5e:	e7a2      	b.n	8004ea6 <oqWriteTimeout+0x26>
}
 8004f60:	4618      	mov	r0, r3
 8004f62:	b00b      	add	sp, #44	; 0x2c
 8004f64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004f70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004f70:	b082      	sub	sp, #8
 8004f72:	2320      	movs	r3, #32
 8004f74:	9301      	str	r3, [sp, #4]
 8004f76:	9b01      	ldr	r3, [sp, #4]
 8004f78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004f7c:	b002      	add	sp, #8
 8004f7e:	4770      	bx	lr

08004f80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004f80:	b082      	sub	sp, #8
 8004f82:	2300      	movs	r3, #0
 8004f84:	9301      	str	r3, [sp, #4]
 8004f86:	9b01      	ldr	r3, [sp, #4]
 8004f88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004f8c:	b002      	add	sp, #8
 8004f8e:	4770      	bx	lr

08004f90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004f90:	b508      	push	{r3, lr}

  port_lock();
 8004f92:	f7ff ffed 	bl	8004f70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8004f96:	bd08      	pop	{r3, pc}
 8004f98:	f3af 8000 	nop.w
 8004f9c:	f3af 8000 	nop.w

08004fa0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004fa0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8004fa2:	f7ff ffed 	bl	8004f80 <port_unlock>
}
 8004fa6:	bd08      	pop	{r3, pc}
 8004fa8:	f3af 8000 	nop.w
 8004fac:	f3af 8000 	nop.w

08004fb0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8004fb0:	b508      	push	{r3, lr}

  chSysLock();
 8004fb2:	f7ff ffed 	bl	8004f90 <chSysLock>
}
 8004fb6:	bd08      	pop	{r3, pc}
 8004fb8:	f3af 8000 	nop.w
 8004fbc:	f3af 8000 	nop.w

08004fc0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8004fc0:	b508      	push	{r3, lr}

  chSysUnlock();
 8004fc2:	f7ff ffed 	bl	8004fa0 <chSysUnlock>
}
 8004fc6:	bd08      	pop	{r3, pc}
 8004fc8:	f3af 8000 	nop.w
 8004fcc:	f3af 8000 	nop.w

08004fd0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8004fd0:	b500      	push	{lr}
 8004fd2:	b083      	sub	sp, #12
 8004fd4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8004fd6:	9801      	ldr	r0, [sp, #4]
 8004fd8:	f7fd f8ca 	bl	8002170 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 8004fdc:	b003      	add	sp, #12
 8004fde:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fe2:	bf00      	nop
 8004fe4:	f3af 8000 	nop.w
 8004fe8:	f3af 8000 	nop.w
 8004fec:	f3af 8000 	nop.w

08004ff0 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8004ff0:	b500      	push	{lr}
 8004ff2:	b083      	sub	sp, #12
 8004ff4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8004ff6:	9801      	ldr	r0, [sp, #4]
 8004ff8:	f7fd f8ca 	bl	8002190 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 8004ffc:	b003      	add	sp, #12
 8004ffe:	f85d fb04 	ldr.w	pc, [sp], #4
 8005002:	bf00      	nop
 8005004:	f3af 8000 	nop.w
 8005008:	f3af 8000 	nop.w
 800500c:	f3af 8000 	nop.w

08005010 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8005010:	b500      	push	{lr}
 8005012:	b083      	sub	sp, #12
 8005014:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8005016:	9801      	ldr	r0, [sp, #4]
 8005018:	f7fd f962 	bl	80022e0 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800501c:	b003      	add	sp, #12
 800501e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005022:	bf00      	nop
 8005024:	f3af 8000 	nop.w
 8005028:	f3af 8000 	nop.w
 800502c:	f3af 8000 	nop.w

08005030 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 8005030:	b508      	push	{r3, lr}

  i2c_lld_init();
 8005032:	f001 fce5 	bl	8006a00 <i2c_lld_init>
}
 8005036:	bd08      	pop	{r3, pc}
 8005038:	f3af 8000 	nop.w
 800503c:	f3af 8000 	nop.w

08005040 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 8005040:	b500      	push	{lr}
 8005042:	b083      	sub	sp, #12
 8005044:	9001      	str	r0, [sp, #4]

  i2cp->state  = I2C_STOP;
 8005046:	9b01      	ldr	r3, [sp, #4]
 8005048:	2201      	movs	r2, #1
 800504a:	701a      	strb	r2, [r3, #0]
  i2cp->config = NULL;
 800504c:	9b01      	ldr	r3, [sp, #4]
 800504e:	2200      	movs	r2, #0
 8005050:	605a      	str	r2, [r3, #4]

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
 8005052:	9b01      	ldr	r3, [sp, #4]
 8005054:	330c      	adds	r3, #12
 8005056:	4618      	mov	r0, r3
 8005058:	f7ff ffba 	bl	8004fd0 <osalMutexObjectInit>
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 800505c:	b003      	add	sp, #12
 800505e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005062:	bf00      	nop
 8005064:	f3af 8000 	nop.w
 8005068:	f3af 8000 	nop.w
 800506c:	f3af 8000 	nop.w

08005070 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 8005070:	b500      	push	{lr}
 8005072:	b083      	sub	sp, #12
 8005074:	9001      	str	r0, [sp, #4]
 8005076:	9100      	str	r1, [sp, #0]

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
 8005078:	f7ff ff9a 	bl	8004fb0 <osalSysLock>
  i2cp->config = config;
 800507c:	9b01      	ldr	r3, [sp, #4]
 800507e:	9a00      	ldr	r2, [sp, #0]
 8005080:	605a      	str	r2, [r3, #4]
  i2c_lld_start(i2cp);
 8005082:	9801      	ldr	r0, [sp, #4]
 8005084:	f001 fcdc 	bl	8006a40 <i2c_lld_start>
  i2cp->state = I2C_READY;
 8005088:	9b01      	ldr	r3, [sp, #4]
 800508a:	2202      	movs	r2, #2
 800508c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800508e:	f7ff ff97 	bl	8004fc0 <osalSysUnlock>
}
 8005092:	b003      	add	sp, #12
 8005094:	f85d fb04 	ldr.w	pc, [sp], #4
 8005098:	f3af 8000 	nop.w
 800509c:	f3af 8000 	nop.w

080050a0 <i2cStop>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cStop(I2CDriver *i2cp) {
 80050a0:	b500      	push	{lr}
 80050a2:	b083      	sub	sp, #12
 80050a4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);

  osalSysLock();
 80050a6:	f7ff ff83 	bl	8004fb0 <osalSysLock>

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
 80050aa:	9801      	ldr	r0, [sp, #4]
 80050ac:	f001 fd50 	bl	8006b50 <i2c_lld_stop>
  i2cp->config = NULL;
 80050b0:	9b01      	ldr	r3, [sp, #4]
 80050b2:	2200      	movs	r2, #0
 80050b4:	605a      	str	r2, [r3, #4]
  i2cp->state  = I2C_STOP;
 80050b6:	9b01      	ldr	r3, [sp, #4]
 80050b8:	2201      	movs	r2, #1
 80050ba:	701a      	strb	r2, [r3, #0]

  osalSysUnlock();
 80050bc:	f7ff ff80 	bl	8004fc0 <osalSysUnlock>
}
 80050c0:	b003      	add	sp, #12
 80050c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80050c6:	bf00      	nop
 80050c8:	f3af 8000 	nop.w
 80050cc:	f3af 8000 	nop.w

080050d0 <i2cGetErrors>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @return              The errors mask.
 *
 * @api
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {
 80050d0:	b082      	sub	sp, #8
 80050d2:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);

  return i2c_lld_get_errors(i2cp);
 80050d4:	9b01      	ldr	r3, [sp, #4]
 80050d6:	689b      	ldr	r3, [r3, #8]
}
 80050d8:	4618      	mov	r0, r3
 80050da:	b002      	add	sp, #8
 80050dc:	4770      	bx	lr
 80050de:	bf00      	nop

080050e0 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 80050e0:	b500      	push	{lr}
 80050e2:	b08b      	sub	sp, #44	; 0x2c
 80050e4:	9007      	str	r0, [sp, #28]
 80050e6:	9205      	str	r2, [sp, #20]
 80050e8:	9304      	str	r3, [sp, #16]
 80050ea:	460b      	mov	r3, r1
 80050ec:	f8ad 301a 	strh.w	r3, [sp, #26]
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
 80050f0:	f7ff ff5e 	bl	8004fb0 <osalSysLock>
  i2cp->errors = I2C_NO_ERROR;
 80050f4:	9b07      	ldr	r3, [sp, #28]
 80050f6:	2200      	movs	r2, #0
 80050f8:	609a      	str	r2, [r3, #8]
  i2cp->state = I2C_ACTIVE_TX;
 80050fa:	9b07      	ldr	r3, [sp, #28]
 80050fc:	2203      	movs	r2, #3
 80050fe:	701a      	strb	r2, [r3, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8005100:	f8bd 201a 	ldrh.w	r2, [sp, #26]
 8005104:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005106:	9300      	str	r3, [sp, #0]
 8005108:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800510a:	9301      	str	r3, [sp, #4]
 800510c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800510e:	9302      	str	r3, [sp, #8]
 8005110:	9807      	ldr	r0, [sp, #28]
 8005112:	4611      	mov	r1, r2
 8005114:	9a05      	ldr	r2, [sp, #20]
 8005116:	9b04      	ldr	r3, [sp, #16]
 8005118:	f001 fdba 	bl	8006c90 <i2c_lld_master_transmit_timeout>
 800511c:	9009      	str	r0, [sp, #36]	; 0x24
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 800511e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005120:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005124:	d103      	bne.n	800512e <i2cMasterTransmitTimeout+0x4e>
    i2cp->state = I2C_LOCKED;
 8005126:	9b07      	ldr	r3, [sp, #28]
 8005128:	2205      	movs	r2, #5
 800512a:	701a      	strb	r2, [r3, #0]
 800512c:	e002      	b.n	8005134 <i2cMasterTransmitTimeout+0x54>
  }
  else {
    i2cp->state = I2C_READY;
 800512e:	9b07      	ldr	r3, [sp, #28]
 8005130:	2202      	movs	r2, #2
 8005132:	701a      	strb	r2, [r3, #0]
  }
  osalSysUnlock();
 8005134:	f7ff ff44 	bl	8004fc0 <osalSysUnlock>
  return rdymsg;
 8005138:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800513a:	4618      	mov	r0, r3
 800513c:	b00b      	add	sp, #44	; 0x2c
 800513e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005142:	bf00      	nop
 8005144:	f3af 8000 	nop.w
 8005148:	f3af 8000 	nop.w
 800514c:	f3af 8000 	nop.w

08005150 <i2cMasterReceiveTimeout>:
 */
msg_t i2cMasterReceiveTimeout(I2CDriver *i2cp,
                              i2caddr_t addr,
                              uint8_t *rxbuf,
                              size_t rxbytes,
                              systime_t timeout){
 8005150:	b500      	push	{lr}
 8005152:	b089      	sub	sp, #36	; 0x24
 8005154:	9005      	str	r0, [sp, #20]
 8005156:	9203      	str	r2, [sp, #12]
 8005158:	9302      	str	r3, [sp, #8]
 800515a:	460b      	mov	r3, r1
 800515c:	f8ad 3012 	strh.w	r3, [sp, #18]
               (rxbytes > 0U) && (rxbuf != NULL) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
 8005160:	f7ff ff26 	bl	8004fb0 <osalSysLock>
  i2cp->errors = I2C_NO_ERROR;
 8005164:	9b05      	ldr	r3, [sp, #20]
 8005166:	2200      	movs	r2, #0
 8005168:	609a      	str	r2, [r3, #8]
  i2cp->state = I2C_ACTIVE_RX;
 800516a:	9b05      	ldr	r3, [sp, #20]
 800516c:	2204      	movs	r2, #4
 800516e:	701a      	strb	r2, [r3, #0]
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
 8005170:	f8bd 2012 	ldrh.w	r2, [sp, #18]
 8005174:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8005176:	9300      	str	r3, [sp, #0]
 8005178:	9805      	ldr	r0, [sp, #20]
 800517a:	4611      	mov	r1, r2
 800517c:	9a03      	ldr	r2, [sp, #12]
 800517e:	9b02      	ldr	r3, [sp, #8]
 8005180:	f001 fd16 	bl	8006bb0 <i2c_lld_master_receive_timeout>
 8005184:	9007      	str	r0, [sp, #28]
  if (rdymsg == MSG_TIMEOUT) {
 8005186:	9b07      	ldr	r3, [sp, #28]
 8005188:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800518c:	d103      	bne.n	8005196 <i2cMasterReceiveTimeout+0x46>
    i2cp->state = I2C_LOCKED;
 800518e:	9b05      	ldr	r3, [sp, #20]
 8005190:	2205      	movs	r2, #5
 8005192:	701a      	strb	r2, [r3, #0]
 8005194:	e002      	b.n	800519c <i2cMasterReceiveTimeout+0x4c>
  }
  else {
    i2cp->state = I2C_READY;
 8005196:	9b05      	ldr	r3, [sp, #20]
 8005198:	2202      	movs	r2, #2
 800519a:	701a      	strb	r2, [r3, #0]
  }
  osalSysUnlock();
 800519c:	f7ff ff10 	bl	8004fc0 <osalSysUnlock>
  return rdymsg;
 80051a0:	9b07      	ldr	r3, [sp, #28]
}
 80051a2:	4618      	mov	r0, r3
 80051a4:	b009      	add	sp, #36	; 0x24
 80051a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80051aa:	bf00      	nop
 80051ac:	f3af 8000 	nop.w

080051b0 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
 80051b0:	b500      	push	{lr}
 80051b2:	b083      	sub	sp, #12
 80051b4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);

  osalMutexLock(&i2cp->mutex);
 80051b6:	9b01      	ldr	r3, [sp, #4]
 80051b8:	330c      	adds	r3, #12
 80051ba:	4618      	mov	r0, r3
 80051bc:	f7ff ff18 	bl	8004ff0 <osalMutexLock>
}
 80051c0:	b003      	add	sp, #12
 80051c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80051c6:	bf00      	nop
 80051c8:	f3af 8000 	nop.w
 80051cc:	f3af 8000 	nop.w

080051d0 <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
 80051d0:	b500      	push	{lr}
 80051d2:	b083      	sub	sp, #12
 80051d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);

  osalMutexUnlock(&i2cp->mutex);
 80051d6:	9b01      	ldr	r3, [sp, #4]
 80051d8:	330c      	adds	r3, #12
 80051da:	4618      	mov	r0, r3
 80051dc:	f7ff ff18 	bl	8005010 <osalMutexUnlock>
}
 80051e0:	b003      	add	sp, #12
 80051e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80051e6:	bf00      	nop
	...

080051f0 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @special
 */
ioportmask_t palReadBus(IOBus *bus) {
 80051f0:	b082      	sub	sp, #8
 80051f2:	9001      	str	r0, [sp, #4]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  return palReadGroup(bus->portid, bus->mask, bus->offset);
 80051f4:	9b01      	ldr	r3, [sp, #4]
 80051f6:	681b      	ldr	r3, [r3, #0]
 80051f8:	691b      	ldr	r3, [r3, #16]
 80051fa:	9a01      	ldr	r2, [sp, #4]
 80051fc:	6892      	ldr	r2, [r2, #8]
 80051fe:	fa23 f202 	lsr.w	r2, r3, r2
 8005202:	9b01      	ldr	r3, [sp, #4]
 8005204:	685b      	ldr	r3, [r3, #4]
 8005206:	4013      	ands	r3, r2
}
 8005208:	4618      	mov	r0, r3
 800520a:	b002      	add	sp, #8
 800520c:	4770      	bx	lr
 800520e:	bf00      	nop

08005210 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @special
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
 8005210:	b082      	sub	sp, #8
 8005212:	9001      	str	r0, [sp, #4]
 8005214:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
 8005216:	9b01      	ldr	r3, [sp, #4]
 8005218:	681b      	ldr	r3, [r3, #0]
 800521a:	9a00      	ldr	r2, [sp, #0]
 800521c:	43d1      	mvns	r1, r2
 800521e:	9a01      	ldr	r2, [sp, #4]
 8005220:	6852      	ldr	r2, [r2, #4]
 8005222:	400a      	ands	r2, r1
 8005224:	9901      	ldr	r1, [sp, #4]
 8005226:	6889      	ldr	r1, [r1, #8]
 8005228:	3110      	adds	r1, #16
 800522a:	fa02 f101 	lsl.w	r1, r2, r1
 800522e:	9a01      	ldr	r2, [sp, #4]
 8005230:	6850      	ldr	r0, [r2, #4]
 8005232:	9a00      	ldr	r2, [sp, #0]
 8005234:	4002      	ands	r2, r0
 8005236:	9801      	ldr	r0, [sp, #4]
 8005238:	6880      	ldr	r0, [r0, #8]
 800523a:	4082      	lsls	r2, r0
 800523c:	430a      	orrs	r2, r1
 800523e:	619a      	str	r2, [r3, #24]
}
 8005240:	b002      	add	sp, #8
 8005242:	4770      	bx	lr
 8005244:	f3af 8000 	nop.w
 8005248:	f3af 8000 	nop.w
 800524c:	f3af 8000 	nop.w

08005250 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @special
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
 8005250:	b500      	push	{lr}
 8005252:	b083      	sub	sp, #12
 8005254:	9001      	str	r0, [sp, #4]
 8005256:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
 8005258:	9b01      	ldr	r3, [sp, #4]
 800525a:	6819      	ldr	r1, [r3, #0]
 800525c:	9b01      	ldr	r3, [sp, #4]
 800525e:	685b      	ldr	r3, [r3, #4]
 8005260:	9a01      	ldr	r2, [sp, #4]
 8005262:	6892      	ldr	r2, [r2, #8]
 8005264:	4093      	lsls	r3, r2
 8005266:	4608      	mov	r0, r1
 8005268:	4619      	mov	r1, r3
 800526a:	9a00      	ldr	r2, [sp, #0]
 800526c:	f000 fef0 	bl	8006050 <_pal_lld_setgroupmode>
}
 8005270:	b003      	add	sp, #12
 8005272:	f85d fb04 	ldr.w	pc, [sp], #4
 8005276:	bf00      	nop
	...

08005280 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005280:	b082      	sub	sp, #8
 8005282:	2320      	movs	r3, #32
 8005284:	9301      	str	r3, [sp, #4]
 8005286:	9b01      	ldr	r3, [sp, #4]
 8005288:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800528c:	b002      	add	sp, #8
 800528e:	4770      	bx	lr

08005290 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005290:	b082      	sub	sp, #8
 8005292:	2300      	movs	r3, #0
 8005294:	9301      	str	r3, [sp, #4]
 8005296:	9b01      	ldr	r3, [sp, #4]
 8005298:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800529c:	b002      	add	sp, #8
 800529e:	4770      	bx	lr

080052a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80052a0:	b508      	push	{r3, lr}

  port_lock();
 80052a2:	f7ff ffed 	bl	8005280 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80052a6:	bd08      	pop	{r3, pc}
 80052a8:	f3af 8000 	nop.w
 80052ac:	f3af 8000 	nop.w

080052b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80052b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 80052b2:	f7ff ffed 	bl	8005290 <port_unlock>
}
 80052b6:	bd08      	pop	{r3, pc}
 80052b8:	f3af 8000 	nop.w
 80052bc:	f3af 8000 	nop.w

080052c0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80052c0:	b082      	sub	sp, #8
 80052c2:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 80052c4:	9b01      	ldr	r3, [sp, #4]
 80052c6:	9a01      	ldr	r2, [sp, #4]
 80052c8:	601a      	str	r2, [r3, #0]
}
 80052ca:	b002      	add	sp, #8
 80052cc:	4770      	bx	lr
 80052ce:	bf00      	nop

080052d0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80052d0:	b508      	push	{r3, lr}

  chSysLock();
 80052d2:	f7ff ffe5 	bl	80052a0 <chSysLock>
}
 80052d6:	bd08      	pop	{r3, pc}
 80052d8:	f3af 8000 	nop.w
 80052dc:	f3af 8000 	nop.w

080052e0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80052e0:	b508      	push	{r3, lr}

  chSysUnlock();
 80052e2:	f7ff ffe5 	bl	80052b0 <chSysUnlock>
}
 80052e6:	bd08      	pop	{r3, pc}
 80052e8:	f3af 8000 	nop.w
 80052ec:	f3af 8000 	nop.w

080052f0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 80052f0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 80052f2:	f7fb fe4d 	bl	8000f90 <chSchRescheduleS>
}
 80052f6:	bd08      	pop	{r3, pc}
 80052f8:	f3af 8000 	nop.w
 80052fc:	f3af 8000 	nop.w

08005300 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8005300:	b500      	push	{lr}
 8005302:	b083      	sub	sp, #12
 8005304:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8005306:	9801      	ldr	r0, [sp, #4]
 8005308:	f7ff ffda 	bl	80052c0 <chEvtObjectInit>
}
 800530c:	b003      	add	sp, #12
 800530e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005312:	bf00      	nop
 8005314:	f3af 8000 	nop.w
 8005318:	f3af 8000 	nop.w
 800531c:	f3af 8000 	nop.w

08005320 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8005320:	b500      	push	{lr}
 8005322:	b083      	sub	sp, #12
 8005324:	9001      	str	r0, [sp, #4]
 8005326:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8005328:	9801      	ldr	r0, [sp, #4]
 800532a:	9900      	ldr	r1, [sp, #0]
 800532c:	f7fd fb20 	bl	8002970 <chEvtBroadcastFlagsI>
}
 8005330:	b003      	add	sp, #12
 8005332:	f85d fb04 	ldr.w	pc, [sp], #4
 8005336:	bf00      	nop
 8005338:	f3af 8000 	nop.w
 800533c:	f3af 8000 	nop.w

08005340 <_write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8005340:	b500      	push	{lr}
 8005342:	b085      	sub	sp, #20
 8005344:	9003      	str	r0, [sp, #12]
 8005346:	9102      	str	r1, [sp, #8]
 8005348:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800534a:	9b03      	ldr	r3, [sp, #12]
 800534c:	3330      	adds	r3, #48	; 0x30
 800534e:	4618      	mov	r0, r3
 8005350:	9902      	ldr	r1, [sp, #8]
 8005352:	9a01      	ldr	r2, [sp, #4]
 8005354:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005358:	f7ff fd92 	bl	8004e80 <oqWriteTimeout>
 800535c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800535e:	4618      	mov	r0, r3
 8005360:	b005      	add	sp, #20
 8005362:	f85d fb04 	ldr.w	pc, [sp], #4
 8005366:	bf00      	nop
 8005368:	f3af 8000 	nop.w
 800536c:	f3af 8000 	nop.w

08005370 <_read>:

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8005370:	b500      	push	{lr}
 8005372:	b085      	sub	sp, #20
 8005374:	9003      	str	r0, [sp, #12]
 8005376:	9102      	str	r1, [sp, #8]
 8005378:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800537a:	9b03      	ldr	r3, [sp, #12]
 800537c:	330c      	adds	r3, #12
 800537e:	4618      	mov	r0, r3
 8005380:	9902      	ldr	r1, [sp, #8]
 8005382:	9a01      	ldr	r2, [sp, #4]
 8005384:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005388:	f7ff fc32 	bl	8004bf0 <iqReadTimeout>
 800538c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800538e:	4618      	mov	r0, r3
 8005390:	b005      	add	sp, #20
 8005392:	f85d fb04 	ldr.w	pc, [sp], #4
 8005396:	bf00      	nop
 8005398:	f3af 8000 	nop.w
 800539c:	f3af 8000 	nop.w

080053a0 <_put>:

static msg_t _put(void *ip, uint8_t b) {
 80053a0:	b500      	push	{lr}
 80053a2:	b083      	sub	sp, #12
 80053a4:	9001      	str	r0, [sp, #4]
 80053a6:	460b      	mov	r3, r1
 80053a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80053ac:	9b01      	ldr	r3, [sp, #4]
 80053ae:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80053b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80053b6:	4610      	mov	r0, r2
 80053b8:	4619      	mov	r1, r3
 80053ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80053be:	f7ff fcd7 	bl	8004d70 <oqPutTimeout>
 80053c2:	4603      	mov	r3, r0
}
 80053c4:	4618      	mov	r0, r3
 80053c6:	b003      	add	sp, #12
 80053c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80053cc:	f3af 8000 	nop.w

080053d0 <_get>:

static msg_t _get(void *ip) {
 80053d0:	b500      	push	{lr}
 80053d2:	b083      	sub	sp, #12
 80053d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80053d6:	9b01      	ldr	r3, [sp, #4]
 80053d8:	330c      	adds	r3, #12
 80053da:	4618      	mov	r0, r3
 80053dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80053e0:	f7ff fbc6 	bl	8004b70 <iqGetTimeout>
 80053e4:	4603      	mov	r3, r0
}
 80053e6:	4618      	mov	r0, r3
 80053e8:	b003      	add	sp, #12
 80053ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80053ee:	bf00      	nop

080053f0 <_putt>:

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 80053f0:	b500      	push	{lr}
 80053f2:	b085      	sub	sp, #20
 80053f4:	9003      	str	r0, [sp, #12]
 80053f6:	460b      	mov	r3, r1
 80053f8:	9201      	str	r2, [sp, #4]
 80053fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80053fe:	9b03      	ldr	r3, [sp, #12]
 8005400:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8005404:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005408:	4610      	mov	r0, r2
 800540a:	4619      	mov	r1, r3
 800540c:	9a01      	ldr	r2, [sp, #4]
 800540e:	f7ff fcaf 	bl	8004d70 <oqPutTimeout>
 8005412:	4603      	mov	r3, r0
}
 8005414:	4618      	mov	r0, r3
 8005416:	b005      	add	sp, #20
 8005418:	f85d fb04 	ldr.w	pc, [sp], #4
 800541c:	f3af 8000 	nop.w

08005420 <_gett>:

static msg_t _gett(void *ip, systime_t timeout) {
 8005420:	b500      	push	{lr}
 8005422:	b083      	sub	sp, #12
 8005424:	9001      	str	r0, [sp, #4]
 8005426:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8005428:	9b01      	ldr	r3, [sp, #4]
 800542a:	330c      	adds	r3, #12
 800542c:	4618      	mov	r0, r3
 800542e:	9900      	ldr	r1, [sp, #0]
 8005430:	f7ff fb9e 	bl	8004b70 <iqGetTimeout>
 8005434:	4603      	mov	r3, r0
}
 8005436:	4618      	mov	r0, r3
 8005438:	b003      	add	sp, #12
 800543a:	f85d fb04 	ldr.w	pc, [sp], #4
 800543e:	bf00      	nop

08005440 <_writet>:

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8005440:	b500      	push	{lr}
 8005442:	b085      	sub	sp, #20
 8005444:	9003      	str	r0, [sp, #12]
 8005446:	9102      	str	r1, [sp, #8]
 8005448:	9201      	str	r2, [sp, #4]
 800544a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800544c:	9b03      	ldr	r3, [sp, #12]
 800544e:	3330      	adds	r3, #48	; 0x30
 8005450:	4618      	mov	r0, r3
 8005452:	9902      	ldr	r1, [sp, #8]
 8005454:	9a01      	ldr	r2, [sp, #4]
 8005456:	9b00      	ldr	r3, [sp, #0]
 8005458:	f7ff fd12 	bl	8004e80 <oqWriteTimeout>
 800545c:	4603      	mov	r3, r0
}
 800545e:	4618      	mov	r0, r3
 8005460:	b005      	add	sp, #20
 8005462:	f85d fb04 	ldr.w	pc, [sp], #4
 8005466:	bf00      	nop
 8005468:	f3af 8000 	nop.w
 800546c:	f3af 8000 	nop.w

08005470 <_readt>:

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8005470:	b500      	push	{lr}
 8005472:	b085      	sub	sp, #20
 8005474:	9003      	str	r0, [sp, #12]
 8005476:	9102      	str	r1, [sp, #8]
 8005478:	9201      	str	r2, [sp, #4]
 800547a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800547c:	9b03      	ldr	r3, [sp, #12]
 800547e:	330c      	adds	r3, #12
 8005480:	4618      	mov	r0, r3
 8005482:	9902      	ldr	r1, [sp, #8]
 8005484:	9a01      	ldr	r2, [sp, #4]
 8005486:	9b00      	ldr	r3, [sp, #0]
 8005488:	f7ff fbb2 	bl	8004bf0 <iqReadTimeout>
 800548c:	4603      	mov	r3, r0
}
 800548e:	4618      	mov	r0, r3
 8005490:	b005      	add	sp, #20
 8005492:	f85d fb04 	ldr.w	pc, [sp], #4
 8005496:	bf00      	nop
 8005498:	f3af 8000 	nop.w
 800549c:	f3af 8000 	nop.w

080054a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80054a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80054a2:	f001 fef5 	bl	8007290 <sd_lld_init>
}
 80054a6:	bd08      	pop	{r3, pc}
 80054a8:	f3af 8000 	nop.w
 80054ac:	f3af 8000 	nop.w

080054b0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80054b0:	b500      	push	{lr}
 80054b2:	b087      	sub	sp, #28
 80054b4:	9005      	str	r0, [sp, #20]
 80054b6:	9104      	str	r1, [sp, #16]
 80054b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80054ba:	9b05      	ldr	r3, [sp, #20]
 80054bc:	4a14      	ldr	r2, [pc, #80]	; (8005510 <sdObjectInit+0x60>)
 80054be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80054c0:	9b05      	ldr	r3, [sp, #20]
 80054c2:	3304      	adds	r3, #4
 80054c4:	4618      	mov	r0, r3
 80054c6:	f7ff ff1b 	bl	8005300 <osalEventObjectInit>
  sdp->state = SD_STOP;
 80054ca:	9b05      	ldr	r3, [sp, #20]
 80054cc:	2201      	movs	r2, #1
 80054ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80054d0:	9b05      	ldr	r3, [sp, #20]
 80054d2:	f103 010c 	add.w	r1, r3, #12
 80054d6:	9b05      	ldr	r3, [sp, #20]
 80054d8:	f103 0254 	add.w	r2, r3, #84	; 0x54
 80054dc:	9b05      	ldr	r3, [sp, #20]
 80054de:	9300      	str	r3, [sp, #0]
 80054e0:	4608      	mov	r0, r1
 80054e2:	4611      	mov	r1, r2
 80054e4:	2210      	movs	r2, #16
 80054e6:	9b04      	ldr	r3, [sp, #16]
 80054e8:	f7ff fac2 	bl	8004a70 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80054ec:	9b05      	ldr	r3, [sp, #20]
 80054ee:	f103 0130 	add.w	r1, r3, #48	; 0x30
 80054f2:	9b05      	ldr	r3, [sp, #20]
 80054f4:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80054f8:	9b05      	ldr	r3, [sp, #20]
 80054fa:	9300      	str	r3, [sp, #0]
 80054fc:	4608      	mov	r0, r1
 80054fe:	4611      	mov	r1, r2
 8005500:	2210      	movs	r2, #16
 8005502:	9b03      	ldr	r3, [sp, #12]
 8005504:	f7ff fbec 	bl	8004ce0 <oqObjectInit>
}
 8005508:	b007      	add	sp, #28
 800550a:	f85d fb04 	ldr.w	pc, [sp], #4
 800550e:	bf00      	nop
 8005510:	0800dec0 	.word	0x0800dec0
 8005514:	f3af 8000 	nop.w
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8005520:	b500      	push	{lr}
 8005522:	b083      	sub	sp, #12
 8005524:	9001      	str	r0, [sp, #4]
 8005526:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8005528:	f7ff fed2 	bl	80052d0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800552c:	9801      	ldr	r0, [sp, #4]
 800552e:	9900      	ldr	r1, [sp, #0]
 8005530:	f001 fece 	bl	80072d0 <sd_lld_start>
  sdp->state = SD_READY;
 8005534:	9b01      	ldr	r3, [sp, #4]
 8005536:	2202      	movs	r2, #2
 8005538:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800553a:	f7ff fed1 	bl	80052e0 <osalSysUnlock>
}
 800553e:	b003      	add	sp, #12
 8005540:	f85d fb04 	ldr.w	pc, [sp], #4
 8005544:	f3af 8000 	nop.w
 8005548:	f3af 8000 	nop.w
 800554c:	f3af 8000 	nop.w

08005550 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8005550:	b500      	push	{lr}
 8005552:	b083      	sub	sp, #12
 8005554:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8005556:	f7ff febb 	bl	80052d0 <osalSysLock>

  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");

  sd_lld_stop(sdp);
 800555a:	9801      	ldr	r0, [sp, #4]
 800555c:	f001 fef0 	bl	8007340 <sd_lld_stop>
  sdp->state = SD_STOP;
 8005560:	9b01      	ldr	r3, [sp, #4]
 8005562:	2201      	movs	r2, #1
 8005564:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8005566:	9b01      	ldr	r3, [sp, #4]
 8005568:	3330      	adds	r3, #48	; 0x30
 800556a:	4618      	mov	r0, r3
 800556c:	f7ff fbe0 	bl	8004d30 <oqResetI>
  iqResetI(&sdp->iqueue);
 8005570:	9b01      	ldr	r3, [sp, #4]
 8005572:	330c      	adds	r3, #12
 8005574:	4618      	mov	r0, r3
 8005576:	f7ff faa3 	bl	8004ac0 <iqResetI>
  osalOsRescheduleS();
 800557a:	f7ff feb9 	bl	80052f0 <osalOsRescheduleS>

  osalSysUnlock();
 800557e:	f7ff feaf 	bl	80052e0 <osalSysUnlock>
}
 8005582:	b003      	add	sp, #12
 8005584:	f85d fb04 	ldr.w	pc, [sp], #4
 8005588:	f3af 8000 	nop.w
 800558c:	f3af 8000 	nop.w

08005590 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8005590:	b500      	push	{lr}
 8005592:	b083      	sub	sp, #12
 8005594:	9001      	str	r0, [sp, #4]
 8005596:	460b      	mov	r3, r1
 8005598:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800559c:	9b01      	ldr	r3, [sp, #4]
 800559e:	695b      	ldr	r3, [r3, #20]
 80055a0:	2b00      	cmp	r3, #0
 80055a2:	d105      	bne.n	80055b0 <sdIncomingDataI+0x20>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 80055a4:	9b01      	ldr	r3, [sp, #4]
 80055a6:	3304      	adds	r3, #4
 80055a8:	4618      	mov	r0, r3
 80055aa:	2104      	movs	r1, #4
 80055ac:	f7ff feb8 	bl	8005320 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80055b0:	9b01      	ldr	r3, [sp, #4]
 80055b2:	f103 020c 	add.w	r2, r3, #12
 80055b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80055ba:	4610      	mov	r0, r2
 80055bc:	4619      	mov	r1, r3
 80055be:	f7ff fa97 	bl	8004af0 <iqPutI>
 80055c2:	4603      	mov	r3, r0
 80055c4:	2b00      	cmp	r3, #0
 80055c6:	da06      	bge.n	80055d6 <sdIncomingDataI+0x46>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 80055c8:	9b01      	ldr	r3, [sp, #4]
 80055ca:	3304      	adds	r3, #4
 80055cc:	4618      	mov	r0, r3
 80055ce:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80055d2:	f7ff fea5 	bl	8005320 <osalEventBroadcastFlagsI>
}
 80055d6:	b003      	add	sp, #12
 80055d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80055dc:	f3af 8000 	nop.w

080055e0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
 80055e0:	b500      	push	{lr}
 80055e2:	b085      	sub	sp, #20
 80055e4:	9001      	str	r0, [sp, #4]
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
 80055e6:	9b01      	ldr	r3, [sp, #4]
 80055e8:	3330      	adds	r3, #48	; 0x30
 80055ea:	4618      	mov	r0, r3
 80055ec:	f7ff fc08 	bl	8004e00 <oqGetI>
 80055f0:	9003      	str	r0, [sp, #12]
  if (b < MSG_OK)
 80055f2:	9b03      	ldr	r3, [sp, #12]
 80055f4:	2b00      	cmp	r3, #0
 80055f6:	da05      	bge.n	8005604 <sdRequestDataI+0x24>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80055f8:	9b01      	ldr	r3, [sp, #4]
 80055fa:	3304      	adds	r3, #4
 80055fc:	4618      	mov	r0, r3
 80055fe:	2108      	movs	r1, #8
 8005600:	f7ff fe8e 	bl	8005320 <osalEventBroadcastFlagsI>
  return b;
 8005604:	9b03      	ldr	r3, [sp, #12]
}
 8005606:	4618      	mov	r0, r3
 8005608:	b005      	add	sp, #20
 800560a:	f85d fb04 	ldr.w	pc, [sp], #4
 800560e:	bf00      	nop

08005610 <sdPutWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdPutWouldBlock(SerialDriver *sdp) {
 8005610:	b500      	push	{lr}
 8005612:	b085      	sub	sp, #20
 8005614:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8005616:	f7ff fe5b 	bl	80052d0 <osalSysLock>
  b = oqIsFullI(&sdp->oqueue);
 800561a:	9b01      	ldr	r3, [sp, #4]
 800561c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800561e:	2b00      	cmp	r3, #0
 8005620:	bf0c      	ite	eq
 8005622:	2301      	moveq	r3, #1
 8005624:	2300      	movne	r3, #0
 8005626:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800562a:	f7ff fe59 	bl	80052e0 <osalSysUnlock>

  return b;
 800562e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005632:	4618      	mov	r0, r3
 8005634:	b005      	add	sp, #20
 8005636:	f85d fb04 	ldr.w	pc, [sp], #4
 800563a:	bf00      	nop
 800563c:	f3af 8000 	nop.w

08005640 <sdGetWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
 8005640:	b500      	push	{lr}
 8005642:	b085      	sub	sp, #20
 8005644:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8005646:	f7ff fe43 	bl	80052d0 <osalSysLock>
  b = iqIsEmptyI(&sdp->iqueue);
 800564a:	9b01      	ldr	r3, [sp, #4]
 800564c:	695b      	ldr	r3, [r3, #20]
 800564e:	2b00      	cmp	r3, #0
 8005650:	bf0c      	ite	eq
 8005652:	2301      	moveq	r3, #1
 8005654:	2300      	movne	r3, #0
 8005656:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800565a:	f7ff fe41 	bl	80052e0 <osalSysUnlock>

  return b;
 800565e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005662:	4618      	mov	r0, r3
 8005664:	b005      	add	sp, #20
 8005666:	f85d fb04 	ldr.w	pc, [sp], #4
 800566a:	bf00      	nop
 800566c:	0000      	movs	r0, r0
	...

08005670 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8005670:	b082      	sub	sp, #8
 8005672:	9001      	str	r0, [sp, #4]
 8005674:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005676:	4a12      	ldr	r2, [pc, #72]	; (80056c0 <nvicEnableVector+0x50>)
 8005678:	9b00      	ldr	r3, [sp, #0]
 800567a:	b2db      	uxtb	r3, r3
 800567c:	011b      	lsls	r3, r3, #4
 800567e:	b2d9      	uxtb	r1, r3
 8005680:	9b01      	ldr	r3, [sp, #4]
 8005682:	4413      	add	r3, r2
 8005684:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8005688:	460a      	mov	r2, r1
 800568a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800568c:	490c      	ldr	r1, [pc, #48]	; (80056c0 <nvicEnableVector+0x50>)
 800568e:	9b01      	ldr	r3, [sp, #4]
 8005690:	095b      	lsrs	r3, r3, #5
 8005692:	9a01      	ldr	r2, [sp, #4]
 8005694:	f002 021f 	and.w	r2, r2, #31
 8005698:	2001      	movs	r0, #1
 800569a:	fa00 f202 	lsl.w	r2, r0, r2
 800569e:	3360      	adds	r3, #96	; 0x60
 80056a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80056a4:	4906      	ldr	r1, [pc, #24]	; (80056c0 <nvicEnableVector+0x50>)
 80056a6:	9b01      	ldr	r3, [sp, #4]
 80056a8:	095b      	lsrs	r3, r3, #5
 80056aa:	9a01      	ldr	r2, [sp, #4]
 80056ac:	f002 021f 	and.w	r2, r2, #31
 80056b0:	2001      	movs	r0, #1
 80056b2:	fa00 f202 	lsl.w	r2, r0, r2
 80056b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80056ba:	b002      	add	sp, #8
 80056bc:	4770      	bx	lr
 80056be:	bf00      	nop
 80056c0:	e000e100 	.word	0xe000e100
 80056c4:	f3af 8000 	nop.w
 80056c8:	f3af 8000 	nop.w
 80056cc:	f3af 8000 	nop.w

080056d0 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 80056d0:	b082      	sub	sp, #8
 80056d2:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80056d4:	490a      	ldr	r1, [pc, #40]	; (8005700 <nvicDisableVector+0x30>)
 80056d6:	9b01      	ldr	r3, [sp, #4]
 80056d8:	095b      	lsrs	r3, r3, #5
 80056da:	9a01      	ldr	r2, [sp, #4]
 80056dc:	f002 021f 	and.w	r2, r2, #31
 80056e0:	2001      	movs	r0, #1
 80056e2:	fa00 f202 	lsl.w	r2, r0, r2
 80056e6:	3320      	adds	r3, #32
 80056e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80056ec:	4a04      	ldr	r2, [pc, #16]	; (8005700 <nvicDisableVector+0x30>)
 80056ee:	9b01      	ldr	r3, [sp, #4]
 80056f0:	4413      	add	r3, r2
 80056f2:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80056f6:	2200      	movs	r2, #0
 80056f8:	701a      	strb	r2, [r3, #0]
#endif
}
 80056fa:	b002      	add	sp, #8
 80056fc:	4770      	bx	lr
 80056fe:	bf00      	nop
 8005700:	e000e100 	.word	0xe000e100
 8005704:	f3af 8000 	nop.w
 8005708:	f3af 8000 	nop.w
 800570c:	f3af 8000 	nop.w

08005710 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8005710:	b082      	sub	sp, #8
 8005712:	9001      	str	r0, [sp, #4]
 8005714:	9100      	str	r1, [sp, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 8005716:	4a06      	ldr	r2, [pc, #24]	; (8005730 <nvicSetSystemHandlerPriority+0x20>)
 8005718:	9b00      	ldr	r3, [sp, #0]
 800571a:	b2db      	uxtb	r3, r3
 800571c:	011b      	lsls	r3, r3, #4
 800571e:	b2d9      	uxtb	r1, r3
 8005720:	9b01      	ldr	r3, [sp, #4]
 8005722:	4413      	add	r3, r2
 8005724:	3318      	adds	r3, #24
 8005726:	460a      	mov	r2, r1
 8005728:	701a      	strb	r2, [r3, #0]
#endif
}
 800572a:	b002      	add	sp, #8
 800572c:	4770      	bx	lr
 800572e:	bf00      	nop
 8005730:	e000ed00 	.word	0xe000ed00
 8005734:	f3af 8000 	nop.w
 8005738:	f3af 8000 	nop.w
 800573c:	f3af 8000 	nop.w

08005740 <nvicClearPending>:
/**
 * @brief   Clears a pending interrupt source.
 *
 * @param[in] n         the interrupt number
 */
void nvicClearPending(uint32_t n) {
 8005740:	b082      	sub	sp, #8
 8005742:	9001      	str	r0, [sp, #4]

  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8005744:	4906      	ldr	r1, [pc, #24]	; (8005760 <nvicClearPending+0x20>)
 8005746:	9b01      	ldr	r3, [sp, #4]
 8005748:	095b      	lsrs	r3, r3, #5
 800574a:	9a01      	ldr	r2, [sp, #4]
 800574c:	f002 021f 	and.w	r2, r2, #31
 8005750:	2001      	movs	r0, #1
 8005752:	fa00 f202 	lsl.w	r2, r0, r2
 8005756:	3360      	adds	r3, #96	; 0x60
 8005758:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800575c:	b002      	add	sp, #8
 800575e:	4770      	bx	lr
 8005760:	e000e100 	.word	0xe000e100
	...

08005770 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8005770:	4a0d      	ldr	r2, [pc, #52]	; (80057a8 <hal_lld_backup_domain_init+0x38>)
 8005772:	4b0d      	ldr	r3, [pc, #52]	; (80057a8 <hal_lld_backup_domain_init+0x38>)
 8005774:	681b      	ldr	r3, [r3, #0]
 8005776:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800577a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800577c:	4b0b      	ldr	r3, [pc, #44]	; (80057ac <hal_lld_backup_domain_init+0x3c>)
 800577e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005780:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005784:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005788:	d006      	beq.n	8005798 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800578a:	4b08      	ldr	r3, [pc, #32]	; (80057ac <hal_lld_backup_domain_init+0x3c>)
 800578c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8005790:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8005792:	4b06      	ldr	r3, [pc, #24]	; (80057ac <hal_lld_backup_domain_init+0x3c>)
 8005794:	2200      	movs	r2, #0
 8005796:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8005798:	4a03      	ldr	r2, [pc, #12]	; (80057a8 <hal_lld_backup_domain_init+0x38>)
 800579a:	4b03      	ldr	r3, [pc, #12]	; (80057a8 <hal_lld_backup_domain_init+0x38>)
 800579c:	685b      	ldr	r3, [r3, #4]
 800579e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80057a2:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 80057a4:	4770      	bx	lr
 80057a6:	bf00      	nop
 80057a8:	40007000 	.word	0x40007000
 80057ac:	40023800 	.word	0x40023800

080057b0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80057b0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 80057b2:	4b17      	ldr	r3, [pc, #92]	; (8005810 <hal_lld_init+0x60>)
 80057b4:	691b      	ldr	r3, [r3, #16]
 80057b6:	4b16      	ldr	r3, [pc, #88]	; (8005810 <hal_lld_init+0x60>)
 80057b8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80057bc:	611a      	str	r2, [r3, #16]
 80057be:	4b14      	ldr	r3, [pc, #80]	; (8005810 <hal_lld_init+0x60>)
 80057c0:	2200      	movs	r2, #0
 80057c2:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 80057c4:	4b12      	ldr	r3, [pc, #72]	; (8005810 <hal_lld_init+0x60>)
 80057c6:	695b      	ldr	r3, [r3, #20]
 80057c8:	4b11      	ldr	r3, [pc, #68]	; (8005810 <hal_lld_init+0x60>)
 80057ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80057ce:	615a      	str	r2, [r3, #20]
 80057d0:	4b0f      	ldr	r3, [pc, #60]	; (8005810 <hal_lld_init+0x60>)
 80057d2:	2200      	movs	r2, #0
 80057d4:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80057d6:	4a0e      	ldr	r2, [pc, #56]	; (8005810 <hal_lld_init+0x60>)
 80057d8:	4b0d      	ldr	r3, [pc, #52]	; (8005810 <hal_lld_init+0x60>)
 80057da:	6a1b      	ldr	r3, [r3, #32]
 80057dc:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 80057e0:	6213      	str	r3, [r2, #32]
 80057e2:	4b0b      	ldr	r3, [pc, #44]	; (8005810 <hal_lld_init+0x60>)
 80057e4:	2200      	movs	r2, #0
 80057e6:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 80057e8:	4b09      	ldr	r3, [pc, #36]	; (8005810 <hal_lld_init+0x60>)
 80057ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80057ec:	4b08      	ldr	r3, [pc, #32]	; (8005810 <hal_lld_init+0x60>)
 80057ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80057f2:	625a      	str	r2, [r3, #36]	; 0x24
 80057f4:	4b06      	ldr	r3, [pc, #24]	; (8005810 <hal_lld_init+0x60>)
 80057f6:	2200      	movs	r2, #0
 80057f8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80057fa:	4a05      	ldr	r2, [pc, #20]	; (8005810 <hal_lld_init+0x60>)
 80057fc:	4b04      	ldr	r3, [pc, #16]	; (8005810 <hal_lld_init+0x60>)
 80057fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005800:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005804:	6413      	str	r3, [r2, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8005806:	f7ff ffb3 	bl	8005770 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800580a:	f000 fab1 	bl	8005d70 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800580e:	bd08      	pop	{r3, pc}
 8005810:	40023800 	.word	0x40023800
 8005814:	f3af 8000 	nop.w
 8005818:	f3af 8000 	nop.w
 800581c:	f3af 8000 	nop.w

08005820 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8005820:	4b47      	ldr	r3, [pc, #284]	; (8005940 <stm32_clock_init+0x120>)
 8005822:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005826:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8005828:	4b46      	ldr	r3, [pc, #280]	; (8005944 <stm32_clock_init+0x124>)
 800582a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800582e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005830:	4a43      	ldr	r2, [pc, #268]	; (8005940 <stm32_clock_init+0x120>)
 8005832:	4b43      	ldr	r3, [pc, #268]	; (8005940 <stm32_clock_init+0x120>)
 8005834:	681b      	ldr	r3, [r3, #0]
 8005836:	f043 0301 	orr.w	r3, r3, #1
 800583a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800583c:	bf00      	nop
 800583e:	4b40      	ldr	r3, [pc, #256]	; (8005940 <stm32_clock_init+0x120>)
 8005840:	681b      	ldr	r3, [r3, #0]
 8005842:	f003 0302 	and.w	r3, r3, #2
 8005846:	2b00      	cmp	r3, #0
 8005848:	d0f9      	beq.n	800583e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800584a:	4a3d      	ldr	r2, [pc, #244]	; (8005940 <stm32_clock_init+0x120>)
 800584c:	4b3c      	ldr	r3, [pc, #240]	; (8005940 <stm32_clock_init+0x120>)
 800584e:	689b      	ldr	r3, [r3, #8]
 8005850:	f023 0303 	bic.w	r3, r3, #3
 8005854:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8005856:	4a3a      	ldr	r2, [pc, #232]	; (8005940 <stm32_clock_init+0x120>)
 8005858:	4b39      	ldr	r3, [pc, #228]	; (8005940 <stm32_clock_init+0x120>)
 800585a:	689b      	ldr	r3, [r3, #8]
 800585c:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800585e:	bf00      	nop
 8005860:	4b37      	ldr	r3, [pc, #220]	; (8005940 <stm32_clock_init+0x120>)
 8005862:	689b      	ldr	r3, [r3, #8]
 8005864:	f003 030c 	and.w	r3, r3, #12
 8005868:	2b00      	cmp	r3, #0
 800586a:	d1f9      	bne.n	8005860 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800586c:	4a34      	ldr	r2, [pc, #208]	; (8005940 <stm32_clock_init+0x120>)
 800586e:	4b34      	ldr	r3, [pc, #208]	; (8005940 <stm32_clock_init+0x120>)
 8005870:	681b      	ldr	r3, [r3, #0]
 8005872:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8005876:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005878:	4b31      	ldr	r3, [pc, #196]	; (8005940 <stm32_clock_init+0x120>)
 800587a:	2200      	movs	r2, #0
 800587c:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800587e:	4a30      	ldr	r2, [pc, #192]	; (8005940 <stm32_clock_init+0x120>)
 8005880:	4b2f      	ldr	r3, [pc, #188]	; (8005940 <stm32_clock_init+0x120>)
 8005882:	681b      	ldr	r3, [r3, #0]
 8005884:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005888:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800588a:	bf00      	nop
 800588c:	4b2c      	ldr	r3, [pc, #176]	; (8005940 <stm32_clock_init+0x120>)
 800588e:	681b      	ldr	r3, [r3, #0]
 8005890:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8005894:	2b00      	cmp	r3, #0
 8005896:	d0f9      	beq.n	800588c <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8005898:	4a29      	ldr	r2, [pc, #164]	; (8005940 <stm32_clock_init+0x120>)
 800589a:	4b29      	ldr	r3, [pc, #164]	; (8005940 <stm32_clock_init+0x120>)
 800589c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800589e:	f043 0301 	orr.w	r3, r3, #1
 80058a2:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80058a4:	bf00      	nop
 80058a6:	4b26      	ldr	r3, [pc, #152]	; (8005940 <stm32_clock_init+0x120>)
 80058a8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80058aa:	f003 0302 	and.w	r3, r3, #2
 80058ae:	2b00      	cmp	r3, #0
 80058b0:	d0f9      	beq.n	80058a6 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80058b2:	4b23      	ldr	r3, [pc, #140]	; (8005940 <stm32_clock_init+0x120>)
 80058b4:	4a24      	ldr	r2, [pc, #144]	; (8005948 <stm32_clock_init+0x128>)
 80058b6:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80058b8:	4a21      	ldr	r2, [pc, #132]	; (8005940 <stm32_clock_init+0x120>)
 80058ba:	4b21      	ldr	r3, [pc, #132]	; (8005940 <stm32_clock_init+0x120>)
 80058bc:	681b      	ldr	r3, [r3, #0]
 80058be:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80058c2:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80058c4:	bf00      	nop
 80058c6:	4b1f      	ldr	r3, [pc, #124]	; (8005944 <stm32_clock_init+0x124>)
 80058c8:	685b      	ldr	r3, [r3, #4]
 80058ca:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80058ce:	2b00      	cmp	r3, #0
 80058d0:	d0f9      	beq.n	80058c6 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80058d2:	bf00      	nop
 80058d4:	4b1a      	ldr	r3, [pc, #104]	; (8005940 <stm32_clock_init+0x120>)
 80058d6:	681b      	ldr	r3, [r3, #0]
 80058d8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80058dc:	2b00      	cmp	r3, #0
 80058de:	d0f9      	beq.n	80058d4 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80058e0:	4b17      	ldr	r3, [pc, #92]	; (8005940 <stm32_clock_init+0x120>)
 80058e2:	4a1a      	ldr	r2, [pc, #104]	; (800594c <stm32_clock_init+0x12c>)
 80058e4:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80058e6:	4b1a      	ldr	r3, [pc, #104]	; (8005950 <stm32_clock_init+0x130>)
 80058e8:	681b      	ldr	r3, [r3, #0]
 80058ea:	4a1a      	ldr	r2, [pc, #104]	; (8005954 <stm32_clock_init+0x134>)
 80058ec:	4293      	cmp	r3, r2
 80058ee:	d109      	bne.n	8005904 <stm32_clock_init+0xe4>
 80058f0:	4b19      	ldr	r3, [pc, #100]	; (8005958 <stm32_clock_init+0x138>)
 80058f2:	681b      	ldr	r3, [r3, #0]
 80058f4:	4a19      	ldr	r2, [pc, #100]	; (800595c <stm32_clock_init+0x13c>)
 80058f6:	4293      	cmp	r3, r2
 80058f8:	d104      	bne.n	8005904 <stm32_clock_init+0xe4>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80058fa:	4b19      	ldr	r3, [pc, #100]	; (8005960 <stm32_clock_init+0x140>)
 80058fc:	f240 1205 	movw	r2, #261	; 0x105
 8005900:	601a      	str	r2, [r3, #0]
 8005902:	e003      	b.n	800590c <stm32_clock_init+0xec>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8005904:	4b16      	ldr	r3, [pc, #88]	; (8005960 <stm32_clock_init+0x140>)
 8005906:	f240 7205 	movw	r2, #1797	; 0x705
 800590a:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800590c:	4a0c      	ldr	r2, [pc, #48]	; (8005940 <stm32_clock_init+0x120>)
 800590e:	4b0c      	ldr	r3, [pc, #48]	; (8005940 <stm32_clock_init+0x120>)
 8005910:	689b      	ldr	r3, [r3, #8]
 8005912:	f043 0302 	orr.w	r3, r3, #2
 8005916:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8005918:	bf00      	nop
 800591a:	4b09      	ldr	r3, [pc, #36]	; (8005940 <stm32_clock_init+0x120>)
 800591c:	689b      	ldr	r3, [r3, #8]
 800591e:	f003 030c 	and.w	r3, r3, #12
 8005922:	2b08      	cmp	r3, #8
 8005924:	d1f9      	bne.n	800591a <stm32_clock_init+0xfa>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8005926:	4a06      	ldr	r2, [pc, #24]	; (8005940 <stm32_clock_init+0x120>)
 8005928:	4b05      	ldr	r3, [pc, #20]	; (8005940 <stm32_clock_init+0x120>)
 800592a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800592c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005930:	6453      	str	r3, [r2, #68]	; 0x44
 8005932:	4a03      	ldr	r2, [pc, #12]	; (8005940 <stm32_clock_init+0x120>)
 8005934:	4b02      	ldr	r3, [pc, #8]	; (8005940 <stm32_clock_init+0x120>)
 8005936:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005938:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800593c:	6653      	str	r3, [r2, #100]	; 0x64
}
 800593e:	4770      	bx	lr
 8005940:	40023800 	.word	0x40023800
 8005944:	40007000 	.word	0x40007000
 8005948:	07405408 	.word	0x07405408
 800594c:	38889400 	.word	0x38889400
 8005950:	e0042000 	.word	0xe0042000
 8005954:	20006411 	.word	0x20006411
 8005958:	e000ed00 	.word	0xe000ed00
 800595c:	410fc241 	.word	0x410fc241
 8005960:	40023c00 	.word	0x40023c00
	...

08005970 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8005970:	b500      	push	{lr}
 8005972:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8005974:	4b0b      	ldr	r3, [pc, #44]	; (80059a4 <Vector6C+0x34>)
 8005976:	681b      	ldr	r3, [r3, #0]
 8005978:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800597c:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 800597e:	4a09      	ldr	r2, [pc, #36]	; (80059a4 <Vector6C+0x34>)
 8005980:	9b01      	ldr	r3, [sp, #4]
 8005982:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8005984:	4b08      	ldr	r3, [pc, #32]	; (80059a8 <Vector6C+0x38>)
 8005986:	681b      	ldr	r3, [r3, #0]
 8005988:	2b00      	cmp	r3, #0
 800598a:	d006      	beq.n	800599a <Vector6C+0x2a>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800598c:	4b06      	ldr	r3, [pc, #24]	; (80059a8 <Vector6C+0x38>)
 800598e:	681b      	ldr	r3, [r3, #0]
 8005990:	4a05      	ldr	r2, [pc, #20]	; (80059a8 <Vector6C+0x38>)
 8005992:	6852      	ldr	r2, [r2, #4]
 8005994:	4610      	mov	r0, r2
 8005996:	9901      	ldr	r1, [sp, #4]
 8005998:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800599a:	f7fe f9f9 	bl	8003d90 <_port_irq_epilogue>
}
 800599e:	b003      	add	sp, #12
 80059a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80059a4:	40026000 	.word	0x40026000
 80059a8:	200008dc 	.word	0x200008dc
 80059ac:	f3af 8000 	nop.w

080059b0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80059b0:	b500      	push	{lr}
 80059b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80059b4:	4b0c      	ldr	r3, [pc, #48]	; (80059e8 <Vector70+0x38>)
 80059b6:	681b      	ldr	r3, [r3, #0]
 80059b8:	099b      	lsrs	r3, r3, #6
 80059ba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80059be:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 80059c0:	4a09      	ldr	r2, [pc, #36]	; (80059e8 <Vector70+0x38>)
 80059c2:	9b01      	ldr	r3, [sp, #4]
 80059c4:	019b      	lsls	r3, r3, #6
 80059c6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 80059c8:	4b08      	ldr	r3, [pc, #32]	; (80059ec <Vector70+0x3c>)
 80059ca:	689b      	ldr	r3, [r3, #8]
 80059cc:	2b00      	cmp	r3, #0
 80059ce:	d006      	beq.n	80059de <Vector70+0x2e>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80059d0:	4b06      	ldr	r3, [pc, #24]	; (80059ec <Vector70+0x3c>)
 80059d2:	689b      	ldr	r3, [r3, #8]
 80059d4:	4a05      	ldr	r2, [pc, #20]	; (80059ec <Vector70+0x3c>)
 80059d6:	68d2      	ldr	r2, [r2, #12]
 80059d8:	4610      	mov	r0, r2
 80059da:	9901      	ldr	r1, [sp, #4]
 80059dc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80059de:	f7fe f9d7 	bl	8003d90 <_port_irq_epilogue>
}
 80059e2:	b003      	add	sp, #12
 80059e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80059e8:	40026000 	.word	0x40026000
 80059ec:	200008dc 	.word	0x200008dc

080059f0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80059f0:	b500      	push	{lr}
 80059f2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80059f4:	4b0c      	ldr	r3, [pc, #48]	; (8005a28 <Vector74+0x38>)
 80059f6:	681b      	ldr	r3, [r3, #0]
 80059f8:	0c1b      	lsrs	r3, r3, #16
 80059fa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80059fe:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8005a00:	4a09      	ldr	r2, [pc, #36]	; (8005a28 <Vector74+0x38>)
 8005a02:	9b01      	ldr	r3, [sp, #4]
 8005a04:	041b      	lsls	r3, r3, #16
 8005a06:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8005a08:	4b08      	ldr	r3, [pc, #32]	; (8005a2c <Vector74+0x3c>)
 8005a0a:	691b      	ldr	r3, [r3, #16]
 8005a0c:	2b00      	cmp	r3, #0
 8005a0e:	d006      	beq.n	8005a1e <Vector74+0x2e>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8005a10:	4b06      	ldr	r3, [pc, #24]	; (8005a2c <Vector74+0x3c>)
 8005a12:	691b      	ldr	r3, [r3, #16]
 8005a14:	4a05      	ldr	r2, [pc, #20]	; (8005a2c <Vector74+0x3c>)
 8005a16:	6952      	ldr	r2, [r2, #20]
 8005a18:	4610      	mov	r0, r2
 8005a1a:	9901      	ldr	r1, [sp, #4]
 8005a1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005a1e:	f7fe f9b7 	bl	8003d90 <_port_irq_epilogue>
}
 8005a22:	b003      	add	sp, #12
 8005a24:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a28:	40026000 	.word	0x40026000
 8005a2c:	200008dc 	.word	0x200008dc

08005a30 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8005a30:	b500      	push	{lr}
 8005a32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005a34:	4b0c      	ldr	r3, [pc, #48]	; (8005a68 <Vector78+0x38>)
 8005a36:	681b      	ldr	r3, [r3, #0]
 8005a38:	0d9b      	lsrs	r3, r3, #22
 8005a3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005a3e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8005a40:	4a09      	ldr	r2, [pc, #36]	; (8005a68 <Vector78+0x38>)
 8005a42:	9b01      	ldr	r3, [sp, #4]
 8005a44:	059b      	lsls	r3, r3, #22
 8005a46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8005a48:	4b08      	ldr	r3, [pc, #32]	; (8005a6c <Vector78+0x3c>)
 8005a4a:	699b      	ldr	r3, [r3, #24]
 8005a4c:	2b00      	cmp	r3, #0
 8005a4e:	d006      	beq.n	8005a5e <Vector78+0x2e>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8005a50:	4b06      	ldr	r3, [pc, #24]	; (8005a6c <Vector78+0x3c>)
 8005a52:	699b      	ldr	r3, [r3, #24]
 8005a54:	4a05      	ldr	r2, [pc, #20]	; (8005a6c <Vector78+0x3c>)
 8005a56:	69d2      	ldr	r2, [r2, #28]
 8005a58:	4610      	mov	r0, r2
 8005a5a:	9901      	ldr	r1, [sp, #4]
 8005a5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005a5e:	f7fe f997 	bl	8003d90 <_port_irq_epilogue>
}
 8005a62:	b003      	add	sp, #12
 8005a64:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a68:	40026000 	.word	0x40026000
 8005a6c:	200008dc 	.word	0x200008dc

08005a70 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8005a70:	b500      	push	{lr}
 8005a72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8005a74:	4b0b      	ldr	r3, [pc, #44]	; (8005aa4 <Vector7C+0x34>)
 8005a76:	685b      	ldr	r3, [r3, #4]
 8005a78:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005a7c:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8005a7e:	4a09      	ldr	r2, [pc, #36]	; (8005aa4 <Vector7C+0x34>)
 8005a80:	9b01      	ldr	r3, [sp, #4]
 8005a82:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 8005a84:	4b08      	ldr	r3, [pc, #32]	; (8005aa8 <Vector7C+0x38>)
 8005a86:	6a1b      	ldr	r3, [r3, #32]
 8005a88:	2b00      	cmp	r3, #0
 8005a8a:	d006      	beq.n	8005a9a <Vector7C+0x2a>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8005a8c:	4b06      	ldr	r3, [pc, #24]	; (8005aa8 <Vector7C+0x38>)
 8005a8e:	6a1b      	ldr	r3, [r3, #32]
 8005a90:	4a05      	ldr	r2, [pc, #20]	; (8005aa8 <Vector7C+0x38>)
 8005a92:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8005a94:	4610      	mov	r0, r2
 8005a96:	9901      	ldr	r1, [sp, #4]
 8005a98:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005a9a:	f7fe f979 	bl	8003d90 <_port_irq_epilogue>
}
 8005a9e:	b003      	add	sp, #12
 8005aa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8005aa4:	40026000 	.word	0x40026000
 8005aa8:	200008dc 	.word	0x200008dc
 8005aac:	f3af 8000 	nop.w

08005ab0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8005ab4:	4b0c      	ldr	r3, [pc, #48]	; (8005ae8 <Vector80+0x38>)
 8005ab6:	685b      	ldr	r3, [r3, #4]
 8005ab8:	099b      	lsrs	r3, r3, #6
 8005aba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005abe:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 8005ac0:	4a09      	ldr	r2, [pc, #36]	; (8005ae8 <Vector80+0x38>)
 8005ac2:	9b01      	ldr	r3, [sp, #4]
 8005ac4:	019b      	lsls	r3, r3, #6
 8005ac6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 8005ac8:	4b08      	ldr	r3, [pc, #32]	; (8005aec <Vector80+0x3c>)
 8005aca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005acc:	2b00      	cmp	r3, #0
 8005ace:	d006      	beq.n	8005ade <Vector80+0x2e>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8005ad0:	4b06      	ldr	r3, [pc, #24]	; (8005aec <Vector80+0x3c>)
 8005ad2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005ad4:	4a05      	ldr	r2, [pc, #20]	; (8005aec <Vector80+0x3c>)
 8005ad6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005ad8:	4610      	mov	r0, r2
 8005ada:	9901      	ldr	r1, [sp, #4]
 8005adc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005ade:	f7fe f957 	bl	8003d90 <_port_irq_epilogue>
}
 8005ae2:	b003      	add	sp, #12
 8005ae4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ae8:	40026000 	.word	0x40026000
 8005aec:	200008dc 	.word	0x200008dc

08005af0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8005af0:	b500      	push	{lr}
 8005af2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8005af4:	4b0c      	ldr	r3, [pc, #48]	; (8005b28 <Vector84+0x38>)
 8005af6:	685b      	ldr	r3, [r3, #4]
 8005af8:	0c1b      	lsrs	r3, r3, #16
 8005afa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005afe:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8005b00:	4a09      	ldr	r2, [pc, #36]	; (8005b28 <Vector84+0x38>)
 8005b02:	9b01      	ldr	r3, [sp, #4]
 8005b04:	041b      	lsls	r3, r3, #16
 8005b06:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8005b08:	4b08      	ldr	r3, [pc, #32]	; (8005b2c <Vector84+0x3c>)
 8005b0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b0c:	2b00      	cmp	r3, #0
 8005b0e:	d006      	beq.n	8005b1e <Vector84+0x2e>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8005b10:	4b06      	ldr	r3, [pc, #24]	; (8005b2c <Vector84+0x3c>)
 8005b12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b14:	4a05      	ldr	r2, [pc, #20]	; (8005b2c <Vector84+0x3c>)
 8005b16:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8005b18:	4610      	mov	r0, r2
 8005b1a:	9901      	ldr	r1, [sp, #4]
 8005b1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005b1e:	f7fe f937 	bl	8003d90 <_port_irq_epilogue>
}
 8005b22:	b003      	add	sp, #12
 8005b24:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b28:	40026000 	.word	0x40026000
 8005b2c:	200008dc 	.word	0x200008dc

08005b30 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8005b30:	b500      	push	{lr}
 8005b32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8005b34:	4b0c      	ldr	r3, [pc, #48]	; (8005b68 <VectorFC+0x38>)
 8005b36:	685b      	ldr	r3, [r3, #4]
 8005b38:	0d9b      	lsrs	r3, r3, #22
 8005b3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005b3e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8005b40:	4a09      	ldr	r2, [pc, #36]	; (8005b68 <VectorFC+0x38>)
 8005b42:	9b01      	ldr	r3, [sp, #4]
 8005b44:	059b      	lsls	r3, r3, #22
 8005b46:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8005b48:	4b08      	ldr	r3, [pc, #32]	; (8005b6c <VectorFC+0x3c>)
 8005b4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005b4c:	2b00      	cmp	r3, #0
 8005b4e:	d006      	beq.n	8005b5e <VectorFC+0x2e>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8005b50:	4b06      	ldr	r3, [pc, #24]	; (8005b6c <VectorFC+0x3c>)
 8005b52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005b54:	4a05      	ldr	r2, [pc, #20]	; (8005b6c <VectorFC+0x3c>)
 8005b56:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8005b58:	4610      	mov	r0, r2
 8005b5a:	9901      	ldr	r1, [sp, #4]
 8005b5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005b5e:	f7fe f917 	bl	8003d90 <_port_irq_epilogue>
}
 8005b62:	b003      	add	sp, #12
 8005b64:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b68:	40026000 	.word	0x40026000
 8005b6c:	200008dc 	.word	0x200008dc

08005b70 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8005b70:	b500      	push	{lr}
 8005b72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8005b74:	4b0b      	ldr	r3, [pc, #44]	; (8005ba4 <Vector120+0x34>)
 8005b76:	681b      	ldr	r3, [r3, #0]
 8005b78:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005b7c:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 8005b7e:	4a09      	ldr	r2, [pc, #36]	; (8005ba4 <Vector120+0x34>)
 8005b80:	9b01      	ldr	r3, [sp, #4]
 8005b82:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 8005b84:	4b08      	ldr	r3, [pc, #32]	; (8005ba8 <Vector120+0x38>)
 8005b86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005b88:	2b00      	cmp	r3, #0
 8005b8a:	d006      	beq.n	8005b9a <Vector120+0x2a>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8005b8c:	4b06      	ldr	r3, [pc, #24]	; (8005ba8 <Vector120+0x38>)
 8005b8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005b90:	4a05      	ldr	r2, [pc, #20]	; (8005ba8 <Vector120+0x38>)
 8005b92:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8005b94:	4610      	mov	r0, r2
 8005b96:	9901      	ldr	r1, [sp, #4]
 8005b98:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005b9a:	f7fe f8f9 	bl	8003d90 <_port_irq_epilogue>
}
 8005b9e:	b003      	add	sp, #12
 8005ba0:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ba4:	40026400 	.word	0x40026400
 8005ba8:	200008dc 	.word	0x200008dc
 8005bac:	f3af 8000 	nop.w

08005bb0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8005bb0:	b500      	push	{lr}
 8005bb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8005bb4:	4b0c      	ldr	r3, [pc, #48]	; (8005be8 <Vector124+0x38>)
 8005bb6:	681b      	ldr	r3, [r3, #0]
 8005bb8:	099b      	lsrs	r3, r3, #6
 8005bba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005bbe:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 8005bc0:	4a09      	ldr	r2, [pc, #36]	; (8005be8 <Vector124+0x38>)
 8005bc2:	9b01      	ldr	r3, [sp, #4]
 8005bc4:	019b      	lsls	r3, r3, #6
 8005bc6:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 8005bc8:	4b08      	ldr	r3, [pc, #32]	; (8005bec <Vector124+0x3c>)
 8005bca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005bcc:	2b00      	cmp	r3, #0
 8005bce:	d006      	beq.n	8005bde <Vector124+0x2e>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8005bd0:	4b06      	ldr	r3, [pc, #24]	; (8005bec <Vector124+0x3c>)
 8005bd2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005bd4:	4a05      	ldr	r2, [pc, #20]	; (8005bec <Vector124+0x3c>)
 8005bd6:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8005bd8:	4610      	mov	r0, r2
 8005bda:	9901      	ldr	r1, [sp, #4]
 8005bdc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005bde:	f7fe f8d7 	bl	8003d90 <_port_irq_epilogue>
}
 8005be2:	b003      	add	sp, #12
 8005be4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005be8:	40026400 	.word	0x40026400
 8005bec:	200008dc 	.word	0x200008dc

08005bf0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8005bf0:	b500      	push	{lr}
 8005bf2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8005bf4:	4b0c      	ldr	r3, [pc, #48]	; (8005c28 <Vector128+0x38>)
 8005bf6:	681b      	ldr	r3, [r3, #0]
 8005bf8:	0c1b      	lsrs	r3, r3, #16
 8005bfa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005bfe:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8005c00:	4a09      	ldr	r2, [pc, #36]	; (8005c28 <Vector128+0x38>)
 8005c02:	9b01      	ldr	r3, [sp, #4]
 8005c04:	041b      	lsls	r3, r3, #16
 8005c06:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8005c08:	4b08      	ldr	r3, [pc, #32]	; (8005c2c <Vector128+0x3c>)
 8005c0a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005c0c:	2b00      	cmp	r3, #0
 8005c0e:	d006      	beq.n	8005c1e <Vector128+0x2e>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8005c10:	4b06      	ldr	r3, [pc, #24]	; (8005c2c <Vector128+0x3c>)
 8005c12:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005c14:	4a05      	ldr	r2, [pc, #20]	; (8005c2c <Vector128+0x3c>)
 8005c16:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8005c18:	4610      	mov	r0, r2
 8005c1a:	9901      	ldr	r1, [sp, #4]
 8005c1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005c1e:	f7fe f8b7 	bl	8003d90 <_port_irq_epilogue>
}
 8005c22:	b003      	add	sp, #12
 8005c24:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c28:	40026400 	.word	0x40026400
 8005c2c:	200008dc 	.word	0x200008dc

08005c30 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8005c30:	b500      	push	{lr}
 8005c32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005c34:	4b0c      	ldr	r3, [pc, #48]	; (8005c68 <Vector12C+0x38>)
 8005c36:	681b      	ldr	r3, [r3, #0]
 8005c38:	0d9b      	lsrs	r3, r3, #22
 8005c3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005c3e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8005c40:	4a09      	ldr	r2, [pc, #36]	; (8005c68 <Vector12C+0x38>)
 8005c42:	9b01      	ldr	r3, [sp, #4]
 8005c44:	059b      	lsls	r3, r3, #22
 8005c46:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8005c48:	4b08      	ldr	r3, [pc, #32]	; (8005c6c <Vector12C+0x3c>)
 8005c4a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c4c:	2b00      	cmp	r3, #0
 8005c4e:	d006      	beq.n	8005c5e <Vector12C+0x2e>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8005c50:	4b06      	ldr	r3, [pc, #24]	; (8005c6c <Vector12C+0x3c>)
 8005c52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c54:	4a05      	ldr	r2, [pc, #20]	; (8005c6c <Vector12C+0x3c>)
 8005c56:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8005c58:	4610      	mov	r0, r2
 8005c5a:	9901      	ldr	r1, [sp, #4]
 8005c5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005c5e:	f7fe f897 	bl	8003d90 <_port_irq_epilogue>
}
 8005c62:	b003      	add	sp, #12
 8005c64:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c68:	40026400 	.word	0x40026400
 8005c6c:	200008dc 	.word	0x200008dc

08005c70 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8005c70:	b500      	push	{lr}
 8005c72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8005c74:	4b0b      	ldr	r3, [pc, #44]	; (8005ca4 <Vector130+0x34>)
 8005c76:	685b      	ldr	r3, [r3, #4]
 8005c78:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005c7c:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 8005c7e:	4a09      	ldr	r2, [pc, #36]	; (8005ca4 <Vector130+0x34>)
 8005c80:	9b01      	ldr	r3, [sp, #4]
 8005c82:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 8005c84:	4b08      	ldr	r3, [pc, #32]	; (8005ca8 <Vector130+0x38>)
 8005c86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005c88:	2b00      	cmp	r3, #0
 8005c8a:	d006      	beq.n	8005c9a <Vector130+0x2a>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8005c8c:	4b06      	ldr	r3, [pc, #24]	; (8005ca8 <Vector130+0x38>)
 8005c8e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005c90:	4a05      	ldr	r2, [pc, #20]	; (8005ca8 <Vector130+0x38>)
 8005c92:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8005c94:	4610      	mov	r0, r2
 8005c96:	9901      	ldr	r1, [sp, #4]
 8005c98:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005c9a:	f7fe f879 	bl	8003d90 <_port_irq_epilogue>
}
 8005c9e:	b003      	add	sp, #12
 8005ca0:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ca4:	40026400 	.word	0x40026400
 8005ca8:	200008dc 	.word	0x200008dc
 8005cac:	f3af 8000 	nop.w

08005cb0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8005cb0:	b500      	push	{lr}
 8005cb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8005cb4:	4b0c      	ldr	r3, [pc, #48]	; (8005ce8 <Vector150+0x38>)
 8005cb6:	685b      	ldr	r3, [r3, #4]
 8005cb8:	099b      	lsrs	r3, r3, #6
 8005cba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005cbe:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8005cc0:	4a09      	ldr	r2, [pc, #36]	; (8005ce8 <Vector150+0x38>)
 8005cc2:	9b01      	ldr	r3, [sp, #4]
 8005cc4:	019b      	lsls	r3, r3, #6
 8005cc6:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8005cc8:	4b08      	ldr	r3, [pc, #32]	; (8005cec <Vector150+0x3c>)
 8005cca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005ccc:	2b00      	cmp	r3, #0
 8005cce:	d006      	beq.n	8005cde <Vector150+0x2e>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8005cd0:	4b06      	ldr	r3, [pc, #24]	; (8005cec <Vector150+0x3c>)
 8005cd2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005cd4:	4a05      	ldr	r2, [pc, #20]	; (8005cec <Vector150+0x3c>)
 8005cd6:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8005cd8:	4610      	mov	r0, r2
 8005cda:	9901      	ldr	r1, [sp, #4]
 8005cdc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005cde:	f7fe f857 	bl	8003d90 <_port_irq_epilogue>
}
 8005ce2:	b003      	add	sp, #12
 8005ce4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ce8:	40026400 	.word	0x40026400
 8005cec:	200008dc 	.word	0x200008dc

08005cf0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8005cf0:	b500      	push	{lr}
 8005cf2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8005cf4:	4b0c      	ldr	r3, [pc, #48]	; (8005d28 <Vector154+0x38>)
 8005cf6:	685b      	ldr	r3, [r3, #4]
 8005cf8:	0c1b      	lsrs	r3, r3, #16
 8005cfa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005cfe:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8005d00:	4a09      	ldr	r2, [pc, #36]	; (8005d28 <Vector154+0x38>)
 8005d02:	9b01      	ldr	r3, [sp, #4]
 8005d04:	041b      	lsls	r3, r3, #16
 8005d06:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 8005d08:	4b08      	ldr	r3, [pc, #32]	; (8005d2c <Vector154+0x3c>)
 8005d0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005d0c:	2b00      	cmp	r3, #0
 8005d0e:	d006      	beq.n	8005d1e <Vector154+0x2e>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8005d10:	4b06      	ldr	r3, [pc, #24]	; (8005d2c <Vector154+0x3c>)
 8005d12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005d14:	4a05      	ldr	r2, [pc, #20]	; (8005d2c <Vector154+0x3c>)
 8005d16:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8005d18:	4610      	mov	r0, r2
 8005d1a:	9901      	ldr	r1, [sp, #4]
 8005d1c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005d1e:	f7fe f837 	bl	8003d90 <_port_irq_epilogue>
}
 8005d22:	b003      	add	sp, #12
 8005d24:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d28:	40026400 	.word	0x40026400
 8005d2c:	200008dc 	.word	0x200008dc

08005d30 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8005d30:	b500      	push	{lr}
 8005d32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8005d34:	4b0c      	ldr	r3, [pc, #48]	; (8005d68 <Vector158+0x38>)
 8005d36:	685b      	ldr	r3, [r3, #4]
 8005d38:	0d9b      	lsrs	r3, r3, #22
 8005d3a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005d3e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 8005d40:	4a09      	ldr	r2, [pc, #36]	; (8005d68 <Vector158+0x38>)
 8005d42:	9b01      	ldr	r3, [sp, #4]
 8005d44:	059b      	lsls	r3, r3, #22
 8005d46:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 8005d48:	4b08      	ldr	r3, [pc, #32]	; (8005d6c <Vector158+0x3c>)
 8005d4a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005d4c:	2b00      	cmp	r3, #0
 8005d4e:	d006      	beq.n	8005d5e <Vector158+0x2e>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8005d50:	4b06      	ldr	r3, [pc, #24]	; (8005d6c <Vector158+0x3c>)
 8005d52:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005d54:	4a05      	ldr	r2, [pc, #20]	; (8005d6c <Vector158+0x3c>)
 8005d56:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8005d58:	4610      	mov	r0, r2
 8005d5a:	9901      	ldr	r1, [sp, #4]
 8005d5c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005d5e:	f7fe f817 	bl	8003d90 <_port_irq_epilogue>
}
 8005d62:	b003      	add	sp, #12
 8005d64:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d68:	40026400 	.word	0x40026400
 8005d6c:	200008dc 	.word	0x200008dc

08005d70 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8005d70:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
 8005d72:	4b16      	ldr	r3, [pc, #88]	; (8005dcc <dmaInit+0x5c>)
 8005d74:	2200      	movs	r2, #0
 8005d76:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8005d78:	2300      	movs	r3, #0
 8005d7a:	9301      	str	r3, [sp, #4]
 8005d7c:	e011      	b.n	8005da2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
 8005d7e:	4914      	ldr	r1, [pc, #80]	; (8005dd0 <dmaInit+0x60>)
 8005d80:	9a01      	ldr	r2, [sp, #4]
 8005d82:	4613      	mov	r3, r2
 8005d84:	005b      	lsls	r3, r3, #1
 8005d86:	4413      	add	r3, r2
 8005d88:	009b      	lsls	r3, r3, #2
 8005d8a:	440b      	add	r3, r1
 8005d8c:	681b      	ldr	r3, [r3, #0]
 8005d8e:	2200      	movs	r2, #0
 8005d90:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8005d92:	4a10      	ldr	r2, [pc, #64]	; (8005dd4 <dmaInit+0x64>)
 8005d94:	9b01      	ldr	r3, [sp, #4]
 8005d96:	2100      	movs	r1, #0
 8005d98:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8005d9c:	9b01      	ldr	r3, [sp, #4]
 8005d9e:	3301      	adds	r3, #1
 8005da0:	9301      	str	r3, [sp, #4]
 8005da2:	9b01      	ldr	r3, [sp, #4]
 8005da4:	2b0f      	cmp	r3, #15
 8005da6:	d9ea      	bls.n	8005d7e <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8005da8:	4b0b      	ldr	r3, [pc, #44]	; (8005dd8 <dmaInit+0x68>)
 8005daa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005dae:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8005db0:	4b09      	ldr	r3, [pc, #36]	; (8005dd8 <dmaInit+0x68>)
 8005db2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005db6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8005db8:	4b08      	ldr	r3, [pc, #32]	; (8005ddc <dmaInit+0x6c>)
 8005dba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005dbe:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8005dc0:	4b06      	ldr	r3, [pc, #24]	; (8005ddc <dmaInit+0x6c>)
 8005dc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005dc6:	60da      	str	r2, [r3, #12]
}
 8005dc8:	b002      	add	sp, #8
 8005dca:	4770      	bx	lr
 8005dcc:	200008d8 	.word	0x200008d8
 8005dd0:	0800dee0 	.word	0x0800dee0
 8005dd4:	200008dc 	.word	0x200008dc
 8005dd8:	40026000 	.word	0x40026000
 8005ddc:	40026400 	.word	0x40026400

08005de0 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8005de0:	b500      	push	{lr}
 8005de2:	b085      	sub	sp, #20
 8005de4:	9003      	str	r0, [sp, #12]
 8005de6:	9102      	str	r1, [sp, #8]
 8005de8:	9201      	str	r2, [sp, #4]
 8005dea:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8005dec:	9b03      	ldr	r3, [sp, #12]
 8005dee:	7a5b      	ldrb	r3, [r3, #9]
 8005df0:	461a      	mov	r2, r3
 8005df2:	2301      	movs	r3, #1
 8005df4:	fa03 f202 	lsl.w	r2, r3, r2
 8005df8:	4b32      	ldr	r3, [pc, #200]	; (8005ec4 <dmaStreamAllocate+0xe4>)
 8005dfa:	681b      	ldr	r3, [r3, #0]
 8005dfc:	4013      	ands	r3, r2
 8005dfe:	2b00      	cmp	r3, #0
 8005e00:	d001      	beq.n	8005e06 <dmaStreamAllocate+0x26>
    return true;
 8005e02:	2301      	movs	r3, #1
 8005e04:	e059      	b.n	8005eba <dmaStreamAllocate+0xda>

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8005e06:	9b03      	ldr	r3, [sp, #12]
 8005e08:	7a5b      	ldrb	r3, [r3, #9]
 8005e0a:	4619      	mov	r1, r3
 8005e0c:	4a2e      	ldr	r2, [pc, #184]	; (8005ec8 <dmaStreamAllocate+0xe8>)
 8005e0e:	9b01      	ldr	r3, [sp, #4]
 8005e10:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8005e14:	9b03      	ldr	r3, [sp, #12]
 8005e16:	7a5b      	ldrb	r3, [r3, #9]
 8005e18:	4a2b      	ldr	r2, [pc, #172]	; (8005ec8 <dmaStreamAllocate+0xe8>)
 8005e1a:	00db      	lsls	r3, r3, #3
 8005e1c:	4413      	add	r3, r2
 8005e1e:	9a00      	ldr	r2, [sp, #0]
 8005e20:	605a      	str	r2, [r3, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);
 8005e22:	9b03      	ldr	r3, [sp, #12]
 8005e24:	7a5b      	ldrb	r3, [r3, #9]
 8005e26:	461a      	mov	r2, r3
 8005e28:	2301      	movs	r3, #1
 8005e2a:	fa03 f202 	lsl.w	r2, r3, r2
 8005e2e:	4b25      	ldr	r3, [pc, #148]	; (8005ec4 <dmaStreamAllocate+0xe4>)
 8005e30:	681b      	ldr	r3, [r3, #0]
 8005e32:	4313      	orrs	r3, r2
 8005e34:	4a23      	ldr	r2, [pc, #140]	; (8005ec4 <dmaStreamAllocate+0xe4>)
 8005e36:	6013      	str	r3, [r2, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8005e38:	4b22      	ldr	r3, [pc, #136]	; (8005ec4 <dmaStreamAllocate+0xe4>)
 8005e3a:	681b      	ldr	r3, [r3, #0]
 8005e3c:	b2db      	uxtb	r3, r3
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d005      	beq.n	8005e4e <dmaStreamAllocate+0x6e>
    rccEnableDMA1(false);
 8005e42:	4a22      	ldr	r2, [pc, #136]	; (8005ecc <dmaStreamAllocate+0xec>)
 8005e44:	4b21      	ldr	r3, [pc, #132]	; (8005ecc <dmaStreamAllocate+0xec>)
 8005e46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e48:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005e4c:	6313      	str	r3, [r2, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 8005e4e:	4b1d      	ldr	r3, [pc, #116]	; (8005ec4 <dmaStreamAllocate+0xe4>)
 8005e50:	681b      	ldr	r3, [r3, #0]
 8005e52:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005e56:	2b00      	cmp	r3, #0
 8005e58:	d005      	beq.n	8005e66 <dmaStreamAllocate+0x86>
    rccEnableDMA2(false);
 8005e5a:	4a1c      	ldr	r2, [pc, #112]	; (8005ecc <dmaStreamAllocate+0xec>)
 8005e5c:	4b1b      	ldr	r3, [pc, #108]	; (8005ecc <dmaStreamAllocate+0xec>)
 8005e5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e60:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8005e64:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8005e66:	9b03      	ldr	r3, [sp, #12]
 8005e68:	681b      	ldr	r3, [r3, #0]
 8005e6a:	9a03      	ldr	r2, [sp, #12]
 8005e6c:	6812      	ldr	r2, [r2, #0]
 8005e6e:	6812      	ldr	r2, [r2, #0]
 8005e70:	f022 021f 	bic.w	r2, r2, #31
 8005e74:	601a      	str	r2, [r3, #0]
 8005e76:	bf00      	nop
 8005e78:	9b03      	ldr	r3, [sp, #12]
 8005e7a:	681b      	ldr	r3, [r3, #0]
 8005e7c:	681b      	ldr	r3, [r3, #0]
 8005e7e:	f003 0301 	and.w	r3, r3, #1
 8005e82:	2b00      	cmp	r3, #0
 8005e84:	d1f8      	bne.n	8005e78 <dmaStreamAllocate+0x98>
 8005e86:	9b03      	ldr	r3, [sp, #12]
 8005e88:	685b      	ldr	r3, [r3, #4]
 8005e8a:	9a03      	ldr	r2, [sp, #12]
 8005e8c:	7a12      	ldrb	r2, [r2, #8]
 8005e8e:	4611      	mov	r1, r2
 8005e90:	223d      	movs	r2, #61	; 0x3d
 8005e92:	408a      	lsls	r2, r1
 8005e94:	601a      	str	r2, [r3, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8005e96:	9b03      	ldr	r3, [sp, #12]
 8005e98:	681b      	ldr	r3, [r3, #0]
 8005e9a:	2200      	movs	r2, #0
 8005e9c:	601a      	str	r2, [r3, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8005e9e:	9b03      	ldr	r3, [sp, #12]
 8005ea0:	681b      	ldr	r3, [r3, #0]
 8005ea2:	2221      	movs	r2, #33	; 0x21
 8005ea4:	615a      	str	r2, [r3, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8005ea6:	9b01      	ldr	r3, [sp, #4]
 8005ea8:	2b00      	cmp	r3, #0
 8005eaa:	d005      	beq.n	8005eb8 <dmaStreamAllocate+0xd8>
    nvicEnableVector(dmastp->vector, priority);
 8005eac:	9b03      	ldr	r3, [sp, #12]
 8005eae:	7a9b      	ldrb	r3, [r3, #10]
 8005eb0:	4618      	mov	r0, r3
 8005eb2:	9902      	ldr	r1, [sp, #8]
 8005eb4:	f7ff fbdc 	bl	8005670 <nvicEnableVector>
  }

  return false;
 8005eb8:	2300      	movs	r3, #0
}
 8005eba:	4618      	mov	r0, r3
 8005ebc:	b005      	add	sp, #20
 8005ebe:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ec2:	bf00      	nop
 8005ec4:	200008d8 	.word	0x200008d8
 8005ec8:	200008dc 	.word	0x200008dc
 8005ecc:	40023800 	.word	0x40023800

08005ed0 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8005ed0:	b500      	push	{lr}
 8005ed2:	b083      	sub	sp, #12
 8005ed4:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1U << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 8005ed6:	9b01      	ldr	r3, [sp, #4]
 8005ed8:	7a9b      	ldrb	r3, [r3, #10]
 8005eda:	4618      	mov	r0, r3
 8005edc:	f7ff fbf8 	bl	80056d0 <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8005ee0:	9b01      	ldr	r3, [sp, #4]
 8005ee2:	7a5b      	ldrb	r3, [r3, #9]
 8005ee4:	461a      	mov	r2, r3
 8005ee6:	2301      	movs	r3, #1
 8005ee8:	4093      	lsls	r3, r2
 8005eea:	43da      	mvns	r2, r3
 8005eec:	4b0f      	ldr	r3, [pc, #60]	; (8005f2c <dmaStreamRelease+0x5c>)
 8005eee:	681b      	ldr	r3, [r3, #0]
 8005ef0:	4013      	ands	r3, r2
 8005ef2:	4a0e      	ldr	r2, [pc, #56]	; (8005f2c <dmaStreamRelease+0x5c>)
 8005ef4:	6013      	str	r3, [r2, #0]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8005ef6:	4b0d      	ldr	r3, [pc, #52]	; (8005f2c <dmaStreamRelease+0x5c>)
 8005ef8:	681b      	ldr	r3, [r3, #0]
 8005efa:	b2db      	uxtb	r3, r3
 8005efc:	2b00      	cmp	r3, #0
 8005efe:	d105      	bne.n	8005f0c <dmaStreamRelease+0x3c>
    rccDisableDMA1(false);
 8005f00:	4a0b      	ldr	r2, [pc, #44]	; (8005f30 <dmaStreamRelease+0x60>)
 8005f02:	4b0b      	ldr	r3, [pc, #44]	; (8005f30 <dmaStreamRelease+0x60>)
 8005f04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f06:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8005f0a:	6313      	str	r3, [r2, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8005f0c:	4b07      	ldr	r3, [pc, #28]	; (8005f2c <dmaStreamRelease+0x5c>)
 8005f0e:	681b      	ldr	r3, [r3, #0]
 8005f10:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005f14:	2b00      	cmp	r3, #0
 8005f16:	d105      	bne.n	8005f24 <dmaStreamRelease+0x54>
    rccDisableDMA2(false);
 8005f18:	4a05      	ldr	r2, [pc, #20]	; (8005f30 <dmaStreamRelease+0x60>)
 8005f1a:	4b05      	ldr	r3, [pc, #20]	; (8005f30 <dmaStreamRelease+0x60>)
 8005f1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f1e:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8005f22:	6313      	str	r3, [r2, #48]	; 0x30
  }
}
 8005f24:	b003      	add	sp, #12
 8005f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f2a:	bf00      	nop
 8005f2c:	200008d8 	.word	0x200008d8
 8005f30:	40023800 	.word	0x40023800
	...

08005f40 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8005f40:	b082      	sub	sp, #8
 8005f42:	9001      	str	r0, [sp, #4]
 8005f44:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8005f46:	9b00      	ldr	r3, [sp, #0]
 8005f48:	685a      	ldr	r2, [r3, #4]
 8005f4a:	9b01      	ldr	r3, [sp, #4]
 8005f4c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f4e:	9b00      	ldr	r3, [sp, #0]
 8005f50:	689a      	ldr	r2, [r3, #8]
 8005f52:	9b01      	ldr	r3, [sp, #4]
 8005f54:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005f56:	9b00      	ldr	r3, [sp, #0]
 8005f58:	68da      	ldr	r2, [r3, #12]
 8005f5a:	9b01      	ldr	r3, [sp, #4]
 8005f5c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005f5e:	9b00      	ldr	r3, [sp, #0]
 8005f60:	691a      	ldr	r2, [r3, #16]
 8005f62:	9b01      	ldr	r3, [sp, #4]
 8005f64:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005f66:	9b00      	ldr	r3, [sp, #0]
 8005f68:	695a      	ldr	r2, [r3, #20]
 8005f6a:	9b01      	ldr	r3, [sp, #4]
 8005f6c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005f6e:	9b00      	ldr	r3, [sp, #0]
 8005f70:	699a      	ldr	r2, [r3, #24]
 8005f72:	9b01      	ldr	r3, [sp, #4]
 8005f74:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005f76:	9b00      	ldr	r3, [sp, #0]
 8005f78:	681a      	ldr	r2, [r3, #0]
 8005f7a:	9b01      	ldr	r3, [sp, #4]
 8005f7c:	601a      	str	r2, [r3, #0]
}
 8005f7e:	b002      	add	sp, #8
 8005f80:	4770      	bx	lr
 8005f82:	bf00      	nop
 8005f84:	f3af 8000 	nop.w
 8005f88:	f3af 8000 	nop.w
 8005f8c:	f3af 8000 	nop.w

08005f90 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8005f90:	b500      	push	{lr}
 8005f92:	b083      	sub	sp, #12
 8005f94:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8005f96:	4a24      	ldr	r2, [pc, #144]	; (8006028 <_pal_lld_init+0x98>)
 8005f98:	4b23      	ldr	r3, [pc, #140]	; (8006028 <_pal_lld_init+0x98>)
 8005f9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005f9c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8005fa0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8005fa4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8005fa6:	4a20      	ldr	r2, [pc, #128]	; (8006028 <_pal_lld_init+0x98>)
 8005fa8:	4b1f      	ldr	r3, [pc, #124]	; (8006028 <_pal_lld_init+0x98>)
 8005faa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005fac:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8005fb0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8005fb4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8005fb6:	9b01      	ldr	r3, [sp, #4]
 8005fb8:	481c      	ldr	r0, [pc, #112]	; (800602c <_pal_lld_init+0x9c>)
 8005fba:	4619      	mov	r1, r3
 8005fbc:	f7ff ffc0 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8005fc0:	9b01      	ldr	r3, [sp, #4]
 8005fc2:	331c      	adds	r3, #28
 8005fc4:	481a      	ldr	r0, [pc, #104]	; (8006030 <_pal_lld_init+0xa0>)
 8005fc6:	4619      	mov	r1, r3
 8005fc8:	f7ff ffba 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8005fcc:	9b01      	ldr	r3, [sp, #4]
 8005fce:	3338      	adds	r3, #56	; 0x38
 8005fd0:	4818      	ldr	r0, [pc, #96]	; (8006034 <_pal_lld_init+0xa4>)
 8005fd2:	4619      	mov	r1, r3
 8005fd4:	f7ff ffb4 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8005fd8:	9b01      	ldr	r3, [sp, #4]
 8005fda:	3354      	adds	r3, #84	; 0x54
 8005fdc:	4816      	ldr	r0, [pc, #88]	; (8006038 <_pal_lld_init+0xa8>)
 8005fde:	4619      	mov	r1, r3
 8005fe0:	f7ff ffae 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8005fe4:	9b01      	ldr	r3, [sp, #4]
 8005fe6:	3370      	adds	r3, #112	; 0x70
 8005fe8:	4814      	ldr	r0, [pc, #80]	; (800603c <_pal_lld_init+0xac>)
 8005fea:	4619      	mov	r1, r3
 8005fec:	f7ff ffa8 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8005ff0:	9b01      	ldr	r3, [sp, #4]
 8005ff2:	338c      	adds	r3, #140	; 0x8c
 8005ff4:	4812      	ldr	r0, [pc, #72]	; (8006040 <_pal_lld_init+0xb0>)
 8005ff6:	4619      	mov	r1, r3
 8005ff8:	f7ff ffa2 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 8005ffc:	9b01      	ldr	r3, [sp, #4]
 8005ffe:	33a8      	adds	r3, #168	; 0xa8
 8006000:	4810      	ldr	r0, [pc, #64]	; (8006044 <_pal_lld_init+0xb4>)
 8006002:	4619      	mov	r1, r3
 8006004:	f7ff ff9c 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8006008:	9b01      	ldr	r3, [sp, #4]
 800600a:	33c4      	adds	r3, #196	; 0xc4
 800600c:	480e      	ldr	r0, [pc, #56]	; (8006048 <_pal_lld_init+0xb8>)
 800600e:	4619      	mov	r1, r3
 8006010:	f7ff ff96 	bl	8005f40 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 8006014:	9b01      	ldr	r3, [sp, #4]
 8006016:	33e0      	adds	r3, #224	; 0xe0
 8006018:	480c      	ldr	r0, [pc, #48]	; (800604c <_pal_lld_init+0xbc>)
 800601a:	4619      	mov	r1, r3
 800601c:	f7ff ff90 	bl	8005f40 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8006020:	b003      	add	sp, #12
 8006022:	f85d fb04 	ldr.w	pc, [sp], #4
 8006026:	bf00      	nop
 8006028:	40023800 	.word	0x40023800
 800602c:	40020000 	.word	0x40020000
 8006030:	40020400 	.word	0x40020400
 8006034:	40020800 	.word	0x40020800
 8006038:	40020c00 	.word	0x40020c00
 800603c:	40021000 	.word	0x40021000
 8006040:	40021400 	.word	0x40021400
 8006044:	40021800 	.word	0x40021800
 8006048:	40021c00 	.word	0x40021c00
 800604c:	40022000 	.word	0x40022000

08006050 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8006050:	b08e      	sub	sp, #56	; 0x38
 8006052:	9003      	str	r0, [sp, #12]
 8006054:	9102      	str	r1, [sp, #8]
 8006056:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8006058:	9b01      	ldr	r3, [sp, #4]
 800605a:	f003 0303 	and.w	r3, r3, #3
 800605e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8006060:	9b01      	ldr	r3, [sp, #4]
 8006062:	f003 0304 	and.w	r3, r3, #4
 8006066:	089b      	lsrs	r3, r3, #2
 8006068:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800606a:	9b01      	ldr	r3, [sp, #4]
 800606c:	f003 0318 	and.w	r3, r3, #24
 8006070:	08db      	lsrs	r3, r3, #3
 8006072:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8006074:	9b01      	ldr	r3, [sp, #4]
 8006076:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800607a:	095b      	lsrs	r3, r3, #5
 800607c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800607e:	9b01      	ldr	r3, [sp, #4]
 8006080:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8006084:	09db      	lsrs	r3, r3, #7
 8006086:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8006088:	2300      	movs	r3, #0
 800608a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800608c:	9b02      	ldr	r3, [sp, #8]
 800608e:	f003 0301 	and.w	r3, r3, #1
 8006092:	2b00      	cmp	r3, #0
 8006094:	d079      	beq.n	800618a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8006096:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006098:	f003 0307 	and.w	r3, r3, #7
 800609c:	009b      	lsls	r3, r3, #2
 800609e:	461a      	mov	r2, r3
 80060a0:	9b08      	ldr	r3, [sp, #32]
 80060a2:	4093      	lsls	r3, r2
 80060a4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80060a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80060a8:	2201      	movs	r2, #1
 80060aa:	fa02 f303 	lsl.w	r3, r2, r3
 80060ae:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80060b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80060b2:	005b      	lsls	r3, r3, #1
 80060b4:	461a      	mov	r2, r3
 80060b6:	2303      	movs	r3, #3
 80060b8:	4093      	lsls	r3, r2
 80060ba:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80060bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80060be:	f003 0307 	and.w	r3, r3, #7
 80060c2:	009b      	lsls	r3, r3, #2
 80060c4:	461a      	mov	r2, r3
 80060c6:	230f      	movs	r3, #15
 80060c8:	4093      	lsls	r3, r2
 80060ca:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80060cc:	9b03      	ldr	r3, [sp, #12]
 80060ce:	685a      	ldr	r2, [r3, #4]
 80060d0:	9b06      	ldr	r3, [sp, #24]
 80060d2:	43db      	mvns	r3, r3
 80060d4:	401a      	ands	r2, r3
 80060d6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80060d8:	431a      	orrs	r2, r3
 80060da:	9b03      	ldr	r3, [sp, #12]
 80060dc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80060de:	9b03      	ldr	r3, [sp, #12]
 80060e0:	689a      	ldr	r2, [r3, #8]
 80060e2:	9b05      	ldr	r3, [sp, #20]
 80060e4:	43db      	mvns	r3, r3
 80060e6:	401a      	ands	r2, r3
 80060e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80060ea:	431a      	orrs	r2, r3
 80060ec:	9b03      	ldr	r3, [sp, #12]
 80060ee:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80060f0:	9b03      	ldr	r3, [sp, #12]
 80060f2:	68da      	ldr	r2, [r3, #12]
 80060f4:	9b05      	ldr	r3, [sp, #20]
 80060f6:	43db      	mvns	r3, r3
 80060f8:	401a      	ands	r2, r3
 80060fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80060fc:	431a      	orrs	r2, r3
 80060fe:	9b03      	ldr	r3, [sp, #12]
 8006100:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8006102:	9b01      	ldr	r3, [sp, #4]
 8006104:	f003 0303 	and.w	r3, r3, #3
 8006108:	2b02      	cmp	r3, #2
 800610a:	d11f      	bne.n	800614c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800610c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800610e:	2b07      	cmp	r3, #7
 8006110:	d809      	bhi.n	8006126 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8006112:	9b03      	ldr	r3, [sp, #12]
 8006114:	6a1a      	ldr	r2, [r3, #32]
 8006116:	9b04      	ldr	r3, [sp, #16]
 8006118:	43db      	mvns	r3, r3
 800611a:	401a      	ands	r2, r3
 800611c:	9b07      	ldr	r3, [sp, #28]
 800611e:	431a      	orrs	r2, r3
 8006120:	9b03      	ldr	r3, [sp, #12]
 8006122:	621a      	str	r2, [r3, #32]
 8006124:	e008      	b.n	8006138 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8006126:	9b03      	ldr	r3, [sp, #12]
 8006128:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800612a:	9b04      	ldr	r3, [sp, #16]
 800612c:	43db      	mvns	r3, r3
 800612e:	401a      	ands	r2, r3
 8006130:	9b07      	ldr	r3, [sp, #28]
 8006132:	431a      	orrs	r2, r3
 8006134:	9b03      	ldr	r3, [sp, #12]
 8006136:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8006138:	9b03      	ldr	r3, [sp, #12]
 800613a:	681a      	ldr	r2, [r3, #0]
 800613c:	9b05      	ldr	r3, [sp, #20]
 800613e:	43db      	mvns	r3, r3
 8006140:	401a      	ands	r2, r3
 8006142:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006144:	431a      	orrs	r2, r3
 8006146:	9b03      	ldr	r3, [sp, #12]
 8006148:	601a      	str	r2, [r3, #0]
 800614a:	e01e      	b.n	800618a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800614c:	9b03      	ldr	r3, [sp, #12]
 800614e:	681a      	ldr	r2, [r3, #0]
 8006150:	9b05      	ldr	r3, [sp, #20]
 8006152:	43db      	mvns	r3, r3
 8006154:	401a      	ands	r2, r3
 8006156:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006158:	431a      	orrs	r2, r3
 800615a:	9b03      	ldr	r3, [sp, #12]
 800615c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800615e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006160:	2b07      	cmp	r3, #7
 8006162:	d809      	bhi.n	8006178 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8006164:	9b03      	ldr	r3, [sp, #12]
 8006166:	6a1a      	ldr	r2, [r3, #32]
 8006168:	9b04      	ldr	r3, [sp, #16]
 800616a:	43db      	mvns	r3, r3
 800616c:	401a      	ands	r2, r3
 800616e:	9b07      	ldr	r3, [sp, #28]
 8006170:	431a      	orrs	r2, r3
 8006172:	9b03      	ldr	r3, [sp, #12]
 8006174:	621a      	str	r2, [r3, #32]
 8006176:	e008      	b.n	800618a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8006178:	9b03      	ldr	r3, [sp, #12]
 800617a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800617c:	9b04      	ldr	r3, [sp, #16]
 800617e:	43db      	mvns	r3, r3
 8006180:	401a      	ands	r2, r3
 8006182:	9b07      	ldr	r3, [sp, #28]
 8006184:	431a      	orrs	r2, r3
 8006186:	9b03      	ldr	r3, [sp, #12]
 8006188:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 800618a:	9b02      	ldr	r3, [sp, #8]
 800618c:	085b      	lsrs	r3, r3, #1
 800618e:	9302      	str	r3, [sp, #8]
    if (!mask)
 8006190:	9b02      	ldr	r3, [sp, #8]
 8006192:	2b00      	cmp	r3, #0
 8006194:	d100      	bne.n	8006198 <_pal_lld_setgroupmode+0x148>
      return;
 8006196:	e00f      	b.n	80061b8 <_pal_lld_setgroupmode+0x168>
    otyper <<= 1;
 8006198:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800619a:	005b      	lsls	r3, r3, #1
 800619c:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800619e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80061a0:	009b      	lsls	r3, r3, #2
 80061a2:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 80061a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80061a6:	009b      	lsls	r3, r3, #2
 80061a8:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 80061aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80061ac:	009b      	lsls	r3, r3, #2
 80061ae:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 80061b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80061b2:	3301      	adds	r3, #1
 80061b4:	9309      	str	r3, [sp, #36]	; 0x24
  }
 80061b6:	e769      	b.n	800608c <_pal_lld_setgroupmode+0x3c>
}
 80061b8:	b00e      	add	sp, #56	; 0x38
 80061ba:	4770      	bx	lr
 80061bc:	0000      	movs	r0, r0
	...

080061c0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80061c0:	b082      	sub	sp, #8
 80061c2:	2320      	movs	r3, #32
 80061c4:	9301      	str	r3, [sp, #4]
 80061c6:	9b01      	ldr	r3, [sp, #4]
 80061c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80061cc:	b002      	add	sp, #8
 80061ce:	4770      	bx	lr

080061d0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80061d0:	b082      	sub	sp, #8
 80061d2:	2300      	movs	r3, #0
 80061d4:	9301      	str	r3, [sp, #4]
 80061d6:	9b01      	ldr	r3, [sp, #4]
 80061d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80061dc:	b002      	add	sp, #8
 80061de:	4770      	bx	lr

080061e0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80061e0:	b508      	push	{r3, lr}

  port_lock();
 80061e2:	f7ff ffed 	bl	80061c0 <port_lock>
}
 80061e6:	bd08      	pop	{r3, pc}
 80061e8:	f3af 8000 	nop.w
 80061ec:	f3af 8000 	nop.w

080061f0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80061f0:	b508      	push	{r3, lr}

  port_unlock();
 80061f2:	f7ff ffed 	bl	80061d0 <port_unlock>
}
 80061f6:	bd08      	pop	{r3, pc}
 80061f8:	f3af 8000 	nop.w
 80061fc:	f3af 8000 	nop.w

08006200 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006200:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006206:	4618      	mov	r0, r3
 8006208:	4770      	bx	lr
 800620a:	bf00      	nop
 800620c:	f3af 8000 	nop.w

08006210 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006210:	b508      	push	{r3, lr}

  return stGetCounter();
 8006212:	f7ff fff5 	bl	8006200 <st_lld_get_counter>
 8006216:	4603      	mov	r3, r0
}
 8006218:	4618      	mov	r0, r3
 800621a:	bd08      	pop	{r3, pc}
 800621c:	f3af 8000 	nop.w

08006220 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006220:	b508      	push	{r3, lr}

  port_lock();
 8006222:	f7ff ffcd 	bl	80061c0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006226:	bd08      	pop	{r3, pc}
 8006228:	f3af 8000 	nop.w
 800622c:	f3af 8000 	nop.w

08006230 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006230:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8006232:	f7ff ffcd 	bl	80061d0 <port_unlock>
}
 8006236:	bd08      	pop	{r3, pc}
 8006238:	f3af 8000 	nop.w
 800623c:	f3af 8000 	nop.w

08006240 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006240:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006242:	f7ff ffcd 	bl	80061e0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006246:	bd08      	pop	{r3, pc}
 8006248:	f3af 8000 	nop.w
 800624c:	f3af 8000 	nop.w

08006250 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006250:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006252:	f7ff ffcd 	bl	80061f0 <port_unlock_from_isr>
}
 8006256:	bd08      	pop	{r3, pc}
 8006258:	f3af 8000 	nop.w
 800625c:	f3af 8000 	nop.w

08006260 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006260:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006262:	f7ff ffd5 	bl	8006210 <port_timer_get_time>
 8006266:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006268:	4618      	mov	r0, r3
 800626a:	bd08      	pop	{r3, pc}
 800626c:	f3af 8000 	nop.w

08006270 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8006270:	b084      	sub	sp, #16
 8006272:	9003      	str	r0, [sp, #12]
 8006274:	9102      	str	r1, [sp, #8]
 8006276:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8006278:	9a03      	ldr	r2, [sp, #12]
 800627a:	9b02      	ldr	r3, [sp, #8]
 800627c:	1ad2      	subs	r2, r2, r3
 800627e:	9901      	ldr	r1, [sp, #4]
 8006280:	9b02      	ldr	r3, [sp, #8]
 8006282:	1acb      	subs	r3, r1, r3
 8006284:	429a      	cmp	r2, r3
 8006286:	bf34      	ite	cc
 8006288:	2301      	movcc	r3, #1
 800628a:	2300      	movcs	r3, #0
 800628c:	b2db      	uxtb	r3, r3
}
 800628e:	4618      	mov	r0, r3
 8006290:	b004      	add	sp, #16
 8006292:	4770      	bx	lr
 8006294:	f3af 8000 	nop.w
 8006298:	f3af 8000 	nop.w
 800629c:	f3af 8000 	nop.w

080062a0 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 80062a0:	b500      	push	{lr}
 80062a2:	b083      	sub	sp, #12
 80062a4:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 80062a6:	9801      	ldr	r0, [sp, #4]
 80062a8:	f7fa fa4a 	bl	8000740 <chSysHalt>
}
 80062ac:	b003      	add	sp, #12
 80062ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80062b2:	bf00      	nop
 80062b4:	f3af 8000 	nop.w
 80062b8:	f3af 8000 	nop.w
 80062bc:	f3af 8000 	nop.w

080062c0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80062c0:	b508      	push	{r3, lr}

  chSysLock();
 80062c2:	f7ff ffad 	bl	8006220 <chSysLock>
}
 80062c6:	bd08      	pop	{r3, pc}
 80062c8:	f3af 8000 	nop.w
 80062cc:	f3af 8000 	nop.w

080062d0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80062d0:	b508      	push	{r3, lr}

  chSysUnlock();
 80062d2:	f7ff ffad 	bl	8006230 <chSysUnlock>
}
 80062d6:	bd08      	pop	{r3, pc}
 80062d8:	f3af 8000 	nop.w
 80062dc:	f3af 8000 	nop.w

080062e0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80062e0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80062e2:	f7ff ffad 	bl	8006240 <chSysLockFromISR>
}
 80062e6:	bd08      	pop	{r3, pc}
 80062e8:	f3af 8000 	nop.w
 80062ec:	f3af 8000 	nop.w

080062f0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80062f0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80062f2:	f7ff ffad 	bl	8006250 <chSysUnlockFromISR>
}
 80062f6:	bd08      	pop	{r3, pc}
 80062f8:	f3af 8000 	nop.w
 80062fc:	f3af 8000 	nop.w

08006300 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8006300:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8006302:	f7ff ffad 	bl	8006260 <chVTGetSystemTimeX>
 8006306:	4603      	mov	r3, r0
}
 8006308:	4618      	mov	r0, r3
 800630a:	bd08      	pop	{r3, pc}
 800630c:	f3af 8000 	nop.w

08006310 <osalOsIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool osalOsIsTimeWithinX(systime_t time,
                                       systime_t start,
                                       systime_t end) {
 8006310:	b500      	push	{lr}
 8006312:	b085      	sub	sp, #20
 8006314:	9003      	str	r0, [sp, #12]
 8006316:	9102      	str	r1, [sp, #8]
 8006318:	9201      	str	r2, [sp, #4]

  return chVTIsTimeWithinX(time, start, end);
 800631a:	9803      	ldr	r0, [sp, #12]
 800631c:	9902      	ldr	r1, [sp, #8]
 800631e:	9a01      	ldr	r2, [sp, #4]
 8006320:	f7ff ffa6 	bl	8006270 <chVTIsTimeWithinX>
 8006324:	4603      	mov	r3, r0
}
 8006326:	4618      	mov	r0, r3
 8006328:	b005      	add	sp, #20
 800632a:	f85d fb04 	ldr.w	pc, [sp], #4
 800632e:	bf00      	nop

08006330 <osalThreadSuspendTimeoutS>:
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {
 8006330:	b500      	push	{lr}
 8006332:	b083      	sub	sp, #12
 8006334:	9001      	str	r0, [sp, #4]
 8006336:	9100      	str	r1, [sp, #0]

  return chThdSuspendTimeoutS(trp, timeout);
 8006338:	9801      	ldr	r0, [sp, #4]
 800633a:	9900      	ldr	r1, [sp, #0]
 800633c:	f7fb fa58 	bl	80017f0 <chThdSuspendTimeoutS>
 8006340:	4603      	mov	r3, r0
}
 8006342:	4618      	mov	r0, r3
 8006344:	b003      	add	sp, #12
 8006346:	f85d fb04 	ldr.w	pc, [sp], #4
 800634a:	bf00      	nop
 800634c:	f3af 8000 	nop.w

08006350 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8006350:	b500      	push	{lr}
 8006352:	b083      	sub	sp, #12
 8006354:	9001      	str	r0, [sp, #4]
 8006356:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8006358:	9801      	ldr	r0, [sp, #4]
 800635a:	9900      	ldr	r1, [sp, #0]
 800635c:	f7fb fa68 	bl	8001830 <chThdResumeI>
}
 8006360:	b003      	add	sp, #12
 8006362:	f85d fb04 	ldr.w	pc, [sp], #4
 8006366:	bf00      	nop
 8006368:	f3af 8000 	nop.w
 800636c:	f3af 8000 	nop.w

08006370 <i2c_lld_abort_operation>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
 8006370:	b084      	sub	sp, #16
 8006372:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006374:	9b01      	ldr	r3, [sp, #4]
 8006376:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006378:	9303      	str	r3, [sp, #12]

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800637a:	9b03      	ldr	r3, [sp, #12]
 800637c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006380:	601a      	str	r2, [r3, #0]
  dp->CR1 = 0;
 8006382:	9b03      	ldr	r3, [sp, #12]
 8006384:	2200      	movs	r2, #0
 8006386:	601a      	str	r2, [r3, #0]
  dp->CR2 = 0;
 8006388:	9b03      	ldr	r3, [sp, #12]
 800638a:	2200      	movs	r2, #0
 800638c:	605a      	str	r2, [r3, #4]
  dp->SR1 = 0;
 800638e:	9b03      	ldr	r3, [sp, #12]
 8006390:	2200      	movs	r2, #0
 8006392:	615a      	str	r2, [r3, #20]

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8006394:	9b01      	ldr	r3, [sp, #4]
 8006396:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006398:	681b      	ldr	r3, [r3, #0]
 800639a:	9a01      	ldr	r2, [sp, #4]
 800639c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800639e:	6812      	ldr	r2, [r2, #0]
 80063a0:	6812      	ldr	r2, [r2, #0]
 80063a2:	f022 021f 	bic.w	r2, r2, #31
 80063a6:	601a      	str	r2, [r3, #0]
 80063a8:	bf00      	nop
 80063aa:	9b01      	ldr	r3, [sp, #4]
 80063ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80063ae:	681b      	ldr	r3, [r3, #0]
 80063b0:	681b      	ldr	r3, [r3, #0]
 80063b2:	f003 0301 	and.w	r3, r3, #1
 80063b6:	2b00      	cmp	r3, #0
 80063b8:	d1f7      	bne.n	80063aa <i2c_lld_abort_operation+0x3a>
 80063ba:	9b01      	ldr	r3, [sp, #4]
 80063bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80063be:	685b      	ldr	r3, [r3, #4]
 80063c0:	9a01      	ldr	r2, [sp, #4]
 80063c2:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80063c4:	7a12      	ldrb	r2, [r2, #8]
 80063c6:	4611      	mov	r1, r2
 80063c8:	223d      	movs	r2, #61	; 0x3d
 80063ca:	408a      	lsls	r2, r1
 80063cc:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmarx);
 80063ce:	9b01      	ldr	r3, [sp, #4]
 80063d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063d2:	681b      	ldr	r3, [r3, #0]
 80063d4:	9a01      	ldr	r2, [sp, #4]
 80063d6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80063d8:	6812      	ldr	r2, [r2, #0]
 80063da:	6812      	ldr	r2, [r2, #0]
 80063dc:	f022 021f 	bic.w	r2, r2, #31
 80063e0:	601a      	str	r2, [r3, #0]
 80063e2:	bf00      	nop
 80063e4:	9b01      	ldr	r3, [sp, #4]
 80063e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063e8:	681b      	ldr	r3, [r3, #0]
 80063ea:	681b      	ldr	r3, [r3, #0]
 80063ec:	f003 0301 	and.w	r3, r3, #1
 80063f0:	2b00      	cmp	r3, #0
 80063f2:	d1f7      	bne.n	80063e4 <i2c_lld_abort_operation+0x74>
 80063f4:	9b01      	ldr	r3, [sp, #4]
 80063f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063f8:	685b      	ldr	r3, [r3, #4]
 80063fa:	9a01      	ldr	r2, [sp, #4]
 80063fc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80063fe:	7a12      	ldrb	r2, [r2, #8]
 8006400:	4611      	mov	r1, r2
 8006402:	223d      	movs	r2, #61	; 0x3d
 8006404:	408a      	lsls	r2, r1
 8006406:	601a      	str	r2, [r3, #0]
}
 8006408:	b004      	add	sp, #16
 800640a:	4770      	bx	lr
 800640c:	f3af 8000 	nop.w

08006410 <i2c_lld_set_clock>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
 8006410:	b086      	sub	sp, #24
 8006412:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006414:	9b01      	ldr	r3, [sp, #4]
 8006416:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006418:	9304      	str	r3, [sp, #16]
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 800641a:	9b01      	ldr	r3, [sp, #4]
 800641c:	685b      	ldr	r3, [r3, #4]
 800641e:	685b      	ldr	r3, [r3, #4]
 8006420:	9303      	str	r3, [sp, #12]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 8006422:	9b01      	ldr	r3, [sp, #4]
 8006424:	685b      	ldr	r3, [r3, #4]
 8006426:	7a1b      	ldrb	r3, [r3, #8]
 8006428:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800642c:	9b04      	ldr	r3, [sp, #16]
 800642e:	685a      	ldr	r2, [r3, #4]
 8006430:	f64f 73c0 	movw	r3, #65472	; 0xffc0
 8006434:	4013      	ands	r3, r2
 8006436:	9a04      	ldr	r2, [sp, #16]
 8006438:	6053      	str	r3, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800643a:	9b04      	ldr	r3, [sp, #16]
 800643c:	685b      	ldr	r3, [r3, #4]
 800643e:	f043 022a 	orr.w	r2, r3, #42	; 0x2a
 8006442:	9b04      	ldr	r3, [sp, #16]
 8006444:	605a      	str	r2, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
 8006446:	2300      	movs	r3, #0
 8006448:	f8ad 3016 	strh.w	r3, [sp, #22]
  clock_div = I2C_CCR_CCR;
 800644c:	f640 73ff 	movw	r3, #4095	; 0xfff
 8006450:	f8ad 3014 	strh.w	r3, [sp, #20]

  if (clock_speed <= 100000) {
 8006454:	9b03      	ldr	r3, [sp, #12]
 8006456:	4a2d      	ldr	r2, [pc, #180]	; (800650c <i2c_lld_set_clock+0xfc>)
 8006458:	4293      	cmp	r3, r2
 800645a:	dc15      	bgt.n	8006488 <i2c_lld_set_clock+0x78>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 800645c:	9b03      	ldr	r3, [sp, #12]
 800645e:	005b      	lsls	r3, r3, #1
 8006460:	461a      	mov	r2, r3
 8006462:	4b2b      	ldr	r3, [pc, #172]	; (8006510 <i2c_lld_set_clock+0x100>)
 8006464:	fbb3 f3f2 	udiv	r3, r3, r2
 8006468:	f8ad 3014 	strh.w	r3, [sp, #20]

    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);
 800646c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006470:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8006474:	b29a      	uxth	r2, r3
 8006476:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800647a:	4313      	orrs	r3, r2
 800647c:	f8ad 3016 	strh.w	r3, [sp, #22]

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8006480:	9b04      	ldr	r3, [sp, #16]
 8006482:	222b      	movs	r2, #43	; 0x2b
 8006484:	621a      	str	r2, [r3, #32]
 8006486:	e03a      	b.n	80064fe <i2c_lld_set_clock+0xee>
  }
  else if (clock_speed <= 400000) {
 8006488:	9b03      	ldr	r3, [sp, #12]
 800648a:	4a22      	ldr	r2, [pc, #136]	; (8006514 <i2c_lld_set_clock+0x104>)
 800648c:	4293      	cmp	r3, r2
 800648e:	dc36      	bgt.n	80064fe <i2c_lld_set_clock+0xee>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 8006490:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006494:	2b02      	cmp	r3, #2
 8006496:	d10a      	bne.n	80064ae <i2c_lld_set_clock+0x9e>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8006498:	9a03      	ldr	r2, [sp, #12]
 800649a:	4613      	mov	r3, r2
 800649c:	005b      	lsls	r3, r3, #1
 800649e:	4413      	add	r3, r2
 80064a0:	461a      	mov	r2, r3
 80064a2:	4b1b      	ldr	r3, [pc, #108]	; (8006510 <i2c_lld_set_clock+0x100>)
 80064a4:	fbb3 f3f2 	udiv	r3, r3, r2
 80064a8:	f8ad 3014 	strh.w	r3, [sp, #20]
 80064ac:	e015      	b.n	80064da <i2c_lld_set_clock+0xca>
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 80064ae:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80064b2:	2b03      	cmp	r3, #3
 80064b4:	d111      	bne.n	80064da <i2c_lld_set_clock+0xca>
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80064b6:	9a03      	ldr	r2, [sp, #12]
 80064b8:	4613      	mov	r3, r2
 80064ba:	009b      	lsls	r3, r3, #2
 80064bc:	4413      	add	r3, r2
 80064be:	009a      	lsls	r2, r3, #2
 80064c0:	4413      	add	r3, r2
 80064c2:	461a      	mov	r2, r3
 80064c4:	4b12      	ldr	r3, [pc, #72]	; (8006510 <i2c_lld_set_clock+0x100>)
 80064c6:	fbb3 f3f2 	udiv	r3, r3, r2
 80064ca:	f8ad 3014 	strh.w	r3, [sp, #20]
      regCCR |= I2C_CCR_DUTY;
 80064ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80064d2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80064d6:	f8ad 3016 	strh.w	r3, [sp, #22]
    }

    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80064da:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80064de:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80064e2:	b29a      	uxth	r2, r3
 80064e4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80064e8:	4313      	orrs	r3, r2
 80064ea:	b29b      	uxth	r3, r3
 80064ec:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80064f0:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80064f4:	f8ad 3016 	strh.w	r3, [sp, #22]

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80064f8:	9b04      	ldr	r3, [sp, #16]
 80064fa:	220d      	movs	r2, #13
 80064fc:	621a      	str	r2, [r3, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 80064fe:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 8006502:	9b04      	ldr	r3, [sp, #16]
 8006504:	61da      	str	r2, [r3, #28]
}
 8006506:	b006      	add	sp, #24
 8006508:	4770      	bx	lr
 800650a:	bf00      	nop
 800650c:	000186a0 	.word	0x000186a0
 8006510:	0280de80 	.word	0x0280de80
 8006514:	00061a80 	.word	0x00061a80
 8006518:	f3af 8000 	nop.w
 800651c:	f3af 8000 	nop.w

08006520 <i2c_lld_set_opmode>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
 8006520:	b086      	sub	sp, #24
 8006522:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006524:	9b01      	ldr	r3, [sp, #4]
 8006526:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006528:	9304      	str	r3, [sp, #16]
  i2copmode_t opmode = i2cp->config->op_mode;
 800652a:	9b01      	ldr	r3, [sp, #4]
 800652c:	685b      	ldr	r3, [r3, #4]
 800652e:	781b      	ldrb	r3, [r3, #0]
 8006530:	f88d 300f 	strb.w	r3, [sp, #15]
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8006534:	9b04      	ldr	r3, [sp, #16]
 8006536:	681b      	ldr	r3, [r3, #0]
 8006538:	f8ad 3016 	strh.w	r3, [sp, #22]
  switch (opmode) {
 800653c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006540:	2b02      	cmp	r3, #2
 8006542:	d00a      	beq.n	800655a <i2c_lld_set_opmode+0x3a>
 8006544:	2b03      	cmp	r3, #3
 8006546:	d015      	beq.n	8006574 <i2c_lld_set_opmode+0x54>
 8006548:	2b01      	cmp	r3, #1
 800654a:	d11a      	bne.n	8006582 <i2c_lld_set_opmode+0x62>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800654c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006550:	f023 030a 	bic.w	r3, r3, #10
 8006554:	f8ad 3016 	strh.w	r3, [sp, #22]
    break;
 8006558:	e013      	b.n	8006582 <i2c_lld_set_opmode+0x62>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
 800655a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800655e:	f043 0302 	orr.w	r3, r3, #2
 8006562:	f8ad 3016 	strh.w	r3, [sp, #22]
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8006566:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800656a:	f023 0308 	bic.w	r3, r3, #8
 800656e:	f8ad 3016 	strh.w	r3, [sp, #22]
    break;
 8006572:	e006      	b.n	8006582 <i2c_lld_set_opmode+0x62>
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8006574:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006578:	f043 030a 	orr.w	r3, r3, #10
 800657c:	f8ad 3016 	strh.w	r3, [sp, #22]
    break;
 8006580:	bf00      	nop
  }
  dp->CR1 = regCR1;
 8006582:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 8006586:	9b04      	ldr	r3, [sp, #16]
 8006588:	601a      	str	r2, [r3, #0]
}
 800658a:	b006      	add	sp, #24
 800658c:	4770      	bx	lr
 800658e:	bf00      	nop

08006590 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 8006590:	b500      	push	{lr}
 8006592:	b087      	sub	sp, #28
 8006594:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006596:	9b01      	ldr	r3, [sp, #4]
 8006598:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800659a:	9305      	str	r3, [sp, #20]
  uint32_t regSR2 = dp->SR2;
 800659c:	9b05      	ldr	r3, [sp, #20]
 800659e:	699b      	ldr	r3, [r3, #24]
 80065a0:	9304      	str	r3, [sp, #16]
  uint32_t event = dp->SR1;
 80065a2:	9b05      	ldr	r3, [sp, #20]
 80065a4:	695b      	ldr	r3, [r3, #20]
 80065a6:	9303      	str	r3, [sp, #12]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80065a8:	9b04      	ldr	r3, [sp, #16]
 80065aa:	041a      	lsls	r2, r3, #16
 80065ac:	9b03      	ldr	r3, [sp, #12]
 80065ae:	4313      	orrs	r3, r2
 80065b0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80065b4:	4a53      	ldr	r2, [pc, #332]	; (8006704 <i2c_lld_serve_event_interrupt+0x174>)
 80065b6:	4293      	cmp	r3, r2
 80065b8:	d031      	beq.n	800661e <i2c_lld_serve_event_interrupt+0x8e>
 80065ba:	4a52      	ldr	r2, [pc, #328]	; (8006704 <i2c_lld_serve_event_interrupt+0x174>)
 80065bc:	4293      	cmp	r3, r2
 80065be:	d806      	bhi.n	80065ce <i2c_lld_serve_event_interrupt+0x3e>
 80065c0:	4a51      	ldr	r2, [pc, #324]	; (8006708 <i2c_lld_serve_event_interrupt+0x178>)
 80065c2:	4293      	cmp	r3, r2
 80065c4:	d00a      	beq.n	80065dc <i2c_lld_serve_event_interrupt+0x4c>
 80065c6:	4a51      	ldr	r2, [pc, #324]	; (800670c <i2c_lld_serve_event_interrupt+0x17c>)
 80065c8:	4293      	cmp	r3, r2
 80065ca:	d030      	beq.n	800662e <i2c_lld_serve_event_interrupt+0x9e>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dp->CR1 |= I2C_CR1_STOP;
    _i2c_wakeup_isr(i2cp);
    break;
  default:
    break;
 80065cc:	e08f      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80065ce:	4a50      	ldr	r2, [pc, #320]	; (8006710 <i2c_lld_serve_event_interrupt+0x180>)
 80065d0:	4293      	cmp	r3, r2
 80065d2:	d050      	beq.n	8006676 <i2c_lld_serve_event_interrupt+0xe6>
 80065d4:	4a4f      	ldr	r2, [pc, #316]	; (8006714 <i2c_lld_serve_event_interrupt+0x184>)
 80065d6:	4293      	cmp	r3, r2
 80065d8:	d05e      	beq.n	8006698 <i2c_lld_serve_event_interrupt+0x108>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dp->CR1 |= I2C_CR1_STOP;
    _i2c_wakeup_isr(i2cp);
    break;
  default:
    break;
 80065da:	e088      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 80065dc:	9b01      	ldr	r3, [sp, #4]
 80065de:	8c1b      	ldrh	r3, [r3, #32]
 80065e0:	0a1b      	lsrs	r3, r3, #8
 80065e2:	b29b      	uxth	r3, r3
 80065e4:	2b00      	cmp	r3, #0
 80065e6:	d014      	beq.n	8006612 <i2c_lld_serve_event_interrupt+0x82>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 80065e8:	9b01      	ldr	r3, [sp, #4]
 80065ea:	8c1b      	ldrh	r3, [r3, #32]
 80065ec:	0a1b      	lsrs	r3, r3, #8
 80065ee:	b29b      	uxth	r3, r3
 80065f0:	f003 0306 	and.w	r3, r3, #6
 80065f4:	b29a      	uxth	r2, r3
 80065f6:	9b01      	ldr	r3, [sp, #4]
 80065f8:	8c1b      	ldrh	r3, [r3, #32]
 80065fa:	f003 0301 	and.w	r3, r3, #1
 80065fe:	b29b      	uxth	r3, r3
 8006600:	4313      	orrs	r3, r2
 8006602:	b29b      	uxth	r3, r3
 8006604:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8006608:	b29b      	uxth	r3, r3
 800660a:	461a      	mov	r2, r3
 800660c:	9b05      	ldr	r3, [sp, #20]
 800660e:	611a      	str	r2, [r3, #16]
    } else {
      dp->DR = i2cp->addr;
    }
    break;
 8006610:	e06d      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
    } else {
      dp->DR = i2cp->addr;
 8006612:	9b01      	ldr	r3, [sp, #4]
 8006614:	8c1b      	ldrh	r3, [r3, #32]
 8006616:	461a      	mov	r2, r3
 8006618:	9b05      	ldr	r3, [sp, #20]
 800661a:	611a      	str	r2, [r3, #16]
    }
    break;
 800661c:	e067      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800661e:	9b01      	ldr	r3, [sp, #4]
 8006620:	8c1b      	ldrh	r3, [r3, #32]
 8006622:	085b      	lsrs	r3, r3, #1
 8006624:	b29b      	uxth	r3, r3
 8006626:	b2da      	uxtb	r2, r3
 8006628:	9b05      	ldr	r3, [sp, #20]
 800662a:	611a      	str	r2, [r3, #16]
    break;
 800662c:	e05f      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800662e:	9b05      	ldr	r3, [sp, #20]
 8006630:	685b      	ldr	r3, [r3, #4]
 8006632:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006636:	9b05      	ldr	r3, [sp, #20]
 8006638:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmarx);
 800663a:	9b01      	ldr	r3, [sp, #4]
 800663c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800663e:	681b      	ldr	r3, [r3, #0]
 8006640:	9a01      	ldr	r2, [sp, #4]
 8006642:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006644:	6812      	ldr	r2, [r2, #0]
 8006646:	6812      	ldr	r2, [r2, #0]
 8006648:	f042 0201 	orr.w	r2, r2, #1
 800664c:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 800664e:	9b05      	ldr	r3, [sp, #20]
 8006650:	685b      	ldr	r3, [r3, #4]
 8006652:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8006656:	9b05      	ldr	r3, [sp, #20]
 8006658:	605a      	str	r2, [r3, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 800665a:	9b01      	ldr	r3, [sp, #4]
 800665c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800665e:	681b      	ldr	r3, [r3, #0]
 8006660:	685b      	ldr	r3, [r3, #4]
 8006662:	2b01      	cmp	r3, #1
 8006664:	d806      	bhi.n	8006674 <i2c_lld_serve_event_interrupt+0xe4>
      dp->CR1 &= ~I2C_CR1_ACK;
 8006666:	9b05      	ldr	r3, [sp, #20]
 8006668:	681b      	ldr	r3, [r3, #0]
 800666a:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800666e:	9b05      	ldr	r3, [sp, #20]
 8006670:	601a      	str	r2, [r3, #0]
    break;
 8006672:	e03c      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
 8006674:	e03b      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8006676:	9b05      	ldr	r3, [sp, #20]
 8006678:	685b      	ldr	r3, [r3, #4]
 800667a:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 800667e:	9b05      	ldr	r3, [sp, #20]
 8006680:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmatx);
 8006682:	9b01      	ldr	r3, [sp, #4]
 8006684:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006686:	681b      	ldr	r3, [r3, #0]
 8006688:	9a01      	ldr	r2, [sp, #4]
 800668a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800668c:	6812      	ldr	r2, [r2, #0]
 800668e:	6812      	ldr	r2, [r2, #0]
 8006690:	f042 0201 	orr.w	r2, r2, #1
 8006694:	601a      	str	r2, [r3, #0]
    break;
 8006696:	e02a      	b.n	80066ee <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8006698:	9b01      	ldr	r3, [sp, #4]
 800669a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800669c:	681b      	ldr	r3, [r3, #0]
 800669e:	685b      	ldr	r3, [r3, #4]
 80066a0:	2b00      	cmp	r3, #0
 80066a2:	d00d      	beq.n	80066c0 <i2c_lld_serve_event_interrupt+0x130>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 80066a4:	9b01      	ldr	r3, [sp, #4]
 80066a6:	8c1b      	ldrh	r3, [r3, #32]
 80066a8:	f043 0301 	orr.w	r3, r3, #1
 80066ac:	b29a      	uxth	r2, r3
 80066ae:	9b01      	ldr	r3, [sp, #4]
 80066b0:	841a      	strh	r2, [r3, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 80066b2:	9b05      	ldr	r3, [sp, #20]
 80066b4:	681b      	ldr	r3, [r3, #0]
 80066b6:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
 80066ba:	9b05      	ldr	r3, [sp, #20]
 80066bc:	601a      	str	r2, [r3, #0]
      return;
 80066be:	e01d      	b.n	80066fc <i2c_lld_serve_event_interrupt+0x16c>
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80066c0:	9b05      	ldr	r3, [sp, #20]
 80066c2:	685b      	ldr	r3, [r3, #4]
 80066c4:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 80066c8:	9b05      	ldr	r3, [sp, #20]
 80066ca:	605a      	str	r2, [r3, #4]
    dp->CR1 |= I2C_CR1_STOP;
 80066cc:	9b05      	ldr	r3, [sp, #20]
 80066ce:	681b      	ldr	r3, [r3, #0]
 80066d0:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 80066d4:	9b05      	ldr	r3, [sp, #20]
 80066d6:	601a      	str	r2, [r3, #0]
    _i2c_wakeup_isr(i2cp);
 80066d8:	f7ff fe02 	bl	80062e0 <osalSysLockFromISR>
 80066dc:	9b01      	ldr	r3, [sp, #4]
 80066de:	331c      	adds	r3, #28
 80066e0:	4618      	mov	r0, r3
 80066e2:	2100      	movs	r1, #0
 80066e4:	f7ff fe34 	bl	8006350 <osalThreadResumeI>
 80066e8:	f7ff fe02 	bl	80062f0 <osalSysUnlockFromISR>
    break;
 80066ec:	bf00      	nop
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80066ee:	9b03      	ldr	r3, [sp, #12]
 80066f0:	f003 030a 	and.w	r3, r3, #10
 80066f4:	2b00      	cmp	r3, #0
 80066f6:	d001      	beq.n	80066fc <i2c_lld_serve_event_interrupt+0x16c>
    (void)dp->SR2;
 80066f8:	9b05      	ldr	r3, [sp, #20]
 80066fa:	699b      	ldr	r3, [r3, #24]
}
 80066fc:	b007      	add	sp, #28
 80066fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006702:	bf00      	nop
 8006704:	00030008 	.word	0x00030008
 8006708:	00030001 	.word	0x00030001
 800670c:	00030002 	.word	0x00030002
 8006710:	00070082 	.word	0x00070082
 8006714:	00070084 	.word	0x00070084
 8006718:	f3af 8000 	nop.w
 800671c:	f3af 8000 	nop.w

08006720 <i2c_lld_serve_rx_end_irq>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8006720:	b500      	push	{lr}
 8006722:	b085      	sub	sp, #20
 8006724:	9001      	str	r0, [sp, #4]
 8006726:	9100      	str	r1, [sp, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 8006728:	9b01      	ldr	r3, [sp, #4]
 800672a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800672c:	9303      	str	r3, [sp, #12]

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800672e:	9b00      	ldr	r3, [sp, #0]
 8006730:	f003 030c 	and.w	r3, r3, #12
 8006734:	2b00      	cmp	r3, #0
 8006736:	d002      	beq.n	800673e <i2c_lld_serve_rx_end_irq+0x1e>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8006738:	481f      	ldr	r0, [pc, #124]	; (80067b8 <i2c_lld_serve_rx_end_irq+0x98>)
 800673a:	f7ff fdb1 	bl	80062a0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 800673e:	9b01      	ldr	r3, [sp, #4]
 8006740:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006742:	681b      	ldr	r3, [r3, #0]
 8006744:	9a01      	ldr	r2, [sp, #4]
 8006746:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006748:	6812      	ldr	r2, [r2, #0]
 800674a:	6812      	ldr	r2, [r2, #0]
 800674c:	f022 021f 	bic.w	r2, r2, #31
 8006750:	601a      	str	r2, [r3, #0]
 8006752:	bf00      	nop
 8006754:	9b01      	ldr	r3, [sp, #4]
 8006756:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006758:	681b      	ldr	r3, [r3, #0]
 800675a:	681b      	ldr	r3, [r3, #0]
 800675c:	f003 0301 	and.w	r3, r3, #1
 8006760:	2b00      	cmp	r3, #0
 8006762:	d1f7      	bne.n	8006754 <i2c_lld_serve_rx_end_irq+0x34>
 8006764:	9b01      	ldr	r3, [sp, #4]
 8006766:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006768:	685b      	ldr	r3, [r3, #4]
 800676a:	9a01      	ldr	r2, [sp, #4]
 800676c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800676e:	7a12      	ldrb	r2, [r2, #8]
 8006770:	4611      	mov	r1, r2
 8006772:	223d      	movs	r2, #61	; 0x3d
 8006774:	408a      	lsls	r2, r1
 8006776:	601a      	str	r2, [r3, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 8006778:	9b03      	ldr	r3, [sp, #12]
 800677a:	685b      	ldr	r3, [r3, #4]
 800677c:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8006780:	9b03      	ldr	r3, [sp, #12]
 8006782:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8006784:	9b03      	ldr	r3, [sp, #12]
 8006786:	681b      	ldr	r3, [r3, #0]
 8006788:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 800678c:	9b03      	ldr	r3, [sp, #12]
 800678e:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8006790:	9b03      	ldr	r3, [sp, #12]
 8006792:	681b      	ldr	r3, [r3, #0]
 8006794:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006798:	9b03      	ldr	r3, [sp, #12]
 800679a:	601a      	str	r2, [r3, #0]
  _i2c_wakeup_isr(i2cp);
 800679c:	f7ff fda0 	bl	80062e0 <osalSysLockFromISR>
 80067a0:	9b01      	ldr	r3, [sp, #4]
 80067a2:	331c      	adds	r3, #28
 80067a4:	4618      	mov	r0, r3
 80067a6:	2100      	movs	r1, #0
 80067a8:	f7ff fdd2 	bl	8006350 <osalThreadResumeI>
 80067ac:	f7ff fda0 	bl	80062f0 <osalSysUnlockFromISR>
}
 80067b0:	b005      	add	sp, #20
 80067b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80067b6:	bf00      	nop
 80067b8:	0800dfa0 	.word	0x0800dfa0
 80067bc:	f3af 8000 	nop.w

080067c0 <i2c_lld_serve_tx_end_irq>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80067c0:	b500      	push	{lr}
 80067c2:	b085      	sub	sp, #20
 80067c4:	9001      	str	r0, [sp, #4]
 80067c6:	9100      	str	r1, [sp, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 80067c8:	9b01      	ldr	r3, [sp, #4]
 80067ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80067cc:	9303      	str	r3, [sp, #12]

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80067ce:	9b00      	ldr	r3, [sp, #0]
 80067d0:	f003 030c 	and.w	r3, r3, #12
 80067d4:	2b00      	cmp	r3, #0
 80067d6:	d002      	beq.n	80067de <i2c_lld_serve_tx_end_irq+0x1e>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 80067d8:	4814      	ldr	r0, [pc, #80]	; (800682c <i2c_lld_serve_tx_end_irq+0x6c>)
 80067da:	f7ff fd61 	bl	80062a0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80067de:	9b01      	ldr	r3, [sp, #4]
 80067e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80067e2:	681b      	ldr	r3, [r3, #0]
 80067e4:	9a01      	ldr	r2, [sp, #4]
 80067e6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80067e8:	6812      	ldr	r2, [r2, #0]
 80067ea:	6812      	ldr	r2, [r2, #0]
 80067ec:	f022 021f 	bic.w	r2, r2, #31
 80067f0:	601a      	str	r2, [r3, #0]
 80067f2:	bf00      	nop
 80067f4:	9b01      	ldr	r3, [sp, #4]
 80067f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80067f8:	681b      	ldr	r3, [r3, #0]
 80067fa:	681b      	ldr	r3, [r3, #0]
 80067fc:	f003 0301 	and.w	r3, r3, #1
 8006800:	2b00      	cmp	r3, #0
 8006802:	d1f7      	bne.n	80067f4 <i2c_lld_serve_tx_end_irq+0x34>
 8006804:	9b01      	ldr	r3, [sp, #4]
 8006806:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006808:	685b      	ldr	r3, [r3, #4]
 800680a:	9a01      	ldr	r2, [sp, #4]
 800680c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800680e:	7a12      	ldrb	r2, [r2, #8]
 8006810:	4611      	mov	r1, r2
 8006812:	223d      	movs	r2, #61	; 0x3d
 8006814:	408a      	lsls	r2, r1
 8006816:	601a      	str	r2, [r3, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8006818:	9b03      	ldr	r3, [sp, #12]
 800681a:	685b      	ldr	r3, [r3, #4]
 800681c:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006820:	9b03      	ldr	r3, [sp, #12]
 8006822:	605a      	str	r2, [r3, #4]
}
 8006824:	b005      	add	sp, #20
 8006826:	f85d fb04 	ldr.w	pc, [sp], #4
 800682a:	bf00      	nop
 800682c:	0800dfa0 	.word	0x0800dfa0

08006830 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 8006830:	b500      	push	{lr}
 8006832:	b083      	sub	sp, #12
 8006834:	9001      	str	r0, [sp, #4]
 8006836:	460b      	mov	r3, r1
 8006838:	f8ad 3002 	strh.w	r3, [sp, #2]

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800683c:	9b01      	ldr	r3, [sp, #4]
 800683e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006840:	681b      	ldr	r3, [r3, #0]
 8006842:	9a01      	ldr	r2, [sp, #4]
 8006844:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006846:	6812      	ldr	r2, [r2, #0]
 8006848:	6812      	ldr	r2, [r2, #0]
 800684a:	f022 021f 	bic.w	r2, r2, #31
 800684e:	601a      	str	r2, [r3, #0]
 8006850:	bf00      	nop
 8006852:	9b01      	ldr	r3, [sp, #4]
 8006854:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006856:	681b      	ldr	r3, [r3, #0]
 8006858:	681b      	ldr	r3, [r3, #0]
 800685a:	f003 0301 	and.w	r3, r3, #1
 800685e:	2b00      	cmp	r3, #0
 8006860:	d1f7      	bne.n	8006852 <i2c_lld_serve_error_interrupt+0x22>
 8006862:	9b01      	ldr	r3, [sp, #4]
 8006864:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006866:	685b      	ldr	r3, [r3, #4]
 8006868:	9a01      	ldr	r2, [sp, #4]
 800686a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800686c:	7a12      	ldrb	r2, [r2, #8]
 800686e:	4611      	mov	r1, r2
 8006870:	223d      	movs	r2, #61	; 0x3d
 8006872:	408a      	lsls	r2, r1
 8006874:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmarx);
 8006876:	9b01      	ldr	r3, [sp, #4]
 8006878:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800687a:	681b      	ldr	r3, [r3, #0]
 800687c:	9a01      	ldr	r2, [sp, #4]
 800687e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006880:	6812      	ldr	r2, [r2, #0]
 8006882:	6812      	ldr	r2, [r2, #0]
 8006884:	f022 021f 	bic.w	r2, r2, #31
 8006888:	601a      	str	r2, [r3, #0]
 800688a:	bf00      	nop
 800688c:	9b01      	ldr	r3, [sp, #4]
 800688e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006890:	681b      	ldr	r3, [r3, #0]
 8006892:	681b      	ldr	r3, [r3, #0]
 8006894:	f003 0301 	and.w	r3, r3, #1
 8006898:	2b00      	cmp	r3, #0
 800689a:	d1f7      	bne.n	800688c <i2c_lld_serve_error_interrupt+0x5c>
 800689c:	9b01      	ldr	r3, [sp, #4]
 800689e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068a0:	685b      	ldr	r3, [r3, #4]
 80068a2:	9a01      	ldr	r2, [sp, #4]
 80068a4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80068a6:	7a12      	ldrb	r2, [r2, #8]
 80068a8:	4611      	mov	r1, r2
 80068aa:	223d      	movs	r2, #61	; 0x3d
 80068ac:	408a      	lsls	r2, r1
 80068ae:	601a      	str	r2, [r3, #0]

  i2cp->errors = I2C_NO_ERROR;
 80068b0:	9b01      	ldr	r3, [sp, #4]
 80068b2:	2200      	movs	r2, #0
 80068b4:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 80068b6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80068ba:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80068be:	2b00      	cmp	r3, #0
 80068c0:	d005      	beq.n	80068ce <i2c_lld_serve_error_interrupt+0x9e>
    i2cp->errors |= I2C_BUS_ERROR;
 80068c2:	9b01      	ldr	r3, [sp, #4]
 80068c4:	689b      	ldr	r3, [r3, #8]
 80068c6:	f043 0201 	orr.w	r2, r3, #1
 80068ca:	9b01      	ldr	r3, [sp, #4]
 80068cc:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 80068ce:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80068d2:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80068d6:	2b00      	cmp	r3, #0
 80068d8:	d005      	beq.n	80068e6 <i2c_lld_serve_error_interrupt+0xb6>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 80068da:	9b01      	ldr	r3, [sp, #4]
 80068dc:	689b      	ldr	r3, [r3, #8]
 80068de:	f043 0202 	orr.w	r2, r3, #2
 80068e2:	9b01      	ldr	r3, [sp, #4]
 80068e4:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 80068e6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80068ea:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80068ee:	2b00      	cmp	r3, #0
 80068f0:	d015      	beq.n	800691e <i2c_lld_serve_error_interrupt+0xee>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 80068f2:	9b01      	ldr	r3, [sp, #4]
 80068f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80068f6:	9a01      	ldr	r2, [sp, #4]
 80068f8:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80068fa:	6852      	ldr	r2, [r2, #4]
 80068fc:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8006900:	605a      	str	r2, [r3, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8006902:	9b01      	ldr	r3, [sp, #4]
 8006904:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006906:	9a01      	ldr	r2, [sp, #4]
 8006908:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800690a:	6812      	ldr	r2, [r2, #0]
 800690c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006910:	601a      	str	r2, [r3, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8006912:	9b01      	ldr	r3, [sp, #4]
 8006914:	689b      	ldr	r3, [r3, #8]
 8006916:	f043 0204 	orr.w	r2, r3, #4
 800691a:	9b01      	ldr	r3, [sp, #4]
 800691c:	609a      	str	r2, [r3, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800691e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006922:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8006926:	2b00      	cmp	r3, #0
 8006928:	d005      	beq.n	8006936 <i2c_lld_serve_error_interrupt+0x106>
    i2cp->errors |= I2C_OVERRUN;
 800692a:	9b01      	ldr	r3, [sp, #4]
 800692c:	689b      	ldr	r3, [r3, #8]
 800692e:	f043 0208 	orr.w	r2, r3, #8
 8006932:	9b01      	ldr	r3, [sp, #4]
 8006934:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8006936:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800693a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800693e:	2b00      	cmp	r3, #0
 8006940:	d005      	beq.n	800694e <i2c_lld_serve_error_interrupt+0x11e>
    i2cp->errors |= I2C_TIMEOUT;
 8006942:	9b01      	ldr	r3, [sp, #4]
 8006944:	689b      	ldr	r3, [r3, #8]
 8006946:	f043 0220 	orr.w	r2, r3, #32
 800694a:	9b01      	ldr	r3, [sp, #4]
 800694c:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800694e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006952:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8006956:	2b00      	cmp	r3, #0
 8006958:	d005      	beq.n	8006966 <i2c_lld_serve_error_interrupt+0x136>
    i2cp->errors |= I2C_PEC_ERROR;
 800695a:	9b01      	ldr	r3, [sp, #4]
 800695c:	689b      	ldr	r3, [r3, #8]
 800695e:	f043 0210 	orr.w	r2, r3, #16
 8006962:	9b01      	ldr	r3, [sp, #4]
 8006964:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8006966:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800696a:	b21b      	sxth	r3, r3
 800696c:	2b00      	cmp	r3, #0
 800696e:	da05      	bge.n	800697c <i2c_lld_serve_error_interrupt+0x14c>
    i2cp->errors |= I2C_SMB_ALERT;
 8006970:	9b01      	ldr	r3, [sp, #4]
 8006972:	689b      	ldr	r3, [r3, #8]
 8006974:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8006978:	9b01      	ldr	r3, [sp, #4]
 800697a:	609a      	str	r2, [r3, #8]

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 800697c:	9b01      	ldr	r3, [sp, #4]
 800697e:	689b      	ldr	r3, [r3, #8]
 8006980:	2b00      	cmp	r3, #0
 8006982:	d00a      	beq.n	800699a <i2c_lld_serve_error_interrupt+0x16a>
    _i2c_wakeup_error_isr(i2cp);
 8006984:	f7ff fcac 	bl	80062e0 <osalSysLockFromISR>
 8006988:	9b01      	ldr	r3, [sp, #4]
 800698a:	331c      	adds	r3, #28
 800698c:	4618      	mov	r0, r3
 800698e:	f06f 0101 	mvn.w	r1, #1
 8006992:	f7ff fcdd 	bl	8006350 <osalThreadResumeI>
 8006996:	f7ff fcab 	bl	80062f0 <osalSysUnlockFromISR>
}
 800699a:	b003      	add	sp, #12
 800699c:	f85d fb04 	ldr.w	pc, [sp], #4

080069a0 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 80069a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);
 80069a2:	4803      	ldr	r0, [pc, #12]	; (80069b0 <VectorBC+0x10>)
 80069a4:	f7ff fdf4 	bl	8006590 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 80069a8:	f7fd f9f2 	bl	8003d90 <_port_irq_epilogue>
}
 80069ac:	bd08      	pop	{r3, pc}
 80069ae:	bf00      	nop
 80069b0:	20000b78 	.word	0x20000b78
 80069b4:	f3af 8000 	nop.w
 80069b8:	f3af 8000 	nop.w
 80069bc:	f3af 8000 	nop.w

080069c0 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80069c0:	b500      	push	{lr}
 80069c2:	b083      	sub	sp, #12
  uint16_t sr = I2CD1.i2c->SR1;
 80069c4:	4b0b      	ldr	r3, [pc, #44]	; (80069f4 <VectorC0+0x34>)
 80069c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80069c8:	695b      	ldr	r3, [r3, #20]
 80069ca:	f8ad 3006 	strh.w	r3, [sp, #6]

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80069ce:	4b09      	ldr	r3, [pc, #36]	; (80069f4 <VectorC0+0x34>)
 80069d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80069d2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80069d6:	f402 425f 	and.w	r2, r2, #57088	; 0xdf00
 80069da:	43d2      	mvns	r2, r2
 80069dc:	615a      	str	r2, [r3, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 80069de:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80069e2:	4804      	ldr	r0, [pc, #16]	; (80069f4 <VectorC0+0x34>)
 80069e4:	4619      	mov	r1, r3
 80069e6:	f7ff ff23 	bl	8006830 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 80069ea:	f7fd f9d1 	bl	8003d90 <_port_irq_epilogue>
}
 80069ee:	b003      	add	sp, #12
 80069f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80069f4:	20000b78 	.word	0x20000b78
 80069f8:	f3af 8000 	nop.w
 80069fc:	f3af 8000 	nop.w

08006a00 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8006a00:	b508      	push	{r3, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 8006a02:	4808      	ldr	r0, [pc, #32]	; (8006a24 <i2c_lld_init+0x24>)
 8006a04:	f7fe fb1c 	bl	8005040 <i2cObjectInit>
  I2CD1.thread = NULL;
 8006a08:	4b06      	ldr	r3, [pc, #24]	; (8006a24 <i2c_lld_init+0x24>)
 8006a0a:	2200      	movs	r2, #0
 8006a0c:	61da      	str	r2, [r3, #28]
  I2CD1.i2c    = I2C1;
 8006a0e:	4b05      	ldr	r3, [pc, #20]	; (8006a24 <i2c_lld_init+0x24>)
 8006a10:	4a05      	ldr	r2, [pc, #20]	; (8006a28 <i2c_lld_init+0x28>)
 8006a12:	635a      	str	r2, [r3, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8006a14:	4b03      	ldr	r3, [pc, #12]	; (8006a24 <i2c_lld_init+0x24>)
 8006a16:	4a05      	ldr	r2, [pc, #20]	; (8006a2c <i2c_lld_init+0x2c>)
 8006a18:	62da      	str	r2, [r3, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8006a1a:	4b02      	ldr	r3, [pc, #8]	; (8006a24 <i2c_lld_init+0x24>)
 8006a1c:	4a04      	ldr	r2, [pc, #16]	; (8006a30 <i2c_lld_init+0x30>)
 8006a1e:	631a      	str	r2, [r3, #48]	; 0x30
  I2CD3.thread = NULL;
  I2CD3.i2c    = I2C3;
  I2CD3.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C3_RX_DMA_STREAM);
  I2CD3.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C3_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C3 */
}
 8006a20:	bd08      	pop	{r3, pc}
 8006a22:	bf00      	nop
 8006a24:	20000b78 	.word	0x20000b78
 8006a28:	40005400 	.word	0x40005400
 8006a2c:	0800dee0 	.word	0x0800dee0
 8006a30:	0800df28 	.word	0x0800df28
 8006a34:	f3af 8000 	nop.w
 8006a38:	f3af 8000 	nop.w
 8006a3c:	f3af 8000 	nop.w

08006a40 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 8006a40:	b500      	push	{lr}
 8006a42:	b085      	sub	sp, #20
 8006a44:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006a46:	9b01      	ldr	r3, [sp, #4]
 8006a48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a4a:	9303      	str	r3, [sp, #12]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8006a4c:	9b01      	ldr	r3, [sp, #4]
 8006a4e:	781b      	ldrb	r3, [r3, #0]
 8006a50:	2b01      	cmp	r3, #1
 8006a52:	d148      	bne.n	8006ae6 <i2c_lld_start+0xa6>

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8006a54:	9b01      	ldr	r3, [sp, #4]
 8006a56:	f240 4256 	movw	r2, #1110	; 0x456
 8006a5a:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8006a5c:	9b01      	ldr	r3, [sp, #4]
 8006a5e:	f240 4216 	movw	r2, #1046	; 0x416
 8006a62:	625a      	str	r2, [r3, #36]	; 0x24
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_P2M;

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8006a64:	9b01      	ldr	r3, [sp, #4]
 8006a66:	4a33      	ldr	r2, [pc, #204]	; (8006b34 <i2c_lld_start+0xf4>)
 8006a68:	4293      	cmp	r3, r2
 8006a6a:	d13c      	bne.n	8006ae6 <i2c_lld_start+0xa6>
      bool b;

      rccResetI2C1();
 8006a6c:	4a32      	ldr	r2, [pc, #200]	; (8006b38 <i2c_lld_start+0xf8>)
 8006a6e:	4b32      	ldr	r3, [pc, #200]	; (8006b38 <i2c_lld_start+0xf8>)
 8006a70:	6a1b      	ldr	r3, [r3, #32]
 8006a72:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8006a76:	6213      	str	r3, [r2, #32]
 8006a78:	4b2f      	ldr	r3, [pc, #188]	; (8006b38 <i2c_lld_start+0xf8>)
 8006a7a:	2200      	movs	r2, #0
 8006a7c:	621a      	str	r2, [r3, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 8006a7e:	9b01      	ldr	r3, [sp, #4]
 8006a80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006a82:	4618      	mov	r0, r3
 8006a84:	2105      	movs	r1, #5
 8006a86:	4a2d      	ldr	r2, [pc, #180]	; (8006b3c <i2c_lld_start+0xfc>)
 8006a88:	9b01      	ldr	r3, [sp, #4]
 8006a8a:	f7ff f9a9 	bl	8005de0 <dmaStreamAllocate>
 8006a8e:	4603      	mov	r3, r0
 8006a90:	f88d 300b 	strb.w	r3, [sp, #11]
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 8006a94:	9b01      	ldr	r3, [sp, #4]
 8006a96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006a98:	4618      	mov	r0, r3
 8006a9a:	2105      	movs	r1, #5
 8006a9c:	4a28      	ldr	r2, [pc, #160]	; (8006b40 <i2c_lld_start+0x100>)
 8006a9e:	9b01      	ldr	r3, [sp, #4]
 8006aa0:	f7ff f99e 	bl	8005de0 <dmaStreamAllocate>
 8006aa4:	4603      	mov	r3, r0
 8006aa6:	f88d 300b 	strb.w	r3, [sp, #11]
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8006aaa:	4a23      	ldr	r2, [pc, #140]	; (8006b38 <i2c_lld_start+0xf8>)
 8006aac:	4b22      	ldr	r3, [pc, #136]	; (8006b38 <i2c_lld_start+0xf8>)
 8006aae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006ab0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8006ab4:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 8006ab6:	201f      	movs	r0, #31
 8006ab8:	2105      	movs	r1, #5
 8006aba:	f7fe fdd9 	bl	8005670 <nvicEnableVector>
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 8006abe:	2020      	movs	r0, #32
 8006ac0:	2105      	movs	r1, #5
 8006ac2:	f7fe fdd5 	bl	8005670 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8006ac6:	9b01      	ldr	r3, [sp, #4]
 8006ac8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006aca:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006ace:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8006ad2:	9a01      	ldr	r2, [sp, #4]
 8006ad4:	6253      	str	r3, [r2, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8006ad6:	9b01      	ldr	r3, [sp, #4]
 8006ad8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006ada:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006ade:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8006ae2:	9a01      	ldr	r2, [sp, #4]
 8006ae4:	6293      	str	r3, [r2, #40]	; 0x28
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8006ae6:	9b01      	ldr	r3, [sp, #4]
 8006ae8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006aea:	681b      	ldr	r3, [r3, #0]
 8006aec:	9a03      	ldr	r2, [sp, #12]
 8006aee:	3210      	adds	r2, #16
 8006af0:	609a      	str	r2, [r3, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8006af2:	9b01      	ldr	r3, [sp, #4]
 8006af4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006af6:	681b      	ldr	r3, [r3, #0]
 8006af8:	9a03      	ldr	r2, [sp, #12]
 8006afa:	3210      	adds	r2, #16
 8006afc:	609a      	str	r2, [r3, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8006afe:	9b03      	ldr	r3, [sp, #12]
 8006b00:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006b04:	601a      	str	r2, [r3, #0]
  dp->CR1 = 0;
 8006b06:	9b03      	ldr	r3, [sp, #12]
 8006b08:	2200      	movs	r2, #0
 8006b0a:	601a      	str	r2, [r3, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8006b0c:	9b03      	ldr	r3, [sp, #12]
 8006b0e:	f44f 6210 	mov.w	r2, #2304	; 0x900
 8006b12:	605a      	str	r2, [r3, #4]

  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
 8006b14:	9801      	ldr	r0, [sp, #4]
 8006b16:	f7ff fc7b 	bl	8006410 <i2c_lld_set_clock>
  i2c_lld_set_opmode(i2cp);
 8006b1a:	9801      	ldr	r0, [sp, #4]
 8006b1c:	f7ff fd00 	bl	8006520 <i2c_lld_set_opmode>

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8006b20:	9b03      	ldr	r3, [sp, #12]
 8006b22:	681b      	ldr	r3, [r3, #0]
 8006b24:	f043 0201 	orr.w	r2, r3, #1
 8006b28:	9b03      	ldr	r3, [sp, #12]
 8006b2a:	601a      	str	r2, [r3, #0]
}
 8006b2c:	b005      	add	sp, #20
 8006b2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006b32:	bf00      	nop
 8006b34:	20000b78 	.word	0x20000b78
 8006b38:	40023800 	.word	0x40023800
 8006b3c:	08006721 	.word	0x08006721
 8006b40:	080067c1 	.word	0x080067c1
 8006b44:	f3af 8000 	nop.w
 8006b48:	f3af 8000 	nop.w
 8006b4c:	f3af 8000 	nop.w

08006b50 <i2c_lld_stop>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {
 8006b50:	b500      	push	{lr}
 8006b52:	b083      	sub	sp, #12
 8006b54:	9001      	str	r0, [sp, #4]

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8006b56:	9b01      	ldr	r3, [sp, #4]
 8006b58:	781b      	ldrb	r3, [r3, #0]
 8006b5a:	2b01      	cmp	r3, #1
 8006b5c:	d01c      	beq.n	8006b98 <i2c_lld_stop+0x48>

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
 8006b5e:	9801      	ldr	r0, [sp, #4]
 8006b60:	f7ff fc06 	bl	8006370 <i2c_lld_abort_operation>
    dmaStreamRelease(i2cp->dmatx);
 8006b64:	9b01      	ldr	r3, [sp, #4]
 8006b66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006b68:	4618      	mov	r0, r3
 8006b6a:	f7ff f9b1 	bl	8005ed0 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 8006b6e:	9b01      	ldr	r3, [sp, #4]
 8006b70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b72:	4618      	mov	r0, r3
 8006b74:	f7ff f9ac 	bl	8005ed0 <dmaStreamRelease>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8006b78:	9b01      	ldr	r3, [sp, #4]
 8006b7a:	4a09      	ldr	r2, [pc, #36]	; (8006ba0 <i2c_lld_stop+0x50>)
 8006b7c:	4293      	cmp	r3, r2
 8006b7e:	d10b      	bne.n	8006b98 <i2c_lld_stop+0x48>
      nvicDisableVector(I2C1_EV_IRQn);
 8006b80:	201f      	movs	r0, #31
 8006b82:	f7fe fda5 	bl	80056d0 <nvicDisableVector>
      nvicDisableVector(I2C1_ER_IRQn);
 8006b86:	2020      	movs	r0, #32
 8006b88:	f7fe fda2 	bl	80056d0 <nvicDisableVector>
      rccDisableI2C1(FALSE);
 8006b8c:	4a05      	ldr	r2, [pc, #20]	; (8006ba4 <i2c_lld_stop+0x54>)
 8006b8e:	4b05      	ldr	r3, [pc, #20]	; (8006ba4 <i2c_lld_stop+0x54>)
 8006b90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006b92:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8006b96:	6413      	str	r3, [r2, #64]	; 0x40
      nvicDisableVector(I2C3_ER_IRQn);
      rccDisableI2C3(FALSE);
    }
#endif
  }
}
 8006b98:	b003      	add	sp, #12
 8006b9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006b9e:	bf00      	nop
 8006ba0:	20000b78 	.word	0x20000b78
 8006ba4:	40023800 	.word	0x40023800
 8006ba8:	f3af 8000 	nop.w
 8006bac:	f3af 8000 	nop.w

08006bb0 <i2c_lld_master_receive_timeout>:
 *
 * @notapi
 */
msg_t i2c_lld_master_receive_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                     uint8_t *rxbuf, size_t rxbytes,
                                     systime_t timeout) {
 8006bb0:	b500      	push	{lr}
 8006bb2:	b089      	sub	sp, #36	; 0x24
 8006bb4:	9003      	str	r0, [sp, #12]
 8006bb6:	9201      	str	r2, [sp, #4]
 8006bb8:	9300      	str	r3, [sp, #0]
 8006bba:	460b      	mov	r3, r1
 8006bbc:	f8ad 300a 	strh.w	r3, [sp, #10]
  I2C_TypeDef *dp = i2cp->i2c;
 8006bc0:	9b03      	ldr	r3, [sp, #12]
 8006bc2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006bc4:	9307      	str	r3, [sp, #28]
#if defined(STM32F1XX_I2C)
  osalDbgCheck(rxbytes > 1);
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8006bc6:	9b03      	ldr	r3, [sp, #12]
 8006bc8:	2200      	movs	r2, #0
 8006bca:	609a      	str	r2, [r3, #8]

  /* Initializes driver fields, LSB = 1 -> receive.*/
  i2cp->addr = (addr << 1) | 0x01;
 8006bcc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8006bd0:	005b      	lsls	r3, r3, #1
 8006bd2:	b29b      	uxth	r3, r3
 8006bd4:	f043 0301 	orr.w	r3, r3, #1
 8006bd8:	b29b      	uxth	r3, r3
 8006bda:	b29a      	uxth	r2, r3
 8006bdc:	9b03      	ldr	r3, [sp, #12]
 8006bde:	841a      	strh	r2, [r3, #32]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();
 8006be0:	f7ff fb76 	bl	80062d0 <osalSysUnlock>

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8006be4:	9b03      	ldr	r3, [sp, #12]
 8006be6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006be8:	681b      	ldr	r3, [r3, #0]
 8006bea:	9a03      	ldr	r2, [sp, #12]
 8006bec:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006bee:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8006bf0:	9b03      	ldr	r3, [sp, #12]
 8006bf2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006bf4:	681b      	ldr	r3, [r3, #0]
 8006bf6:	9a01      	ldr	r2, [sp, #4]
 8006bf8:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8006bfa:	9b03      	ldr	r3, [sp, #12]
 8006bfc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006bfe:	681b      	ldr	r3, [r3, #0]
 8006c00:	9a00      	ldr	r2, [sp, #0]
 8006c02:	605a      	str	r2, [r3, #4]

  /* Calculating the time window for the timeout on the busy bus condition.*/
  start = osalOsGetSystemTimeX();
 8006c04:	f7ff fb7c 	bl	8006300 <osalOsGetSystemTimeX>
 8006c08:	9006      	str	r0, [sp, #24]
  end = start + OSAL_MS2ST(STM32_I2C_BUSY_TIMEOUT);
 8006c0a:	9b06      	ldr	r3, [sp, #24]
 8006c0c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8006c10:	9305      	str	r3, [sp, #20]

  /* Waits until BUSY flag is reset or, alternatively, for a timeout
     condition.*/
  while (true) {
    osalSysLock();
 8006c12:	f7ff fb55 	bl	80062c0 <osalSysLock>

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8006c16:	9b07      	ldr	r3, [sp, #28]
 8006c18:	699b      	ldr	r3, [r3, #24]
 8006c1a:	f003 0302 	and.w	r3, r3, #2
 8006c1e:	2b00      	cmp	r3, #0
 8006c20:	d11a      	bne.n	8006c58 <i2c_lld_master_receive_timeout+0xa8>
 8006c22:	9b07      	ldr	r3, [sp, #28]
 8006c24:	681b      	ldr	r3, [r3, #0]
 8006c26:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006c2a:	2b00      	cmp	r3, #0
 8006c2c:	d114      	bne.n	8006c58 <i2c_lld_master_receive_timeout+0xa8>
      break;
 8006c2e:	bf00      	nop

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8006c30:	9b07      	ldr	r3, [sp, #28]
 8006c32:	685b      	ldr	r3, [r3, #4]
 8006c34:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006c38:	9b07      	ldr	r3, [sp, #28]
 8006c3a:	605a      	str	r2, [r3, #4]
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8006c3c:	9b07      	ldr	r3, [sp, #28]
 8006c3e:	681b      	ldr	r3, [r3, #0]
 8006c40:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
 8006c44:	9b07      	ldr	r3, [sp, #28]
 8006c46:	601a      	str	r2, [r3, #0]

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 8006c48:	9b03      	ldr	r3, [sp, #12]
 8006c4a:	331c      	adds	r3, #28
 8006c4c:	4618      	mov	r0, r3
 8006c4e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006c50:	f7ff fb6e 	bl	8006330 <osalThreadSuspendTimeoutS>
 8006c54:	4603      	mov	r3, r0
 8006c56:	e013      	b.n	8006c80 <i2c_lld_master_receive_timeout+0xd0>
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8006c58:	f7ff fb52 	bl	8006300 <osalOsGetSystemTimeX>
 8006c5c:	4603      	mov	r3, r0
 8006c5e:	4618      	mov	r0, r3
 8006c60:	9906      	ldr	r1, [sp, #24]
 8006c62:	9a05      	ldr	r2, [sp, #20]
 8006c64:	f7ff fb54 	bl	8006310 <osalOsIsTimeWithinX>
 8006c68:	4603      	mov	r3, r0
 8006c6a:	f083 0301 	eor.w	r3, r3, #1
 8006c6e:	b2db      	uxtb	r3, r3
 8006c70:	2b00      	cmp	r3, #0
 8006c72:	d002      	beq.n	8006c7a <i2c_lld_master_receive_timeout+0xca>
      return MSG_TIMEOUT;
 8006c74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006c78:	e002      	b.n	8006c80 <i2c_lld_master_receive_timeout+0xd0>

    osalSysUnlock();
 8006c7a:	f7ff fb29 	bl	80062d0 <osalSysUnlock>
  }
 8006c7e:	e7c8      	b.n	8006c12 <i2c_lld_master_receive_timeout+0x62>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 8006c80:	4618      	mov	r0, r3
 8006c82:	b009      	add	sp, #36	; 0x24
 8006c84:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c88:	f3af 8000 	nop.w
 8006c8c:	f3af 8000 	nop.w

08006c90 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8006c90:	b500      	push	{lr}
 8006c92:	b089      	sub	sp, #36	; 0x24
 8006c94:	9003      	str	r0, [sp, #12]
 8006c96:	9201      	str	r2, [sp, #4]
 8006c98:	9300      	str	r3, [sp, #0]
 8006c9a:	460b      	mov	r3, r1
 8006c9c:	f8ad 300a 	strh.w	r3, [sp, #10]
  I2C_TypeDef *dp = i2cp->i2c;
 8006ca0:	9b03      	ldr	r3, [sp, #12]
 8006ca2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ca4:	9307      	str	r3, [sp, #28]
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8006ca6:	9b03      	ldr	r3, [sp, #12]
 8006ca8:	2200      	movs	r2, #0
 8006caa:	609a      	str	r2, [r3, #8]

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8006cac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8006cb0:	005b      	lsls	r3, r3, #1
 8006cb2:	b29a      	uxth	r2, r3
 8006cb4:	9b03      	ldr	r3, [sp, #12]
 8006cb6:	841a      	strh	r2, [r3, #32]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();
 8006cb8:	f7ff fb0a 	bl	80062d0 <osalSysUnlock>

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8006cbc:	9b03      	ldr	r3, [sp, #12]
 8006cbe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006cc0:	681b      	ldr	r3, [r3, #0]
 8006cc2:	9a03      	ldr	r2, [sp, #12]
 8006cc4:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8006cc6:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8006cc8:	9b03      	ldr	r3, [sp, #12]
 8006cca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006ccc:	681b      	ldr	r3, [r3, #0]
 8006cce:	9a01      	ldr	r2, [sp, #4]
 8006cd0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8006cd2:	9b03      	ldr	r3, [sp, #12]
 8006cd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006cd6:	681b      	ldr	r3, [r3, #0]
 8006cd8:	9a00      	ldr	r2, [sp, #0]
 8006cda:	605a      	str	r2, [r3, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8006cdc:	9b03      	ldr	r3, [sp, #12]
 8006cde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006ce0:	681b      	ldr	r3, [r3, #0]
 8006ce2:	9a03      	ldr	r2, [sp, #12]
 8006ce4:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006ce6:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8006ce8:	9b03      	ldr	r3, [sp, #12]
 8006cea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006cec:	681b      	ldr	r3, [r3, #0]
 8006cee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006cf0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8006cf2:	9b03      	ldr	r3, [sp, #12]
 8006cf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006cf6:	681b      	ldr	r3, [r3, #0]
 8006cf8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8006cfa:	605a      	str	r2, [r3, #4]

  /* Calculating the time window for the timeout on the busy bus condition.*/
  start = osalOsGetSystemTimeX();
 8006cfc:	f7ff fb00 	bl	8006300 <osalOsGetSystemTimeX>
 8006d00:	9006      	str	r0, [sp, #24]
  end = start + OSAL_MS2ST(STM32_I2C_BUSY_TIMEOUT);
 8006d02:	9b06      	ldr	r3, [sp, #24]
 8006d04:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8006d08:	9305      	str	r3, [sp, #20]

  /* Waits until BUSY flag is reset or, alternatively, for a timeout
     condition.*/
  while (true) {
    osalSysLock();
 8006d0a:	f7ff fad9 	bl	80062c0 <osalSysLock>

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8006d0e:	9b07      	ldr	r3, [sp, #28]
 8006d10:	699b      	ldr	r3, [r3, #24]
 8006d12:	f003 0302 	and.w	r3, r3, #2
 8006d16:	2b00      	cmp	r3, #0
 8006d18:	d11a      	bne.n	8006d50 <i2c_lld_master_transmit_timeout+0xc0>
 8006d1a:	9b07      	ldr	r3, [sp, #28]
 8006d1c:	681b      	ldr	r3, [r3, #0]
 8006d1e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006d22:	2b00      	cmp	r3, #0
 8006d24:	d114      	bne.n	8006d50 <i2c_lld_master_transmit_timeout+0xc0>
      break;
 8006d26:	bf00      	nop

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8006d28:	9b07      	ldr	r3, [sp, #28]
 8006d2a:	685b      	ldr	r3, [r3, #4]
 8006d2c:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006d30:	9b07      	ldr	r3, [sp, #28]
 8006d32:	605a      	str	r2, [r3, #4]
  dp->CR1 |= I2C_CR1_START;
 8006d34:	9b07      	ldr	r3, [sp, #28]
 8006d36:	681b      	ldr	r3, [r3, #0]
 8006d38:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8006d3c:	9b07      	ldr	r3, [sp, #28]
 8006d3e:	601a      	str	r2, [r3, #0]

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 8006d40:	9b03      	ldr	r3, [sp, #12]
 8006d42:	331c      	adds	r3, #28
 8006d44:	4618      	mov	r0, r3
 8006d46:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006d48:	f7ff faf2 	bl	8006330 <osalThreadSuspendTimeoutS>
 8006d4c:	4603      	mov	r3, r0
 8006d4e:	e013      	b.n	8006d78 <i2c_lld_master_transmit_timeout+0xe8>
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8006d50:	f7ff fad6 	bl	8006300 <osalOsGetSystemTimeX>
 8006d54:	4603      	mov	r3, r0
 8006d56:	4618      	mov	r0, r3
 8006d58:	9906      	ldr	r1, [sp, #24]
 8006d5a:	9a05      	ldr	r2, [sp, #20]
 8006d5c:	f7ff fad8 	bl	8006310 <osalOsIsTimeWithinX>
 8006d60:	4603      	mov	r3, r0
 8006d62:	f083 0301 	eor.w	r3, r3, #1
 8006d66:	b2db      	uxtb	r3, r3
 8006d68:	2b00      	cmp	r3, #0
 8006d6a:	d002      	beq.n	8006d72 <i2c_lld_master_transmit_timeout+0xe2>
      return MSG_TIMEOUT;
 8006d6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006d70:	e002      	b.n	8006d78 <i2c_lld_master_transmit_timeout+0xe8>

    osalSysUnlock();
 8006d72:	f7ff faad 	bl	80062d0 <osalSysUnlock>
  }
 8006d76:	e7c8      	b.n	8006d0a <i2c_lld_master_transmit_timeout+0x7a>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 8006d78:	4618      	mov	r0, r3
 8006d7a:	b009      	add	sp, #36	; 0x24
 8006d7c:	f85d fb04 	ldr.w	pc, [sp], #4

08006d80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006d80:	b082      	sub	sp, #8
 8006d82:	2320      	movs	r3, #32
 8006d84:	9301      	str	r3, [sp, #4]
 8006d86:	9b01      	ldr	r3, [sp, #4]
 8006d88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006d8c:	b002      	add	sp, #8
 8006d8e:	4770      	bx	lr

08006d90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006d90:	b082      	sub	sp, #8
 8006d92:	2300      	movs	r3, #0
 8006d94:	9301      	str	r3, [sp, #4]
 8006d96:	9b01      	ldr	r3, [sp, #4]
 8006d98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006d9c:	b002      	add	sp, #8
 8006d9e:	4770      	bx	lr

08006da0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006da0:	b508      	push	{r3, lr}

  port_lock();
 8006da2:	f7ff ffed 	bl	8006d80 <port_lock>
}
 8006da6:	bd08      	pop	{r3, pc}
 8006da8:	f3af 8000 	nop.w
 8006dac:	f3af 8000 	nop.w

08006db0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006db0:	b508      	push	{r3, lr}

  port_unlock();
 8006db2:	f7ff ffed 	bl	8006d90 <port_unlock>
}
 8006db6:	bd08      	pop	{r3, pc}
 8006db8:	f3af 8000 	nop.w
 8006dbc:	f3af 8000 	nop.w

08006dc0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006dc0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006dc2:	f7ff ffed 	bl	8006da0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006dc6:	bd08      	pop	{r3, pc}
 8006dc8:	f3af 8000 	nop.w
 8006dcc:	f3af 8000 	nop.w

08006dd0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006dd0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006dd2:	f7ff ffed 	bl	8006db0 <port_unlock_from_isr>
}
 8006dd6:	bd08      	pop	{r3, pc}
 8006dd8:	f3af 8000 	nop.w
 8006ddc:	f3af 8000 	nop.w

08006de0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8006de0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8006de2:	f7ff ffed 	bl	8006dc0 <chSysLockFromISR>
}
 8006de6:	bd08      	pop	{r3, pc}
 8006de8:	f3af 8000 	nop.w
 8006dec:	f3af 8000 	nop.w

08006df0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8006df0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8006df2:	f7ff ffed 	bl	8006dd0 <chSysUnlockFromISR>
}
 8006df6:	bd08      	pop	{r3, pc}
 8006df8:	f3af 8000 	nop.w
 8006dfc:	f3af 8000 	nop.w

08006e00 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8006e00:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8006e02:	f7f9 fd35 	bl	8000870 <chSysTimerHandlerI>
}
 8006e06:	bd08      	pop	{r3, pc}
 8006e08:	f3af 8000 	nop.w
 8006e0c:	f3af 8000 	nop.w

08006e10 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8006e10:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8006e12:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e16:	691b      	ldr	r3, [r3, #16]
 8006e18:	f003 0302 	and.w	r3, r3, #2
 8006e1c:	2b00      	cmp	r3, #0
 8006e1e:	d009      	beq.n	8006e34 <VectorB0+0x24>
    STM32_ST_TIM->SR = 0U;
 8006e20:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e24:	2200      	movs	r2, #0
 8006e26:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8006e28:	f7ff ffda 	bl	8006de0 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 8006e2c:	f7ff ffe8 	bl	8006e00 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8006e30:	f7ff ffde 	bl	8006df0 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
 8006e34:	f7fc ffac 	bl	8003d90 <_port_irq_epilogue>
}
 8006e38:	bd08      	pop	{r3, pc}
 8006e3a:	bf00      	nop
 8006e3c:	f3af 8000 	nop.w

08006e40 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8006e40:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8006e42:	4a19      	ldr	r2, [pc, #100]	; (8006ea8 <st_lld_init+0x68>)
 8006e44:	4b18      	ldr	r3, [pc, #96]	; (8006ea8 <st_lld_init+0x68>)
 8006e46:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006e48:	f043 0301 	orr.w	r3, r3, #1
 8006e4c:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006e4e:	4a17      	ldr	r2, [pc, #92]	; (8006eac <st_lld_init+0x6c>)
 8006e50:	4b16      	ldr	r3, [pc, #88]	; (8006eac <st_lld_init+0x6c>)
 8006e52:	689b      	ldr	r3, [r3, #8]
 8006e54:	f043 0301 	orr.w	r3, r3, #1
 8006e58:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006e5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e5e:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8006e62:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006e64:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e68:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006e6c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8006e6e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e72:	2200      	movs	r2, #0
 8006e74:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8006e76:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e7a:	2200      	movs	r2, #0
 8006e7c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8006e7e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e82:	2200      	movs	r2, #0
 8006e84:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8006e86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e8a:	2200      	movs	r2, #0
 8006e8c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8006e8e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e92:	2201      	movs	r2, #1
 8006e94:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8006e96:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006e9a:	2201      	movs	r2, #1
 8006e9c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8006e9e:	201c      	movs	r0, #28
 8006ea0:	2108      	movs	r1, #8
 8006ea2:	f7fe fbe5 	bl	8005670 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8006ea6:	bd08      	pop	{r3, pc}
 8006ea8:	40023800 	.word	0x40023800
 8006eac:	e0042000 	.word	0xe0042000

08006eb0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006eb0:	b082      	sub	sp, #8
 8006eb2:	2320      	movs	r3, #32
 8006eb4:	9301      	str	r3, [sp, #4]
 8006eb6:	9b01      	ldr	r3, [sp, #4]
 8006eb8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006ebc:	b002      	add	sp, #8
 8006ebe:	4770      	bx	lr

08006ec0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006ec0:	b082      	sub	sp, #8
 8006ec2:	2300      	movs	r3, #0
 8006ec4:	9301      	str	r3, [sp, #4]
 8006ec6:	9b01      	ldr	r3, [sp, #4]
 8006ec8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006ecc:	b002      	add	sp, #8
 8006ece:	4770      	bx	lr

08006ed0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006ed0:	b508      	push	{r3, lr}

  port_lock();
 8006ed2:	f7ff ffed 	bl	8006eb0 <port_lock>
}
 8006ed6:	bd08      	pop	{r3, pc}
 8006ed8:	f3af 8000 	nop.w
 8006edc:	f3af 8000 	nop.w

08006ee0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006ee0:	b508      	push	{r3, lr}

  port_unlock();
 8006ee2:	f7ff ffed 	bl	8006ec0 <port_unlock>
}
 8006ee6:	bd08      	pop	{r3, pc}
 8006ee8:	f3af 8000 	nop.w
 8006eec:	f3af 8000 	nop.w

08006ef0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006ef0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006ef2:	f7ff ffed 	bl	8006ed0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006ef6:	bd08      	pop	{r3, pc}
 8006ef8:	f3af 8000 	nop.w
 8006efc:	f3af 8000 	nop.w

08006f00 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006f00:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006f02:	f7ff ffed 	bl	8006ee0 <port_unlock_from_isr>
}
 8006f06:	bd08      	pop	{r3, pc}
 8006f08:	f3af 8000 	nop.w
 8006f0c:	f3af 8000 	nop.w

08006f10 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8006f10:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8006f12:	f7ff ffed 	bl	8006ef0 <chSysLockFromISR>
}
 8006f16:	bd08      	pop	{r3, pc}
 8006f18:	f3af 8000 	nop.w
 8006f1c:	f3af 8000 	nop.w

08006f20 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8006f20:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8006f22:	f7ff ffed 	bl	8006f00 <chSysUnlockFromISR>
}
 8006f26:	bd08      	pop	{r3, pc}
 8006f28:	f3af 8000 	nop.w
 8006f2c:	f3af 8000 	nop.w

08006f30 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8006f30:	b500      	push	{lr}
 8006f32:	b083      	sub	sp, #12
 8006f34:	9001      	str	r0, [sp, #4]
 8006f36:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8006f38:	9801      	ldr	r0, [sp, #4]
 8006f3a:	9900      	ldr	r1, [sp, #0]
 8006f3c:	f7fb fd18 	bl	8002970 <chEvtBroadcastFlagsI>
}
 8006f40:	b003      	add	sp, #12
 8006f42:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f46:	bf00      	nop
 8006f48:	f3af 8000 	nop.w
 8006f4c:	f3af 8000 	nop.w

08006f50 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8006f50:	b084      	sub	sp, #16
 8006f52:	9001      	str	r0, [sp, #4]
 8006f54:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8006f56:	9b01      	ldr	r3, [sp, #4]
 8006f58:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006f5a:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8006f5c:	9b01      	ldr	r3, [sp, #4]
 8006f5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006f60:	4a24      	ldr	r2, [pc, #144]	; (8006ff4 <usart_init+0xa4>)
 8006f62:	4293      	cmp	r3, r2
 8006f64:	d004      	beq.n	8006f70 <usart_init+0x20>
 8006f66:	9b01      	ldr	r3, [sp, #4]
 8006f68:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006f6a:	4a23      	ldr	r2, [pc, #140]	; (8006ff8 <usart_init+0xa8>)
 8006f6c:	4293      	cmp	r3, r2
 8006f6e:	d107      	bne.n	8006f80 <usart_init+0x30>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8006f70:	9b00      	ldr	r3, [sp, #0]
 8006f72:	681b      	ldr	r3, [r3, #0]
 8006f74:	4a21      	ldr	r2, [pc, #132]	; (8006ffc <usart_init+0xac>)
 8006f76:	fbb2 f2f3 	udiv	r2, r2, r3
 8006f7a:	9b03      	ldr	r3, [sp, #12]
 8006f7c:	609a      	str	r2, [r3, #8]
 8006f7e:	e006      	b.n	8006f8e <usart_init+0x3e>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8006f80:	9b00      	ldr	r3, [sp, #0]
 8006f82:	681b      	ldr	r3, [r3, #0]
 8006f84:	4a1e      	ldr	r2, [pc, #120]	; (8007000 <usart_init+0xb0>)
 8006f86:	fbb2 f2f3 	udiv	r2, r2, r3
 8006f8a:	9b03      	ldr	r3, [sp, #12]
 8006f8c:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8006f8e:	9b00      	ldr	r3, [sp, #0]
 8006f90:	88db      	ldrh	r3, [r3, #6]
 8006f92:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006f96:	b29b      	uxth	r3, r3
 8006f98:	461a      	mov	r2, r3
 8006f9a:	9b03      	ldr	r3, [sp, #12]
 8006f9c:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8006f9e:	9b00      	ldr	r3, [sp, #0]
 8006fa0:	891b      	ldrh	r3, [r3, #8]
 8006fa2:	f043 0301 	orr.w	r3, r3, #1
 8006fa6:	b29b      	uxth	r3, r3
 8006fa8:	461a      	mov	r2, r3
 8006faa:	9b03      	ldr	r3, [sp, #12]
 8006fac:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8006fae:	9b00      	ldr	r3, [sp, #0]
 8006fb0:	889b      	ldrh	r3, [r3, #4]
 8006fb2:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8006fb6:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8006fba:	b29b      	uxth	r3, r3
 8006fbc:	461a      	mov	r2, r3
 8006fbe:	9b03      	ldr	r3, [sp, #12]
 8006fc0:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8006fc2:	9b03      	ldr	r3, [sp, #12]
 8006fc4:	2200      	movs	r2, #0
 8006fc6:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8006fc8:	9b03      	ldr	r3, [sp, #12]
 8006fca:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8006fcc:	9b03      	ldr	r3, [sp, #12]
 8006fce:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8006fd0:	9b00      	ldr	r3, [sp, #0]
 8006fd2:	889b      	ldrh	r3, [r3, #4]
 8006fd4:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 8006fd8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006fdc:	d104      	bne.n	8006fe8 <usart_init+0x98>
    sdp->rxmask = 0x7F;
 8006fde:	9b01      	ldr	r3, [sp, #4]
 8006fe0:	227f      	movs	r2, #127	; 0x7f
 8006fe2:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 8006fe6:	e003      	b.n	8006ff0 <usart_init+0xa0>
  }
  else {
    sdp->rxmask = 0xFF;
 8006fe8:	9b01      	ldr	r3, [sp, #4]
 8006fea:	22ff      	movs	r2, #255	; 0xff
 8006fec:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
  }
}
 8006ff0:	b004      	add	sp, #16
 8006ff2:	4770      	bx	lr
 8006ff4:	40011000 	.word	0x40011000
 8006ff8:	40011400 	.word	0x40011400
 8006ffc:	0501bd00 	.word	0x0501bd00
 8007000:	0280de80 	.word	0x0280de80
 8007004:	f3af 8000 	nop.w
 8007008:	f3af 8000 	nop.w
 800700c:	f3af 8000 	nop.w

08007010 <usart_deinit>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 8007010:	b082      	sub	sp, #8
 8007012:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 8007014:	9b01      	ldr	r3, [sp, #4]
 8007016:	2200      	movs	r2, #0
 8007018:	60da      	str	r2, [r3, #12]
  u->CR2 = 0;
 800701a:	9b01      	ldr	r3, [sp, #4]
 800701c:	2200      	movs	r2, #0
 800701e:	611a      	str	r2, [r3, #16]
  u->CR3 = 0;
 8007020:	9b01      	ldr	r3, [sp, #4]
 8007022:	2200      	movs	r2, #0
 8007024:	615a      	str	r2, [r3, #20]
}
 8007026:	b002      	add	sp, #8
 8007028:	4770      	bx	lr
 800702a:	bf00      	nop
 800702c:	f3af 8000 	nop.w

08007030 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8007030:	b500      	push	{lr}
 8007032:	b085      	sub	sp, #20
 8007034:	9001      	str	r0, [sp, #4]
 8007036:	460b      	mov	r3, r1
 8007038:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 800703c:	2300      	movs	r3, #0
 800703e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8007040:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8007044:	f003 0308 	and.w	r3, r3, #8
 8007048:	2b00      	cmp	r3, #0
 800704a:	d003      	beq.n	8007054 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 800704c:	9b03      	ldr	r3, [sp, #12]
 800704e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007052:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8007054:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8007058:	f003 0301 	and.w	r3, r3, #1
 800705c:	2b00      	cmp	r3, #0
 800705e:	d003      	beq.n	8007068 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 8007060:	9b03      	ldr	r3, [sp, #12]
 8007062:	f043 0320 	orr.w	r3, r3, #32
 8007066:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8007068:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800706c:	f003 0302 	and.w	r3, r3, #2
 8007070:	2b00      	cmp	r3, #0
 8007072:	d003      	beq.n	800707c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 8007074:	9b03      	ldr	r3, [sp, #12]
 8007076:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800707a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 800707c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8007080:	f003 0304 	and.w	r3, r3, #4
 8007084:	2b00      	cmp	r3, #0
 8007086:	d003      	beq.n	8007090 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8007088:	9b03      	ldr	r3, [sp, #12]
 800708a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800708e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8007090:	9b01      	ldr	r3, [sp, #4]
 8007092:	3304      	adds	r3, #4
 8007094:	4618      	mov	r0, r3
 8007096:	9903      	ldr	r1, [sp, #12]
 8007098:	f7ff ff4a 	bl	8006f30 <osalEventBroadcastFlagsI>
}
 800709c:	b005      	add	sp, #20
 800709e:	f85d fb04 	ldr.w	pc, [sp], #4
 80070a2:	bf00      	nop
 80070a4:	f3af 8000 	nop.w
 80070a8:	f3af 8000 	nop.w
 80070ac:	f3af 8000 	nop.w

080070b0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 80070b0:	b500      	push	{lr}
 80070b2:	b087      	sub	sp, #28
 80070b4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 80070b6:	9b01      	ldr	r3, [sp, #4]
 80070b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80070ba:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
 80070bc:	9b04      	ldr	r3, [sp, #16]
 80070be:	68db      	ldr	r3, [r3, #12]
 80070c0:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
 80070c4:	9b04      	ldr	r3, [sp, #16]
 80070c6:	681b      	ldr	r3, [r3, #0]
 80070c8:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80070cc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80070d0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80070d4:	2b00      	cmp	r3, #0
 80070d6:	d00e      	beq.n	80070f6 <serve_interrupt+0x46>
    osalSysLockFromISR();
 80070d8:	f7ff ff1a 	bl	8006f10 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80070dc:	9b01      	ldr	r3, [sp, #4]
 80070de:	3304      	adds	r3, #4
 80070e0:	4618      	mov	r0, r3
 80070e2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80070e6:	f7ff ff23 	bl	8006f30 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 80070ea:	9b04      	ldr	r3, [sp, #16]
 80070ec:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80070f0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80070f2:	f7ff ff15 	bl	8006f20 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
 80070f6:	f7ff ff0b 	bl	8006f10 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80070fa:	e024      	b.n	8007146 <serve_interrupt+0x96>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80070fc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8007100:	f003 030f 	and.w	r3, r3, #15
 8007104:	2b00      	cmp	r3, #0
 8007106:	d005      	beq.n	8007114 <serve_interrupt+0x64>
      set_error(sdp, sr);
 8007108:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800710c:	9801      	ldr	r0, [sp, #4]
 800710e:	4619      	mov	r1, r3
 8007110:	f7ff ff8e 	bl	8007030 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 8007114:	9b04      	ldr	r3, [sp, #16]
 8007116:	685b      	ldr	r3, [r3, #4]
 8007118:	b2da      	uxtb	r2, r3
 800711a:	9b01      	ldr	r3, [sp, #4]
 800711c:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 8007120:	4013      	ands	r3, r2
 8007122:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
 8007126:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800712a:	f003 0320 	and.w	r3, r3, #32
 800712e:	2b00      	cmp	r3, #0
 8007130:	d005      	beq.n	800713e <serve_interrupt+0x8e>
      sdIncomingDataI(sdp, b);
 8007132:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8007136:	9801      	ldr	r0, [sp, #4]
 8007138:	4619      	mov	r1, r3
 800713a:	f7fe fa29 	bl	8005590 <sdIncomingDataI>
    sr = u->SR;
 800713e:	9b04      	ldr	r3, [sp, #16]
 8007140:	681b      	ldr	r3, [r3, #0]
 8007142:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8007146:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800714a:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 800714e:	2b00      	cmp	r3, #0
 8007150:	d1d4      	bne.n	80070fc <serve_interrupt+0x4c>
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
 8007152:	f7ff fee5 	bl	8006f20 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8007156:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800715a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800715e:	2b00      	cmp	r3, #0
 8007160:	d024      	beq.n	80071ac <serve_interrupt+0xfc>
 8007162:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8007166:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800716a:	2b00      	cmp	r3, #0
 800716c:	d01e      	beq.n	80071ac <serve_interrupt+0xfc>
    msg_t b;
    osalSysLockFromISR();
 800716e:	f7ff fecf 	bl	8006f10 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 8007172:	9b01      	ldr	r3, [sp, #4]
 8007174:	3330      	adds	r3, #48	; 0x30
 8007176:	4618      	mov	r0, r3
 8007178:	f7fd fe42 	bl	8004e00 <oqGetI>
 800717c:	9002      	str	r0, [sp, #8]
    if (b < MSG_OK) {
 800717e:	9b02      	ldr	r3, [sp, #8]
 8007180:	2b00      	cmp	r3, #0
 8007182:	da0e      	bge.n	80071a2 <serve_interrupt+0xf2>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8007184:	9b01      	ldr	r3, [sp, #4]
 8007186:	3304      	adds	r3, #4
 8007188:	4618      	mov	r0, r3
 800718a:	2108      	movs	r1, #8
 800718c:	f7ff fed0 	bl	8006f30 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8007190:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8007194:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8007198:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800719c:	9b04      	ldr	r3, [sp, #16]
 800719e:	60da      	str	r2, [r3, #12]
 80071a0:	e002      	b.n	80071a8 <serve_interrupt+0xf8>
    }
    else
      u->DR = b;
 80071a2:	9a02      	ldr	r2, [sp, #8]
 80071a4:	9b04      	ldr	r3, [sp, #16]
 80071a6:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 80071a8:	f7ff feba 	bl	8006f20 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80071ac:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80071b0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80071b4:	2b00      	cmp	r3, #0
 80071b6:	d025      	beq.n	8007204 <serve_interrupt+0x154>
    osalSysLockFromISR();
 80071b8:	f7ff feaa 	bl	8006f10 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 80071bc:	9b01      	ldr	r3, [sp, #4]
 80071be:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80071c0:	9b01      	ldr	r3, [sp, #4]
 80071c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80071c4:	429a      	cmp	r2, r3
 80071c6:	d105      	bne.n	80071d4 <serve_interrupt+0x124>
 80071c8:	9b01      	ldr	r3, [sp, #4]
 80071ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80071cc:	2b00      	cmp	r3, #0
 80071ce:	d001      	beq.n	80071d4 <serve_interrupt+0x124>
 80071d0:	2301      	movs	r3, #1
 80071d2:	e000      	b.n	80071d6 <serve_interrupt+0x126>
 80071d4:	2300      	movs	r3, #0
 80071d6:	f003 0301 	and.w	r3, r3, #1
 80071da:	b2db      	uxtb	r3, r3
 80071dc:	2b00      	cmp	r3, #0
 80071de:	d005      	beq.n	80071ec <serve_interrupt+0x13c>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 80071e0:	9b01      	ldr	r3, [sp, #4]
 80071e2:	3304      	adds	r3, #4
 80071e4:	4618      	mov	r0, r3
 80071e6:	2110      	movs	r1, #16
 80071e8:	f7ff fea2 	bl	8006f30 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80071ec:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80071f0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80071f4:	9b04      	ldr	r3, [sp, #16]
 80071f6:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 80071f8:	9b04      	ldr	r3, [sp, #16]
 80071fa:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80071fe:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8007200:	f7ff fe8e 	bl	8006f20 <osalSysUnlockFromISR>
  }
}
 8007204:	b007      	add	sp, #28
 8007206:	f85d fb04 	ldr.w	pc, [sp], #4
 800720a:	bf00      	nop
 800720c:	f3af 8000 	nop.w

08007210 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8007210:	b082      	sub	sp, #8
 8007212:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8007214:	4a03      	ldr	r2, [pc, #12]	; (8007224 <notify2+0x14>)
 8007216:	4b03      	ldr	r3, [pc, #12]	; (8007224 <notify2+0x14>)
 8007218:	68db      	ldr	r3, [r3, #12]
 800721a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800721e:	60d3      	str	r3, [r2, #12]
}
 8007220:	b002      	add	sp, #8
 8007222:	4770      	bx	lr
 8007224:	40004400 	.word	0x40004400
 8007228:	f3af 8000 	nop.w
 800722c:	f3af 8000 	nop.w

08007230 <notify3>:
#endif

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {
 8007230:	b082      	sub	sp, #8
 8007232:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8007234:	4a03      	ldr	r2, [pc, #12]	; (8007244 <notify3+0x14>)
 8007236:	4b03      	ldr	r3, [pc, #12]	; (8007244 <notify3+0x14>)
 8007238:	68db      	ldr	r3, [r3, #12]
 800723a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800723e:	60d3      	str	r3, [r2, #12]
}
 8007240:	b002      	add	sp, #8
 8007242:	4770      	bx	lr
 8007244:	40004800 	.word	0x40004800
 8007248:	f3af 8000 	nop.w
 800724c:	f3af 8000 	nop.w

08007250 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8007250:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8007252:	4803      	ldr	r0, [pc, #12]	; (8007260 <VectorD8+0x10>)
 8007254:	f7ff ff2c 	bl	80070b0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8007258:	f7fc fd9a 	bl	8003d90 <_port_irq_epilogue>
}
 800725c:	bd08      	pop	{r3, pc}
 800725e:	bf00      	nop
 8007260:	20000bb0 	.word	0x20000bb0
 8007264:	f3af 8000 	nop.w
 8007268:	f3af 8000 	nop.w
 800726c:	f3af 8000 	nop.w

08007270 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8007270:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);
 8007272:	4803      	ldr	r0, [pc, #12]	; (8007280 <VectorDC+0x10>)
 8007274:	f7ff ff1c 	bl	80070b0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8007278:	f7fc fd8a 	bl	8003d90 <_port_irq_epilogue>
}
 800727c:	bd08      	pop	{r3, pc}
 800727e:	bf00      	nop
 8007280:	20000c2c 	.word	0x20000c2c
 8007284:	f3af 8000 	nop.w
 8007288:	f3af 8000 	nop.w
 800728c:	f3af 8000 	nop.w

08007290 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8007290:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8007292:	4808      	ldr	r0, [pc, #32]	; (80072b4 <sd_lld_init+0x24>)
 8007294:	2100      	movs	r1, #0
 8007296:	4a08      	ldr	r2, [pc, #32]	; (80072b8 <sd_lld_init+0x28>)
 8007298:	f7fe f90a 	bl	80054b0 <sdObjectInit>
  SD2.usart = USART2;
 800729c:	4b05      	ldr	r3, [pc, #20]	; (80072b4 <sd_lld_init+0x24>)
 800729e:	4a07      	ldr	r2, [pc, #28]	; (80072bc <sd_lld_init+0x2c>)
 80072a0:	675a      	str	r2, [r3, #116]	; 0x74
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 80072a2:	4807      	ldr	r0, [pc, #28]	; (80072c0 <sd_lld_init+0x30>)
 80072a4:	2100      	movs	r1, #0
 80072a6:	4a07      	ldr	r2, [pc, #28]	; (80072c4 <sd_lld_init+0x34>)
 80072a8:	f7fe f902 	bl	80054b0 <sdObjectInit>
  SD3.usart = USART3;
 80072ac:	4b04      	ldr	r3, [pc, #16]	; (80072c0 <sd_lld_init+0x30>)
 80072ae:	4a06      	ldr	r2, [pc, #24]	; (80072c8 <sd_lld_init+0x38>)
 80072b0:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 80072b2:	bd08      	pop	{r3, pc}
 80072b4:	20000bb0 	.word	0x20000bb0
 80072b8:	08007211 	.word	0x08007211
 80072bc:	40004400 	.word	0x40004400
 80072c0:	20000c2c 	.word	0x20000c2c
 80072c4:	08007231 	.word	0x08007231
 80072c8:	40004800 	.word	0x40004800
 80072cc:	f3af 8000 	nop.w

080072d0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80072d0:	b500      	push	{lr}
 80072d2:	b083      	sub	sp, #12
 80072d4:	9001      	str	r0, [sp, #4]
 80072d6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 80072d8:	9b00      	ldr	r3, [sp, #0]
 80072da:	2b00      	cmp	r3, #0
 80072dc:	d101      	bne.n	80072e2 <sd_lld_start+0x12>
    config = &default_config;
 80072de:	4b14      	ldr	r3, [pc, #80]	; (8007330 <sd_lld_start+0x60>)
 80072e0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 80072e2:	9b01      	ldr	r3, [sp, #4]
 80072e4:	7a1b      	ldrb	r3, [r3, #8]
 80072e6:	2b01      	cmp	r3, #1
 80072e8:	d11b      	bne.n	8007322 <sd_lld_start+0x52>
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 80072ea:	9b01      	ldr	r3, [sp, #4]
 80072ec:	4a11      	ldr	r2, [pc, #68]	; (8007334 <sd_lld_start+0x64>)
 80072ee:	4293      	cmp	r3, r2
 80072f0:	d109      	bne.n	8007306 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
 80072f2:	4a11      	ldr	r2, [pc, #68]	; (8007338 <sd_lld_start+0x68>)
 80072f4:	4b10      	ldr	r3, [pc, #64]	; (8007338 <sd_lld_start+0x68>)
 80072f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80072f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80072fc:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 80072fe:	2026      	movs	r0, #38	; 0x26
 8007300:	210c      	movs	r1, #12
 8007302:	f7fe f9b5 	bl	8005670 <nvicEnableVector>
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
 8007306:	9b01      	ldr	r3, [sp, #4]
 8007308:	4a0c      	ldr	r2, [pc, #48]	; (800733c <sd_lld_start+0x6c>)
 800730a:	4293      	cmp	r3, r2
 800730c:	d109      	bne.n	8007322 <sd_lld_start+0x52>
      rccEnableUSART3(FALSE);
 800730e:	4a0a      	ldr	r2, [pc, #40]	; (8007338 <sd_lld_start+0x68>)
 8007310:	4b09      	ldr	r3, [pc, #36]	; (8007338 <sd_lld_start+0x68>)
 8007312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007314:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8007318:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
 800731a:	2027      	movs	r0, #39	; 0x27
 800731c:	210c      	movs	r1, #12
 800731e:	f7fe f9a7 	bl	8005670 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8007322:	9801      	ldr	r0, [sp, #4]
 8007324:	9900      	ldr	r1, [sp, #0]
 8007326:	f7ff fe13 	bl	8006f50 <usart_init>
}
 800732a:	b003      	add	sp, #12
 800732c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007330:	0800dfac 	.word	0x0800dfac
 8007334:	20000bb0 	.word	0x20000bb0
 8007338:	40023800 	.word	0x40023800
 800733c:	20000c2c 	.word	0x20000c2c

08007340 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 8007340:	b500      	push	{lr}
 8007342:	b083      	sub	sp, #12
 8007344:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 8007346:	9b01      	ldr	r3, [sp, #4]
 8007348:	7a1b      	ldrb	r3, [r3, #8]
 800734a:	2b02      	cmp	r3, #2
 800734c:	d120      	bne.n	8007390 <sd_lld_stop+0x50>
    usart_deinit(sdp->usart);
 800734e:	9b01      	ldr	r3, [sp, #4]
 8007350:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007352:	4618      	mov	r0, r3
 8007354:	f7ff fe5c 	bl	8007010 <usart_deinit>
      nvicDisableVector(STM32_USART1_NUMBER);
      return;
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8007358:	9b01      	ldr	r3, [sp, #4]
 800735a:	4a0f      	ldr	r2, [pc, #60]	; (8007398 <sd_lld_stop+0x58>)
 800735c:	4293      	cmp	r3, r2
 800735e:	d109      	bne.n	8007374 <sd_lld_stop+0x34>
      rccDisableUSART2(FALSE);
 8007360:	4a0e      	ldr	r2, [pc, #56]	; (800739c <sd_lld_stop+0x5c>)
 8007362:	4b0e      	ldr	r3, [pc, #56]	; (800739c <sd_lld_stop+0x5c>)
 8007364:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007366:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800736a:	6413      	str	r3, [r2, #64]	; 0x40
      nvicDisableVector(STM32_USART2_NUMBER);
 800736c:	2026      	movs	r0, #38	; 0x26
 800736e:	f7fe f9af 	bl	80056d0 <nvicDisableVector>
      return;
 8007372:	e00d      	b.n	8007390 <sd_lld_stop+0x50>
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
 8007374:	9b01      	ldr	r3, [sp, #4]
 8007376:	4a0a      	ldr	r2, [pc, #40]	; (80073a0 <sd_lld_stop+0x60>)
 8007378:	4293      	cmp	r3, r2
 800737a:	d109      	bne.n	8007390 <sd_lld_stop+0x50>
      rccDisableUSART3(FALSE);
 800737c:	4a07      	ldr	r2, [pc, #28]	; (800739c <sd_lld_stop+0x5c>)
 800737e:	4b07      	ldr	r3, [pc, #28]	; (800739c <sd_lld_stop+0x5c>)
 8007380:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007382:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8007386:	6413      	str	r3, [r2, #64]	; 0x40
      nvicDisableVector(STM32_USART3_NUMBER);
 8007388:	2027      	movs	r0, #39	; 0x27
 800738a:	f7fe f9a1 	bl	80056d0 <nvicDisableVector>
      return;
 800738e:	bf00      	nop
      nvicDisableVector(STM32_UART8_NUMBER);
      return;
    }
#endif
  }
}
 8007390:	b003      	add	sp, #12
 8007392:	f85d fb04 	ldr.w	pc, [sp], #4
 8007396:	bf00      	nop
 8007398:	20000bb0 	.word	0x20000bb0
 800739c:	40023800 	.word	0x40023800
 80073a0:	20000c2c 	.word	0x20000c2c
	...

080073b0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80073b0:	b508      	push	{r3, lr}

  stm32_clock_init();
 80073b2:	f7fe fa35 	bl	8005820 <stm32_clock_init>
}
 80073b6:	bd08      	pop	{r3, pc}
 80073b8:	f3af 8000 	nop.w
 80073bc:	f3af 8000 	nop.w

080073c0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80073c0:	4770      	bx	lr
 80073c2:	bf00      	nop
	...

080073d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80073d0:	b082      	sub	sp, #8
 80073d2:	2320      	movs	r3, #32
 80073d4:	9301      	str	r3, [sp, #4]
 80073d6:	9b01      	ldr	r3, [sp, #4]
 80073d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80073dc:	b002      	add	sp, #8
 80073de:	4770      	bx	lr

080073e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80073e0:	b082      	sub	sp, #8
 80073e2:	2300      	movs	r3, #0
 80073e4:	9301      	str	r3, [sp, #4]
 80073e6:	9b01      	ldr	r3, [sp, #4]
 80073e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80073ec:	b002      	add	sp, #8
 80073ee:	4770      	bx	lr

080073f0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80073f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80073f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80073f6:	4618      	mov	r0, r3
 80073f8:	4770      	bx	lr
 80073fa:	bf00      	nop
 80073fc:	f3af 8000 	nop.w

08007400 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007400:	b508      	push	{r3, lr}

  return stGetCounter();
 8007402:	f7ff fff5 	bl	80073f0 <st_lld_get_counter>
 8007406:	4603      	mov	r3, r0
}
 8007408:	4618      	mov	r0, r3
 800740a:	bd08      	pop	{r3, pc}
 800740c:	f3af 8000 	nop.w

08007410 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007410:	b508      	push	{r3, lr}

  port_lock();
 8007412:	f7ff ffdd 	bl	80073d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8007416:	bd08      	pop	{r3, pc}
 8007418:	f3af 8000 	nop.w
 800741c:	f3af 8000 	nop.w

08007420 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007420:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007422:	f7ff ffdd 	bl	80073e0 <port_unlock>
}
 8007426:	bd08      	pop	{r3, pc}
 8007428:	f3af 8000 	nop.w
 800742c:	f3af 8000 	nop.w

08007430 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007430:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007432:	f7ff ffe5 	bl	8007400 <port_timer_get_time>
 8007436:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007438:	4618      	mov	r0, r3
 800743a:	bd08      	pop	{r3, pc}
 800743c:	f3af 8000 	nop.w

08007440 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8007440:	b084      	sub	sp, #16
 8007442:	9003      	str	r0, [sp, #12]
 8007444:	9102      	str	r1, [sp, #8]
 8007446:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8007448:	9a03      	ldr	r2, [sp, #12]
 800744a:	9b02      	ldr	r3, [sp, #8]
 800744c:	1ad2      	subs	r2, r2, r3
 800744e:	9901      	ldr	r1, [sp, #4]
 8007450:	9b02      	ldr	r3, [sp, #8]
 8007452:	1acb      	subs	r3, r1, r3
 8007454:	429a      	cmp	r2, r3
 8007456:	bf34      	ite	cc
 8007458:	2301      	movcc	r3, #1
 800745a:	2300      	movcs	r3, #0
 800745c:	b2db      	uxtb	r3, r3
}
 800745e:	4618      	mov	r0, r3
 8007460:	b004      	add	sp, #16
 8007462:	4770      	bx	lr
 8007464:	f3af 8000 	nop.w
 8007468:	f3af 8000 	nop.w
 800746c:	f3af 8000 	nop.w

08007470 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8007470:	b508      	push	{r3, lr}

  chSysLock();
 8007472:	f7ff ffcd 	bl	8007410 <chSysLock>
}
 8007476:	bd08      	pop	{r3, pc}
 8007478:	f3af 8000 	nop.w
 800747c:	f3af 8000 	nop.w

08007480 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8007480:	b508      	push	{r3, lr}

  chSysUnlock();
 8007482:	f7ff ffcd 	bl	8007420 <chSysUnlock>
}
 8007486:	bd08      	pop	{r3, pc}
 8007488:	f3af 8000 	nop.w
 800748c:	f3af 8000 	nop.w

08007490 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8007490:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8007492:	f7ff ffcd 	bl	8007430 <chVTGetSystemTimeX>
 8007496:	4603      	mov	r3, r0
}
 8007498:	4618      	mov	r0, r3
 800749a:	bd08      	pop	{r3, pc}
 800749c:	f3af 8000 	nop.w

080074a0 <osalOsIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool osalOsIsTimeWithinX(systime_t time,
                                       systime_t start,
                                       systime_t end) {
 80074a0:	b500      	push	{lr}
 80074a2:	b085      	sub	sp, #20
 80074a4:	9003      	str	r0, [sp, #12]
 80074a6:	9102      	str	r1, [sp, #8]
 80074a8:	9201      	str	r2, [sp, #4]

  return chVTIsTimeWithinX(time, start, end);
 80074aa:	9803      	ldr	r0, [sp, #12]
 80074ac:	9902      	ldr	r1, [sp, #8]
 80074ae:	9a01      	ldr	r2, [sp, #4]
 80074b0:	f7ff ffc6 	bl	8007440 <chVTIsTimeWithinX>
 80074b4:	4603      	mov	r3, r0
}
 80074b6:	4618      	mov	r0, r3
 80074b8:	b005      	add	sp, #20
 80074ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80074be:	bf00      	nop

080074c0 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 80074c0:	b500      	push	{lr}
 80074c2:	b083      	sub	sp, #12
 80074c4:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 80074c6:	9801      	ldr	r0, [sp, #4]
 80074c8:	f7fa f92a 	bl	8001720 <chThdSleep>
}
 80074cc:	b003      	add	sp, #12
 80074ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80074d2:	bf00      	nop
 80074d4:	f3af 8000 	nop.w
 80074d8:	f3af 8000 	nop.w
 80074dc:	f3af 8000 	nop.w

080074e0 <clear_tokens>:
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 80074e0:	4b01      	ldr	r3, [pc, #4]	; (80074e8 <clear_tokens+0x8>)
 80074e2:	4a02      	ldr	r2, [pc, #8]	; (80074ec <clear_tokens+0xc>)
 80074e4:	601a      	str	r2, [r3, #0]
}
 80074e6:	4770      	bx	lr
 80074e8:	20000974 	.word	0x20000974
 80074ec:	20000964 	.word	0x20000964

080074f0 <print_tokens>:

static void print_tokens(void) {
 80074f0:	b500      	push	{lr}
 80074f2:	b083      	sub	sp, #12
  char *cp = test_tokens_buffer;
 80074f4:	4b0b      	ldr	r3, [pc, #44]	; (8007524 <print_tokens+0x34>)
 80074f6:	9301      	str	r3, [sp, #4]

  while (cp < test_tokp)
 80074f8:	e00b      	b.n	8007512 <print_tokens+0x22>
    streamPut(test_chp, *cp++);
 80074fa:	4b0b      	ldr	r3, [pc, #44]	; (8007528 <print_tokens+0x38>)
 80074fc:	681b      	ldr	r3, [r3, #0]
 80074fe:	681b      	ldr	r3, [r3, #0]
 8007500:	689a      	ldr	r2, [r3, #8]
 8007502:	4b09      	ldr	r3, [pc, #36]	; (8007528 <print_tokens+0x38>)
 8007504:	6818      	ldr	r0, [r3, #0]
 8007506:	9b01      	ldr	r3, [sp, #4]
 8007508:	1c59      	adds	r1, r3, #1
 800750a:	9101      	str	r1, [sp, #4]
 800750c:	781b      	ldrb	r3, [r3, #0]
 800750e:	4619      	mov	r1, r3
 8007510:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8007512:	4b06      	ldr	r3, [pc, #24]	; (800752c <print_tokens+0x3c>)
 8007514:	681b      	ldr	r3, [r3, #0]
 8007516:	9a01      	ldr	r2, [sp, #4]
 8007518:	429a      	cmp	r2, r3
 800751a:	d3ee      	bcc.n	80074fa <print_tokens+0xa>
    streamPut(test_chp, *cp++);
}
 800751c:	b003      	add	sp, #12
 800751e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007522:	bf00      	nop
 8007524:	20000964 	.word	0x20000964
 8007528:	20000978 	.word	0x20000978
 800752c:	20000974 	.word	0x20000974

08007530 <execute_test>:

static void execute_test(const testcase_t *tcp) {
 8007530:	b500      	push	{lr}
 8007532:	b083      	sub	sp, #12
 8007534:	9001      	str	r0, [sp, #4]

  /* Initialization */
  clear_tokens();
 8007536:	f7ff ffd3 	bl	80074e0 <clear_tokens>
  test_local_fail = false;
 800753a:	4b0b      	ldr	r3, [pc, #44]	; (8007568 <execute_test+0x38>)
 800753c:	2200      	movs	r2, #0
 800753e:	701a      	strb	r2, [r3, #0]

  if (tcp->setup != NULL)
 8007540:	9b01      	ldr	r3, [sp, #4]
 8007542:	685b      	ldr	r3, [r3, #4]
 8007544:	2b00      	cmp	r3, #0
 8007546:	d002      	beq.n	800754e <execute_test+0x1e>
    tcp->setup();
 8007548:	9b01      	ldr	r3, [sp, #4]
 800754a:	685b      	ldr	r3, [r3, #4]
 800754c:	4798      	blx	r3
  tcp->execute();
 800754e:	9b01      	ldr	r3, [sp, #4]
 8007550:	68db      	ldr	r3, [r3, #12]
 8007552:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8007554:	9b01      	ldr	r3, [sp, #4]
 8007556:	689b      	ldr	r3, [r3, #8]
 8007558:	2b00      	cmp	r3, #0
 800755a:	d002      	beq.n	8007562 <execute_test+0x32>
    tcp->teardown();
 800755c:	9b01      	ldr	r3, [sp, #4]
 800755e:	689b      	ldr	r3, [r3, #8]
 8007560:	4798      	blx	r3
}
 8007562:	b003      	add	sp, #12
 8007564:	f85d fb04 	ldr.w	pc, [sp], #4
 8007568:	2000095c 	.word	0x2000095c
 800756c:	f3af 8000 	nop.w

08007570 <print_line>:

static void print_line(void) {
 8007570:	b500      	push	{lr}
 8007572:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 8007574:	2300      	movs	r3, #0
 8007576:	9301      	str	r3, [sp, #4]
 8007578:	e00b      	b.n	8007592 <print_line+0x22>
    streamPut(test_chp, '-');
 800757a:	4b0e      	ldr	r3, [pc, #56]	; (80075b4 <print_line+0x44>)
 800757c:	681b      	ldr	r3, [r3, #0]
 800757e:	681b      	ldr	r3, [r3, #0]
 8007580:	689b      	ldr	r3, [r3, #8]
 8007582:	4a0c      	ldr	r2, [pc, #48]	; (80075b4 <print_line+0x44>)
 8007584:	6812      	ldr	r2, [r2, #0]
 8007586:	4610      	mov	r0, r2
 8007588:	212d      	movs	r1, #45	; 0x2d
 800758a:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800758c:	9b01      	ldr	r3, [sp, #4]
 800758e:	3301      	adds	r3, #1
 8007590:	9301      	str	r3, [sp, #4]
 8007592:	9b01      	ldr	r3, [sp, #4]
 8007594:	2b4b      	cmp	r3, #75	; 0x4b
 8007596:	d9f0      	bls.n	800757a <print_line+0xa>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8007598:	4b06      	ldr	r3, [pc, #24]	; (80075b4 <print_line+0x44>)
 800759a:	681b      	ldr	r3, [r3, #0]
 800759c:	681b      	ldr	r3, [r3, #0]
 800759e:	681b      	ldr	r3, [r3, #0]
 80075a0:	4a04      	ldr	r2, [pc, #16]	; (80075b4 <print_line+0x44>)
 80075a2:	6812      	ldr	r2, [r2, #0]
 80075a4:	4610      	mov	r0, r2
 80075a6:	4904      	ldr	r1, [pc, #16]	; (80075b8 <print_line+0x48>)
 80075a8:	2202      	movs	r2, #2
 80075aa:	4798      	blx	r3
}
 80075ac:	b003      	add	sp, #12
 80075ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80075b2:	bf00      	nop
 80075b4:	20000978 	.word	0x20000978
 80075b8:	0800e0b4 	.word	0x0800e0b4
 80075bc:	f3af 8000 	nop.w

080075c0 <_test_fail>:

/*===========================================================================*/
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {
 80075c0:	b082      	sub	sp, #8
 80075c2:	9001      	str	r0, [sp, #4]

  test_local_fail      = true;
 80075c4:	4b06      	ldr	r3, [pc, #24]	; (80075e0 <_test_fail+0x20>)
 80075c6:	2201      	movs	r2, #1
 80075c8:	701a      	strb	r2, [r3, #0]
  test_global_fail     = true;
 80075ca:	4b06      	ldr	r3, [pc, #24]	; (80075e4 <_test_fail+0x24>)
 80075cc:	2201      	movs	r2, #1
 80075ce:	701a      	strb	r2, [r3, #0]
  test_failure_message = msg;
 80075d0:	4a05      	ldr	r2, [pc, #20]	; (80075e8 <_test_fail+0x28>)
 80075d2:	9b01      	ldr	r3, [sp, #4]
 80075d4:	6013      	str	r3, [r2, #0]
  return true;
 80075d6:	2301      	movs	r3, #1
}
 80075d8:	4618      	mov	r0, r3
 80075da:	b002      	add	sp, #8
 80075dc:	4770      	bx	lr
 80075de:	bf00      	nop
 80075e0:	2000095c 	.word	0x2000095c
 80075e4:	20000ca8 	.word	0x20000ca8
 80075e8:	20000960 	.word	0x20000960
 80075ec:	f3af 8000 	nop.w

080075f0 <_test_assert>:

bool _test_assert(bool condition, const char *msg) {
 80075f0:	b500      	push	{lr}
 80075f2:	b083      	sub	sp, #12
 80075f4:	4603      	mov	r3, r0
 80075f6:	9100      	str	r1, [sp, #0]
 80075f8:	f88d 3007 	strb.w	r3, [sp, #7]

  if (!condition)
 80075fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007600:	f083 0301 	eor.w	r3, r3, #1
 8007604:	b2db      	uxtb	r3, r3
 8007606:	2b00      	cmp	r3, #0
 8007608:	d004      	beq.n	8007614 <_test_assert+0x24>
    return _test_fail(msg);
 800760a:	9800      	ldr	r0, [sp, #0]
 800760c:	f7ff ffd8 	bl	80075c0 <_test_fail>
 8007610:	4603      	mov	r3, r0
 8007612:	e000      	b.n	8007616 <_test_assert+0x26>
  return false;
 8007614:	2300      	movs	r3, #0
}
 8007616:	4618      	mov	r0, r3
 8007618:	b003      	add	sp, #12
 800761a:	f85d fb04 	ldr.w	pc, [sp], #4
 800761e:	bf00      	nop

08007620 <_test_assert_sequence>:

bool _test_assert_sequence(char *expected, const char *msg) {
 8007620:	b500      	push	{lr}
 8007622:	b085      	sub	sp, #20
 8007624:	9001      	str	r0, [sp, #4]
 8007626:	9100      	str	r1, [sp, #0]
  char *cp = test_tokens_buffer;
 8007628:	4b13      	ldr	r3, [pc, #76]	; (8007678 <_test_assert_sequence+0x58>)
 800762a:	9303      	str	r3, [sp, #12]

  while (cp < test_tokp) {
 800762c:	e00e      	b.n	800764c <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 800762e:	9b03      	ldr	r3, [sp, #12]
 8007630:	1c5a      	adds	r2, r3, #1
 8007632:	9203      	str	r2, [sp, #12]
 8007634:	781a      	ldrb	r2, [r3, #0]
 8007636:	9b01      	ldr	r3, [sp, #4]
 8007638:	1c59      	adds	r1, r3, #1
 800763a:	9101      	str	r1, [sp, #4]
 800763c:	781b      	ldrb	r3, [r3, #0]
 800763e:	429a      	cmp	r2, r3
 8007640:	d004      	beq.n	800764c <_test_assert_sequence+0x2c>
     return _test_fail(msg);
 8007642:	9800      	ldr	r0, [sp, #0]
 8007644:	f7ff ffbc 	bl	80075c0 <_test_fail>
 8007648:	4603      	mov	r3, r0
 800764a:	e010      	b.n	800766e <_test_assert_sequence+0x4e>
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 800764c:	4b0b      	ldr	r3, [pc, #44]	; (800767c <_test_assert_sequence+0x5c>)
 800764e:	681b      	ldr	r3, [r3, #0]
 8007650:	9a03      	ldr	r2, [sp, #12]
 8007652:	429a      	cmp	r2, r3
 8007654:	d3eb      	bcc.n	800762e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 8007656:	9b01      	ldr	r3, [sp, #4]
 8007658:	781b      	ldrb	r3, [r3, #0]
 800765a:	2b00      	cmp	r3, #0
 800765c:	d004      	beq.n	8007668 <_test_assert_sequence+0x48>
    return _test_fail(msg);
 800765e:	9800      	ldr	r0, [sp, #0]
 8007660:	f7ff ffae 	bl	80075c0 <_test_fail>
 8007664:	4603      	mov	r3, r0
 8007666:	e002      	b.n	800766e <_test_assert_sequence+0x4e>

  clear_tokens();
 8007668:	f7ff ff3a 	bl	80074e0 <clear_tokens>

  return false;
 800766c:	2300      	movs	r3, #0
}
 800766e:	4618      	mov	r0, r3
 8007670:	b005      	add	sp, #20
 8007672:	f85d fb04 	ldr.w	pc, [sp], #4
 8007676:	bf00      	nop
 8007678:	20000964 	.word	0x20000964
 800767c:	20000974 	.word	0x20000974

08007680 <_test_assert_time_window>:

bool _test_assert_time_window(systime_t start,
                              systime_t end,
                              const char *msg) {
 8007680:	b500      	push	{lr}
 8007682:	b085      	sub	sp, #20
 8007684:	9003      	str	r0, [sp, #12]
 8007686:	9102      	str	r1, [sp, #8]
 8007688:	9201      	str	r2, [sp, #4]

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
 800768a:	f7ff ff01 	bl	8007490 <osalOsGetSystemTimeX>
 800768e:	4603      	mov	r3, r0
 8007690:	4618      	mov	r0, r3
 8007692:	9903      	ldr	r1, [sp, #12]
 8007694:	9a02      	ldr	r2, [sp, #8]
 8007696:	f7ff ff03 	bl	80074a0 <osalOsIsTimeWithinX>
 800769a:	4603      	mov	r3, r0
 800769c:	4618      	mov	r0, r3
 800769e:	9901      	ldr	r1, [sp, #4]
 80076a0:	f7ff ffa6 	bl	80075f0 <_test_assert>
 80076a4:	4603      	mov	r3, r0
                      msg);
}
 80076a6:	4618      	mov	r0, r3
 80076a8:	b005      	add	sp, #20
 80076aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80076ae:	bf00      	nop

080076b0 <test_printn>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 80076b0:	b500      	push	{lr}
 80076b2:	b089      	sub	sp, #36	; 0x24
 80076b4:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 80076b6:	9b01      	ldr	r3, [sp, #4]
 80076b8:	2b00      	cmp	r3, #0
 80076ba:	d109      	bne.n	80076d0 <test_printn+0x20>
    streamPut(test_chp, '0');
 80076bc:	4b1e      	ldr	r3, [pc, #120]	; (8007738 <test_printn+0x88>)
 80076be:	681b      	ldr	r3, [r3, #0]
 80076c0:	681b      	ldr	r3, [r3, #0]
 80076c2:	689b      	ldr	r3, [r3, #8]
 80076c4:	4a1c      	ldr	r2, [pc, #112]	; (8007738 <test_printn+0x88>)
 80076c6:	6812      	ldr	r2, [r2, #0]
 80076c8:	4610      	mov	r0, r2
 80076ca:	2130      	movs	r1, #48	; 0x30
 80076cc:	4798      	blx	r3
 80076ce:	e02f      	b.n	8007730 <test_printn+0x80>
  else {
    p = buf;
 80076d0:	ab03      	add	r3, sp, #12
 80076d2:	9307      	str	r3, [sp, #28]
    while (n)
 80076d4:	e016      	b.n	8007704 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 80076d6:	9907      	ldr	r1, [sp, #28]
 80076d8:	1c4b      	adds	r3, r1, #1
 80076da:	9307      	str	r3, [sp, #28]
 80076dc:	9801      	ldr	r0, [sp, #4]
 80076de:	4b17      	ldr	r3, [pc, #92]	; (800773c <test_printn+0x8c>)
 80076e0:	fba3 2300 	umull	r2, r3, r3, r0
 80076e4:	08da      	lsrs	r2, r3, #3
 80076e6:	4613      	mov	r3, r2
 80076e8:	009b      	lsls	r3, r3, #2
 80076ea:	4413      	add	r3, r2
 80076ec:	005b      	lsls	r3, r3, #1
 80076ee:	1ac2      	subs	r2, r0, r3
 80076f0:	b2d3      	uxtb	r3, r2
 80076f2:	3330      	adds	r3, #48	; 0x30
 80076f4:	b2db      	uxtb	r3, r3
 80076f6:	700b      	strb	r3, [r1, #0]
 80076f8:	9b01      	ldr	r3, [sp, #4]
 80076fa:	4a10      	ldr	r2, [pc, #64]	; (800773c <test_printn+0x8c>)
 80076fc:	fba2 2303 	umull	r2, r3, r2, r3
 8007700:	08db      	lsrs	r3, r3, #3
 8007702:	9301      	str	r3, [sp, #4]

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8007704:	9b01      	ldr	r3, [sp, #4]
 8007706:	2b00      	cmp	r3, #0
 8007708:	d1e5      	bne.n	80076d6 <test_printn+0x26>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800770a:	e00d      	b.n	8007728 <test_printn+0x78>
      streamPut(test_chp, *--p);
 800770c:	4b0a      	ldr	r3, [pc, #40]	; (8007738 <test_printn+0x88>)
 800770e:	681b      	ldr	r3, [r3, #0]
 8007710:	681b      	ldr	r3, [r3, #0]
 8007712:	689b      	ldr	r3, [r3, #8]
 8007714:	4a08      	ldr	r2, [pc, #32]	; (8007738 <test_printn+0x88>)
 8007716:	6811      	ldr	r1, [r2, #0]
 8007718:	9a07      	ldr	r2, [sp, #28]
 800771a:	3a01      	subs	r2, #1
 800771c:	9207      	str	r2, [sp, #28]
 800771e:	9a07      	ldr	r2, [sp, #28]
 8007720:	7812      	ldrb	r2, [r2, #0]
 8007722:	4608      	mov	r0, r1
 8007724:	4611      	mov	r1, r2
 8007726:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8007728:	ab03      	add	r3, sp, #12
 800772a:	9a07      	ldr	r2, [sp, #28]
 800772c:	429a      	cmp	r2, r3
 800772e:	d8ed      	bhi.n	800770c <test_printn+0x5c>
      streamPut(test_chp, *--p);
  }
}
 8007730:	b009      	add	sp, #36	; 0x24
 8007732:	f85d fb04 	ldr.w	pc, [sp], #4
 8007736:	bf00      	nop
 8007738:	20000978 	.word	0x20000978
 800773c:	cccccccd 	.word	0xcccccccd

08007740 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8007740:	b500      	push	{lr}
 8007742:	b083      	sub	sp, #12
 8007744:	9001      	str	r0, [sp, #4]

  while (*msgp)
 8007746:	e00b      	b.n	8007760 <test_print+0x20>
    streamPut(test_chp, *msgp++);
 8007748:	4b09      	ldr	r3, [pc, #36]	; (8007770 <test_print+0x30>)
 800774a:	681b      	ldr	r3, [r3, #0]
 800774c:	681b      	ldr	r3, [r3, #0]
 800774e:	689a      	ldr	r2, [r3, #8]
 8007750:	4b07      	ldr	r3, [pc, #28]	; (8007770 <test_print+0x30>)
 8007752:	6818      	ldr	r0, [r3, #0]
 8007754:	9b01      	ldr	r3, [sp, #4]
 8007756:	1c59      	adds	r1, r3, #1
 8007758:	9101      	str	r1, [sp, #4]
 800775a:	781b      	ldrb	r3, [r3, #0]
 800775c:	4619      	mov	r1, r3
 800775e:	4790      	blx	r2
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8007760:	9b01      	ldr	r3, [sp, #4]
 8007762:	781b      	ldrb	r3, [r3, #0]
 8007764:	2b00      	cmp	r3, #0
 8007766:	d1ef      	bne.n	8007748 <test_print+0x8>
    streamPut(test_chp, *msgp++);
}
 8007768:	b003      	add	sp, #12
 800776a:	f85d fb04 	ldr.w	pc, [sp], #4
 800776e:	bf00      	nop
 8007770:	20000978 	.word	0x20000978
 8007774:	f3af 8000 	nop.w
 8007778:	f3af 8000 	nop.w
 800777c:	f3af 8000 	nop.w

08007780 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8007780:	b500      	push	{lr}
 8007782:	b083      	sub	sp, #12
 8007784:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 8007786:	9801      	ldr	r0, [sp, #4]
 8007788:	f7ff ffda 	bl	8007740 <test_print>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800778c:	4b06      	ldr	r3, [pc, #24]	; (80077a8 <test_println+0x28>)
 800778e:	681b      	ldr	r3, [r3, #0]
 8007790:	681b      	ldr	r3, [r3, #0]
 8007792:	681b      	ldr	r3, [r3, #0]
 8007794:	4a04      	ldr	r2, [pc, #16]	; (80077a8 <test_println+0x28>)
 8007796:	6812      	ldr	r2, [r2, #0]
 8007798:	4610      	mov	r0, r2
 800779a:	4904      	ldr	r1, [pc, #16]	; (80077ac <test_println+0x2c>)
 800779c:	2202      	movs	r2, #2
 800779e:	4798      	blx	r3
}
 80077a0:	b003      	add	sp, #12
 80077a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80077a6:	bf00      	nop
 80077a8:	20000978 	.word	0x20000978
 80077ac:	0800e0b4 	.word	0x0800e0b4

080077b0 <test_emit_token>:
 *
 * @param[in] token     the token as a char
 *
 * @api
 */
void test_emit_token(char token) {
 80077b0:	b500      	push	{lr}
 80077b2:	b083      	sub	sp, #12
 80077b4:	4603      	mov	r3, r0
 80077b6:	f88d 3007 	strb.w	r3, [sp, #7]

  osalSysLock();
 80077ba:	f7ff fe59 	bl	8007470 <osalSysLock>
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 80077be:	4b09      	ldr	r3, [pc, #36]	; (80077e4 <test_emit_token+0x34>)
 80077c0:	681b      	ldr	r3, [r3, #0]
 80077c2:	4a09      	ldr	r2, [pc, #36]	; (80077e8 <test_emit_token+0x38>)
 80077c4:	4293      	cmp	r3, r2
 80077c6:	d207      	bcs.n	80077d8 <test_emit_token+0x28>
    *test_tokp++ = token;
 80077c8:	4b06      	ldr	r3, [pc, #24]	; (80077e4 <test_emit_token+0x34>)
 80077ca:	681b      	ldr	r3, [r3, #0]
 80077cc:	1c5a      	adds	r2, r3, #1
 80077ce:	4905      	ldr	r1, [pc, #20]	; (80077e4 <test_emit_token+0x34>)
 80077d0:	600a      	str	r2, [r1, #0]
 80077d2:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80077d6:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80077d8:	f7ff fe52 	bl	8007480 <osalSysUnlock>
}
 80077dc:	b003      	add	sp, #12
 80077de:	f85d fb04 	ldr.w	pc, [sp], #4
 80077e2:	bf00      	nop
 80077e4:	20000974 	.word	0x20000974
 80077e8:	20000974 	.word	0x20000974
 80077ec:	f3af 8000 	nop.w

080077f0 <test_emit_token_i>:
 *
 * @param[in] token     the token as a char
 *
 * @iclass
 */
void test_emit_token_i(char token) {
 80077f0:	b082      	sub	sp, #8
 80077f2:	4603      	mov	r3, r0
 80077f4:	f88d 3007 	strb.w	r3, [sp, #7]

  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 80077f8:	4b07      	ldr	r3, [pc, #28]	; (8007818 <test_emit_token_i+0x28>)
 80077fa:	681b      	ldr	r3, [r3, #0]
 80077fc:	4a07      	ldr	r2, [pc, #28]	; (800781c <test_emit_token_i+0x2c>)
 80077fe:	4293      	cmp	r3, r2
 8007800:	d207      	bcs.n	8007812 <test_emit_token_i+0x22>
    *test_tokp++ = token;
 8007802:	4b05      	ldr	r3, [pc, #20]	; (8007818 <test_emit_token_i+0x28>)
 8007804:	681b      	ldr	r3, [r3, #0]
 8007806:	1c5a      	adds	r2, r3, #1
 8007808:	4903      	ldr	r1, [pc, #12]	; (8007818 <test_emit_token_i+0x28>)
 800780a:	600a      	str	r2, [r1, #0]
 800780c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8007810:	701a      	strb	r2, [r3, #0]
}
 8007812:	b002      	add	sp, #8
 8007814:	4770      	bx	lr
 8007816:	bf00      	nop
 8007818:	20000974 	.word	0x20000974
 800781c:	20000974 	.word	0x20000974

08007820 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
 8007820:	b500      	push	{lr}
 8007822:	b085      	sub	sp, #20
 8007824:	9001      	str	r0, [sp, #4]
  int i, j;

  test_chp = stream;
 8007826:	4a57      	ldr	r2, [pc, #348]	; (8007984 <test_execute+0x164>)
 8007828:	9b01      	ldr	r3, [sp, #4]
 800782a:	6013      	str	r3, [r2, #0]
  test_println("");
 800782c:	4856      	ldr	r0, [pc, #344]	; (8007988 <test_execute+0x168>)
 800782e:	f7ff ffa7 	bl	8007780 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 8007832:	4856      	ldr	r0, [pc, #344]	; (800798c <test_execute+0x16c>)
 8007834:	f7ff ffa4 	bl	8007780 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8007838:	4855      	ldr	r0, [pc, #340]	; (8007990 <test_execute+0x170>)
 800783a:	f7ff ffa1 	bl	8007780 <test_println>
  test_print("*** Compiled:     ");
 800783e:	4855      	ldr	r0, [pc, #340]	; (8007994 <test_execute+0x174>)
 8007840:	f7ff ff7e 	bl	8007740 <test_print>
  test_println(__DATE__ " - " __TIME__);
 8007844:	4854      	ldr	r0, [pc, #336]	; (8007998 <test_execute+0x178>)
 8007846:	f7ff ff9b 	bl	8007780 <test_println>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
 800784a:	4854      	ldr	r0, [pc, #336]	; (800799c <test_execute+0x17c>)
 800784c:	f7ff ff78 	bl	8007740 <test_print>
  test_println(PLATFORM_NAME);
 8007850:	4853      	ldr	r0, [pc, #332]	; (80079a0 <test_execute+0x180>)
 8007852:	f7ff ff95 	bl	8007780 <test_println>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
 8007856:	4853      	ldr	r0, [pc, #332]	; (80079a4 <test_execute+0x184>)
 8007858:	f7ff ff72 	bl	8007740 <test_print>
  test_println(BOARD_NAME);
 800785c:	4852      	ldr	r0, [pc, #328]	; (80079a8 <test_execute+0x188>)
 800785e:	f7ff ff8f 	bl	8007780 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
 8007862:	f000 f90d 	bl	8007a80 <test_print_port_info>
#endif
  test_println("");
 8007866:	4848      	ldr	r0, [pc, #288]	; (8007988 <test_execute+0x168>)
 8007868:	f7ff ff8a 	bl	8007780 <test_println>

  test_global_fail = false;
 800786c:	4b4f      	ldr	r3, [pc, #316]	; (80079ac <test_execute+0x18c>)
 800786e:	2200      	movs	r2, #0
 8007870:	701a      	strb	r2, [r3, #0]
  i = 0;
 8007872:	2300      	movs	r3, #0
 8007874:	9303      	str	r3, [sp, #12]
  while (test_suite[i]) {
 8007876:	e065      	b.n	8007944 <test_execute+0x124>
    j = 0;
 8007878:	2300      	movs	r3, #0
 800787a:	9302      	str	r3, [sp, #8]
    while (test_suite[i][j]) {
 800787c:	e055      	b.n	800792a <test_execute+0x10a>
      print_line();
 800787e:	f7ff fe77 	bl	8007570 <print_line>
      test_print("--- Test Case ");
 8007882:	484b      	ldr	r0, [pc, #300]	; (80079b0 <test_execute+0x190>)
 8007884:	f7ff ff5c 	bl	8007740 <test_print>
      test_printn(i + 1);
 8007888:	9b03      	ldr	r3, [sp, #12]
 800788a:	3301      	adds	r3, #1
 800788c:	4618      	mov	r0, r3
 800788e:	f7ff ff0f 	bl	80076b0 <test_printn>
      test_print(".");
 8007892:	4848      	ldr	r0, [pc, #288]	; (80079b4 <test_execute+0x194>)
 8007894:	f7ff ff54 	bl	8007740 <test_print>
      test_printn(j + 1);
 8007898:	9b02      	ldr	r3, [sp, #8]
 800789a:	3301      	adds	r3, #1
 800789c:	4618      	mov	r0, r3
 800789e:	f7ff ff07 	bl	80076b0 <test_printn>
      test_print(" (");
 80078a2:	4845      	ldr	r0, [pc, #276]	; (80079b8 <test_execute+0x198>)
 80078a4:	f7ff ff4c 	bl	8007740 <test_print>
      test_print(test_suite[i][j]->name);
 80078a8:	4a44      	ldr	r2, [pc, #272]	; (80079bc <test_execute+0x19c>)
 80078aa:	9b03      	ldr	r3, [sp, #12]
 80078ac:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80078b0:	9b02      	ldr	r3, [sp, #8]
 80078b2:	009b      	lsls	r3, r3, #2
 80078b4:	4413      	add	r3, r2
 80078b6:	681b      	ldr	r3, [r3, #0]
 80078b8:	681b      	ldr	r3, [r3, #0]
 80078ba:	4618      	mov	r0, r3
 80078bc:	f7ff ff40 	bl	8007740 <test_print>
      test_println(")");
 80078c0:	483f      	ldr	r0, [pc, #252]	; (80079c0 <test_execute+0x1a0>)
 80078c2:	f7ff ff5d 	bl	8007780 <test_println>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
 80078c6:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80078ca:	f7ff fdf9 	bl	80074c0 <osalThreadSleep>
#endif
      execute_test(test_suite[i][j]);
 80078ce:	4a3b      	ldr	r2, [pc, #236]	; (80079bc <test_execute+0x19c>)
 80078d0:	9b03      	ldr	r3, [sp, #12]
 80078d2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80078d6:	9b02      	ldr	r3, [sp, #8]
 80078d8:	009b      	lsls	r3, r3, #2
 80078da:	4413      	add	r3, r2
 80078dc:	681b      	ldr	r3, [r3, #0]
 80078de:	4618      	mov	r0, r3
 80078e0:	f7ff fe26 	bl	8007530 <execute_test>
      if (test_local_fail) {
 80078e4:	4b37      	ldr	r3, [pc, #220]	; (80079c4 <test_execute+0x1a4>)
 80078e6:	781b      	ldrb	r3, [r3, #0]
 80078e8:	2b00      	cmp	r3, #0
 80078ea:	d018      	beq.n	800791e <test_execute+0xfe>
        test_print("--- Result: FAILURE (#");
 80078ec:	4836      	ldr	r0, [pc, #216]	; (80079c8 <test_execute+0x1a8>)
 80078ee:	f7ff ff27 	bl	8007740 <test_print>
        test_printn(test_step);
 80078f2:	4b36      	ldr	r3, [pc, #216]	; (80079cc <test_execute+0x1ac>)
 80078f4:	681b      	ldr	r3, [r3, #0]
 80078f6:	4618      	mov	r0, r3
 80078f8:	f7ff feda 	bl	80076b0 <test_printn>
        test_print(" [");
 80078fc:	4834      	ldr	r0, [pc, #208]	; (80079d0 <test_execute+0x1b0>)
 80078fe:	f7ff ff1f 	bl	8007740 <test_print>
        print_tokens();
 8007902:	f7ff fdf5 	bl	80074f0 <print_tokens>
        test_print("] \"");
 8007906:	4833      	ldr	r0, [pc, #204]	; (80079d4 <test_execute+0x1b4>)
 8007908:	f7ff ff1a 	bl	8007740 <test_print>
        test_print(test_failure_message);
 800790c:	4b32      	ldr	r3, [pc, #200]	; (80079d8 <test_execute+0x1b8>)
 800790e:	681b      	ldr	r3, [r3, #0]
 8007910:	4618      	mov	r0, r3
 8007912:	f7ff ff15 	bl	8007740 <test_print>
        test_println("\")");
 8007916:	4831      	ldr	r0, [pc, #196]	; (80079dc <test_execute+0x1bc>)
 8007918:	f7ff ff32 	bl	8007780 <test_println>
 800791c:	e002      	b.n	8007924 <test_execute+0x104>
      }
      else
        test_println("--- Result: SUCCESS");
 800791e:	4830      	ldr	r0, [pc, #192]	; (80079e0 <test_execute+0x1c0>)
 8007920:	f7ff ff2e 	bl	8007780 <test_println>
      j++;
 8007924:	9b02      	ldr	r3, [sp, #8]
 8007926:	3301      	adds	r3, #1
 8007928:	9302      	str	r3, [sp, #8]

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 800792a:	4a24      	ldr	r2, [pc, #144]	; (80079bc <test_execute+0x19c>)
 800792c:	9b03      	ldr	r3, [sp, #12]
 800792e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8007932:	9b02      	ldr	r3, [sp, #8]
 8007934:	009b      	lsls	r3, r3, #2
 8007936:	4413      	add	r3, r2
 8007938:	681b      	ldr	r3, [r3, #0]
 800793a:	2b00      	cmp	r3, #0
 800793c:	d19f      	bne.n	800787e <test_execute+0x5e>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 800793e:	9b03      	ldr	r3, [sp, #12]
 8007940:	3301      	adds	r3, #1
 8007942:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8007944:	4a1d      	ldr	r2, [pc, #116]	; (80079bc <test_execute+0x19c>)
 8007946:	9b03      	ldr	r3, [sp, #12]
 8007948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800794c:	2b00      	cmp	r3, #0
 800794e:	d193      	bne.n	8007878 <test_execute+0x58>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8007950:	f7ff fe0e 	bl	8007570 <print_line>
  test_println("");
 8007954:	480c      	ldr	r0, [pc, #48]	; (8007988 <test_execute+0x168>)
 8007956:	f7ff ff13 	bl	8007780 <test_println>
  test_print("Final result: ");
 800795a:	4822      	ldr	r0, [pc, #136]	; (80079e4 <test_execute+0x1c4>)
 800795c:	f7ff fef0 	bl	8007740 <test_print>
  if (test_global_fail)
 8007960:	4b12      	ldr	r3, [pc, #72]	; (80079ac <test_execute+0x18c>)
 8007962:	781b      	ldrb	r3, [r3, #0]
 8007964:	2b00      	cmp	r3, #0
 8007966:	d003      	beq.n	8007970 <test_execute+0x150>
    test_println("FAILURE");
 8007968:	481f      	ldr	r0, [pc, #124]	; (80079e8 <test_execute+0x1c8>)
 800796a:	f7ff ff09 	bl	8007780 <test_println>
 800796e:	e002      	b.n	8007976 <test_execute+0x156>
  else
    test_println("SUCCESS");
 8007970:	481e      	ldr	r0, [pc, #120]	; (80079ec <test_execute+0x1cc>)
 8007972:	f7ff ff05 	bl	8007780 <test_println>

#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
 8007976:	4b0d      	ldr	r3, [pc, #52]	; (80079ac <test_execute+0x18c>)
 8007978:	781b      	ldrb	r3, [r3, #0]
}
 800797a:	4618      	mov	r0, r3
 800797c:	b005      	add	sp, #20
 800797e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007982:	bf00      	nop
 8007984:	20000978 	.word	0x20000978
 8007988:	0800e0b8 	.word	0x0800e0b8
 800798c:	0800e0bc 	.word	0x0800e0bc
 8007990:	0800e0d8 	.word	0x0800e0d8
 8007994:	0800e0dc 	.word	0x0800e0dc
 8007998:	0800e0f0 	.word	0x0800e0f0
 800799c:	0800e108 	.word	0x0800e108
 80079a0:	0800e11c 	.word	0x0800e11c
 80079a4:	0800e148 	.word	0x0800e148
 80079a8:	0800e15c 	.word	0x0800e15c
 80079ac:	20000ca8 	.word	0x20000ca8
 80079b0:	0800e184 	.word	0x0800e184
 80079b4:	0800e194 	.word	0x0800e194
 80079b8:	0800e198 	.word	0x0800e198
 80079bc:	20000804 	.word	0x20000804
 80079c0:	0800e19c 	.word	0x0800e19c
 80079c4:	2000095c 	.word	0x2000095c
 80079c8:	0800e1a0 	.word	0x0800e1a0
 80079cc:	20000cac 	.word	0x20000cac
 80079d0:	0800e1b8 	.word	0x0800e1b8
 80079d4:	0800e1bc 	.word	0x0800e1bc
 80079d8:	20000960 	.word	0x20000960
 80079dc:	0800e1c0 	.word	0x0800e1c0
 80079e0:	0800e1c4 	.word	0x0800e1c4
 80079e4:	0800e1d8 	.word	0x0800e1d8
 80079e8:	0800e1e8 	.word	0x0800e1e8
 80079ec:	0800e1f0 	.word	0x0800e1f0

080079f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80079f0:	b082      	sub	sp, #8
 80079f2:	2320      	movs	r3, #32
 80079f4:	9301      	str	r3, [sp, #4]
 80079f6:	9b01      	ldr	r3, [sp, #4]
 80079f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80079fc:	b002      	add	sp, #8
 80079fe:	4770      	bx	lr

08007a00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007a00:	b082      	sub	sp, #8
 8007a02:	2300      	movs	r3, #0
 8007a04:	9301      	str	r3, [sp, #4]
 8007a06:	9b01      	ldr	r3, [sp, #4]
 8007a08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007a0c:	b002      	add	sp, #8
 8007a0e:	4770      	bx	lr

08007a10 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8007a10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007a14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8007a16:	4618      	mov	r0, r3
 8007a18:	4770      	bx	lr
 8007a1a:	bf00      	nop
 8007a1c:	f3af 8000 	nop.w

08007a20 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8007a20:	b508      	push	{r3, lr}

  return stGetCounter();
 8007a22:	f7ff fff5 	bl	8007a10 <st_lld_get_counter>
 8007a26:	4603      	mov	r3, r0
}
 8007a28:	4618      	mov	r0, r3
 8007a2a:	bd08      	pop	{r3, pc}
 8007a2c:	f3af 8000 	nop.w

08007a30 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007a30:	b508      	push	{r3, lr}

  port_lock();
 8007a32:	f7ff ffdd 	bl	80079f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8007a36:	bd08      	pop	{r3, pc}
 8007a38:	f3af 8000 	nop.w
 8007a3c:	f3af 8000 	nop.w

08007a40 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007a40:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8007a42:	f7ff ffdd 	bl	8007a00 <port_unlock>
}
 8007a46:	bd08      	pop	{r3, pc}
 8007a48:	f3af 8000 	nop.w
 8007a4c:	f3af 8000 	nop.w

08007a50 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8007a50:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8007a52:	f7ff ffe5 	bl	8007a20 <port_timer_get_time>
 8007a56:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8007a58:	4618      	mov	r0, r3
 8007a5a:	bd08      	pop	{r3, pc}
 8007a5c:	f3af 8000 	nop.w

08007a60 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8007a60:	b500      	push	{lr}
 8007a62:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8007a64:	f7ff ffe4 	bl	8007a30 <chSysLock>
  systime = chVTGetSystemTimeX();
 8007a68:	f7ff fff2 	bl	8007a50 <chVTGetSystemTimeX>
 8007a6c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8007a6e:	f7ff ffe7 	bl	8007a40 <chSysUnlock>

  return systime;
 8007a72:	9b01      	ldr	r3, [sp, #4]
}
 8007a74:	4618      	mov	r0, r3
 8007a76:	b003      	add	sp, #12
 8007a78:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a7c:	f3af 8000 	nop.w

08007a80 <test_print_port_info>:

/*===========================================================================*/
/* Shared code.                                                              */
/*===========================================================================*/

void test_print_port_info(void) {
 8007a80:	b508      	push	{r3, lr}

#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 8007a82:	480c      	ldr	r0, [pc, #48]	; (8007ab4 <test_print_port_info+0x34>)
 8007a84:	f7ff fe5c 	bl	8007740 <test_print>
  test_println(PORT_COMPILER_NAME);
 8007a88:	480b      	ldr	r0, [pc, #44]	; (8007ab8 <test_print_port_info+0x38>)
 8007a8a:	f7ff fe79 	bl	8007780 <test_println>
#endif
  test_print("*** Architecture: ");
 8007a8e:	480b      	ldr	r0, [pc, #44]	; (8007abc <test_print_port_info+0x3c>)
 8007a90:	f7ff fe56 	bl	8007740 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 8007a94:	480a      	ldr	r0, [pc, #40]	; (8007ac0 <test_print_port_info+0x40>)
 8007a96:	f7ff fe73 	bl	8007780 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 8007a9a:	480a      	ldr	r0, [pc, #40]	; (8007ac4 <test_print_port_info+0x44>)
 8007a9c:	f7ff fe50 	bl	8007740 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 8007aa0:	4809      	ldr	r0, [pc, #36]	; (8007ac8 <test_print_port_info+0x48>)
 8007aa2:	f7ff fe6d 	bl	8007780 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 8007aa6:	4809      	ldr	r0, [pc, #36]	; (8007acc <test_print_port_info+0x4c>)
 8007aa8:	f7ff fe4a 	bl	8007740 <test_print>
  test_println(PORT_INFO);
 8007aac:	4808      	ldr	r0, [pc, #32]	; (8007ad0 <test_print_port_info+0x50>)
 8007aae:	f7ff fe67 	bl	8007780 <test_println>
#endif
}
 8007ab2:	bd08      	pop	{r3, pc}
 8007ab4:	0800e1f8 	.word	0x0800e1f8
 8007ab8:	0800e20c 	.word	0x0800e20c
 8007abc:	0800e22c 	.word	0x0800e22c
 8007ac0:	0800e240 	.word	0x0800e240
 8007ac4:	0800e24c 	.word	0x0800e24c
 8007ac8:	0800e260 	.word	0x0800e260
 8007acc:	0800e26c 	.word	0x0800e26c
 8007ad0:	0800e280 	.word	0x0800e280
 8007ad4:	f3af 8000 	nop.w
 8007ad8:	f3af 8000 	nop.w
 8007adc:	f3af 8000 	nop.w

08007ae0 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8007ae0:	b500      	push	{lr}
 8007ae2:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8007ae4:	2300      	movs	r3, #0
 8007ae6:	9301      	str	r3, [sp, #4]
 8007ae8:	e00f      	b.n	8007b0a <test_terminate_threads+0x2a>
    if (threads[i])
 8007aea:	4a0b      	ldr	r2, [pc, #44]	; (8007b18 <test_terminate_threads+0x38>)
 8007aec:	9b01      	ldr	r3, [sp, #4]
 8007aee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007af2:	2b00      	cmp	r3, #0
 8007af4:	d006      	beq.n	8007b04 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 8007af6:	4a08      	ldr	r2, [pc, #32]	; (8007b18 <test_terminate_threads+0x38>)
 8007af8:	9b01      	ldr	r3, [sp, #4]
 8007afa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007afe:	4618      	mov	r0, r3
 8007b00:	f7f9 fdf6 	bl	80016f0 <chThdTerminate>
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8007b04:	9b01      	ldr	r3, [sp, #4]
 8007b06:	3301      	adds	r3, #1
 8007b08:	9301      	str	r3, [sp, #4]
 8007b0a:	9b01      	ldr	r3, [sp, #4]
 8007b0c:	2b04      	cmp	r3, #4
 8007b0e:	d9ec      	bls.n	8007aea <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8007b10:	b003      	add	sp, #12
 8007b12:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b16:	bf00      	nop
 8007b18:	20000cb0 	.word	0x20000cb0
 8007b1c:	f3af 8000 	nop.w

08007b20 <test_wait_threads>:

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8007b20:	b500      	push	{lr}
 8007b22:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8007b24:	2300      	movs	r3, #0
 8007b26:	9301      	str	r3, [sp, #4]
 8007b28:	e014      	b.n	8007b54 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 8007b2a:	4a0d      	ldr	r2, [pc, #52]	; (8007b60 <test_wait_threads+0x40>)
 8007b2c:	9b01      	ldr	r3, [sp, #4]
 8007b2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007b32:	2b00      	cmp	r3, #0
 8007b34:	d00b      	beq.n	8007b4e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 8007b36:	4a0a      	ldr	r2, [pc, #40]	; (8007b60 <test_wait_threads+0x40>)
 8007b38:	9b01      	ldr	r3, [sp, #4]
 8007b3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007b3e:	4618      	mov	r0, r3
 8007b40:	f7f9 fd7e 	bl	8001640 <chThdWait>
      threads[i] = NULL;
 8007b44:	4a06      	ldr	r2, [pc, #24]	; (8007b60 <test_wait_threads+0x40>)
 8007b46:	9b01      	ldr	r3, [sp, #4]
 8007b48:	2100      	movs	r1, #0
 8007b4a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8007b4e:	9b01      	ldr	r3, [sp, #4]
 8007b50:	3301      	adds	r3, #1
 8007b52:	9301      	str	r3, [sp, #4]
 8007b54:	9b01      	ldr	r3, [sp, #4]
 8007b56:	2b04      	cmp	r3, #4
 8007b58:	d9e7      	bls.n	8007b2a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8007b5a:	b003      	add	sp, #12
 8007b5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b60:	20000cb0 	.word	0x20000cb0
 8007b64:	f3af 8000 	nop.w
 8007b68:	f3af 8000 	nop.w
 8007b6c:	f3af 8000 	nop.w

08007b70 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8007b70:	b508      	push	{r3, lr}

  chThdSleep(1);
 8007b72:	2001      	movs	r0, #1
 8007b74:	f7f9 fdd4 	bl	8001720 <chThdSleep>
  return chVTGetSystemTime();
 8007b78:	f7ff ff72 	bl	8007a60 <chVTGetSystemTime>
 8007b7c:	4603      	mov	r3, r0
}
 8007b7e:	4618      	mov	r0, r3
 8007b80:	bd08      	pop	{r3, pc}
 8007b82:	bf00      	nop
	...

08007b90 <test_001_001_execute>:
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void test_001_001_execute(void) {
 8007b90:	b508      	push	{r3, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8007b92:	4b18      	ldr	r3, [pc, #96]	; (8007bf4 <test_001_001_execute+0x64>)
 8007b94:	2201      	movs	r2, #1
 8007b96:	601a      	str	r2, [r3, #0]
  {
    test_println("--- Product:                   ChibiOS/RT");
 8007b98:	4817      	ldr	r0, [pc, #92]	; (8007bf8 <test_001_001_execute+0x68>)
 8007b9a:	f7ff fdf1 	bl	8007780 <test_println>
    test_print("--- Stable Flag:               ");
 8007b9e:	4817      	ldr	r0, [pc, #92]	; (8007bfc <test_001_001_execute+0x6c>)
 8007ba0:	f7ff fdce 	bl	8007740 <test_print>
    test_printn(CH_KERNEL_STABLE);
 8007ba4:	2001      	movs	r0, #1
 8007ba6:	f7ff fd83 	bl	80076b0 <test_printn>
    test_println("");
 8007baa:	4815      	ldr	r0, [pc, #84]	; (8007c00 <test_001_001_execute+0x70>)
 8007bac:	f7ff fde8 	bl	8007780 <test_println>
    test_print("--- Version String:            ");
 8007bb0:	4814      	ldr	r0, [pc, #80]	; (8007c04 <test_001_001_execute+0x74>)
 8007bb2:	f7ff fdc5 	bl	8007740 <test_print>
    test_println(CH_KERNEL_VERSION);
 8007bb6:	4814      	ldr	r0, [pc, #80]	; (8007c08 <test_001_001_execute+0x78>)
 8007bb8:	f7ff fde2 	bl	8007780 <test_println>
    test_print("--- Major Number:              ");
 8007bbc:	4813      	ldr	r0, [pc, #76]	; (8007c0c <test_001_001_execute+0x7c>)
 8007bbe:	f7ff fdbf 	bl	8007740 <test_print>
    test_printn(CH_KERNEL_MAJOR);
 8007bc2:	2004      	movs	r0, #4
 8007bc4:	f7ff fd74 	bl	80076b0 <test_printn>
    test_println("");
 8007bc8:	480d      	ldr	r0, [pc, #52]	; (8007c00 <test_001_001_execute+0x70>)
 8007bca:	f7ff fdd9 	bl	8007780 <test_println>
    test_print("--- Minor Number:              ");
 8007bce:	4810      	ldr	r0, [pc, #64]	; (8007c10 <test_001_001_execute+0x80>)
 8007bd0:	f7ff fdb6 	bl	8007740 <test_print>
    test_printn(CH_KERNEL_MINOR);
 8007bd4:	2000      	movs	r0, #0
 8007bd6:	f7ff fd6b 	bl	80076b0 <test_printn>
    test_println("");
 8007bda:	4809      	ldr	r0, [pc, #36]	; (8007c00 <test_001_001_execute+0x70>)
 8007bdc:	f7ff fdd0 	bl	8007780 <test_println>
    test_print("--- Patch Number:              ");
 8007be0:	480c      	ldr	r0, [pc, #48]	; (8007c14 <test_001_001_execute+0x84>)
 8007be2:	f7ff fdad 	bl	8007740 <test_print>
    test_printn(CH_KERNEL_PATCH);
 8007be6:	2003      	movs	r0, #3
 8007be8:	f7ff fd62 	bl	80076b0 <test_printn>
    test_println("");
 8007bec:	4804      	ldr	r0, [pc, #16]	; (8007c00 <test_001_001_execute+0x70>)
 8007bee:	f7ff fdc7 	bl	8007780 <test_println>
  }
}
 8007bf2:	bd08      	pop	{r3, pc}
 8007bf4:	20000cac 	.word	0x20000cac
 8007bf8:	0800e2ac 	.word	0x0800e2ac
 8007bfc:	0800e2d8 	.word	0x0800e2d8
 8007c00:	0800e2f8 	.word	0x0800e2f8
 8007c04:	0800e2fc 	.word	0x0800e2fc
 8007c08:	0800e31c 	.word	0x0800e31c
 8007c0c:	0800e324 	.word	0x0800e324
 8007c10:	0800e344 	.word	0x0800e344
 8007c14:	0800e364 	.word	0x0800e364
 8007c18:	f3af 8000 	nop.w
 8007c1c:	f3af 8000 	nop.w

08007c20 <test_001_002_execute>:
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the configuration options settings.
 * .
 */

static void test_001_002_execute(void) {
 8007c20:	b508      	push	{r3, lr}

  /* [1.2.1] Prints the configuration options settings.*/
  test_set_step(1);
 8007c22:	4b9b      	ldr	r3, [pc, #620]	; (8007e90 <test_001_002_execute+0x270>)
 8007c24:	2201      	movs	r2, #1
 8007c26:	601a      	str	r2, [r3, #0]
  {
    test_print("--- CH_CFG_ST_RESOLUTION:      ");
 8007c28:	489a      	ldr	r0, [pc, #616]	; (8007e94 <test_001_002_execute+0x274>)
 8007c2a:	f7ff fd89 	bl	8007740 <test_print>
    test_printn(CH_CFG_ST_RESOLUTION);
 8007c2e:	2020      	movs	r0, #32
 8007c30:	f7ff fd3e 	bl	80076b0 <test_printn>
    test_println("");
 8007c34:	4898      	ldr	r0, [pc, #608]	; (8007e98 <test_001_002_execute+0x278>)
 8007c36:	f7ff fda3 	bl	8007780 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:       ");
 8007c3a:	4898      	ldr	r0, [pc, #608]	; (8007e9c <test_001_002_execute+0x27c>)
 8007c3c:	f7ff fd80 	bl	8007740 <test_print>
    test_printn(CH_CFG_ST_FREQUENCY);
 8007c40:	f242 7010 	movw	r0, #10000	; 0x2710
 8007c44:	f7ff fd34 	bl	80076b0 <test_printn>
    test_println("");
 8007c48:	4893      	ldr	r0, [pc, #588]	; (8007e98 <test_001_002_execute+0x278>)
 8007c4a:	f7ff fd99 	bl	8007780 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:       ");
 8007c4e:	4894      	ldr	r0, [pc, #592]	; (8007ea0 <test_001_002_execute+0x280>)
 8007c50:	f7ff fd76 	bl	8007740 <test_print>
    test_printn(CH_CFG_ST_TIMEDELTA);
 8007c54:	2002      	movs	r0, #2
 8007c56:	f7ff fd2b 	bl	80076b0 <test_printn>
    test_println("");
 8007c5a:	488f      	ldr	r0, [pc, #572]	; (8007e98 <test_001_002_execute+0x278>)
 8007c5c:	f7ff fd90 	bl	8007780 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:       ");
 8007c60:	4890      	ldr	r0, [pc, #576]	; (8007ea4 <test_001_002_execute+0x284>)
 8007c62:	f7ff fd6d 	bl	8007740 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
 8007c66:	2000      	movs	r0, #0
 8007c68:	f7ff fd22 	bl	80076b0 <test_printn>
    test_println("");
 8007c6c:	488a      	ldr	r0, [pc, #552]	; (8007e98 <test_001_002_execute+0x278>)
 8007c6e:	f7ff fd87 	bl	8007780 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:       ");
 8007c72:	488d      	ldr	r0, [pc, #564]	; (8007ea8 <test_001_002_execute+0x288>)
 8007c74:	f7ff fd64 	bl	8007740 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
 8007c78:	2000      	movs	r0, #0
 8007c7a:	f7ff fd19 	bl	80076b0 <test_printn>
    test_println("");
 8007c7e:	4886      	ldr	r0, [pc, #536]	; (8007e98 <test_001_002_execute+0x278>)
 8007c80:	f7ff fd7e 	bl	8007780 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:     ");
 8007c84:	4889      	ldr	r0, [pc, #548]	; (8007eac <test_001_002_execute+0x28c>)
 8007c86:	f7ff fd5b 	bl	8007740 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
 8007c8a:	2000      	movs	r0, #0
 8007c8c:	f7ff fd10 	bl	80076b0 <test_printn>
    test_println("");
 8007c90:	4881      	ldr	r0, [pc, #516]	; (8007e98 <test_001_002_execute+0x278>)
 8007c92:	f7ff fd75 	bl	8007780 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:     ");
 8007c96:	4886      	ldr	r0, [pc, #536]	; (8007eb0 <test_001_002_execute+0x290>)
 8007c98:	f7ff fd52 	bl	8007740 <test_print>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
 8007c9c:	2001      	movs	r0, #1
 8007c9e:	f7ff fd07 	bl	80076b0 <test_printn>
    test_println("");
 8007ca2:	487d      	ldr	r0, [pc, #500]	; (8007e98 <test_001_002_execute+0x278>)
 8007ca4:	f7ff fd6c 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_TM:             ");
 8007ca8:	4882      	ldr	r0, [pc, #520]	; (8007eb4 <test_001_002_execute+0x294>)
 8007caa:	f7ff fd49 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_TM);
 8007cae:	2001      	movs	r0, #1
 8007cb0:	f7ff fcfe 	bl	80076b0 <test_printn>
    test_println("");
 8007cb4:	4878      	ldr	r0, [pc, #480]	; (8007e98 <test_001_002_execute+0x278>)
 8007cb6:	f7ff fd63 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:       ");
 8007cba:	487f      	ldr	r0, [pc, #508]	; (8007eb8 <test_001_002_execute+0x298>)
 8007cbc:	f7ff fd40 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_REGISTRY);
 8007cc0:	2001      	movs	r0, #1
 8007cc2:	f7ff fcf5 	bl	80076b0 <test_printn>
    test_println("");
 8007cc6:	4874      	ldr	r0, [pc, #464]	; (8007e98 <test_001_002_execute+0x278>)
 8007cc8:	f7ff fd5a 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:       ");
 8007ccc:	487b      	ldr	r0, [pc, #492]	; (8007ebc <test_001_002_execute+0x29c>)
 8007cce:	f7ff fd37 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_WAITEXIT);
 8007cd2:	2001      	movs	r0, #1
 8007cd4:	f7ff fcec 	bl	80076b0 <test_printn>
    test_println("");
 8007cd8:	486f      	ldr	r0, [pc, #444]	; (8007e98 <test_001_002_execute+0x278>)
 8007cda:	f7ff fd51 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:     ");
 8007cde:	4878      	ldr	r0, [pc, #480]	; (8007ec0 <test_001_002_execute+0x2a0>)
 8007ce0:	f7ff fd2e 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES);
 8007ce4:	2001      	movs	r0, #1
 8007ce6:	f7ff fce3 	bl	80076b0 <test_printn>
    test_println("");
 8007cea:	486b      	ldr	r0, [pc, #428]	; (8007e98 <test_001_002_execute+0x278>)
 8007cec:	f7ff fd48 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRI: ");
 8007cf0:	4874      	ldr	r0, [pc, #464]	; (8007ec4 <test_001_002_execute+0x2a4>)
 8007cf2:	f7ff fd25 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
 8007cf6:	2000      	movs	r0, #0
 8007cf8:	f7ff fcda 	bl	80076b0 <test_printn>
    test_println("");
 8007cfc:	4866      	ldr	r0, [pc, #408]	; (8007e98 <test_001_002_execute+0x278>)
 8007cfe:	f7ff fd3f 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:        ");
 8007d02:	4871      	ldr	r0, [pc, #452]	; (8007ec8 <test_001_002_execute+0x2a8>)
 8007d04:	f7ff fd1c 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MUTEXES);
 8007d08:	2001      	movs	r0, #1
 8007d0a:	f7ff fcd1 	bl	80076b0 <test_printn>
    test_println("");
 8007d0e:	4862      	ldr	r0, [pc, #392]	; (8007e98 <test_001_002_execute+0x278>)
 8007d10:	f7ff fd36 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURS: ");
 8007d14:	486d      	ldr	r0, [pc, #436]	; (8007ecc <test_001_002_execute+0x2ac>)
 8007d16:	f7ff fd13 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
 8007d1a:	2000      	movs	r0, #0
 8007d1c:	f7ff fcc8 	bl	80076b0 <test_printn>
    test_println("");
 8007d20:	485d      	ldr	r0, [pc, #372]	; (8007e98 <test_001_002_execute+0x278>)
 8007d22:	f7ff fd2d 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:       ");
 8007d26:	486a      	ldr	r0, [pc, #424]	; (8007ed0 <test_001_002_execute+0x2b0>)
 8007d28:	f7ff fd0a 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_CONDVARS);
 8007d2c:	2001      	movs	r0, #1
 8007d2e:	f7ff fcbf 	bl	80076b0 <test_printn>
    test_println("");
 8007d32:	4859      	ldr	r0, [pc, #356]	; (8007e98 <test_001_002_execute+0x278>)
 8007d34:	f7ff fd24 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEO: ");
 8007d38:	4866      	ldr	r0, [pc, #408]	; (8007ed4 <test_001_002_execute+0x2b4>)
 8007d3a:	f7ff fd01 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
 8007d3e:	2001      	movs	r0, #1
 8007d40:	f7ff fcb6 	bl	80076b0 <test_printn>
    test_println("");
 8007d44:	4854      	ldr	r0, [pc, #336]	; (8007e98 <test_001_002_execute+0x278>)
 8007d46:	f7ff fd1b 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:         ");
 8007d4a:	4863      	ldr	r0, [pc, #396]	; (8007ed8 <test_001_002_execute+0x2b8>)
 8007d4c:	f7ff fcf8 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_EVENTS);
 8007d50:	2001      	movs	r0, #1
 8007d52:	f7ff fcad 	bl	80076b0 <test_printn>
    test_println("");
 8007d56:	4850      	ldr	r0, [pc, #320]	; (8007e98 <test_001_002_execute+0x278>)
 8007d58:	f7ff fd12 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT: ");
 8007d5c:	485f      	ldr	r0, [pc, #380]	; (8007edc <test_001_002_execute+0x2bc>)
 8007d5e:	f7ff fcef 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
 8007d62:	2001      	movs	r0, #1
 8007d64:	f7ff fca4 	bl	80076b0 <test_printn>
    test_println("");
 8007d68:	484b      	ldr	r0, [pc, #300]	; (8007e98 <test_001_002_execute+0x278>)
 8007d6a:	f7ff fd09 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:       ");
 8007d6e:	485c      	ldr	r0, [pc, #368]	; (8007ee0 <test_001_002_execute+0x2c0>)
 8007d70:	f7ff fce6 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MESSAGES);
 8007d74:	2001      	movs	r0, #1
 8007d76:	f7ff fc9b 	bl	80076b0 <test_printn>
    test_println("");
 8007d7a:	4847      	ldr	r0, [pc, #284]	; (8007e98 <test_001_002_execute+0x278>)
 8007d7c:	f7ff fd00 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRI:   ");
 8007d80:	4858      	ldr	r0, [pc, #352]	; (8007ee4 <test_001_002_execute+0x2c4>)
 8007d82:	f7ff fcdd 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
 8007d86:	2000      	movs	r0, #0
 8007d88:	f7ff fc92 	bl	80076b0 <test_printn>
    test_println("");
 8007d8c:	4842      	ldr	r0, [pc, #264]	; (8007e98 <test_001_002_execute+0x278>)
 8007d8e:	f7ff fcf7 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:      ");
 8007d92:	4855      	ldr	r0, [pc, #340]	; (8007ee8 <test_001_002_execute+0x2c8>)
 8007d94:	f7ff fcd4 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MAILBOXES);
 8007d98:	2001      	movs	r0, #1
 8007d9a:	f7ff fc89 	bl	80076b0 <test_printn>
    test_println("");
 8007d9e:	483e      	ldr	r0, [pc, #248]	; (8007e98 <test_001_002_execute+0x278>)
 8007da0:	f7ff fcee 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:        ");
 8007da4:	4851      	ldr	r0, [pc, #324]	; (8007eec <test_001_002_execute+0x2cc>)
 8007da6:	f7ff fccb 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MEMCORE);
 8007daa:	2001      	movs	r0, #1
 8007dac:	f7ff fc80 	bl	80076b0 <test_printn>
    test_println("");
 8007db0:	4839      	ldr	r0, [pc, #228]	; (8007e98 <test_001_002_execute+0x278>)
 8007db2:	f7ff fce5 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_HEAP:           ");
 8007db6:	484e      	ldr	r0, [pc, #312]	; (8007ef0 <test_001_002_execute+0x2d0>)
 8007db8:	f7ff fcc2 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_HEAP);
 8007dbc:	2001      	movs	r0, #1
 8007dbe:	f7ff fc77 	bl	80076b0 <test_printn>
    test_println("");
 8007dc2:	4835      	ldr	r0, [pc, #212]	; (8007e98 <test_001_002_execute+0x278>)
 8007dc4:	f7ff fcdc 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:       ");
 8007dc8:	484a      	ldr	r0, [pc, #296]	; (8007ef4 <test_001_002_execute+0x2d4>)
 8007dca:	f7ff fcb9 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_MEMPOOLS);
 8007dce:	2001      	movs	r0, #1
 8007dd0:	f7ff fc6e 	bl	80076b0 <test_printn>
    test_println("");
 8007dd4:	4830      	ldr	r0, [pc, #192]	; (8007e98 <test_001_002_execute+0x278>)
 8007dd6:	f7ff fcd3 	bl	8007780 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:        ");
 8007dda:	4847      	ldr	r0, [pc, #284]	; (8007ef8 <test_001_002_execute+0x2d8>)
 8007ddc:	f7ff fcb0 	bl	8007740 <test_print>
    test_printn(CH_CFG_USE_DYNAMIC);
 8007de0:	2001      	movs	r0, #1
 8007de2:	f7ff fc65 	bl	80076b0 <test_printn>
    test_println("");
 8007de6:	482c      	ldr	r0, [pc, #176]	; (8007e98 <test_001_002_execute+0x278>)
 8007de8:	f7ff fcca 	bl	8007780 <test_println>
    test_print("--- CH_DBG_STATISTICS:         ");
 8007dec:	4843      	ldr	r0, [pc, #268]	; (8007efc <test_001_002_execute+0x2dc>)
 8007dee:	f7ff fca7 	bl	8007740 <test_print>
    test_printn(CH_DBG_STATISTICS);
 8007df2:	2000      	movs	r0, #0
 8007df4:	f7ff fc5c 	bl	80076b0 <test_printn>
    test_println("");
 8007df8:	4827      	ldr	r0, [pc, #156]	; (8007e98 <test_001_002_execute+0x278>)
 8007dfa:	f7ff fcc1 	bl	8007780 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK: ");
 8007dfe:	4840      	ldr	r0, [pc, #256]	; (8007f00 <test_001_002_execute+0x2e0>)
 8007e00:	f7ff fc9e 	bl	8007740 <test_print>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
 8007e04:	2000      	movs	r0, #0
 8007e06:	f7ff fc53 	bl	80076b0 <test_printn>
    test_println("");
 8007e0a:	4823      	ldr	r0, [pc, #140]	; (8007e98 <test_001_002_execute+0x278>)
 8007e0c:	f7ff fcb8 	bl	8007780 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:      ");
 8007e10:	483c      	ldr	r0, [pc, #240]	; (8007f04 <test_001_002_execute+0x2e4>)
 8007e12:	f7ff fc95 	bl	8007740 <test_print>
    test_printn(CH_DBG_ENABLE_CHECKS);
 8007e16:	2000      	movs	r0, #0
 8007e18:	f7ff fc4a 	bl	80076b0 <test_printn>
    test_println("");
 8007e1c:	481e      	ldr	r0, [pc, #120]	; (8007e98 <test_001_002_execute+0x278>)
 8007e1e:	f7ff fcaf 	bl	8007780 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:     ");
 8007e22:	4839      	ldr	r0, [pc, #228]	; (8007f08 <test_001_002_execute+0x2e8>)
 8007e24:	f7ff fc8c 	bl	8007740 <test_print>
    test_printn(CH_DBG_ENABLE_ASSERTS);
 8007e28:	2000      	movs	r0, #0
 8007e2a:	f7ff fc41 	bl	80076b0 <test_printn>
    test_println("");
 8007e2e:	481a      	ldr	r0, [pc, #104]	; (8007e98 <test_001_002_execute+0x278>)
 8007e30:	f7ff fca6 	bl	8007780 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:         ");
 8007e34:	4835      	ldr	r0, [pc, #212]	; (8007f0c <test_001_002_execute+0x2ec>)
 8007e36:	f7ff fc83 	bl	8007740 <test_print>
    test_printn(CH_DBG_TRACE_MASK);
 8007e3a:	20ff      	movs	r0, #255	; 0xff
 8007e3c:	f7ff fc38 	bl	80076b0 <test_printn>
    test_println("");
 8007e40:	4815      	ldr	r0, [pc, #84]	; (8007e98 <test_001_002_execute+0x278>)
 8007e42:	f7ff fc9d 	bl	8007780 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:  ");
 8007e46:	4832      	ldr	r0, [pc, #200]	; (8007f10 <test_001_002_execute+0x2f0>)
 8007e48:	f7ff fc7a 	bl	8007740 <test_print>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
 8007e4c:	2080      	movs	r0, #128	; 0x80
 8007e4e:	f7ff fc2f 	bl	80076b0 <test_printn>
    test_println("");
 8007e52:	4811      	ldr	r0, [pc, #68]	; (8007e98 <test_001_002_execute+0x278>)
 8007e54:	f7ff fc94 	bl	8007780 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK: ");
 8007e58:	482e      	ldr	r0, [pc, #184]	; (8007f14 <test_001_002_execute+0x2f4>)
 8007e5a:	f7ff fc71 	bl	8007740 <test_print>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
 8007e5e:	2000      	movs	r0, #0
 8007e60:	f7ff fc26 	bl	80076b0 <test_printn>
    test_println("");
 8007e64:	480c      	ldr	r0, [pc, #48]	; (8007e98 <test_001_002_execute+0x278>)
 8007e66:	f7ff fc8b 	bl	8007780 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:       ");
 8007e6a:	482b      	ldr	r0, [pc, #172]	; (8007f18 <test_001_002_execute+0x2f8>)
 8007e6c:	f7ff fc68 	bl	8007740 <test_print>
    test_printn(CH_DBG_FILL_THREADS);
 8007e70:	2000      	movs	r0, #0
 8007e72:	f7ff fc1d 	bl	80076b0 <test_printn>
    test_println("");
 8007e76:	4808      	ldr	r0, [pc, #32]	; (8007e98 <test_001_002_execute+0x278>)
 8007e78:	f7ff fc82 	bl	8007780 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:  ");
 8007e7c:	4827      	ldr	r0, [pc, #156]	; (8007f1c <test_001_002_execute+0x2fc>)
 8007e7e:	f7ff fc5f 	bl	8007740 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
 8007e82:	2000      	movs	r0, #0
 8007e84:	f7ff fc14 	bl	80076b0 <test_printn>
    test_println("");
 8007e88:	4803      	ldr	r0, [pc, #12]	; (8007e98 <test_001_002_execute+0x278>)
 8007e8a:	f7ff fc79 	bl	8007780 <test_println>
  }
}
 8007e8e:	bd08      	pop	{r3, pc}
 8007e90:	20000cac 	.word	0x20000cac
 8007e94:	0800e3a0 	.word	0x0800e3a0
 8007e98:	0800e2f8 	.word	0x0800e2f8
 8007e9c:	0800e3c0 	.word	0x0800e3c0
 8007ea0:	0800e3e0 	.word	0x0800e3e0
 8007ea4:	0800e400 	.word	0x0800e400
 8007ea8:	0800e420 	.word	0x0800e420
 8007eac:	0800e440 	.word	0x0800e440
 8007eb0:	0800e460 	.word	0x0800e460
 8007eb4:	0800e480 	.word	0x0800e480
 8007eb8:	0800e4a0 	.word	0x0800e4a0
 8007ebc:	0800e4c0 	.word	0x0800e4c0
 8007ec0:	0800e4e0 	.word	0x0800e4e0
 8007ec4:	0800e500 	.word	0x0800e500
 8007ec8:	0800e520 	.word	0x0800e520
 8007ecc:	0800e540 	.word	0x0800e540
 8007ed0:	0800e560 	.word	0x0800e560
 8007ed4:	0800e580 	.word	0x0800e580
 8007ed8:	0800e5a0 	.word	0x0800e5a0
 8007edc:	0800e5c0 	.word	0x0800e5c0
 8007ee0:	0800e5e0 	.word	0x0800e5e0
 8007ee4:	0800e600 	.word	0x0800e600
 8007ee8:	0800e620 	.word	0x0800e620
 8007eec:	0800e640 	.word	0x0800e640
 8007ef0:	0800e660 	.word	0x0800e660
 8007ef4:	0800e680 	.word	0x0800e680
 8007ef8:	0800e6a0 	.word	0x0800e6a0
 8007efc:	0800e6c0 	.word	0x0800e6c0
 8007f00:	0800e6e0 	.word	0x0800e6e0
 8007f04:	0800e700 	.word	0x0800e700
 8007f08:	0800e720 	.word	0x0800e720
 8007f0c:	0800e740 	.word	0x0800e740
 8007f10:	0800e760 	.word	0x0800e760
 8007f14:	0800e780 	.word	0x0800e780
 8007f18:	0800e7a0 	.word	0x0800e7a0
 8007f1c:	0800e7c0 	.word	0x0800e7c0

08007f20 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 8007f20:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007f22:	f3ef 8311 	mrs	r3, BASEPRI
 8007f26:	9300      	str	r3, [sp, #0]
  return(result);
 8007f28:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 8007f2a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 8007f2c:	9b01      	ldr	r3, [sp, #4]
}
 8007f2e:	4618      	mov	r0, r3
 8007f30:	b002      	add	sp, #8
 8007f32:	4770      	bx	lr
 8007f34:	f3af 8000 	nop.w
 8007f38:	f3af 8000 	nop.w
 8007f3c:	f3af 8000 	nop.w

08007f40 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retval false        the word specified a disabled interrupts status.
 * @retval true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 8007f40:	b082      	sub	sp, #8
 8007f42:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 8007f44:	9b01      	ldr	r3, [sp, #4]
 8007f46:	2b00      	cmp	r3, #0
 8007f48:	bf0c      	ite	eq
 8007f4a:	2301      	moveq	r3, #1
 8007f4c:	2300      	movne	r3, #0
 8007f4e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f50:	4618      	mov	r0, r3
 8007f52:	b002      	add	sp, #8
 8007f54:	4770      	bx	lr
 8007f56:	bf00      	nop
 8007f58:	f3af 8000 	nop.w
 8007f5c:	f3af 8000 	nop.w

08007f60 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007f60:	b082      	sub	sp, #8
 8007f62:	2320      	movs	r3, #32
 8007f64:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8007f66:	9b01      	ldr	r3, [sp, #4]
 8007f68:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f6c:	b002      	add	sp, #8
 8007f6e:	4770      	bx	lr

08007f70 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007f70:	b082      	sub	sp, #8
 8007f72:	2300      	movs	r3, #0
 8007f74:	9301      	str	r3, [sp, #4]
 8007f76:	9b01      	ldr	r3, [sp, #4]
 8007f78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f7c:	b002      	add	sp, #8
 8007f7e:	4770      	bx	lr

08007f80 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007f80:	b508      	push	{r3, lr}

  port_lock();
 8007f82:	f7ff ffed 	bl	8007f60 <port_lock>
}
 8007f86:	bd08      	pop	{r3, pc}
 8007f88:	f3af 8000 	nop.w
 8007f8c:	f3af 8000 	nop.w

08007f90 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007f90:	b508      	push	{r3, lr}

  port_unlock();
 8007f92:	f7ff ffed 	bl	8007f70 <port_unlock>
}
 8007f96:	bd08      	pop	{r3, pc}
 8007f98:	f3af 8000 	nop.w
 8007f9c:	f3af 8000 	nop.w

08007fa0 <port_disable>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8007fa0:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8007fa2:	4770      	bx	lr
 8007fa4:	f3af 8000 	nop.w
 8007fa8:	f3af 8000 	nop.w
 8007fac:	f3af 8000 	nop.w

08007fb0 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 8007fb0:	b082      	sub	sp, #8
 8007fb2:	2320      	movs	r3, #32
 8007fb4:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8007fb6:	9b01      	ldr	r3, [sp, #4]
 8007fb8:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007fbc:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 8007fbe:	b002      	add	sp, #8
 8007fc0:	4770      	bx	lr
 8007fc2:	bf00      	nop
 8007fc4:	f3af 8000 	nop.w
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8007fd0:	b082      	sub	sp, #8
 8007fd2:	2300      	movs	r3, #0
 8007fd4:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8007fd6:	9b01      	ldr	r3, [sp, #4]
 8007fd8:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007fdc:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 8007fde:	b002      	add	sp, #8
 8007fe0:	4770      	bx	lr
 8007fe2:	bf00      	nop
 8007fe4:	f3af 8000 	nop.w
 8007fe8:	f3af 8000 	nop.w
 8007fec:	f3af 8000 	nop.w

08007ff0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8007ff0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007ff4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8007ff6:	4618      	mov	r0, r3
 8007ff8:	4770      	bx	lr
 8007ffa:	bf00      	nop
 8007ffc:	f3af 8000 	nop.w

08008000 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8008000:	b508      	push	{r3, lr}

  return stGetCounter();
 8008002:	f7ff fff5 	bl	8007ff0 <st_lld_get_counter>
 8008006:	4603      	mov	r3, r0
}
 8008008:	4618      	mov	r0, r3
 800800a:	bd08      	pop	{r3, pc}
 800800c:	f3af 8000 	nop.w

08008010 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 8008010:	b508      	push	{r3, lr}

  port_disable();
 8008012:	f7ff ffc5 	bl	8007fa0 <port_disable>
  _dbg_check_disable();
}
 8008016:	bd08      	pop	{r3, pc}
 8008018:	f3af 8000 	nop.w
 800801c:	f3af 8000 	nop.w

08008020 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 8008020:	b508      	push	{r3, lr}

  port_suspend();
 8008022:	f7ff ffc5 	bl	8007fb0 <port_suspend>
  _dbg_check_suspend();
}
 8008026:	bd08      	pop	{r3, pc}
 8008028:	f3af 8000 	nop.w
 800802c:	f3af 8000 	nop.w

08008030 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8008030:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8008032:	f7ff ffcd 	bl	8007fd0 <port_enable>
}
 8008036:	bd08      	pop	{r3, pc}
 8008038:	f3af 8000 	nop.w
 800803c:	f3af 8000 	nop.w

08008040 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008040:	b508      	push	{r3, lr}

  port_lock();
 8008042:	f7ff ff8d 	bl	8007f60 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8008046:	bd08      	pop	{r3, pc}
 8008048:	f3af 8000 	nop.w
 800804c:	f3af 8000 	nop.w

08008050 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008050:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008052:	f7ff ff8d 	bl	8007f70 <port_unlock>
}
 8008056:	bd08      	pop	{r3, pc}
 8008058:	f3af 8000 	nop.w
 800805c:	f3af 8000 	nop.w

08008060 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8008060:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8008062:	f7ff ff8d 	bl	8007f80 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8008066:	bd08      	pop	{r3, pc}
 8008068:	f3af 8000 	nop.w
 800806c:	f3af 8000 	nop.w

08008070 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8008070:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8008072:	f7ff ff8d 	bl	8007f90 <port_unlock_from_isr>
}
 8008076:	bd08      	pop	{r3, pc}
 8008078:	f3af 8000 	nop.w
 800807c:	f3af 8000 	nop.w

08008080 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 8008080:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 8008082:	f7ff ff4d 	bl	8007f20 <port_get_irq_status>
 8008086:	4603      	mov	r3, r0
 8008088:	4618      	mov	r0, r3
 800808a:	f7ff ff59 	bl	8007f40 <port_irq_enabled>
 800808e:	4603      	mov	r3, r0
 8008090:	2b00      	cmp	r3, #0
 8008092:	d001      	beq.n	8008098 <chSysUnconditionalLock+0x18>
    chSysLock();
 8008094:	f7ff ffd4 	bl	8008040 <chSysLock>
  }
}
 8008098:	bd08      	pop	{r3, pc}
 800809a:	bf00      	nop
 800809c:	f3af 8000 	nop.w

080080a0 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 80080a0:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 80080a2:	f7ff ff3d 	bl	8007f20 <port_get_irq_status>
 80080a6:	4603      	mov	r3, r0
 80080a8:	4618      	mov	r0, r3
 80080aa:	f7ff ff49 	bl	8007f40 <port_irq_enabled>
 80080ae:	4603      	mov	r3, r0
 80080b0:	f083 0301 	eor.w	r3, r3, #1
 80080b4:	b2db      	uxtb	r3, r3
 80080b6:	2b00      	cmp	r3, #0
 80080b8:	d001      	beq.n	80080be <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 80080ba:	f7ff ffc9 	bl	8008050 <chSysUnlock>
  }
}
 80080be:	bd08      	pop	{r3, pc}

080080c0 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 80080c0:	b082      	sub	sp, #8
 80080c2:	9001      	str	r0, [sp, #4]

  vtp->func = NULL;
 80080c4:	9b01      	ldr	r3, [sp, #4]
 80080c6:	2200      	movs	r2, #0
 80080c8:	60da      	str	r2, [r3, #12]
}
 80080ca:	b002      	add	sp, #8
 80080cc:	4770      	bx	lr
 80080ce:	bf00      	nop

080080d0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80080d0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80080d2:	f7ff ff95 	bl	8008000 <port_timer_get_time>
 80080d6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80080d8:	4618      	mov	r0, r3
 80080da:	bd08      	pop	{r3, pc}
 80080dc:	f3af 8000 	nop.w

080080e0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80080e0:	b082      	sub	sp, #8
 80080e2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->func != NULL);
 80080e4:	9b01      	ldr	r3, [sp, #4]
 80080e6:	68db      	ldr	r3, [r3, #12]
 80080e8:	2b00      	cmp	r3, #0
 80080ea:	bf14      	ite	ne
 80080ec:	2301      	movne	r3, #1
 80080ee:	2300      	moveq	r3, #0
 80080f0:	b2db      	uxtb	r3, r3
}
 80080f2:	4618      	mov	r0, r3
 80080f4:	b002      	add	sp, #8
 80080f6:	4770      	bx	lr
 80080f8:	f3af 8000 	nop.w
 80080fc:	f3af 8000 	nop.w

08008100 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 8008100:	b500      	push	{lr}
 8008102:	b085      	sub	sp, #20
 8008104:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8008106:	f7ff ff9b 	bl	8008040 <chSysLock>
  b = chVTIsArmedI(vtp);
 800810a:	9801      	ldr	r0, [sp, #4]
 800810c:	f7ff ffe8 	bl	80080e0 <chVTIsArmedI>
 8008110:	4603      	mov	r3, r0
 8008112:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8008116:	f7ff ff9b 	bl	8008050 <chSysUnlock>

  return b;
 800811a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800811e:	4618      	mov	r0, r3
 8008120:	b005      	add	sp, #20
 8008122:	f85d fb04 	ldr.w	pc, [sp], #4
 8008126:	bf00      	nop
 8008128:	f3af 8000 	nop.w
 800812c:	f3af 8000 	nop.w

08008130 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8008130:	b500      	push	{lr}
 8008132:	b083      	sub	sp, #12
 8008134:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8008136:	9801      	ldr	r0, [sp, #4]
 8008138:	f7ff ffd2 	bl	80080e0 <chVTIsArmedI>
 800813c:	4603      	mov	r3, r0
 800813e:	2b00      	cmp	r3, #0
 8008140:	d002      	beq.n	8008148 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8008142:	9801      	ldr	r0, [sp, #4]
 8008144:	f7f8 fcf4 	bl	8000b30 <chVTDoResetI>
  }
}
 8008148:	b003      	add	sp, #12
 800814a:	f85d fb04 	ldr.w	pc, [sp], #4
 800814e:	bf00      	nop

08008150 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8008150:	b500      	push	{lr}
 8008152:	b085      	sub	sp, #20
 8008154:	9003      	str	r0, [sp, #12]
 8008156:	9102      	str	r1, [sp, #8]
 8008158:	9201      	str	r2, [sp, #4]
 800815a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800815c:	9803      	ldr	r0, [sp, #12]
 800815e:	f7ff ffe7 	bl	8008130 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8008162:	9803      	ldr	r0, [sp, #12]
 8008164:	9902      	ldr	r1, [sp, #8]
 8008166:	9a01      	ldr	r2, [sp, #4]
 8008168:	9b00      	ldr	r3, [sp, #0]
 800816a:	f7f8 fc51 	bl	8000a10 <chVTDoSetI>
}
 800816e:	b005      	add	sp, #20
 8008170:	f85d fb04 	ldr.w	pc, [sp], #4
 8008174:	f3af 8000 	nop.w
 8008178:	f3af 8000 	nop.w
 800817c:	f3af 8000 	nop.w

08008180 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8008180:	b500      	push	{lr}
 8008182:	b085      	sub	sp, #20
 8008184:	9003      	str	r0, [sp, #12]
 8008186:	9102      	str	r1, [sp, #8]
 8008188:	9201      	str	r2, [sp, #4]
 800818a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800818c:	f7ff ff58 	bl	8008040 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 8008190:	9803      	ldr	r0, [sp, #12]
 8008192:	9902      	ldr	r1, [sp, #8]
 8008194:	9a01      	ldr	r2, [sp, #4]
 8008196:	9b00      	ldr	r3, [sp, #0]
 8008198:	f7ff ffda 	bl	8008150 <chVTSetI>
  chSysUnlock();
 800819c:	f7ff ff58 	bl	8008050 <chSysUnlock>
}
 80081a0:	b005      	add	sp, #20
 80081a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80081a6:	bf00      	nop
 80081a8:	f3af 8000 	nop.w
 80081ac:	f3af 8000 	nop.w

080081b0 <vtcb>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 80081b0:	b500      	push	{lr}
 80081b2:	b085      	sub	sp, #20
 80081b4:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 80081b6:	f7ff ff53 	bl	8008060 <chSysLockFromISR>
  chSysUnlockFromISR();
 80081ba:	f7ff ff59 	bl	8008070 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 80081be:	f7ff ff4f 	bl	8008060 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 80081c2:	f7f8 fb5d 	bl	8000880 <chSysGetStatusAndLockX>
 80081c6:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 80081c8:	9803      	ldr	r0, [sp, #12]
 80081ca:	f7f8 fb79 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 80081ce:	f7ff ff4f 	bl	8008070 <chSysUnlockFromISR>
}
 80081d2:	b005      	add	sp, #20
 80081d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80081d8:	f3af 8000 	nop.w
 80081dc:	f3af 8000 	nop.w

080081e0 <test_002_001_execute>:
 * - [2.1.3] Testing Registry List integrity.
 * - [2.1.4] Testing Port-defined integrity.
 * .
 */

static void test_002_001_execute(void) {
 80081e0:	b500      	push	{lr}
 80081e2:	b083      	sub	sp, #12
  bool result;

  /* [2.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 80081e4:	4b45      	ldr	r3, [pc, #276]	; (80082fc <test_002_001_execute+0x11c>)
 80081e6:	2201      	movs	r2, #1
 80081e8:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 80081ea:	f7ff ff29 	bl	8008040 <chSysLock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80081ee:	2001      	movs	r0, #1
 80081f0:	f7f8 fab6 	bl	8000760 <chSysIntegrityCheckI>
 80081f4:	4603      	mov	r3, r0
 80081f6:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 80081fa:	f7ff ff29 	bl	8008050 <chSysUnlock>
    test_assert(result == false, "ready list check failed");
 80081fe:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008202:	2b00      	cmp	r3, #0
 8008204:	bf14      	ite	ne
 8008206:	2301      	movne	r3, #1
 8008208:	2300      	moveq	r3, #0
 800820a:	b2db      	uxtb	r3, r3
 800820c:	f083 0301 	eor.w	r3, r3, #1
 8008210:	b2db      	uxtb	r3, r3
 8008212:	f003 0301 	and.w	r3, r3, #1
 8008216:	b2db      	uxtb	r3, r3
 8008218:	4618      	mov	r0, r3
 800821a:	4939      	ldr	r1, [pc, #228]	; (8008300 <test_002_001_execute+0x120>)
 800821c:	f7ff f9e8 	bl	80075f0 <_test_assert>
 8008220:	4603      	mov	r3, r0
 8008222:	2b00      	cmp	r3, #0
 8008224:	d000      	beq.n	8008228 <test_002_001_execute+0x48>
 8008226:	e065      	b.n	80082f4 <test_002_001_execute+0x114>
  }

  /* [2.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8008228:	4b34      	ldr	r3, [pc, #208]	; (80082fc <test_002_001_execute+0x11c>)
 800822a:	2202      	movs	r2, #2
 800822c:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800822e:	f7ff ff07 	bl	8008040 <chSysLock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8008232:	2002      	movs	r0, #2
 8008234:	f7f8 fa94 	bl	8000760 <chSysIntegrityCheckI>
 8008238:	4603      	mov	r3, r0
 800823a:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 800823e:	f7ff ff07 	bl	8008050 <chSysUnlock>
    test_assert(result == false, "virtual timers list check failed");
 8008242:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008246:	2b00      	cmp	r3, #0
 8008248:	bf14      	ite	ne
 800824a:	2301      	movne	r3, #1
 800824c:	2300      	moveq	r3, #0
 800824e:	b2db      	uxtb	r3, r3
 8008250:	f083 0301 	eor.w	r3, r3, #1
 8008254:	b2db      	uxtb	r3, r3
 8008256:	f003 0301 	and.w	r3, r3, #1
 800825a:	b2db      	uxtb	r3, r3
 800825c:	4618      	mov	r0, r3
 800825e:	4929      	ldr	r1, [pc, #164]	; (8008304 <test_002_001_execute+0x124>)
 8008260:	f7ff f9c6 	bl	80075f0 <_test_assert>
 8008264:	4603      	mov	r3, r0
 8008266:	2b00      	cmp	r3, #0
 8008268:	d000      	beq.n	800826c <test_002_001_execute+0x8c>
 800826a:	e043      	b.n	80082f4 <test_002_001_execute+0x114>
  }

  /* [2.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 800826c:	4b23      	ldr	r3, [pc, #140]	; (80082fc <test_002_001_execute+0x11c>)
 800826e:	2203      	movs	r2, #3
 8008270:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8008272:	f7ff fee5 	bl	8008040 <chSysLock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8008276:	2004      	movs	r0, #4
 8008278:	f7f8 fa72 	bl	8000760 <chSysIntegrityCheckI>
 800827c:	4603      	mov	r3, r0
 800827e:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 8008282:	f7ff fee5 	bl	8008050 <chSysUnlock>
    test_assert(result == false, "registry list check failed");
 8008286:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800828a:	2b00      	cmp	r3, #0
 800828c:	bf14      	ite	ne
 800828e:	2301      	movne	r3, #1
 8008290:	2300      	moveq	r3, #0
 8008292:	b2db      	uxtb	r3, r3
 8008294:	f083 0301 	eor.w	r3, r3, #1
 8008298:	b2db      	uxtb	r3, r3
 800829a:	f003 0301 	and.w	r3, r3, #1
 800829e:	b2db      	uxtb	r3, r3
 80082a0:	4618      	mov	r0, r3
 80082a2:	4919      	ldr	r1, [pc, #100]	; (8008308 <test_002_001_execute+0x128>)
 80082a4:	f7ff f9a4 	bl	80075f0 <_test_assert>
 80082a8:	4603      	mov	r3, r0
 80082aa:	2b00      	cmp	r3, #0
 80082ac:	d000      	beq.n	80082b0 <test_002_001_execute+0xd0>
 80082ae:	e021      	b.n	80082f4 <test_002_001_execute+0x114>
  }

  /* [2.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 80082b0:	4b12      	ldr	r3, [pc, #72]	; (80082fc <test_002_001_execute+0x11c>)
 80082b2:	2204      	movs	r2, #4
 80082b4:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 80082b6:	f7ff fec3 	bl	8008040 <chSysLock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80082ba:	2008      	movs	r0, #8
 80082bc:	f7f8 fa50 	bl	8000760 <chSysIntegrityCheckI>
 80082c0:	4603      	mov	r3, r0
 80082c2:	f88d 3007 	strb.w	r3, [sp, #7]
    chSysUnlock();
 80082c6:	f7ff fec3 	bl	8008050 <chSysUnlock>
    test_assert(result == false, "port layer check failed");
 80082ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80082ce:	2b00      	cmp	r3, #0
 80082d0:	bf14      	ite	ne
 80082d2:	2301      	movne	r3, #1
 80082d4:	2300      	moveq	r3, #0
 80082d6:	b2db      	uxtb	r3, r3
 80082d8:	f083 0301 	eor.w	r3, r3, #1
 80082dc:	b2db      	uxtb	r3, r3
 80082de:	f003 0301 	and.w	r3, r3, #1
 80082e2:	b2db      	uxtb	r3, r3
 80082e4:	4618      	mov	r0, r3
 80082e6:	4909      	ldr	r1, [pc, #36]	; (800830c <test_002_001_execute+0x12c>)
 80082e8:	f7ff f982 	bl	80075f0 <_test_assert>
 80082ec:	4603      	mov	r3, r0
 80082ee:	2b00      	cmp	r3, #0
 80082f0:	d000      	beq.n	80082f4 <test_002_001_execute+0x114>
 80082f2:	bf00      	nop
  }
}
 80082f4:	b003      	add	sp, #12
 80082f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80082fa:	bf00      	nop
 80082fc:	20000cac 	.word	0x20000cac
 8008300:	0800e80c 	.word	0x0800e80c
 8008304:	0800e824 	.word	0x0800e824
 8008308:	0800e848 	.word	0x0800e848
 800830c:	0800e864 	.word	0x0800e864

08008310 <test_002_002_execute>:
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_002_002_execute(void) {
 8008310:	b500      	push	{lr}
 8008312:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8008314:	4b28      	ldr	r3, [pc, #160]	; (80083b8 <test_002_002_execute+0xa8>)
 8008316:	2201      	movs	r2, #1
 8008318:	601a      	str	r2, [r3, #0]
  {
    sts = chSysGetStatusAndLockX();
 800831a:	f7f8 fab1 	bl	8000880 <chSysGetStatusAndLockX>
 800831e:	9005      	str	r0, [sp, #20]
    chSysRestoreStatusX(sts);
 8008320:	9805      	ldr	r0, [sp, #20]
 8008322:	f7f8 facd 	bl	80008c0 <chSysRestoreStatusX>
  }

  /* [2.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 8008326:	4b24      	ldr	r3, [pc, #144]	; (80083b8 <test_002_002_execute+0xa8>)
 8008328:	2202      	movs	r2, #2
 800832a:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800832c:	f7ff fe88 	bl	8008040 <chSysLock>
    sts = chSysGetStatusAndLockX();
 8008330:	f7f8 faa6 	bl	8000880 <chSysGetStatusAndLockX>
 8008334:	9005      	str	r0, [sp, #20]
    chSysRestoreStatusX(sts);
 8008336:	9805      	ldr	r0, [sp, #20]
 8008338:	f7f8 fac2 	bl	80008c0 <chSysRestoreStatusX>
    chSysUnlock();
 800833c:	f7ff fe88 	bl	8008050 <chSysUnlock>
  }

  /* [2.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 8008340:	4b1d      	ldr	r3, [pc, #116]	; (80083b8 <test_002_002_execute+0xa8>)
 8008342:	2203      	movs	r2, #3
 8008344:	601a      	str	r2, [r3, #0]
  {
    chSysUnconditionalLock();
 8008346:	f7ff fe9b 	bl	8008080 <chSysUnconditionalLock>
    chSysUnconditionalLock();
 800834a:	f7ff fe99 	bl	8008080 <chSysUnconditionalLock>
    chSysUnlock();
 800834e:	f7ff fe7f 	bl	8008050 <chSysUnlock>
  }

  /* [2.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8008352:	4b19      	ldr	r3, [pc, #100]	; (80083b8 <test_002_002_execute+0xa8>)
 8008354:	2204      	movs	r2, #4
 8008356:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8008358:	f7ff fe72 	bl	8008040 <chSysLock>
    chSysUnconditionalUnlock();
 800835c:	f7ff fea0 	bl	80080a0 <chSysUnconditionalUnlock>
    chSysUnconditionalUnlock();
 8008360:	f7ff fe9e 	bl	80080a0 <chSysUnconditionalUnlock>
  }

  /* [2.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8008364:	4b14      	ldr	r3, [pc, #80]	; (80083b8 <test_002_002_execute+0xa8>)
 8008366:	2205      	movs	r2, #5
 8008368:	601a      	str	r2, [r3, #0]
  {
    chVTObjectInit(&vt);
 800836a:	466b      	mov	r3, sp
 800836c:	4618      	mov	r0, r3
 800836e:	f7ff fea7 	bl	80080c0 <chVTObjectInit>
    chVTSet(&vt, 1, vtcb, NULL);
 8008372:	466b      	mov	r3, sp
 8008374:	4618      	mov	r0, r3
 8008376:	2101      	movs	r1, #1
 8008378:	4a10      	ldr	r2, [pc, #64]	; (80083bc <test_002_002_execute+0xac>)
 800837a:	2300      	movs	r3, #0
 800837c:	f7ff ff00 	bl	8008180 <chVTSet>
    chThdSleep(10);
 8008380:	200a      	movs	r0, #10
 8008382:	f7f9 f9cd 	bl	8001720 <chThdSleep>

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8008386:	466b      	mov	r3, sp
 8008388:	4618      	mov	r0, r3
 800838a:	f7ff feb9 	bl	8008100 <chVTIsArmed>
 800838e:	4603      	mov	r3, r0
 8008390:	2b00      	cmp	r3, #0
 8008392:	bf14      	ite	ne
 8008394:	2301      	movne	r3, #1
 8008396:	2300      	moveq	r3, #0
 8008398:	b2db      	uxtb	r3, r3
 800839a:	f083 0301 	eor.w	r3, r3, #1
 800839e:	b2db      	uxtb	r3, r3
 80083a0:	f003 0301 	and.w	r3, r3, #1
 80083a4:	b2db      	uxtb	r3, r3
 80083a6:	4618      	mov	r0, r3
 80083a8:	4905      	ldr	r1, [pc, #20]	; (80083c0 <test_002_002_execute+0xb0>)
 80083aa:	f7ff f921 	bl	80075f0 <_test_assert>
 80083ae:	4603      	mov	r3, r0
 80083b0:	2b00      	cmp	r3, #0
  }
}
 80083b2:	b007      	add	sp, #28
 80083b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80083b8:	20000cac 	.word	0x20000cac
 80083bc:	080081b1 	.word	0x080081b1
 80083c0:	0800e8ac 	.word	0x0800e8ac
 80083c4:	f3af 8000 	nop.w
 80083c8:	f3af 8000 	nop.w
 80083cc:	f3af 8000 	nop.w

080083d0 <test_002_003_execute>:
 * <h2>Test Steps</h2>
 * - [2.3.1] Testing chSysSuspend(), chSysDisable() and chSysEnable().
 * .
 */

static void test_002_003_execute(void) {
 80083d0:	b508      	push	{r3, lr}

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 80083d2:	4b06      	ldr	r3, [pc, #24]	; (80083ec <test_002_003_execute+0x1c>)
 80083d4:	2201      	movs	r2, #1
 80083d6:	601a      	str	r2, [r3, #0]
  {
    chSysSuspend();
 80083d8:	f7ff fe22 	bl	8008020 <chSysSuspend>
    chSysDisable();
 80083dc:	f7ff fe18 	bl	8008010 <chSysDisable>
    chSysSuspend();
 80083e0:	f7ff fe1e 	bl	8008020 <chSysSuspend>
    chSysEnable();
 80083e4:	f7ff fe24 	bl	8008030 <chSysEnable>
  }
}
 80083e8:	bd08      	pop	{r3, pc}
 80083ea:	bf00      	nop
 80083ec:	20000cac 	.word	0x20000cac

080083f0 <test_002_004_execute>:
 * - [2.4.1] A System Tick Counter increment is expected, the test
 *   simply hangs if it does not happen.
 * .
 */

static void test_002_004_execute(void) {
 80083f0:	b500      	push	{lr}
 80083f2:	b083      	sub	sp, #12

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 80083f4:	4b07      	ldr	r3, [pc, #28]	; (8008414 <test_002_004_execute+0x24>)
 80083f6:	2201      	movs	r2, #1
 80083f8:	601a      	str	r2, [r3, #0]
  {
    systime_t time = chVTGetSystemTimeX();
 80083fa:	f7ff fe69 	bl	80080d0 <chVTGetSystemTimeX>
 80083fe:	9001      	str	r0, [sp, #4]
    while (time == chVTGetSystemTimeX()) {
 8008400:	bf00      	nop
 8008402:	f7ff fe65 	bl	80080d0 <chVTGetSystemTimeX>
 8008406:	4602      	mov	r2, r0
 8008408:	9b01      	ldr	r3, [sp, #4]
 800840a:	429a      	cmp	r2, r3
 800840c:	d0f9      	beq.n	8008402 <test_002_004_execute+0x12>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 800840e:	b003      	add	sp, #12
 8008410:	f85d fb04 	ldr.w	pc, [sp], #4
 8008414:	20000cac 	.word	0x20000cac
	...

08008420 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008420:	b082      	sub	sp, #8
 8008422:	2320      	movs	r3, #32
 8008424:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008426:	9b01      	ldr	r3, [sp, #4]
 8008428:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800842c:	b002      	add	sp, #8
 800842e:	4770      	bx	lr

08008430 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008430:	b082      	sub	sp, #8
 8008432:	2300      	movs	r3, #0
 8008434:	9301      	str	r3, [sp, #4]
 8008436:	9b01      	ldr	r3, [sp, #4]
 8008438:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800843c:	b002      	add	sp, #8
 800843e:	4770      	bx	lr

08008440 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8008440:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8008446:	4618      	mov	r0, r3
 8008448:	4770      	bx	lr
 800844a:	bf00      	nop
 800844c:	f3af 8000 	nop.w

08008450 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8008450:	b508      	push	{r3, lr}

  return stGetCounter();
 8008452:	f7ff fff5 	bl	8008440 <st_lld_get_counter>
 8008456:	4603      	mov	r3, r0
}
 8008458:	4618      	mov	r0, r3
 800845a:	bd08      	pop	{r3, pc}
 800845c:	f3af 8000 	nop.w

08008460 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008460:	b508      	push	{r3, lr}

  port_lock();
 8008462:	f7ff ffdd 	bl	8008420 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8008466:	bd08      	pop	{r3, pc}
 8008468:	f3af 8000 	nop.w
 800846c:	f3af 8000 	nop.w

08008470 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008470:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008472:	f7ff ffdd 	bl	8008430 <port_unlock>
}
 8008476:	bd08      	pop	{r3, pc}
 8008478:	f3af 8000 	nop.w
 800847c:	f3af 8000 	nop.w

08008480 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8008480:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8008482:	f7ff ffe5 	bl	8008450 <port_timer_get_time>
 8008486:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8008488:	4618      	mov	r0, r3
 800848a:	bd08      	pop	{r3, pc}
 800848c:	f3af 8000 	nop.w

08008490 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8008490:	4b01      	ldr	r3, [pc, #4]	; (8008498 <chThdGetSelfX+0x8>)
 8008492:	699b      	ldr	r3, [r3, #24]
}
 8008494:	4618      	mov	r0, r3
 8008496:	4770      	bx	lr
 8008498:	20000af8 	.word	0x20000af8
 800849c:	f3af 8000 	nop.w

080084a0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80084a0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 80084a2:	f7ff fff5 	bl	8008490 <chThdGetSelfX>
 80084a6:	4603      	mov	r3, r0
 80084a8:	689b      	ldr	r3, [r3, #8]
}
 80084aa:	4618      	mov	r0, r3
 80084ac:	bd08      	pop	{r3, pc}
 80084ae:	bf00      	nop

080084b0 <thread>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {
 80084b0:	b500      	push	{lr}
 80084b2:	b083      	sub	sp, #12
 80084b4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 80084b6:	9b01      	ldr	r3, [sp, #4]
 80084b8:	781b      	ldrb	r3, [r3, #0]
 80084ba:	4618      	mov	r0, r3
 80084bc:	f7ff f978 	bl	80077b0 <test_emit_token>
}
 80084c0:	b003      	add	sp, #12
 80084c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80084c6:	bf00      	nop
 80084c8:	f3af 8000 	nop.w
 80084cc:	f3af 8000 	nop.w

080084d0 <test_003_001_execute>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void test_003_001_execute(void) {
 80084d0:	b500      	push	{lr}
 80084d2:	b083      	sub	sp, #12
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 80084d4:	4b3f      	ldr	r3, [pc, #252]	; (80085d4 <test_003_001_execute+0x104>)
 80084d6:	2201      	movs	r2, #1
 80084d8:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 80084da:	f7ff ffd1 	bl	8008480 <chVTGetSystemTimeX>
 80084de:	9001      	str	r0, [sp, #4]
    chThdSleep(100);
 80084e0:	2064      	movs	r0, #100	; 0x64
 80084e2:	f7f9 f91d 	bl	8001720 <chThdSleep>
    test_assert_time_window(time + 100,
 80084e6:	9b01      	ldr	r3, [sp, #4]
 80084e8:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80084ec:	9b01      	ldr	r3, [sp, #4]
 80084ee:	3367      	adds	r3, #103	; 0x67
 80084f0:	4610      	mov	r0, r2
 80084f2:	4619      	mov	r1, r3
 80084f4:	4a38      	ldr	r2, [pc, #224]	; (80085d8 <test_003_001_execute+0x108>)
 80084f6:	f7ff f8c3 	bl	8007680 <_test_assert_time_window>
 80084fa:	4603      	mov	r3, r0
 80084fc:	2b00      	cmp	r3, #0
 80084fe:	d000      	beq.n	8008502 <test_003_001_execute+0x32>
 8008500:	e065      	b.n	80085ce <test_003_001_execute+0xfe>
  }

  /* [3.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8008502:	4b34      	ldr	r3, [pc, #208]	; (80085d4 <test_003_001_execute+0x104>)
 8008504:	2202      	movs	r2, #2
 8008506:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 8008508:	f7ff ffba 	bl	8008480 <chVTGetSystemTimeX>
 800850c:	9001      	str	r0, [sp, #4]
    chThdSleepMicroseconds(100000);
 800850e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008512:	f7f9 f905 	bl	8001720 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 8008516:	9b01      	ldr	r3, [sp, #4]
 8008518:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800851c:	9b01      	ldr	r3, [sp, #4]
 800851e:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 8008522:	4610      	mov	r0, r2
 8008524:	4619      	mov	r1, r3
 8008526:	4a2c      	ldr	r2, [pc, #176]	; (80085d8 <test_003_001_execute+0x108>)
 8008528:	f7ff f8aa 	bl	8007680 <_test_assert_time_window>
 800852c:	4603      	mov	r3, r0
 800852e:	2b00      	cmp	r3, #0
 8008530:	d000      	beq.n	8008534 <test_003_001_execute+0x64>
 8008532:	e04c      	b.n	80085ce <test_003_001_execute+0xfe>
  }

  /* [3.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8008534:	4b27      	ldr	r3, [pc, #156]	; (80085d4 <test_003_001_execute+0x104>)
 8008536:	2203      	movs	r2, #3
 8008538:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 800853a:	f7ff ffa1 	bl	8008480 <chVTGetSystemTimeX>
 800853e:	9001      	str	r0, [sp, #4]
    chThdSleepMilliseconds(100);
 8008540:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008544:	f7f9 f8ec 	bl	8001720 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 8008548:	9b01      	ldr	r3, [sp, #4]
 800854a:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800854e:	9b01      	ldr	r3, [sp, #4]
 8008550:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 8008554:	4610      	mov	r0, r2
 8008556:	4619      	mov	r1, r3
 8008558:	4a1f      	ldr	r2, [pc, #124]	; (80085d8 <test_003_001_execute+0x108>)
 800855a:	f7ff f891 	bl	8007680 <_test_assert_time_window>
 800855e:	4603      	mov	r3, r0
 8008560:	2b00      	cmp	r3, #0
 8008562:	d000      	beq.n	8008566 <test_003_001_execute+0x96>
 8008564:	e033      	b.n	80085ce <test_003_001_execute+0xfe>
                            "out of time window");
  }

  /* [3.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 8008566:	4b1b      	ldr	r3, [pc, #108]	; (80085d4 <test_003_001_execute+0x104>)
 8008568:	2204      	movs	r2, #4
 800856a:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 800856c:	f7ff ff88 	bl	8008480 <chVTGetSystemTimeX>
 8008570:	9001      	str	r0, [sp, #4]
    chThdSleepSeconds(1);
 8008572:	f242 7010 	movw	r0, #10000	; 0x2710
 8008576:	f7f9 f8d3 	bl	8001720 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 800857a:	9b01      	ldr	r3, [sp, #4]
 800857c:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 8008580:	3210      	adds	r2, #16
 8008582:	9b01      	ldr	r3, [sp, #4]
 8008584:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 8008588:	3313      	adds	r3, #19
 800858a:	4610      	mov	r0, r2
 800858c:	4619      	mov	r1, r3
 800858e:	4a12      	ldr	r2, [pc, #72]	; (80085d8 <test_003_001_execute+0x108>)
 8008590:	f7ff f876 	bl	8007680 <_test_assert_time_window>
 8008594:	4603      	mov	r3, r0
 8008596:	2b00      	cmp	r3, #0
 8008598:	d000      	beq.n	800859c <test_003_001_execute+0xcc>
 800859a:	e018      	b.n	80085ce <test_003_001_execute+0xfe>
                            "out of time window");
  }

  /* [3.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 800859c:	4b0d      	ldr	r3, [pc, #52]	; (80085d4 <test_003_001_execute+0x104>)
 800859e:	2205      	movs	r2, #5
 80085a0:	601a      	str	r2, [r3, #0]
  {
    time = chVTGetSystemTimeX();
 80085a2:	f7ff ff6d 	bl	8008480 <chVTGetSystemTimeX>
 80085a6:	9001      	str	r0, [sp, #4]
    chThdSleepUntil(time + 100);
 80085a8:	9b01      	ldr	r3, [sp, #4]
 80085aa:	3364      	adds	r3, #100	; 0x64
 80085ac:	4618      	mov	r0, r3
 80085ae:	f7f9 f8c7 	bl	8001740 <chThdSleepUntil>
    test_assert_time_window(time + 100,
 80085b2:	9b01      	ldr	r3, [sp, #4]
 80085b4:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80085b8:	9b01      	ldr	r3, [sp, #4]
 80085ba:	3367      	adds	r3, #103	; 0x67
 80085bc:	4610      	mov	r0, r2
 80085be:	4619      	mov	r1, r3
 80085c0:	4a05      	ldr	r2, [pc, #20]	; (80085d8 <test_003_001_execute+0x108>)
 80085c2:	f7ff f85d 	bl	8007680 <_test_assert_time_window>
 80085c6:	4603      	mov	r3, r0
 80085c8:	2b00      	cmp	r3, #0
 80085ca:	d000      	beq.n	80085ce <test_003_001_execute+0xfe>
 80085cc:	bf00      	nop
                            time + 100 + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
  }
}
 80085ce:	b003      	add	sp, #12
 80085d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80085d4:	20000cac 	.word	0x20000cac
 80085d8:	0800e96c 	.word	0x0800e96c
 80085dc:	f3af 8000 	nop.w

080085e0 <test_003_002_execute>:
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void test_003_002_execute(void) {
 80085e0:	b510      	push	{r4, lr}
 80085e2:	b082      	sub	sp, #8

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80085e4:	4b93      	ldr	r3, [pc, #588]	; (8008834 <test_003_002_execute+0x254>)
 80085e6:	2201      	movs	r2, #1
 80085e8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80085ea:	4b93      	ldr	r3, [pc, #588]	; (8008838 <test_003_002_execute+0x258>)
 80085ec:	681c      	ldr	r4, [r3, #0]
 80085ee:	f7ff ff57 	bl	80084a0 <chThdGetPriorityX>
 80085f2:	4603      	mov	r3, r0
 80085f4:	1f5a      	subs	r2, r3, #5
 80085f6:	4b91      	ldr	r3, [pc, #580]	; (800883c <test_003_002_execute+0x25c>)
 80085f8:	9300      	str	r3, [sp, #0]
 80085fa:	4620      	mov	r0, r4
 80085fc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008600:	4b8f      	ldr	r3, [pc, #572]	; (8008840 <test_003_002_execute+0x260>)
 8008602:	f7f8 ff25 	bl	8001450 <chThdCreateStatic>
 8008606:	4602      	mov	r2, r0
 8008608:	4b8e      	ldr	r3, [pc, #568]	; (8008844 <test_003_002_execute+0x264>)
 800860a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800860c:	4b8a      	ldr	r3, [pc, #552]	; (8008838 <test_003_002_execute+0x258>)
 800860e:	685c      	ldr	r4, [r3, #4]
 8008610:	f7ff ff46 	bl	80084a0 <chThdGetPriorityX>
 8008614:	4603      	mov	r3, r0
 8008616:	1f1a      	subs	r2, r3, #4
 8008618:	4b8b      	ldr	r3, [pc, #556]	; (8008848 <test_003_002_execute+0x268>)
 800861a:	9300      	str	r3, [sp, #0]
 800861c:	4620      	mov	r0, r4
 800861e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008622:	4b87      	ldr	r3, [pc, #540]	; (8008840 <test_003_002_execute+0x260>)
 8008624:	f7f8 ff14 	bl	8001450 <chThdCreateStatic>
 8008628:	4602      	mov	r2, r0
 800862a:	4b86      	ldr	r3, [pc, #536]	; (8008844 <test_003_002_execute+0x264>)
 800862c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800862e:	4b82      	ldr	r3, [pc, #520]	; (8008838 <test_003_002_execute+0x258>)
 8008630:	689c      	ldr	r4, [r3, #8]
 8008632:	f7ff ff35 	bl	80084a0 <chThdGetPriorityX>
 8008636:	4603      	mov	r3, r0
 8008638:	1eda      	subs	r2, r3, #3
 800863a:	4b84      	ldr	r3, [pc, #528]	; (800884c <test_003_002_execute+0x26c>)
 800863c:	9300      	str	r3, [sp, #0]
 800863e:	4620      	mov	r0, r4
 8008640:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008644:	4b7e      	ldr	r3, [pc, #504]	; (8008840 <test_003_002_execute+0x260>)
 8008646:	f7f8 ff03 	bl	8001450 <chThdCreateStatic>
 800864a:	4602      	mov	r2, r0
 800864c:	4b7d      	ldr	r3, [pc, #500]	; (8008844 <test_003_002_execute+0x264>)
 800864e:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8008650:	4b79      	ldr	r3, [pc, #484]	; (8008838 <test_003_002_execute+0x258>)
 8008652:	68dc      	ldr	r4, [r3, #12]
 8008654:	f7ff ff24 	bl	80084a0 <chThdGetPriorityX>
 8008658:	4603      	mov	r3, r0
 800865a:	1e9a      	subs	r2, r3, #2
 800865c:	4b7c      	ldr	r3, [pc, #496]	; (8008850 <test_003_002_execute+0x270>)
 800865e:	9300      	str	r3, [sp, #0]
 8008660:	4620      	mov	r0, r4
 8008662:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008666:	4b76      	ldr	r3, [pc, #472]	; (8008840 <test_003_002_execute+0x260>)
 8008668:	f7f8 fef2 	bl	8001450 <chThdCreateStatic>
 800866c:	4602      	mov	r2, r0
 800866e:	4b75      	ldr	r3, [pc, #468]	; (8008844 <test_003_002_execute+0x264>)
 8008670:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8008672:	4b71      	ldr	r3, [pc, #452]	; (8008838 <test_003_002_execute+0x258>)
 8008674:	691c      	ldr	r4, [r3, #16]
 8008676:	f7ff ff13 	bl	80084a0 <chThdGetPriorityX>
 800867a:	4603      	mov	r3, r0
 800867c:	1e5a      	subs	r2, r3, #1
 800867e:	4b75      	ldr	r3, [pc, #468]	; (8008854 <test_003_002_execute+0x274>)
 8008680:	9300      	str	r3, [sp, #0]
 8008682:	4620      	mov	r0, r4
 8008684:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008688:	4b6d      	ldr	r3, [pc, #436]	; (8008840 <test_003_002_execute+0x260>)
 800868a:	f7f8 fee1 	bl	8001450 <chThdCreateStatic>
 800868e:	4602      	mov	r2, r0
 8008690:	4b6c      	ldr	r3, [pc, #432]	; (8008844 <test_003_002_execute+0x264>)
 8008692:	611a      	str	r2, [r3, #16]
    test_wait_threads();
 8008694:	f7ff fa44 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008698:	486f      	ldr	r0, [pc, #444]	; (8008858 <test_003_002_execute+0x278>)
 800869a:	4970      	ldr	r1, [pc, #448]	; (800885c <test_003_002_execute+0x27c>)
 800869c:	f7fe ffc0 	bl	8007620 <_test_assert_sequence>
 80086a0:	4603      	mov	r3, r0
 80086a2:	2b00      	cmp	r3, #0
 80086a4:	d000      	beq.n	80086a8 <test_003_002_execute+0xc8>
 80086a6:	e0c3      	b.n	8008830 <test_003_002_execute+0x250>
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 80086a8:	4b62      	ldr	r3, [pc, #392]	; (8008834 <test_003_002_execute+0x254>)
 80086aa:	2202      	movs	r2, #2
 80086ac:	601a      	str	r2, [r3, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80086ae:	4b62      	ldr	r3, [pc, #392]	; (8008838 <test_003_002_execute+0x258>)
 80086b0:	691c      	ldr	r4, [r3, #16]
 80086b2:	f7ff fef5 	bl	80084a0 <chThdGetPriorityX>
 80086b6:	4603      	mov	r3, r0
 80086b8:	1e5a      	subs	r2, r3, #1
 80086ba:	4b66      	ldr	r3, [pc, #408]	; (8008854 <test_003_002_execute+0x274>)
 80086bc:	9300      	str	r3, [sp, #0]
 80086be:	4620      	mov	r0, r4
 80086c0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80086c4:	4b5e      	ldr	r3, [pc, #376]	; (8008840 <test_003_002_execute+0x260>)
 80086c6:	f7f8 fec3 	bl	8001450 <chThdCreateStatic>
 80086ca:	4602      	mov	r2, r0
 80086cc:	4b5d      	ldr	r3, [pc, #372]	; (8008844 <test_003_002_execute+0x264>)
 80086ce:	611a      	str	r2, [r3, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80086d0:	4b59      	ldr	r3, [pc, #356]	; (8008838 <test_003_002_execute+0x258>)
 80086d2:	68dc      	ldr	r4, [r3, #12]
 80086d4:	f7ff fee4 	bl	80084a0 <chThdGetPriorityX>
 80086d8:	4603      	mov	r3, r0
 80086da:	1e9a      	subs	r2, r3, #2
 80086dc:	4b5c      	ldr	r3, [pc, #368]	; (8008850 <test_003_002_execute+0x270>)
 80086de:	9300      	str	r3, [sp, #0]
 80086e0:	4620      	mov	r0, r4
 80086e2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80086e6:	4b56      	ldr	r3, [pc, #344]	; (8008840 <test_003_002_execute+0x260>)
 80086e8:	f7f8 feb2 	bl	8001450 <chThdCreateStatic>
 80086ec:	4602      	mov	r2, r0
 80086ee:	4b55      	ldr	r3, [pc, #340]	; (8008844 <test_003_002_execute+0x264>)
 80086f0:	60da      	str	r2, [r3, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80086f2:	4b51      	ldr	r3, [pc, #324]	; (8008838 <test_003_002_execute+0x258>)
 80086f4:	689c      	ldr	r4, [r3, #8]
 80086f6:	f7ff fed3 	bl	80084a0 <chThdGetPriorityX>
 80086fa:	4603      	mov	r3, r0
 80086fc:	1eda      	subs	r2, r3, #3
 80086fe:	4b53      	ldr	r3, [pc, #332]	; (800884c <test_003_002_execute+0x26c>)
 8008700:	9300      	str	r3, [sp, #0]
 8008702:	4620      	mov	r0, r4
 8008704:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008708:	4b4d      	ldr	r3, [pc, #308]	; (8008840 <test_003_002_execute+0x260>)
 800870a:	f7f8 fea1 	bl	8001450 <chThdCreateStatic>
 800870e:	4602      	mov	r2, r0
 8008710:	4b4c      	ldr	r3, [pc, #304]	; (8008844 <test_003_002_execute+0x264>)
 8008712:	609a      	str	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8008714:	4b48      	ldr	r3, [pc, #288]	; (8008838 <test_003_002_execute+0x258>)
 8008716:	685c      	ldr	r4, [r3, #4]
 8008718:	f7ff fec2 	bl	80084a0 <chThdGetPriorityX>
 800871c:	4603      	mov	r3, r0
 800871e:	1f1a      	subs	r2, r3, #4
 8008720:	4b49      	ldr	r3, [pc, #292]	; (8008848 <test_003_002_execute+0x268>)
 8008722:	9300      	str	r3, [sp, #0]
 8008724:	4620      	mov	r0, r4
 8008726:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800872a:	4b45      	ldr	r3, [pc, #276]	; (8008840 <test_003_002_execute+0x260>)
 800872c:	f7f8 fe90 	bl	8001450 <chThdCreateStatic>
 8008730:	4602      	mov	r2, r0
 8008732:	4b44      	ldr	r3, [pc, #272]	; (8008844 <test_003_002_execute+0x264>)
 8008734:	605a      	str	r2, [r3, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8008736:	4b40      	ldr	r3, [pc, #256]	; (8008838 <test_003_002_execute+0x258>)
 8008738:	681c      	ldr	r4, [r3, #0]
 800873a:	f7ff feb1 	bl	80084a0 <chThdGetPriorityX>
 800873e:	4603      	mov	r3, r0
 8008740:	1f5a      	subs	r2, r3, #5
 8008742:	4b3e      	ldr	r3, [pc, #248]	; (800883c <test_003_002_execute+0x25c>)
 8008744:	9300      	str	r3, [sp, #0]
 8008746:	4620      	mov	r0, r4
 8008748:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800874c:	4b3c      	ldr	r3, [pc, #240]	; (8008840 <test_003_002_execute+0x260>)
 800874e:	f7f8 fe7f 	bl	8001450 <chThdCreateStatic>
 8008752:	4602      	mov	r2, r0
 8008754:	4b3b      	ldr	r3, [pc, #236]	; (8008844 <test_003_002_execute+0x264>)
 8008756:	601a      	str	r2, [r3, #0]
    test_wait_threads();
 8008758:	f7ff f9e2 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800875c:	483e      	ldr	r0, [pc, #248]	; (8008858 <test_003_002_execute+0x278>)
 800875e:	493f      	ldr	r1, [pc, #252]	; (800885c <test_003_002_execute+0x27c>)
 8008760:	f7fe ff5e 	bl	8007620 <_test_assert_sequence>
 8008764:	4603      	mov	r3, r0
 8008766:	2b00      	cmp	r3, #0
 8008768:	d000      	beq.n	800876c <test_003_002_execute+0x18c>
 800876a:	e061      	b.n	8008830 <test_003_002_execute+0x250>
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 800876c:	4b31      	ldr	r3, [pc, #196]	; (8008834 <test_003_002_execute+0x254>)
 800876e:	2203      	movs	r2, #3
 8008770:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8008772:	4b31      	ldr	r3, [pc, #196]	; (8008838 <test_003_002_execute+0x258>)
 8008774:	685c      	ldr	r4, [r3, #4]
 8008776:	f7ff fe93 	bl	80084a0 <chThdGetPriorityX>
 800877a:	4603      	mov	r3, r0
 800877c:	1f1a      	subs	r2, r3, #4
 800877e:	4b32      	ldr	r3, [pc, #200]	; (8008848 <test_003_002_execute+0x268>)
 8008780:	9300      	str	r3, [sp, #0]
 8008782:	4620      	mov	r0, r4
 8008784:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008788:	4b2d      	ldr	r3, [pc, #180]	; (8008840 <test_003_002_execute+0x260>)
 800878a:	f7f8 fe61 	bl	8001450 <chThdCreateStatic>
 800878e:	4602      	mov	r2, r0
 8008790:	4b2c      	ldr	r3, [pc, #176]	; (8008844 <test_003_002_execute+0x264>)
 8008792:	605a      	str	r2, [r3, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8008794:	4b28      	ldr	r3, [pc, #160]	; (8008838 <test_003_002_execute+0x258>)
 8008796:	681c      	ldr	r4, [r3, #0]
 8008798:	f7ff fe82 	bl	80084a0 <chThdGetPriorityX>
 800879c:	4603      	mov	r3, r0
 800879e:	1f5a      	subs	r2, r3, #5
 80087a0:	4b26      	ldr	r3, [pc, #152]	; (800883c <test_003_002_execute+0x25c>)
 80087a2:	9300      	str	r3, [sp, #0]
 80087a4:	4620      	mov	r0, r4
 80087a6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80087aa:	4b25      	ldr	r3, [pc, #148]	; (8008840 <test_003_002_execute+0x260>)
 80087ac:	f7f8 fe50 	bl	8001450 <chThdCreateStatic>
 80087b0:	4602      	mov	r2, r0
 80087b2:	4b24      	ldr	r3, [pc, #144]	; (8008844 <test_003_002_execute+0x264>)
 80087b4:	601a      	str	r2, [r3, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80087b6:	4b20      	ldr	r3, [pc, #128]	; (8008838 <test_003_002_execute+0x258>)
 80087b8:	691c      	ldr	r4, [r3, #16]
 80087ba:	f7ff fe71 	bl	80084a0 <chThdGetPriorityX>
 80087be:	4603      	mov	r3, r0
 80087c0:	1e5a      	subs	r2, r3, #1
 80087c2:	4b24      	ldr	r3, [pc, #144]	; (8008854 <test_003_002_execute+0x274>)
 80087c4:	9300      	str	r3, [sp, #0]
 80087c6:	4620      	mov	r0, r4
 80087c8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80087cc:	4b1c      	ldr	r3, [pc, #112]	; (8008840 <test_003_002_execute+0x260>)
 80087ce:	f7f8 fe3f 	bl	8001450 <chThdCreateStatic>
 80087d2:	4602      	mov	r2, r0
 80087d4:	4b1b      	ldr	r3, [pc, #108]	; (8008844 <test_003_002_execute+0x264>)
 80087d6:	611a      	str	r2, [r3, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80087d8:	4b17      	ldr	r3, [pc, #92]	; (8008838 <test_003_002_execute+0x258>)
 80087da:	68dc      	ldr	r4, [r3, #12]
 80087dc:	f7ff fe60 	bl	80084a0 <chThdGetPriorityX>
 80087e0:	4603      	mov	r3, r0
 80087e2:	1e9a      	subs	r2, r3, #2
 80087e4:	4b1a      	ldr	r3, [pc, #104]	; (8008850 <test_003_002_execute+0x270>)
 80087e6:	9300      	str	r3, [sp, #0]
 80087e8:	4620      	mov	r0, r4
 80087ea:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80087ee:	4b14      	ldr	r3, [pc, #80]	; (8008840 <test_003_002_execute+0x260>)
 80087f0:	f7f8 fe2e 	bl	8001450 <chThdCreateStatic>
 80087f4:	4602      	mov	r2, r0
 80087f6:	4b13      	ldr	r3, [pc, #76]	; (8008844 <test_003_002_execute+0x264>)
 80087f8:	60da      	str	r2, [r3, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80087fa:	4b0f      	ldr	r3, [pc, #60]	; (8008838 <test_003_002_execute+0x258>)
 80087fc:	689c      	ldr	r4, [r3, #8]
 80087fe:	f7ff fe4f 	bl	80084a0 <chThdGetPriorityX>
 8008802:	4603      	mov	r3, r0
 8008804:	1eda      	subs	r2, r3, #3
 8008806:	4b11      	ldr	r3, [pc, #68]	; (800884c <test_003_002_execute+0x26c>)
 8008808:	9300      	str	r3, [sp, #0]
 800880a:	4620      	mov	r0, r4
 800880c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008810:	4b0b      	ldr	r3, [pc, #44]	; (8008840 <test_003_002_execute+0x260>)
 8008812:	f7f8 fe1d 	bl	8001450 <chThdCreateStatic>
 8008816:	4602      	mov	r2, r0
 8008818:	4b0a      	ldr	r3, [pc, #40]	; (8008844 <test_003_002_execute+0x264>)
 800881a:	609a      	str	r2, [r3, #8]
    test_wait_threads();
 800881c:	f7ff f980 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008820:	480d      	ldr	r0, [pc, #52]	; (8008858 <test_003_002_execute+0x278>)
 8008822:	490e      	ldr	r1, [pc, #56]	; (800885c <test_003_002_execute+0x27c>)
 8008824:	f7fe fefc 	bl	8007620 <_test_assert_sequence>
 8008828:	4603      	mov	r3, r0
 800882a:	2b00      	cmp	r3, #0
 800882c:	d000      	beq.n	8008830 <test_003_002_execute+0x250>
 800882e:	bf00      	nop
  }
}
 8008830:	b002      	add	sp, #8
 8008832:	bd10      	pop	{r4, pc}
 8008834:	20000cac 	.word	0x20000cac
 8008838:	0800e298 	.word	0x0800e298
 800883c:	0800e9ac 	.word	0x0800e9ac
 8008840:	080084b1 	.word	0x080084b1
 8008844:	20000cb0 	.word	0x20000cb0
 8008848:	0800e9b0 	.word	0x0800e9b0
 800884c:	0800e9b4 	.word	0x0800e9b4
 8008850:	0800e9b8 	.word	0x0800e9b8
 8008854:	0800e9bc 	.word	0x0800e9bc
 8008858:	0800e9c0 	.word	0x0800e9c0
 800885c:	0800e9c8 	.word	0x0800e9c8

08008860 <test_003_003_execute>:
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_003_003_execute(void) {
 8008860:	b500      	push	{lr}
 8008862:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8008864:	4b2b      	ldr	r3, [pc, #172]	; (8008914 <test_003_003_execute+0xb4>)
 8008866:	2201      	movs	r2, #1
 8008868:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800886a:	f7ff fe19 	bl	80084a0 <chThdGetPriorityX>
 800886e:	9001      	str	r0, [sp, #4]
    p1 = chThdSetPriority(prio + 1);
 8008870:	9b01      	ldr	r3, [sp, #4]
 8008872:	3301      	adds	r3, #1
 8008874:	4618      	mov	r0, r3
 8008876:	f7f8 ff0b 	bl	8001690 <chThdSetPriority>
 800887a:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
 800887c:	9a00      	ldr	r2, [sp, #0]
 800887e:	9b01      	ldr	r3, [sp, #4]
 8008880:	429a      	cmp	r2, r3
 8008882:	bf0c      	ite	eq
 8008884:	2301      	moveq	r3, #1
 8008886:	2300      	movne	r3, #0
 8008888:	b2db      	uxtb	r3, r3
 800888a:	4618      	mov	r0, r3
 800888c:	4922      	ldr	r1, [pc, #136]	; (8008918 <test_003_003_execute+0xb8>)
 800888e:	f7fe feaf 	bl	80075f0 <_test_assert>
 8008892:	4603      	mov	r3, r0
 8008894:	2b00      	cmp	r3, #0
 8008896:	d000      	beq.n	800889a <test_003_003_execute+0x3a>
 8008898:	e039      	b.n	800890e <test_003_003_execute+0xae>
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 800889a:	f7ff fe01 	bl	80084a0 <chThdGetPriorityX>
 800889e:	4602      	mov	r2, r0
 80088a0:	9b01      	ldr	r3, [sp, #4]
 80088a2:	3301      	adds	r3, #1
 80088a4:	429a      	cmp	r2, r3
 80088a6:	bf0c      	ite	eq
 80088a8:	2301      	moveq	r3, #1
 80088aa:	2300      	movne	r3, #0
 80088ac:	b2db      	uxtb	r3, r3
 80088ae:	4618      	mov	r0, r3
 80088b0:	491a      	ldr	r1, [pc, #104]	; (800891c <test_003_003_execute+0xbc>)
 80088b2:	f7fe fe9d 	bl	80075f0 <_test_assert>
 80088b6:	4603      	mov	r3, r0
 80088b8:	2b00      	cmp	r3, #0
 80088ba:	d000      	beq.n	80088be <test_003_003_execute+0x5e>
 80088bc:	e027      	b.n	800890e <test_003_003_execute+0xae>
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 80088be:	4b15      	ldr	r3, [pc, #84]	; (8008914 <test_003_003_execute+0xb4>)
 80088c0:	2202      	movs	r2, #2
 80088c2:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(p1);
 80088c4:	9800      	ldr	r0, [sp, #0]
 80088c6:	f7f8 fee3 	bl	8001690 <chThdSetPriority>
 80088ca:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 80088cc:	9b01      	ldr	r3, [sp, #4]
 80088ce:	1c5a      	adds	r2, r3, #1
 80088d0:	9b00      	ldr	r3, [sp, #0]
 80088d2:	429a      	cmp	r2, r3
 80088d4:	bf0c      	ite	eq
 80088d6:	2301      	moveq	r3, #1
 80088d8:	2300      	movne	r3, #0
 80088da:	b2db      	uxtb	r3, r3
 80088dc:	4618      	mov	r0, r3
 80088de:	490e      	ldr	r1, [pc, #56]	; (8008918 <test_003_003_execute+0xb8>)
 80088e0:	f7fe fe86 	bl	80075f0 <_test_assert>
 80088e4:	4603      	mov	r3, r0
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d000      	beq.n	80088ec <test_003_003_execute+0x8c>
 80088ea:	e010      	b.n	800890e <test_003_003_execute+0xae>
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 80088ec:	f7ff fdd8 	bl	80084a0 <chThdGetPriorityX>
 80088f0:	4602      	mov	r2, r0
 80088f2:	9b01      	ldr	r3, [sp, #4]
 80088f4:	429a      	cmp	r2, r3
 80088f6:	bf0c      	ite	eq
 80088f8:	2301      	moveq	r3, #1
 80088fa:	2300      	movne	r3, #0
 80088fc:	b2db      	uxtb	r3, r3
 80088fe:	4618      	mov	r0, r3
 8008900:	4906      	ldr	r1, [pc, #24]	; (800891c <test_003_003_execute+0xbc>)
 8008902:	f7fe fe75 	bl	80075f0 <_test_assert>
 8008906:	4603      	mov	r3, r0
 8008908:	2b00      	cmp	r3, #0
 800890a:	d000      	beq.n	800890e <test_003_003_execute+0xae>
 800890c:	bf00      	nop
  }
}
 800890e:	b003      	add	sp, #12
 8008910:	f85d fb04 	ldr.w	pc, [sp], #4
 8008914:	20000cac 	.word	0x20000cac
 8008918:	0800ea20 	.word	0x0800ea20
 800891c:	0800ea44 	.word	0x0800ea44

08008920 <test_003_004_execute>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void test_003_004_execute(void) {
 8008920:	b500      	push	{lr}
 8008922:	b083      	sub	sp, #12
  tprio_t prio, p1;

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
 8008924:	4b57      	ldr	r3, [pc, #348]	; (8008a84 <test_003_004_execute+0x164>)
 8008926:	2201      	movs	r2, #1
 8008928:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800892a:	f7ff fdb9 	bl	80084a0 <chThdGetPriorityX>
 800892e:	9001      	str	r0, [sp, #4]
    chThdGetSelfX()->prio += 2;
 8008930:	f7ff fdae 	bl	8008490 <chThdGetSelfX>
 8008934:	4603      	mov	r3, r0
 8008936:	689a      	ldr	r2, [r3, #8]
 8008938:	3202      	adds	r2, #2
 800893a:	609a      	str	r2, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
 800893c:	f7ff fdb0 	bl	80084a0 <chThdGetPriorityX>
 8008940:	4602      	mov	r2, r0
 8008942:	9b01      	ldr	r3, [sp, #4]
 8008944:	3302      	adds	r3, #2
 8008946:	429a      	cmp	r2, r3
 8008948:	bf0c      	ite	eq
 800894a:	2301      	moveq	r3, #1
 800894c:	2300      	movne	r3, #0
 800894e:	b2db      	uxtb	r3, r3
 8008950:	4618      	mov	r0, r3
 8008952:	494d      	ldr	r1, [pc, #308]	; (8008a88 <test_003_004_execute+0x168>)
 8008954:	f7fe fe4c 	bl	80075f0 <_test_assert>
 8008958:	4603      	mov	r3, r0
 800895a:	2b00      	cmp	r3, #0
 800895c:	d000      	beq.n	8008960 <test_003_004_execute+0x40>
 800895e:	e08d      	b.n	8008a7c <test_003_004_execute+0x15c>
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8008960:	4b48      	ldr	r3, [pc, #288]	; (8008a84 <test_003_004_execute+0x164>)
 8008962:	2202      	movs	r2, #2
 8008964:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 8008966:	9b01      	ldr	r3, [sp, #4]
 8008968:	3301      	adds	r3, #1
 800896a:	4618      	mov	r0, r3
 800896c:	f7f8 fe90 	bl	8001690 <chThdSetPriority>
 8008970:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio, "unexpected returned priority level");
 8008972:	9a00      	ldr	r2, [sp, #0]
 8008974:	9b01      	ldr	r3, [sp, #4]
 8008976:	429a      	cmp	r2, r3
 8008978:	bf0c      	ite	eq
 800897a:	2301      	moveq	r3, #1
 800897c:	2300      	movne	r3, #0
 800897e:	b2db      	uxtb	r3, r3
 8008980:	4618      	mov	r0, r3
 8008982:	4942      	ldr	r1, [pc, #264]	; (8008a8c <test_003_004_execute+0x16c>)
 8008984:	f7fe fe34 	bl	80075f0 <_test_assert>
 8008988:	4603      	mov	r3, r0
 800898a:	2b00      	cmp	r3, #0
 800898c:	d000      	beq.n	8008990 <test_003_004_execute+0x70>
 800898e:	e075      	b.n	8008a7c <test_003_004_execute+0x15c>
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8008990:	f7ff fd7e 	bl	8008490 <chThdGetSelfX>
 8008994:	4603      	mov	r3, r0
 8008996:	689a      	ldr	r2, [r3, #8]
 8008998:	9b01      	ldr	r3, [sp, #4]
 800899a:	3302      	adds	r3, #2
 800899c:	429a      	cmp	r2, r3
 800899e:	bf0c      	ite	eq
 80089a0:	2301      	moveq	r3, #1
 80089a2:	2300      	movne	r3, #0
 80089a4:	b2db      	uxtb	r3, r3
 80089a6:	4618      	mov	r0, r3
 80089a8:	4937      	ldr	r1, [pc, #220]	; (8008a88 <test_003_004_execute+0x168>)
 80089aa:	f7fe fe21 	bl	80075f0 <_test_assert>
 80089ae:	4603      	mov	r3, r0
 80089b0:	2b00      	cmp	r3, #0
 80089b2:	d000      	beq.n	80089b6 <test_003_004_execute+0x96>
 80089b4:	e062      	b.n	8008a7c <test_003_004_execute+0x15c>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 80089b6:	f7ff fd6b 	bl	8008490 <chThdGetSelfX>
 80089ba:	4603      	mov	r3, r0
 80089bc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80089be:	9b01      	ldr	r3, [sp, #4]
 80089c0:	3301      	adds	r3, #1
 80089c2:	429a      	cmp	r2, r3
 80089c4:	bf0c      	ite	eq
 80089c6:	2301      	moveq	r3, #1
 80089c8:	2300      	movne	r3, #0
 80089ca:	b2db      	uxtb	r3, r3
 80089cc:	4618      	mov	r0, r3
 80089ce:	4930      	ldr	r1, [pc, #192]	; (8008a90 <test_003_004_execute+0x170>)
 80089d0:	f7fe fe0e 	bl	80075f0 <_test_assert>
 80089d4:	4603      	mov	r3, r0
 80089d6:	2b00      	cmp	r3, #0
 80089d8:	d000      	beq.n	80089dc <test_003_004_execute+0xbc>
 80089da:	e04f      	b.n	8008a7c <test_003_004_execute+0x15c>
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 80089dc:	4b29      	ldr	r3, [pc, #164]	; (8008a84 <test_003_004_execute+0x164>)
 80089de:	2203      	movs	r2, #3
 80089e0:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 80089e2:	9b01      	ldr	r3, [sp, #4]
 80089e4:	3303      	adds	r3, #3
 80089e6:	4618      	mov	r0, r3
 80089e8:	f7f8 fe52 	bl	8001690 <chThdSetPriority>
 80089ec:	9000      	str	r0, [sp, #0]
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 80089ee:	9b01      	ldr	r3, [sp, #4]
 80089f0:	1c5a      	adds	r2, r3, #1
 80089f2:	9b00      	ldr	r3, [sp, #0]
 80089f4:	429a      	cmp	r2, r3
 80089f6:	bf0c      	ite	eq
 80089f8:	2301      	moveq	r3, #1
 80089fa:	2300      	movne	r3, #0
 80089fc:	b2db      	uxtb	r3, r3
 80089fe:	4618      	mov	r0, r3
 8008a00:	4922      	ldr	r1, [pc, #136]	; (8008a8c <test_003_004_execute+0x16c>)
 8008a02:	f7fe fdf5 	bl	80075f0 <_test_assert>
 8008a06:	4603      	mov	r3, r0
 8008a08:	2b00      	cmp	r3, #0
 8008a0a:	d000      	beq.n	8008a0e <test_003_004_execute+0xee>
 8008a0c:	e036      	b.n	8008a7c <test_003_004_execute+0x15c>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8008a0e:	f7ff fd3f 	bl	8008490 <chThdGetSelfX>
 8008a12:	4603      	mov	r3, r0
 8008a14:	689a      	ldr	r2, [r3, #8]
 8008a16:	9b01      	ldr	r3, [sp, #4]
 8008a18:	3303      	adds	r3, #3
 8008a1a:	429a      	cmp	r2, r3
 8008a1c:	bf0c      	ite	eq
 8008a1e:	2301      	moveq	r3, #1
 8008a20:	2300      	movne	r3, #0
 8008a22:	b2db      	uxtb	r3, r3
 8008a24:	4618      	mov	r0, r3
 8008a26:	4918      	ldr	r1, [pc, #96]	; (8008a88 <test_003_004_execute+0x168>)
 8008a28:	f7fe fde2 	bl	80075f0 <_test_assert>
 8008a2c:	4603      	mov	r3, r0
 8008a2e:	2b00      	cmp	r3, #0
 8008a30:	d000      	beq.n	8008a34 <test_003_004_execute+0x114>
 8008a32:	e023      	b.n	8008a7c <test_003_004_execute+0x15c>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8008a34:	f7ff fd2c 	bl	8008490 <chThdGetSelfX>
 8008a38:	4603      	mov	r3, r0
 8008a3a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8008a3c:	9b01      	ldr	r3, [sp, #4]
 8008a3e:	3303      	adds	r3, #3
 8008a40:	429a      	cmp	r2, r3
 8008a42:	bf0c      	ite	eq
 8008a44:	2301      	moveq	r3, #1
 8008a46:	2300      	movne	r3, #0
 8008a48:	b2db      	uxtb	r3, r3
 8008a4a:	4618      	mov	r0, r3
 8008a4c:	4911      	ldr	r1, [pc, #68]	; (8008a94 <test_003_004_execute+0x174>)
 8008a4e:	f7fe fdcf 	bl	80075f0 <_test_assert>
 8008a52:	4603      	mov	r3, r0
 8008a54:	2b00      	cmp	r3, #0
 8008a56:	d000      	beq.n	8008a5a <test_003_004_execute+0x13a>
 8008a58:	e010      	b.n	8008a7c <test_003_004_execute+0x15c>
  }

  /* [3.4.4] Restoring original conditions.*/
  test_set_step(4);
 8008a5a:	4b0a      	ldr	r3, [pc, #40]	; (8008a84 <test_003_004_execute+0x164>)
 8008a5c:	2204      	movs	r2, #4
 8008a5e:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8008a60:	f7ff fcfe 	bl	8008460 <chSysLock>
    chThdGetSelfX()->prio = prio;
 8008a64:	f7ff fd14 	bl	8008490 <chThdGetSelfX>
 8008a68:	4602      	mov	r2, r0
 8008a6a:	9b01      	ldr	r3, [sp, #4]
 8008a6c:	6093      	str	r3, [r2, #8]
    chThdGetSelfX()->realprio = prio;
 8008a6e:	f7ff fd0f 	bl	8008490 <chThdGetSelfX>
 8008a72:	4602      	mov	r2, r0
 8008a74:	9b01      	ldr	r3, [sp, #4]
 8008a76:	63d3      	str	r3, [r2, #60]	; 0x3c
    chSysUnlock();
 8008a78:	f7ff fcfa 	bl	8008470 <chSysUnlock>
  }
}
 8008a7c:	b003      	add	sp, #12
 8008a7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008a82:	bf00      	nop
 8008a84:	20000cac 	.word	0x20000cac
 8008a88:	0800ea44 	.word	0x0800ea44
 8008a8c:	0800ea20 	.word	0x0800ea20
 8008a90:	0800ea88 	.word	0x0800ea88
 8008a94:	0800eab0 	.word	0x0800eab0
	...

08008aa0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008aa0:	b082      	sub	sp, #8
 8008aa2:	2320      	movs	r3, #32
 8008aa4:	9301      	str	r3, [sp, #4]
 8008aa6:	9b01      	ldr	r3, [sp, #4]
 8008aa8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008aac:	b002      	add	sp, #8
 8008aae:	4770      	bx	lr

08008ab0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008ab0:	b082      	sub	sp, #8
 8008ab2:	2300      	movs	r3, #0
 8008ab4:	9301      	str	r3, [sp, #4]
 8008ab6:	9b01      	ldr	r3, [sp, #4]
 8008ab8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008abc:	b002      	add	sp, #8
 8008abe:	4770      	bx	lr

08008ac0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8008ac0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008ac4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8008ac6:	4618      	mov	r0, r3
 8008ac8:	4770      	bx	lr
 8008aca:	bf00      	nop
 8008acc:	f3af 8000 	nop.w

08008ad0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8008ad0:	b508      	push	{r3, lr}

  return stGetCounter();
 8008ad2:	f7ff fff5 	bl	8008ac0 <st_lld_get_counter>
 8008ad6:	4603      	mov	r3, r0
}
 8008ad8:	4618      	mov	r0, r3
 8008ada:	bd08      	pop	{r3, pc}
 8008adc:	f3af 8000 	nop.w

08008ae0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008ae0:	b508      	push	{r3, lr}

  port_lock();
 8008ae2:	f7ff ffdd 	bl	8008aa0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8008ae6:	bd08      	pop	{r3, pc}
 8008ae8:	f3af 8000 	nop.w
 8008aec:	f3af 8000 	nop.w

08008af0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008af0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008af2:	f7ff ffdd 	bl	8008ab0 <port_unlock>
}
 8008af6:	bd08      	pop	{r3, pc}
 8008af8:	f3af 8000 	nop.w
 8008afc:	f3af 8000 	nop.w

08008b00 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8008b00:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8008b02:	f7ff ffe5 	bl	8008ad0 <port_timer_get_time>
 8008b06:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8008b08:	4618      	mov	r0, r3
 8008b0a:	bd08      	pop	{r3, pc}
 8008b0c:	f3af 8000 	nop.w

08008b10 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8008b10:	4b01      	ldr	r3, [pc, #4]	; (8008b18 <chThdGetSelfX+0x8>)
 8008b12:	699b      	ldr	r3, [r3, #24]
}
 8008b14:	4618      	mov	r0, r3
 8008b16:	4770      	bx	lr
 8008b18:	20000af8 	.word	0x20000af8
 8008b1c:	f3af 8000 	nop.w

08008b20 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8008b20:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 8008b22:	f7ff fff5 	bl	8008b10 <chThdGetSelfX>
 8008b26:	4603      	mov	r3, r0
 8008b28:	689b      	ldr	r3, [r3, #8]
}
 8008b2a:	4618      	mov	r0, r3
 8008b2c:	bd08      	pop	{r3, pc}
 8008b2e:	bf00      	nop

08008b30 <thread1>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8008b30:	b500      	push	{lr}
 8008b32:	b083      	sub	sp, #12
 8008b34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8008b36:	f7ff ffd3 	bl	8008ae0 <chSysLock>
  chThdResumeI(&tr1, MSG_OK);
 8008b3a:	4808      	ldr	r0, [pc, #32]	; (8008b5c <thread1+0x2c>)
 8008b3c:	2100      	movs	r1, #0
 8008b3e:	f7f8 fe77 	bl	8001830 <chThdResumeI>
  chSchRescheduleS();
 8008b42:	f7f8 fa25 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8008b46:	f7ff ffd3 	bl	8008af0 <chSysUnlock>
  test_emit_token(*(char *)p);
 8008b4a:	9b01      	ldr	r3, [sp, #4]
 8008b4c:	781b      	ldrb	r3, [r3, #0]
 8008b4e:	4618      	mov	r0, r3
 8008b50:	f7fe fe2e 	bl	80077b0 <test_emit_token>
}
 8008b54:	b003      	add	sp, #12
 8008b56:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b5a:	bf00      	nop
 8008b5c:	2000097c 	.word	0x2000097c

08008b60 <test_004_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void test_004_001_setup(void) {
  tr1 = NULL;
 8008b60:	4b01      	ldr	r3, [pc, #4]	; (8008b68 <test_004_001_setup+0x8>)
 8008b62:	2200      	movs	r2, #0
 8008b64:	601a      	str	r2, [r3, #0]
}
 8008b66:	4770      	bx	lr
 8008b68:	2000097c 	.word	0x2000097c
 8008b6c:	f3af 8000 	nop.w

08008b70 <test_004_001_execute>:

static void test_004_001_execute(void) {
 8008b70:	b510      	push	{r4, lr}
 8008b72:	b084      	sub	sp, #16
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8008b74:	4b3e      	ldr	r3, [pc, #248]	; (8008c70 <test_004_001_execute+0x100>)
 8008b76:	2201      	movs	r2, #1
 8008b78:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8008b7a:	4b3e      	ldr	r3, [pc, #248]	; (8008c74 <test_004_001_execute+0x104>)
 8008b7c:	681c      	ldr	r4, [r3, #0]
 8008b7e:	f7ff ffcf 	bl	8008b20 <chThdGetPriorityX>
 8008b82:	4603      	mov	r3, r0
 8008b84:	1e5a      	subs	r2, r3, #1
 8008b86:	4b3c      	ldr	r3, [pc, #240]	; (8008c78 <test_004_001_execute+0x108>)
 8008b88:	9300      	str	r3, [sp, #0]
 8008b8a:	4620      	mov	r0, r4
 8008b8c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008b90:	4b3a      	ldr	r3, [pc, #232]	; (8008c7c <test_004_001_execute+0x10c>)
 8008b92:	f7f8 fc5d 	bl	8001450 <chThdCreateStatic>
 8008b96:	4602      	mov	r2, r0
 8008b98:	4b39      	ldr	r3, [pc, #228]	; (8008c80 <test_004_001_execute+0x110>)
 8008b9a:	601a      	str	r2, [r3, #0]
    chSysLock();
 8008b9c:	f7ff ffa0 	bl	8008ae0 <chSysLock>
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
 8008ba0:	4838      	ldr	r0, [pc, #224]	; (8008c84 <test_004_001_execute+0x114>)
 8008ba2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008ba6:	f7f8 fe23 	bl	80017f0 <chThdSuspendTimeoutS>
 8008baa:	9003      	str	r0, [sp, #12]
    chSysUnlock();
 8008bac:	f7ff ffa0 	bl	8008af0 <chSysUnlock>
    test_assert(NULL == tr1, "not NULL");
 8008bb0:	4b34      	ldr	r3, [pc, #208]	; (8008c84 <test_004_001_execute+0x114>)
 8008bb2:	681b      	ldr	r3, [r3, #0]
 8008bb4:	2b00      	cmp	r3, #0
 8008bb6:	bf0c      	ite	eq
 8008bb8:	2301      	moveq	r3, #1
 8008bba:	2300      	movne	r3, #0
 8008bbc:	b2db      	uxtb	r3, r3
 8008bbe:	4618      	mov	r0, r3
 8008bc0:	4931      	ldr	r1, [pc, #196]	; (8008c88 <test_004_001_execute+0x118>)
 8008bc2:	f7fe fd15 	bl	80075f0 <_test_assert>
 8008bc6:	4603      	mov	r3, r0
 8008bc8:	2b00      	cmp	r3, #0
 8008bca:	d000      	beq.n	8008bce <test_004_001_execute+0x5e>
 8008bcc:	e04e      	b.n	8008c6c <test_004_001_execute+0xfc>
    test_assert(MSG_OK == msg,"wrong returned message");
 8008bce:	9b03      	ldr	r3, [sp, #12]
 8008bd0:	2b00      	cmp	r3, #0
 8008bd2:	bf0c      	ite	eq
 8008bd4:	2301      	moveq	r3, #1
 8008bd6:	2300      	movne	r3, #0
 8008bd8:	b2db      	uxtb	r3, r3
 8008bda:	4618      	mov	r0, r3
 8008bdc:	492b      	ldr	r1, [pc, #172]	; (8008c8c <test_004_001_execute+0x11c>)
 8008bde:	f7fe fd07 	bl	80075f0 <_test_assert>
 8008be2:	4603      	mov	r3, r0
 8008be4:	2b00      	cmp	r3, #0
 8008be6:	d000      	beq.n	8008bea <test_004_001_execute+0x7a>
 8008be8:	e040      	b.n	8008c6c <test_004_001_execute+0xfc>
    test_wait_threads();
 8008bea:	f7fe ff99 	bl	8007b20 <test_wait_threads>
  }

  /* [4.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 8008bee:	4b20      	ldr	r3, [pc, #128]	; (8008c70 <test_004_001_execute+0x100>)
 8008bf0:	2202      	movs	r2, #2
 8008bf2:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8008bf4:	f7ff ff74 	bl	8008ae0 <chSysLock>
    time = chVTGetSystemTimeX();
 8008bf8:	f7ff ff82 	bl	8008b00 <chVTGetSystemTimeX>
 8008bfc:	9002      	str	r0, [sp, #8]
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
 8008bfe:	4821      	ldr	r0, [pc, #132]	; (8008c84 <test_004_001_execute+0x114>)
 8008c00:	f242 7110 	movw	r1, #10000	; 0x2710
 8008c04:	f7f8 fdf4 	bl	80017f0 <chThdSuspendTimeoutS>
 8008c08:	9003      	str	r0, [sp, #12]
    chSysUnlock();
 8008c0a:	f7ff ff71 	bl	8008af0 <chSysUnlock>
    test_assert_time_window(time + MS2ST(1000),
 8008c0e:	9b02      	ldr	r3, [sp, #8]
 8008c10:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 8008c14:	3210      	adds	r2, #16
 8008c16:	9b02      	ldr	r3, [sp, #8]
 8008c18:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 8008c1c:	3313      	adds	r3, #19
 8008c1e:	4610      	mov	r0, r2
 8008c20:	4619      	mov	r1, r3
 8008c22:	4a1b      	ldr	r2, [pc, #108]	; (8008c90 <test_004_001_execute+0x120>)
 8008c24:	f7fe fd2c 	bl	8007680 <_test_assert_time_window>
 8008c28:	4603      	mov	r3, r0
 8008c2a:	2b00      	cmp	r3, #0
 8008c2c:	d000      	beq.n	8008c30 <test_004_001_execute+0xc0>
 8008c2e:	e01d      	b.n	8008c6c <test_004_001_execute+0xfc>
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8008c30:	4b14      	ldr	r3, [pc, #80]	; (8008c84 <test_004_001_execute+0x114>)
 8008c32:	681b      	ldr	r3, [r3, #0]
 8008c34:	2b00      	cmp	r3, #0
 8008c36:	bf0c      	ite	eq
 8008c38:	2301      	moveq	r3, #1
 8008c3a:	2300      	movne	r3, #0
 8008c3c:	b2db      	uxtb	r3, r3
 8008c3e:	4618      	mov	r0, r3
 8008c40:	4911      	ldr	r1, [pc, #68]	; (8008c88 <test_004_001_execute+0x118>)
 8008c42:	f7fe fcd5 	bl	80075f0 <_test_assert>
 8008c46:	4603      	mov	r3, r0
 8008c48:	2b00      	cmp	r3, #0
 8008c4a:	d000      	beq.n	8008c4e <test_004_001_execute+0xde>
 8008c4c:	e00e      	b.n	8008c6c <test_004_001_execute+0xfc>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8008c4e:	9b03      	ldr	r3, [sp, #12]
 8008c50:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008c54:	bf0c      	ite	eq
 8008c56:	2301      	moveq	r3, #1
 8008c58:	2300      	movne	r3, #0
 8008c5a:	b2db      	uxtb	r3, r3
 8008c5c:	4618      	mov	r0, r3
 8008c5e:	490b      	ldr	r1, [pc, #44]	; (8008c8c <test_004_001_execute+0x11c>)
 8008c60:	f7fe fcc6 	bl	80075f0 <_test_assert>
 8008c64:	4603      	mov	r3, r0
 8008c66:	2b00      	cmp	r3, #0
 8008c68:	d000      	beq.n	8008c6c <test_004_001_execute+0xfc>
 8008c6a:	bf00      	nop
  }
}
 8008c6c:	b004      	add	sp, #16
 8008c6e:	bd10      	pop	{r4, pc}
 8008c70:	20000cac 	.word	0x20000cac
 8008c74:	0800e298 	.word	0x0800e298
 8008c78:	0800eb24 	.word	0x0800eb24
 8008c7c:	08008b31 	.word	0x08008b31
 8008c80:	20000cb0 	.word	0x20000cb0
 8008c84:	2000097c 	.word	0x2000097c
 8008c88:	0800eb28 	.word	0x0800eb28
 8008c8c:	0800eb34 	.word	0x0800eb34
 8008c90:	0800eb4c 	.word	0x0800eb4c
	...

08008ca0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008ca0:	b082      	sub	sp, #8
 8008ca2:	2320      	movs	r3, #32
 8008ca4:	9301      	str	r3, [sp, #4]
 8008ca6:	9b01      	ldr	r3, [sp, #4]
 8008ca8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008cac:	b002      	add	sp, #8
 8008cae:	4770      	bx	lr

08008cb0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008cb0:	b082      	sub	sp, #8
 8008cb2:	2300      	movs	r3, #0
 8008cb4:	9301      	str	r3, [sp, #4]
 8008cb6:	9b01      	ldr	r3, [sp, #4]
 8008cb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008cbc:	b002      	add	sp, #8
 8008cbe:	4770      	bx	lr

08008cc0 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8008cc0:	b082      	sub	sp, #8
 8008cc2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next == (const thread_t *)tqp);
 8008cc4:	9b01      	ldr	r3, [sp, #4]
 8008cc6:	681a      	ldr	r2, [r3, #0]
 8008cc8:	9b01      	ldr	r3, [sp, #4]
 8008cca:	429a      	cmp	r2, r3
 8008ccc:	bf0c      	ite	eq
 8008cce:	2301      	moveq	r3, #1
 8008cd0:	2300      	movne	r3, #0
 8008cd2:	b2db      	uxtb	r3, r3
}
 8008cd4:	4618      	mov	r0, r3
 8008cd6:	b002      	add	sp, #8
 8008cd8:	4770      	bx	lr
 8008cda:	bf00      	nop
 8008cdc:	f3af 8000 	nop.w

08008ce0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008ce0:	b508      	push	{r3, lr}

  port_lock();
 8008ce2:	f7ff ffdd 	bl	8008ca0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8008ce6:	bd08      	pop	{r3, pc}
 8008ce8:	f3af 8000 	nop.w
 8008cec:	f3af 8000 	nop.w

08008cf0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008cf0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8008cf2:	f7ff ffdd 	bl	8008cb0 <port_unlock>
}
 8008cf6:	bd08      	pop	{r3, pc}
 8008cf8:	f3af 8000 	nop.w
 8008cfc:	f3af 8000 	nop.w

08008d00 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8008d00:	4b01      	ldr	r3, [pc, #4]	; (8008d08 <chThdGetSelfX+0x8>)
 8008d02:	699b      	ldr	r3, [r3, #24]
}
 8008d04:	4618      	mov	r0, r3
 8008d06:	4770      	bx	lr
 8008d08:	20000af8 	.word	0x20000af8
 8008d0c:	f3af 8000 	nop.w

08008d10 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8008d10:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 8008d12:	f7ff fff5 	bl	8008d00 <chThdGetSelfX>
 8008d16:	4603      	mov	r3, r0
 8008d18:	689b      	ldr	r3, [r3, #8]
}
 8008d1a:	4618      	mov	r0, r3
 8008d1c:	bd08      	pop	{r3, pc}
 8008d1e:	bf00      	nop

08008d20 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8008d20:	b082      	sub	sp, #8
 8008d22:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->cnt;
 8008d24:	9b01      	ldr	r3, [sp, #4]
 8008d26:	689b      	ldr	r3, [r3, #8]
}
 8008d28:	4618      	mov	r0, r3
 8008d2a:	b002      	add	sp, #8
 8008d2c:	4770      	bx	lr
 8008d2e:	bf00      	nop

08008d30 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 8008d30:	b500      	push	{lr}
 8008d32:	b083      	sub	sp, #12
 8008d34:	9001      	str	r0, [sp, #4]
 8008d36:	460b      	mov	r3, r1
 8008d38:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8008d3c:	9a01      	ldr	r2, [sp, #4]
 8008d3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008d42:	2b00      	cmp	r3, #0
 8008d44:	d001      	beq.n	8008d4a <chBSemObjectInit+0x1a>
 8008d46:	2300      	movs	r3, #0
 8008d48:	e000      	b.n	8008d4c <chBSemObjectInit+0x1c>
 8008d4a:	2301      	movs	r3, #1
 8008d4c:	4610      	mov	r0, r2
 8008d4e:	4619      	mov	r1, r3
 8008d50:	f7f8 fff6 	bl	8001d40 <chSemObjectInit>
}
 8008d54:	b003      	add	sp, #12
 8008d56:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d5a:	bf00      	nop
 8008d5c:	f3af 8000 	nop.w

08008d60 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 8008d60:	b500      	push	{lr}
 8008d62:	b083      	sub	sp, #12
 8008d64:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->sem);
 8008d66:	9b01      	ldr	r3, [sp, #4]
 8008d68:	4618      	mov	r0, r3
 8008d6a:	f7f9 f831 	bl	8001dd0 <chSemWait>
 8008d6e:	4603      	mov	r3, r0
}
 8008d70:	4618      	mov	r0, r3
 8008d72:	b003      	add	sp, #12
 8008d74:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d78:	f3af 8000 	nop.w
 8008d7c:	f3af 8000 	nop.w

08008d80 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 8008d80:	b500      	push	{lr}
 8008d82:	b083      	sub	sp, #12
 8008d84:	9001      	str	r0, [sp, #4]
 8008d86:	460b      	mov	r3, r1
 8008d88:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8008d8c:	9a01      	ldr	r2, [sp, #4]
 8008d8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008d92:	2b00      	cmp	r3, #0
 8008d94:	d001      	beq.n	8008d9a <chBSemReset+0x1a>
 8008d96:	2300      	movs	r3, #0
 8008d98:	e000      	b.n	8008d9c <chBSemReset+0x1c>
 8008d9a:	2301      	movs	r3, #1
 8008d9c:	4610      	mov	r0, r2
 8008d9e:	4619      	mov	r1, r3
 8008da0:	f7f8 ffde 	bl	8001d60 <chSemReset>
}
 8008da4:	b003      	add	sp, #12
 8008da6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008daa:	bf00      	nop
 8008dac:	f3af 8000 	nop.w

08008db0 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 8008db0:	b500      	push	{lr}
 8008db2:	b083      	sub	sp, #12
 8008db4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8008db6:	9b01      	ldr	r3, [sp, #4]
 8008db8:	689b      	ldr	r3, [r3, #8]
 8008dba:	2b00      	cmp	r3, #0
 8008dbc:	dc03      	bgt.n	8008dc6 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->sem);
 8008dbe:	9b01      	ldr	r3, [sp, #4]
 8008dc0:	4618      	mov	r0, r3
 8008dc2:	f7f9 f8a5 	bl	8001f10 <chSemSignalI>
  }
}
 8008dc6:	b003      	add	sp, #12
 8008dc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8008dcc:	f3af 8000 	nop.w

08008dd0 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 8008dd0:	b500      	push	{lr}
 8008dd2:	b083      	sub	sp, #12
 8008dd4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8008dd6:	f7ff ff83 	bl	8008ce0 <chSysLock>
  chBSemSignalI(bsp);
 8008dda:	9801      	ldr	r0, [sp, #4]
 8008ddc:	f7ff ffe8 	bl	8008db0 <chBSemSignalI>
  chSchRescheduleS();
 8008de0:	f7f8 f8d6 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8008de4:	f7ff ff84 	bl	8008cf0 <chSysUnlock>
}
 8008de8:	b003      	add	sp, #12
 8008dea:	f85d fb04 	ldr.w	pc, [sp], #4
 8008dee:	bf00      	nop

08008df0 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 8008df0:	b082      	sub	sp, #8
 8008df2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8008df4:	9b01      	ldr	r3, [sp, #4]
 8008df6:	689b      	ldr	r3, [r3, #8]
 8008df8:	2b00      	cmp	r3, #0
 8008dfa:	bfd4      	ite	le
 8008dfc:	2301      	movle	r3, #1
 8008dfe:	2300      	movgt	r3, #0
 8008e00:	b2db      	uxtb	r3, r3
}
 8008e02:	4618      	mov	r0, r3
 8008e04:	b002      	add	sp, #8
 8008e06:	4770      	bx	lr
 8008e08:	f3af 8000 	nop.w
 8008e0c:	f3af 8000 	nop.w

08008e10 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8008e10:	b508      	push	{r3, lr}

  chSysLock();
 8008e12:	f7ff ff65 	bl	8008ce0 <chSysLock>
}
 8008e16:	bd08      	pop	{r3, pc}
 8008e18:	f3af 8000 	nop.w
 8008e1c:	f3af 8000 	nop.w

08008e20 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8008e20:	b508      	push	{r3, lr}

  chSysUnlock();
 8008e22:	f7ff ff65 	bl	8008cf0 <chSysUnlock>
}
 8008e26:	bd08      	pop	{r3, pc}
 8008e28:	f3af 8000 	nop.w
 8008e2c:	f3af 8000 	nop.w

08008e30 <thread1>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 8008e30:	b500      	push	{lr}
 8008e32:	b083      	sub	sp, #12
 8008e34:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 8008e36:	4805      	ldr	r0, [pc, #20]	; (8008e4c <thread1+0x1c>)
 8008e38:	f7f8 ffca 	bl	8001dd0 <chSemWait>
  test_emit_token(*(char *)p);
 8008e3c:	9b01      	ldr	r3, [sp, #4]
 8008e3e:	781b      	ldrb	r3, [r3, #0]
 8008e40:	4618      	mov	r0, r3
 8008e42:	f7fe fcb5 	bl	80077b0 <test_emit_token>
}
 8008e46:	b003      	add	sp, #12
 8008e48:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e4c:	20000980 	.word	0x20000980

08008e50 <thread2>:

static THD_FUNCTION(thread2, p) {
 8008e50:	b500      	push	{lr}
 8008e52:	b083      	sub	sp, #12
 8008e54:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 8008e56:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8008e5a:	f7f8 fc61 	bl	8001720 <chThdSleep>
  chSysLock();
 8008e5e:	f7ff ff3f 	bl	8008ce0 <chSysLock>
  chSemSignalI(&sem1); /* For coverage reasons */
 8008e62:	4805      	ldr	r0, [pc, #20]	; (8008e78 <thread2+0x28>)
 8008e64:	f7f9 f854 	bl	8001f10 <chSemSignalI>
  chSchRescheduleS();
 8008e68:	f7f8 f892 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 8008e6c:	f7ff ff40 	bl	8008cf0 <chSysUnlock>
}
 8008e70:	b003      	add	sp, #12
 8008e72:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e76:	bf00      	nop
 8008e78:	20000980 	.word	0x20000980
 8008e7c:	f3af 8000 	nop.w

08008e80 <thread3>:

static THD_FUNCTION(thread3, p) {
 8008e80:	b500      	push	{lr}
 8008e82:	b083      	sub	sp, #12
 8008e84:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 8008e86:	4804      	ldr	r0, [pc, #16]	; (8008e98 <thread3+0x18>)
 8008e88:	f7f8 ffa2 	bl	8001dd0 <chSemWait>
  chSemSignal(&sem1);
 8008e8c:	4802      	ldr	r0, [pc, #8]	; (8008e98 <thread3+0x18>)
 8008e8e:	f7f9 f81f 	bl	8001ed0 <chSemSignal>
}
 8008e92:	b003      	add	sp, #12
 8008e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e98:	20000980 	.word	0x20000980
 8008e9c:	f3af 8000 	nop.w

08008ea0 <thread4>:

static THD_FUNCTION(thread4, p) {
 8008ea0:	b500      	push	{lr}
 8008ea2:	b083      	sub	sp, #12
 8008ea4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 8008ea6:	9801      	ldr	r0, [sp, #4]
 8008ea8:	f7ff ff92 	bl	8008dd0 <chBSemSignal>
}
 8008eac:	b003      	add	sp, #12
 8008eae:	f85d fb04 	ldr.w	pc, [sp], #4
 8008eb2:	bf00      	nop
 8008eb4:	f3af 8000 	nop.w
 8008eb8:	f3af 8000 	nop.w
 8008ebc:	f3af 8000 	nop.w

08008ec0 <test_005_001_setup>:
 * - [5.1.3] The function chSemReset() is invoked, after return the
 *   counter is tested.
 * .
 */

static void test_005_001_setup(void) {
 8008ec0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 8008ec2:	4802      	ldr	r0, [pc, #8]	; (8008ecc <test_005_001_setup+0xc>)
 8008ec4:	2101      	movs	r1, #1
 8008ec6:	f7f8 ff3b 	bl	8001d40 <chSemObjectInit>
}
 8008eca:	bd08      	pop	{r3, pc}
 8008ecc:	20000980 	.word	0x20000980

08008ed0 <test_005_001_teardown>:

static void test_005_001_teardown(void) {
 8008ed0:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
 8008ed2:	4802      	ldr	r0, [pc, #8]	; (8008edc <test_005_001_teardown+0xc>)
 8008ed4:	2100      	movs	r1, #0
 8008ed6:	f7f8 ff43 	bl	8001d60 <chSemReset>
}
 8008eda:	bd08      	pop	{r3, pc}
 8008edc:	20000980 	.word	0x20000980

08008ee0 <test_005_001_execute>:

static void test_005_001_execute(void) {
 8008ee0:	b500      	push	{lr}
 8008ee2:	b083      	sub	sp, #12

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8008ee4:	4b34      	ldr	r3, [pc, #208]	; (8008fb8 <test_005_001_execute+0xd8>)
 8008ee6:	2201      	movs	r2, #1
 8008ee8:	601a      	str	r2, [r3, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8008eea:	4834      	ldr	r0, [pc, #208]	; (8008fbc <test_005_001_execute+0xdc>)
 8008eec:	f7f8 ff70 	bl	8001dd0 <chSemWait>
 8008ef0:	9001      	str	r0, [sp, #4]
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8008ef2:	f7ff ff8d 	bl	8008e10 <osalSysLock>
 8008ef6:	4831      	ldr	r0, [pc, #196]	; (8008fbc <test_005_001_execute+0xdc>)
 8008ef8:	f7ff ff12 	bl	8008d20 <chSemGetCounterI>
 8008efc:	4603      	mov	r3, r0
 8008efe:	2b00      	cmp	r3, #0
 8008f00:	bf0c      	ite	eq
 8008f02:	2301      	moveq	r3, #1
 8008f04:	2300      	movne	r3, #0
 8008f06:	b2db      	uxtb	r3, r3
 8008f08:	4618      	mov	r0, r3
 8008f0a:	492d      	ldr	r1, [pc, #180]	; (8008fc0 <test_005_001_execute+0xe0>)
 8008f0c:	f7fe fb70 	bl	80075f0 <_test_assert>
 8008f10:	4603      	mov	r3, r0
 8008f12:	2b00      	cmp	r3, #0
 8008f14:	d002      	beq.n	8008f1c <test_005_001_execute+0x3c>
 8008f16:	f7ff ff83 	bl	8008e20 <osalSysUnlock>
 8008f1a:	e04a      	b.n	8008fb2 <test_005_001_execute+0xd2>
 8008f1c:	f7ff ff80 	bl	8008e20 <osalSysUnlock>
    test_assert(MSG_OK == msg, "wrong returned message");
 8008f20:	9b01      	ldr	r3, [sp, #4]
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	bf0c      	ite	eq
 8008f26:	2301      	moveq	r3, #1
 8008f28:	2300      	movne	r3, #0
 8008f2a:	b2db      	uxtb	r3, r3
 8008f2c:	4618      	mov	r0, r3
 8008f2e:	4925      	ldr	r1, [pc, #148]	; (8008fc4 <test_005_001_execute+0xe4>)
 8008f30:	f7fe fb5e 	bl	80075f0 <_test_assert>
 8008f34:	4603      	mov	r3, r0
 8008f36:	2b00      	cmp	r3, #0
 8008f38:	d000      	beq.n	8008f3c <test_005_001_execute+0x5c>
 8008f3a:	e03a      	b.n	8008fb2 <test_005_001_execute+0xd2>
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8008f3c:	4b1e      	ldr	r3, [pc, #120]	; (8008fb8 <test_005_001_execute+0xd8>)
 8008f3e:	2202      	movs	r2, #2
 8008f40:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
 8008f42:	481e      	ldr	r0, [pc, #120]	; (8008fbc <test_005_001_execute+0xdc>)
 8008f44:	f7f8 ffc4 	bl	8001ed0 <chSemSignal>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8008f48:	f7ff ff62 	bl	8008e10 <osalSysLock>
 8008f4c:	481b      	ldr	r0, [pc, #108]	; (8008fbc <test_005_001_execute+0xdc>)
 8008f4e:	f7ff fee7 	bl	8008d20 <chSemGetCounterI>
 8008f52:	4603      	mov	r3, r0
 8008f54:	2b01      	cmp	r3, #1
 8008f56:	bf0c      	ite	eq
 8008f58:	2301      	moveq	r3, #1
 8008f5a:	2300      	movne	r3, #0
 8008f5c:	b2db      	uxtb	r3, r3
 8008f5e:	4618      	mov	r0, r3
 8008f60:	4917      	ldr	r1, [pc, #92]	; (8008fc0 <test_005_001_execute+0xe0>)
 8008f62:	f7fe fb45 	bl	80075f0 <_test_assert>
 8008f66:	4603      	mov	r3, r0
 8008f68:	2b00      	cmp	r3, #0
 8008f6a:	d002      	beq.n	8008f72 <test_005_001_execute+0x92>
 8008f6c:	f7ff ff58 	bl	8008e20 <osalSysUnlock>
 8008f70:	e01f      	b.n	8008fb2 <test_005_001_execute+0xd2>
 8008f72:	f7ff ff55 	bl	8008e20 <osalSysUnlock>
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8008f76:	4b10      	ldr	r3, [pc, #64]	; (8008fb8 <test_005_001_execute+0xd8>)
 8008f78:	2203      	movs	r2, #3
 8008f7a:	601a      	str	r2, [r3, #0]
  {
    chSemReset(&sem1, 2);
 8008f7c:	480f      	ldr	r0, [pc, #60]	; (8008fbc <test_005_001_execute+0xdc>)
 8008f7e:	2102      	movs	r1, #2
 8008f80:	f7f8 feee 	bl	8001d60 <chSemReset>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8008f84:	f7ff ff44 	bl	8008e10 <osalSysLock>
 8008f88:	480c      	ldr	r0, [pc, #48]	; (8008fbc <test_005_001_execute+0xdc>)
 8008f8a:	f7ff fec9 	bl	8008d20 <chSemGetCounterI>
 8008f8e:	4603      	mov	r3, r0
 8008f90:	2b02      	cmp	r3, #2
 8008f92:	bf0c      	ite	eq
 8008f94:	2301      	moveq	r3, #1
 8008f96:	2300      	movne	r3, #0
 8008f98:	b2db      	uxtb	r3, r3
 8008f9a:	4618      	mov	r0, r3
 8008f9c:	4908      	ldr	r1, [pc, #32]	; (8008fc0 <test_005_001_execute+0xe0>)
 8008f9e:	f7fe fb27 	bl	80075f0 <_test_assert>
 8008fa2:	4603      	mov	r3, r0
 8008fa4:	2b00      	cmp	r3, #0
 8008fa6:	d002      	beq.n	8008fae <test_005_001_execute+0xce>
 8008fa8:	f7ff ff3a 	bl	8008e20 <osalSysUnlock>
 8008fac:	e001      	b.n	8008fb2 <test_005_001_execute+0xd2>
 8008fae:	f7ff ff37 	bl	8008e20 <osalSysUnlock>
  }
}
 8008fb2:	b003      	add	sp, #12
 8008fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fb8:	20000cac 	.word	0x20000cac
 8008fbc:	20000980 	.word	0x20000980
 8008fc0:	0800eb9c 	.word	0x0800eb9c
 8008fc4:	0800ebb0 	.word	0x0800ebb0
 8008fc8:	f3af 8000 	nop.w
 8008fcc:	f3af 8000 	nop.w

08008fd0 <test_005_002_setup>:
 * - [5.2.2] The semaphore is signaled 5 times. The thread activation
 *   sequence is tested.
 * .
 */

static void test_005_002_setup(void) {
 8008fd0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8008fd2:	4802      	ldr	r0, [pc, #8]	; (8008fdc <test_005_002_setup+0xc>)
 8008fd4:	2100      	movs	r1, #0
 8008fd6:	f7f8 feb3 	bl	8001d40 <chSemObjectInit>
}
 8008fda:	bd08      	pop	{r3, pc}
 8008fdc:	20000980 	.word	0x20000980

08008fe0 <test_005_002_execute>:

static void test_005_002_execute(void) {
 8008fe0:	b510      	push	{r4, lr}
 8008fe2:	b082      	sub	sp, #8

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8008fe4:	4b3a      	ldr	r3, [pc, #232]	; (80090d0 <test_005_002_execute+0xf0>)
 8008fe6:	2201      	movs	r2, #1
 8008fe8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8008fea:	4b3a      	ldr	r3, [pc, #232]	; (80090d4 <test_005_002_execute+0xf4>)
 8008fec:	681c      	ldr	r4, [r3, #0]
 8008fee:	f7ff fe8f 	bl	8008d10 <chThdGetPriorityX>
 8008ff2:	4603      	mov	r3, r0
 8008ff4:	1d5a      	adds	r2, r3, #5
 8008ff6:	4b38      	ldr	r3, [pc, #224]	; (80090d8 <test_005_002_execute+0xf8>)
 8008ff8:	9300      	str	r3, [sp, #0]
 8008ffa:	4620      	mov	r0, r4
 8008ffc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009000:	4b36      	ldr	r3, [pc, #216]	; (80090dc <test_005_002_execute+0xfc>)
 8009002:	f7f8 fa25 	bl	8001450 <chThdCreateStatic>
 8009006:	4602      	mov	r2, r0
 8009008:	4b35      	ldr	r3, [pc, #212]	; (80090e0 <test_005_002_execute+0x100>)
 800900a:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800900c:	4b31      	ldr	r3, [pc, #196]	; (80090d4 <test_005_002_execute+0xf4>)
 800900e:	685c      	ldr	r4, [r3, #4]
 8009010:	f7ff fe7e 	bl	8008d10 <chThdGetPriorityX>
 8009014:	4603      	mov	r3, r0
 8009016:	1c5a      	adds	r2, r3, #1
 8009018:	4b32      	ldr	r3, [pc, #200]	; (80090e4 <test_005_002_execute+0x104>)
 800901a:	9300      	str	r3, [sp, #0]
 800901c:	4620      	mov	r0, r4
 800901e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009022:	4b2e      	ldr	r3, [pc, #184]	; (80090dc <test_005_002_execute+0xfc>)
 8009024:	f7f8 fa14 	bl	8001450 <chThdCreateStatic>
 8009028:	4602      	mov	r2, r0
 800902a:	4b2d      	ldr	r3, [pc, #180]	; (80090e0 <test_005_002_execute+0x100>)
 800902c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800902e:	4b29      	ldr	r3, [pc, #164]	; (80090d4 <test_005_002_execute+0xf4>)
 8009030:	689c      	ldr	r4, [r3, #8]
 8009032:	f7ff fe6d 	bl	8008d10 <chThdGetPriorityX>
 8009036:	4603      	mov	r3, r0
 8009038:	1cda      	adds	r2, r3, #3
 800903a:	4b2b      	ldr	r3, [pc, #172]	; (80090e8 <test_005_002_execute+0x108>)
 800903c:	9300      	str	r3, [sp, #0]
 800903e:	4620      	mov	r0, r4
 8009040:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009044:	4b25      	ldr	r3, [pc, #148]	; (80090dc <test_005_002_execute+0xfc>)
 8009046:	f7f8 fa03 	bl	8001450 <chThdCreateStatic>
 800904a:	4602      	mov	r2, r0
 800904c:	4b24      	ldr	r3, [pc, #144]	; (80090e0 <test_005_002_execute+0x100>)
 800904e:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8009050:	4b20      	ldr	r3, [pc, #128]	; (80090d4 <test_005_002_execute+0xf4>)
 8009052:	68dc      	ldr	r4, [r3, #12]
 8009054:	f7ff fe5c 	bl	8008d10 <chThdGetPriorityX>
 8009058:	4603      	mov	r3, r0
 800905a:	1d1a      	adds	r2, r3, #4
 800905c:	4b23      	ldr	r3, [pc, #140]	; (80090ec <test_005_002_execute+0x10c>)
 800905e:	9300      	str	r3, [sp, #0]
 8009060:	4620      	mov	r0, r4
 8009062:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009066:	4b1d      	ldr	r3, [pc, #116]	; (80090dc <test_005_002_execute+0xfc>)
 8009068:	f7f8 f9f2 	bl	8001450 <chThdCreateStatic>
 800906c:	4602      	mov	r2, r0
 800906e:	4b1c      	ldr	r3, [pc, #112]	; (80090e0 <test_005_002_execute+0x100>)
 8009070:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8009072:	4b18      	ldr	r3, [pc, #96]	; (80090d4 <test_005_002_execute+0xf4>)
 8009074:	691c      	ldr	r4, [r3, #16]
 8009076:	f7ff fe4b 	bl	8008d10 <chThdGetPriorityX>
 800907a:	4603      	mov	r3, r0
 800907c:	1c9a      	adds	r2, r3, #2
 800907e:	4b1c      	ldr	r3, [pc, #112]	; (80090f0 <test_005_002_execute+0x110>)
 8009080:	9300      	str	r3, [sp, #0]
 8009082:	4620      	mov	r0, r4
 8009084:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009088:	4b14      	ldr	r3, [pc, #80]	; (80090dc <test_005_002_execute+0xfc>)
 800908a:	f7f8 f9e1 	bl	8001450 <chThdCreateStatic>
 800908e:	4602      	mov	r2, r0
 8009090:	4b13      	ldr	r3, [pc, #76]	; (80090e0 <test_005_002_execute+0x100>)
 8009092:	611a      	str	r2, [r3, #16]
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8009094:	4b0e      	ldr	r3, [pc, #56]	; (80090d0 <test_005_002_execute+0xf0>)
 8009096:	2202      	movs	r2, #2
 8009098:	601a      	str	r2, [r3, #0]
  {
    chSemSignal(&sem1);
 800909a:	4816      	ldr	r0, [pc, #88]	; (80090f4 <test_005_002_execute+0x114>)
 800909c:	f7f8 ff18 	bl	8001ed0 <chSemSignal>
    chSemSignal(&sem1);
 80090a0:	4814      	ldr	r0, [pc, #80]	; (80090f4 <test_005_002_execute+0x114>)
 80090a2:	f7f8 ff15 	bl	8001ed0 <chSemSignal>
    chSemSignal(&sem1);
 80090a6:	4813      	ldr	r0, [pc, #76]	; (80090f4 <test_005_002_execute+0x114>)
 80090a8:	f7f8 ff12 	bl	8001ed0 <chSemSignal>
    chSemSignal(&sem1);
 80090ac:	4811      	ldr	r0, [pc, #68]	; (80090f4 <test_005_002_execute+0x114>)
 80090ae:	f7f8 ff0f 	bl	8001ed0 <chSemSignal>
    chSemSignal(&sem1);
 80090b2:	4810      	ldr	r0, [pc, #64]	; (80090f4 <test_005_002_execute+0x114>)
 80090b4:	f7f8 ff0c 	bl	8001ed0 <chSemSignal>
    test_wait_threads();
 80090b8:	f7fe fd32 	bl	8007b20 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 80090bc:	480e      	ldr	r0, [pc, #56]	; (80090f8 <test_005_002_execute+0x118>)
 80090be:	490f      	ldr	r1, [pc, #60]	; (80090fc <test_005_002_execute+0x11c>)
 80090c0:	f7fe faae 	bl	8007620 <_test_assert_sequence>
 80090c4:	4603      	mov	r3, r0
 80090c6:	2b00      	cmp	r3, #0
 80090c8:	d000      	beq.n	80090cc <test_005_002_execute+0xec>
 80090ca:	bf00      	nop
#endif
  }
}
 80090cc:	b002      	add	sp, #8
 80090ce:	bd10      	pop	{r4, pc}
 80090d0:	20000cac 	.word	0x20000cac
 80090d4:	0800e298 	.word	0x0800e298
 80090d8:	0800ec00 	.word	0x0800ec00
 80090dc:	08008e31 	.word	0x08008e31
 80090e0:	20000cb0 	.word	0x20000cb0
 80090e4:	0800ec04 	.word	0x0800ec04
 80090e8:	0800ec08 	.word	0x0800ec08
 80090ec:	0800ec0c 	.word	0x0800ec0c
 80090f0:	0800ec10 	.word	0x0800ec10
 80090f4:	20000980 	.word	0x20000980
 80090f8:	0800ec14 	.word	0x0800ec14
 80090fc:	0800ec1c 	.word	0x0800ec1c

08009100 <test_005_003_setup>:
 * - [5.3.2] Testing non-timeout condition.
 * - [5.3.3] Testing timeout condition.
 * .
 */

static void test_005_003_setup(void) {
 8009100:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8009102:	4802      	ldr	r0, [pc, #8]	; (800910c <test_005_003_setup+0xc>)
 8009104:	2100      	movs	r1, #0
 8009106:	f7f8 fe1b 	bl	8001d40 <chSemObjectInit>
}
 800910a:	bd08      	pop	{r3, pc}
 800910c:	20000980 	.word	0x20000980

08009110 <test_005_003_execute>:

static void test_005_003_execute(void) {
 8009110:	b510      	push	{r4, lr}
 8009112:	b086      	sub	sp, #24
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8009114:	4b6a      	ldr	r3, [pc, #424]	; (80092c0 <test_005_003_execute+0x1b0>)
 8009116:	2201      	movs	r2, #1
 8009118:	601a      	str	r2, [r3, #0]
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800911a:	486a      	ldr	r0, [pc, #424]	; (80092c4 <test_005_003_execute+0x1b4>)
 800911c:	2100      	movs	r1, #0
 800911e:	f7f8 fe8f 	bl	8001e40 <chSemWaitTimeout>
 8009122:	9004      	str	r0, [sp, #16]
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8009124:	9b04      	ldr	r3, [sp, #16]
 8009126:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800912a:	bf0c      	ite	eq
 800912c:	2301      	moveq	r3, #1
 800912e:	2300      	movne	r3, #0
 8009130:	b2db      	uxtb	r3, r3
 8009132:	4618      	mov	r0, r3
 8009134:	4964      	ldr	r1, [pc, #400]	; (80092c8 <test_005_003_execute+0x1b8>)
 8009136:	f7fe fa5b 	bl	80075f0 <_test_assert>
 800913a:	4603      	mov	r3, r0
 800913c:	2b00      	cmp	r3, #0
 800913e:	d000      	beq.n	8009142 <test_005_003_execute+0x32>
 8009140:	e0bb      	b.n	80092ba <test_005_003_execute+0x1aa>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009142:	4860      	ldr	r0, [pc, #384]	; (80092c4 <test_005_003_execute+0x1b4>)
 8009144:	f7ff fdbc 	bl	8008cc0 <queue_isempty>
 8009148:	4603      	mov	r3, r0
 800914a:	4618      	mov	r0, r3
 800914c:	495f      	ldr	r1, [pc, #380]	; (80092cc <test_005_003_execute+0x1bc>)
 800914e:	f7fe fa4f 	bl	80075f0 <_test_assert>
 8009152:	4603      	mov	r3, r0
 8009154:	2b00      	cmp	r3, #0
 8009156:	d000      	beq.n	800915a <test_005_003_execute+0x4a>
 8009158:	e0af      	b.n	80092ba <test_005_003_execute+0x1aa>
    test_assert(sem1.cnt == 0, "counter not zero");
 800915a:	4b5a      	ldr	r3, [pc, #360]	; (80092c4 <test_005_003_execute+0x1b4>)
 800915c:	689b      	ldr	r3, [r3, #8]
 800915e:	2b00      	cmp	r3, #0
 8009160:	bf0c      	ite	eq
 8009162:	2301      	moveq	r3, #1
 8009164:	2300      	movne	r3, #0
 8009166:	b2db      	uxtb	r3, r3
 8009168:	4618      	mov	r0, r3
 800916a:	4959      	ldr	r1, [pc, #356]	; (80092d0 <test_005_003_execute+0x1c0>)
 800916c:	f7fe fa40 	bl	80075f0 <_test_assert>
 8009170:	4603      	mov	r3, r0
 8009172:	2b00      	cmp	r3, #0
 8009174:	d000      	beq.n	8009178 <test_005_003_execute+0x68>
 8009176:	e0a0      	b.n	80092ba <test_005_003_execute+0x1aa>
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8009178:	4b51      	ldr	r3, [pc, #324]	; (80092c0 <test_005_003_execute+0x1b0>)
 800917a:	2202      	movs	r2, #2
 800917c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800917e:	4b55      	ldr	r3, [pc, #340]	; (80092d4 <test_005_003_execute+0x1c4>)
 8009180:	681c      	ldr	r4, [r3, #0]
 8009182:	f7ff fdc5 	bl	8008d10 <chThdGetPriorityX>
 8009186:	4603      	mov	r3, r0
 8009188:	1e5a      	subs	r2, r3, #1
 800918a:	2300      	movs	r3, #0
 800918c:	9300      	str	r3, [sp, #0]
 800918e:	4620      	mov	r0, r4
 8009190:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009194:	4b50      	ldr	r3, [pc, #320]	; (80092d8 <test_005_003_execute+0x1c8>)
 8009196:	f7f8 f95b 	bl	8001450 <chThdCreateStatic>
 800919a:	4602      	mov	r2, r0
 800919c:	4b4f      	ldr	r3, [pc, #316]	; (80092dc <test_005_003_execute+0x1cc>)
 800919e:	601a      	str	r2, [r3, #0]
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
 80091a0:	4848      	ldr	r0, [pc, #288]	; (80092c4 <test_005_003_execute+0x1b4>)
 80091a2:	f241 3188 	movw	r1, #5000	; 0x1388
 80091a6:	f7f8 fe4b 	bl	8001e40 <chSemWaitTimeout>
 80091aa:	9004      	str	r0, [sp, #16]
    test_wait_threads();
 80091ac:	f7fe fcb8 	bl	8007b20 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 80091b0:	9b04      	ldr	r3, [sp, #16]
 80091b2:	2b00      	cmp	r3, #0
 80091b4:	bf0c      	ite	eq
 80091b6:	2301      	moveq	r3, #1
 80091b8:	2300      	movne	r3, #0
 80091ba:	b2db      	uxtb	r3, r3
 80091bc:	4618      	mov	r0, r3
 80091be:	4942      	ldr	r1, [pc, #264]	; (80092c8 <test_005_003_execute+0x1b8>)
 80091c0:	f7fe fa16 	bl	80075f0 <_test_assert>
 80091c4:	4603      	mov	r3, r0
 80091c6:	2b00      	cmp	r3, #0
 80091c8:	d000      	beq.n	80091cc <test_005_003_execute+0xbc>
 80091ca:	e076      	b.n	80092ba <test_005_003_execute+0x1aa>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80091cc:	483d      	ldr	r0, [pc, #244]	; (80092c4 <test_005_003_execute+0x1b4>)
 80091ce:	f7ff fd77 	bl	8008cc0 <queue_isempty>
 80091d2:	4603      	mov	r3, r0
 80091d4:	4618      	mov	r0, r3
 80091d6:	493d      	ldr	r1, [pc, #244]	; (80092cc <test_005_003_execute+0x1bc>)
 80091d8:	f7fe fa0a 	bl	80075f0 <_test_assert>
 80091dc:	4603      	mov	r3, r0
 80091de:	2b00      	cmp	r3, #0
 80091e0:	d000      	beq.n	80091e4 <test_005_003_execute+0xd4>
 80091e2:	e06a      	b.n	80092ba <test_005_003_execute+0x1aa>
    test_assert(sem1.cnt == 0, "counter not zero");
 80091e4:	4b37      	ldr	r3, [pc, #220]	; (80092c4 <test_005_003_execute+0x1b4>)
 80091e6:	689b      	ldr	r3, [r3, #8]
 80091e8:	2b00      	cmp	r3, #0
 80091ea:	bf0c      	ite	eq
 80091ec:	2301      	moveq	r3, #1
 80091ee:	2300      	movne	r3, #0
 80091f0:	b2db      	uxtb	r3, r3
 80091f2:	4618      	mov	r0, r3
 80091f4:	4936      	ldr	r1, [pc, #216]	; (80092d0 <test_005_003_execute+0x1c0>)
 80091f6:	f7fe f9fb 	bl	80075f0 <_test_assert>
 80091fa:	4603      	mov	r3, r0
 80091fc:	2b00      	cmp	r3, #0
 80091fe:	d000      	beq.n	8009202 <test_005_003_execute+0xf2>
 8009200:	e05b      	b.n	80092ba <test_005_003_execute+0x1aa>
  }

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
 8009202:	4b2f      	ldr	r3, [pc, #188]	; (80092c0 <test_005_003_execute+0x1b0>)
 8009204:	2203      	movs	r2, #3
 8009206:	601a      	str	r2, [r3, #0]
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 8009208:	f7fe fcb2 	bl	8007b70 <test_wait_tick>
 800920c:	4603      	mov	r3, r0
 800920e:	f603 13c4 	addw	r3, r3, #2500	; 0x9c4
 8009212:	9303      	str	r3, [sp, #12]
    for (i = 0; i < 5; i++) {
 8009214:	2300      	movs	r3, #0
 8009216:	9305      	str	r3, [sp, #20]
 8009218:	e039      	b.n	800928e <test_005_003_execute+0x17e>
      test_emit_token('A' + i);
 800921a:	9b05      	ldr	r3, [sp, #20]
 800921c:	b2db      	uxtb	r3, r3
 800921e:	3341      	adds	r3, #65	; 0x41
 8009220:	b2db      	uxtb	r3, r3
 8009222:	4618      	mov	r0, r3
 8009224:	f7fe fac4 	bl	80077b0 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
 8009228:	4826      	ldr	r0, [pc, #152]	; (80092c4 <test_005_003_execute+0x1b4>)
 800922a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800922e:	f7f8 fe07 	bl	8001e40 <chSemWaitTimeout>
 8009232:	9004      	str	r0, [sp, #16]
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8009234:	9b04      	ldr	r3, [sp, #16]
 8009236:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800923a:	bf0c      	ite	eq
 800923c:	2301      	moveq	r3, #1
 800923e:	2300      	movne	r3, #0
 8009240:	b2db      	uxtb	r3, r3
 8009242:	4618      	mov	r0, r3
 8009244:	4920      	ldr	r1, [pc, #128]	; (80092c8 <test_005_003_execute+0x1b8>)
 8009246:	f7fe f9d3 	bl	80075f0 <_test_assert>
 800924a:	4603      	mov	r3, r0
 800924c:	2b00      	cmp	r3, #0
 800924e:	d000      	beq.n	8009252 <test_005_003_execute+0x142>
 8009250:	e033      	b.n	80092ba <test_005_003_execute+0x1aa>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8009252:	481c      	ldr	r0, [pc, #112]	; (80092c4 <test_005_003_execute+0x1b4>)
 8009254:	f7ff fd34 	bl	8008cc0 <queue_isempty>
 8009258:	4603      	mov	r3, r0
 800925a:	4618      	mov	r0, r3
 800925c:	491b      	ldr	r1, [pc, #108]	; (80092cc <test_005_003_execute+0x1bc>)
 800925e:	f7fe f9c7 	bl	80075f0 <_test_assert>
 8009262:	4603      	mov	r3, r0
 8009264:	2b00      	cmp	r3, #0
 8009266:	d000      	beq.n	800926a <test_005_003_execute+0x15a>
 8009268:	e027      	b.n	80092ba <test_005_003_execute+0x1aa>
      test_assert(sem1.cnt == 0, "counter not zero");
 800926a:	4b16      	ldr	r3, [pc, #88]	; (80092c4 <test_005_003_execute+0x1b4>)
 800926c:	689b      	ldr	r3, [r3, #8]
 800926e:	2b00      	cmp	r3, #0
 8009270:	bf0c      	ite	eq
 8009272:	2301      	moveq	r3, #1
 8009274:	2300      	movne	r3, #0
 8009276:	b2db      	uxtb	r3, r3
 8009278:	4618      	mov	r0, r3
 800927a:	4915      	ldr	r1, [pc, #84]	; (80092d0 <test_005_003_execute+0x1c0>)
 800927c:	f7fe f9b8 	bl	80075f0 <_test_assert>
 8009280:	4603      	mov	r3, r0
 8009282:	2b00      	cmp	r3, #0
 8009284:	d000      	beq.n	8009288 <test_005_003_execute+0x178>
 8009286:	e018      	b.n	80092ba <test_005_003_execute+0x1aa>

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
 8009288:	9b05      	ldr	r3, [sp, #20]
 800928a:	3301      	adds	r3, #1
 800928c:	9305      	str	r3, [sp, #20]
 800928e:	9b05      	ldr	r3, [sp, #20]
 8009290:	2b04      	cmp	r3, #4
 8009292:	d9c2      	bls.n	800921a <test_005_003_execute+0x10a>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8009294:	4812      	ldr	r0, [pc, #72]	; (80092e0 <test_005_003_execute+0x1d0>)
 8009296:	4913      	ldr	r1, [pc, #76]	; (80092e4 <test_005_003_execute+0x1d4>)
 8009298:	f7fe f9c2 	bl	8007620 <_test_assert_sequence>
 800929c:	4603      	mov	r3, r0
 800929e:	2b00      	cmp	r3, #0
 80092a0:	d000      	beq.n	80092a4 <test_005_003_execute+0x194>
 80092a2:	e00a      	b.n	80092ba <test_005_003_execute+0x1aa>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80092a4:	9b03      	ldr	r3, [sp, #12]
 80092a6:	3314      	adds	r3, #20
 80092a8:	9803      	ldr	r0, [sp, #12]
 80092aa:	4619      	mov	r1, r3
 80092ac:	4a0e      	ldr	r2, [pc, #56]	; (80092e8 <test_005_003_execute+0x1d8>)
 80092ae:	f7fe f9e7 	bl	8007680 <_test_assert_time_window>
 80092b2:	4603      	mov	r3, r0
 80092b4:	2b00      	cmp	r3, #0
 80092b6:	d000      	beq.n	80092ba <test_005_003_execute+0x1aa>
 80092b8:	bf00      	nop
                            "out of time window");
  }
}
 80092ba:	b006      	add	sp, #24
 80092bc:	bd10      	pop	{r4, pc}
 80092be:	bf00      	nop
 80092c0:	20000cac 	.word	0x20000cac
 80092c4:	20000980 	.word	0x20000980
 80092c8:	0800ec5c 	.word	0x0800ec5c
 80092cc:	0800ec74 	.word	0x0800ec74
 80092d0:	0800ec84 	.word	0x0800ec84
 80092d4:	0800e298 	.word	0x0800e298
 80092d8:	08008e51 	.word	0x08008e51
 80092dc:	20000cb0 	.word	0x20000cb0
 80092e0:	0800ec14 	.word	0x0800ec14
 80092e4:	0800ec1c 	.word	0x0800ec1c
 80092e8:	0800ec98 	.word	0x0800ec98
 80092ec:	f3af 8000 	nop.w

080092f0 <test_005_004_setup>:
 * - [5.4.2] The semaphore counter is increased by two, it is then
 *   tested to be one, the thread must have completed.
 * .
 */

static void test_005_004_setup(void) {
 80092f0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 80092f2:	4802      	ldr	r0, [pc, #8]	; (80092fc <test_005_004_setup+0xc>)
 80092f4:	2100      	movs	r1, #0
 80092f6:	f7f8 fd23 	bl	8001d40 <chSemObjectInit>
}
 80092fa:	bd08      	pop	{r3, pc}
 80092fc:	20000980 	.word	0x20000980

08009300 <test_005_004_execute>:

static void test_005_004_execute(void) {
 8009300:	b510      	push	{r4, lr}
 8009302:	b082      	sub	sp, #8

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8009304:	4b21      	ldr	r3, [pc, #132]	; (800938c <test_005_004_execute+0x8c>)
 8009306:	2201      	movs	r2, #1
 8009308:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800930a:	4b21      	ldr	r3, [pc, #132]	; (8009390 <test_005_004_execute+0x90>)
 800930c:	681c      	ldr	r4, [r3, #0]
 800930e:	f7ff fcff 	bl	8008d10 <chThdGetPriorityX>
 8009312:	4603      	mov	r3, r0
 8009314:	1c5a      	adds	r2, r3, #1
 8009316:	4b1f      	ldr	r3, [pc, #124]	; (8009394 <test_005_004_execute+0x94>)
 8009318:	9300      	str	r3, [sp, #0]
 800931a:	4620      	mov	r0, r4
 800931c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009320:	4b1d      	ldr	r3, [pc, #116]	; (8009398 <test_005_004_execute+0x98>)
 8009322:	f7f8 f895 	bl	8001450 <chThdCreateStatic>
 8009326:	4602      	mov	r2, r0
 8009328:	4b1c      	ldr	r3, [pc, #112]	; (800939c <test_005_004_execute+0x9c>)
 800932a:	601a      	str	r2, [r3, #0]
  }

  /* [5.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 800932c:	4b17      	ldr	r3, [pc, #92]	; (800938c <test_005_004_execute+0x8c>)
 800932e:	2202      	movs	r2, #2
 8009330:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8009332:	f7ff fcd5 	bl	8008ce0 <chSysLock>
    chSemAddCounterI(&sem1, 2);
 8009336:	481a      	ldr	r0, [pc, #104]	; (80093a0 <test_005_004_execute+0xa0>)
 8009338:	2102      	movs	r1, #2
 800933a:	f7f8 fe09 	bl	8001f50 <chSemAddCounterI>
    chSchRescheduleS();
 800933e:	f7f7 fe27 	bl	8000f90 <chSchRescheduleS>
    chSysUnlock();
 8009342:	f7ff fcd5 	bl	8008cf0 <chSysUnlock>
    test_wait_threads();
 8009346:	f7fe fbeb 	bl	8007b20 <test_wait_threads>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800934a:	f7ff fd61 	bl	8008e10 <osalSysLock>
 800934e:	4814      	ldr	r0, [pc, #80]	; (80093a0 <test_005_004_execute+0xa0>)
 8009350:	f7ff fce6 	bl	8008d20 <chSemGetCounterI>
 8009354:	4603      	mov	r3, r0
 8009356:	2b01      	cmp	r3, #1
 8009358:	bf0c      	ite	eq
 800935a:	2301      	moveq	r3, #1
 800935c:	2300      	movne	r3, #0
 800935e:	b2db      	uxtb	r3, r3
 8009360:	4618      	mov	r0, r3
 8009362:	4910      	ldr	r1, [pc, #64]	; (80093a4 <test_005_004_execute+0xa4>)
 8009364:	f7fe f944 	bl	80075f0 <_test_assert>
 8009368:	4603      	mov	r3, r0
 800936a:	2b00      	cmp	r3, #0
 800936c:	d002      	beq.n	8009374 <test_005_004_execute+0x74>
 800936e:	f7ff fd57 	bl	8008e20 <osalSysUnlock>
 8009372:	e009      	b.n	8009388 <test_005_004_execute+0x88>
 8009374:	f7ff fd54 	bl	8008e20 <osalSysUnlock>
    test_assert_sequence("A", "invalid sequence");
 8009378:	4806      	ldr	r0, [pc, #24]	; (8009394 <test_005_004_execute+0x94>)
 800937a:	490b      	ldr	r1, [pc, #44]	; (80093a8 <test_005_004_execute+0xa8>)
 800937c:	f7fe f950 	bl	8007620 <_test_assert_sequence>
 8009380:	4603      	mov	r3, r0
 8009382:	2b00      	cmp	r3, #0
 8009384:	d000      	beq.n	8009388 <test_005_004_execute+0x88>
 8009386:	bf00      	nop
  }
}
 8009388:	b002      	add	sp, #8
 800938a:	bd10      	pop	{r4, pc}
 800938c:	20000cac 	.word	0x20000cac
 8009390:	0800e298 	.word	0x0800e298
 8009394:	0800ec00 	.word	0x0800ec00
 8009398:	08008e31 	.word	0x08008e31
 800939c:	20000cb0 	.word	0x20000cb0
 80093a0:	20000980 	.word	0x20000980
 80093a4:	0800ecd4 	.word	0x0800ecd4
 80093a8:	0800ec1c 	.word	0x0800ec1c
 80093ac:	f3af 8000 	nop.w

080093b0 <test_005_005_setup>:
 *   specifying the same semaphore for the wait and signal phases. The
 *   counter value must be one on exit.
 * .
 */

static void test_005_005_setup(void) {
 80093b0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 80093b2:	4802      	ldr	r0, [pc, #8]	; (80093bc <test_005_005_setup+0xc>)
 80093b4:	2100      	movs	r1, #0
 80093b6:	f7f8 fcc3 	bl	8001d40 <chSemObjectInit>
}
 80093ba:	bd08      	pop	{r3, pc}
 80093bc:	20000980 	.word	0x20000980

080093c0 <test_005_005_teardown>:

static void test_005_005_teardown(void) {
 80093c0:	b508      	push	{r3, lr}
  test_wait_threads();
 80093c2:	f7fe fbad 	bl	8007b20 <test_wait_threads>
}
 80093c6:	bd08      	pop	{r3, pc}
 80093c8:	f3af 8000 	nop.w
 80093cc:	f3af 8000 	nop.w

080093d0 <test_005_005_execute>:

static void test_005_005_execute(void) {
 80093d0:	b510      	push	{r4, lr}
 80093d2:	b082      	sub	sp, #8

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80093d4:	4b2c      	ldr	r3, [pc, #176]	; (8009488 <test_005_005_execute+0xb8>)
 80093d6:	2201      	movs	r2, #1
 80093d8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80093da:	4b2c      	ldr	r3, [pc, #176]	; (800948c <test_005_005_execute+0xbc>)
 80093dc:	681c      	ldr	r4, [r3, #0]
 80093de:	f7ff fc97 	bl	8008d10 <chThdGetPriorityX>
 80093e2:	4603      	mov	r3, r0
 80093e4:	1c5a      	adds	r2, r3, #1
 80093e6:	2300      	movs	r3, #0
 80093e8:	9300      	str	r3, [sp, #0]
 80093ea:	4620      	mov	r0, r4
 80093ec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80093f0:	4b27      	ldr	r3, [pc, #156]	; (8009490 <test_005_005_execute+0xc0>)
 80093f2:	f7f8 f82d 	bl	8001450 <chThdCreateStatic>
 80093f6:	4602      	mov	r2, r0
 80093f8:	4b26      	ldr	r3, [pc, #152]	; (8009494 <test_005_005_execute+0xc4>)
 80093fa:	601a      	str	r2, [r3, #0]
  }

  /* [5.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80093fc:	4b22      	ldr	r3, [pc, #136]	; (8009488 <test_005_005_execute+0xb8>)
 80093fe:	2202      	movs	r2, #2
 8009400:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8009402:	4825      	ldr	r0, [pc, #148]	; (8009498 <test_005_005_execute+0xc8>)
 8009404:	4924      	ldr	r1, [pc, #144]	; (8009498 <test_005_005_execute+0xc8>)
 8009406:	f7f8 fdcb 	bl	8001fa0 <chSemSignalWait>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800940a:	4823      	ldr	r0, [pc, #140]	; (8009498 <test_005_005_execute+0xc8>)
 800940c:	f7ff fc58 	bl	8008cc0 <queue_isempty>
 8009410:	4603      	mov	r3, r0
 8009412:	4618      	mov	r0, r3
 8009414:	4921      	ldr	r1, [pc, #132]	; (800949c <test_005_005_execute+0xcc>)
 8009416:	f7fe f8eb 	bl	80075f0 <_test_assert>
 800941a:	4603      	mov	r3, r0
 800941c:	2b00      	cmp	r3, #0
 800941e:	d000      	beq.n	8009422 <test_005_005_execute+0x52>
 8009420:	e030      	b.n	8009484 <test_005_005_execute+0xb4>
    test_assert(sem1.cnt == 0, "counter not zero");
 8009422:	4b1d      	ldr	r3, [pc, #116]	; (8009498 <test_005_005_execute+0xc8>)
 8009424:	689b      	ldr	r3, [r3, #8]
 8009426:	2b00      	cmp	r3, #0
 8009428:	bf0c      	ite	eq
 800942a:	2301      	moveq	r3, #1
 800942c:	2300      	movne	r3, #0
 800942e:	b2db      	uxtb	r3, r3
 8009430:	4618      	mov	r0, r3
 8009432:	491b      	ldr	r1, [pc, #108]	; (80094a0 <test_005_005_execute+0xd0>)
 8009434:	f7fe f8dc 	bl	80075f0 <_test_assert>
 8009438:	4603      	mov	r3, r0
 800943a:	2b00      	cmp	r3, #0
 800943c:	d000      	beq.n	8009440 <test_005_005_execute+0x70>
 800943e:	e021      	b.n	8009484 <test_005_005_execute+0xb4>
  }

  /* [5.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 8009440:	4b11      	ldr	r3, [pc, #68]	; (8009488 <test_005_005_execute+0xb8>)
 8009442:	2203      	movs	r2, #3
 8009444:	601a      	str	r2, [r3, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8009446:	4814      	ldr	r0, [pc, #80]	; (8009498 <test_005_005_execute+0xc8>)
 8009448:	4913      	ldr	r1, [pc, #76]	; (8009498 <test_005_005_execute+0xc8>)
 800944a:	f7f8 fda9 	bl	8001fa0 <chSemSignalWait>
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800944e:	4812      	ldr	r0, [pc, #72]	; (8009498 <test_005_005_execute+0xc8>)
 8009450:	f7ff fc36 	bl	8008cc0 <queue_isempty>
 8009454:	4603      	mov	r3, r0
 8009456:	4618      	mov	r0, r3
 8009458:	4910      	ldr	r1, [pc, #64]	; (800949c <test_005_005_execute+0xcc>)
 800945a:	f7fe f8c9 	bl	80075f0 <_test_assert>
 800945e:	4603      	mov	r3, r0
 8009460:	2b00      	cmp	r3, #0
 8009462:	d000      	beq.n	8009466 <test_005_005_execute+0x96>
 8009464:	e00e      	b.n	8009484 <test_005_005_execute+0xb4>
    test_assert(sem1.cnt == 0, "counter not zero");
 8009466:	4b0c      	ldr	r3, [pc, #48]	; (8009498 <test_005_005_execute+0xc8>)
 8009468:	689b      	ldr	r3, [r3, #8]
 800946a:	2b00      	cmp	r3, #0
 800946c:	bf0c      	ite	eq
 800946e:	2301      	moveq	r3, #1
 8009470:	2300      	movne	r3, #0
 8009472:	b2db      	uxtb	r3, r3
 8009474:	4618      	mov	r0, r3
 8009476:	490a      	ldr	r1, [pc, #40]	; (80094a0 <test_005_005_execute+0xd0>)
 8009478:	f7fe f8ba 	bl	80075f0 <_test_assert>
 800947c:	4603      	mov	r3, r0
 800947e:	2b00      	cmp	r3, #0
 8009480:	d000      	beq.n	8009484 <test_005_005_execute+0xb4>
 8009482:	bf00      	nop
  }
}
 8009484:	b002      	add	sp, #8
 8009486:	bd10      	pop	{r4, pc}
 8009488:	20000cac 	.word	0x20000cac
 800948c:	0800e298 	.word	0x0800e298
 8009490:	08008e81 	.word	0x08008e81
 8009494:	20000cb0 	.word	0x20000cb0
 8009498:	20000980 	.word	0x20000980
 800949c:	0800ec74 	.word	0x0800ec74
 80094a0:	0800ec84 	.word	0x0800ec84
 80094a4:	f3af 8000 	nop.w
 80094a8:	f3af 8000 	nop.w
 80094ac:	f3af 8000 	nop.w

080094b0 <test_005_006_teardown>:
 * - [5.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void test_005_006_teardown(void) {
 80094b0:	b508      	push	{r3, lr}
  test_wait_threads();
 80094b2:	f7fe fb35 	bl	8007b20 <test_wait_threads>
}
 80094b6:	bd08      	pop	{r3, pc}
 80094b8:	f3af 8000 	nop.w
 80094bc:	f3af 8000 	nop.w

080094c0 <test_005_006_execute>:

static void test_005_006_execute(void) {
 80094c0:	b510      	push	{r4, lr}
 80094c2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80094c4:	4b7e      	ldr	r3, [pc, #504]	; (80096c0 <test_005_006_execute+0x200>)
 80094c6:	2201      	movs	r2, #1
 80094c8:	601a      	str	r2, [r3, #0]
  {
    chBSemObjectInit(&bsem, true);
 80094ca:	ab02      	add	r3, sp, #8
 80094cc:	4618      	mov	r0, r3
 80094ce:	2101      	movs	r1, #1
 80094d0:	f7ff fc2e 	bl	8008d30 <chBSemObjectInit>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80094d4:	f7ff fc9c 	bl	8008e10 <osalSysLock>
 80094d8:	ab02      	add	r3, sp, #8
 80094da:	4618      	mov	r0, r3
 80094dc:	f7ff fc88 	bl	8008df0 <chBSemGetStateI>
 80094e0:	4603      	mov	r3, r0
 80094e2:	2b00      	cmp	r3, #0
 80094e4:	bf14      	ite	ne
 80094e6:	2301      	movne	r3, #1
 80094e8:	2300      	moveq	r3, #0
 80094ea:	b2db      	uxtb	r3, r3
 80094ec:	4618      	mov	r0, r3
 80094ee:	4975      	ldr	r1, [pc, #468]	; (80096c4 <test_005_006_execute+0x204>)
 80094f0:	f7fe f87e 	bl	80075f0 <_test_assert>
 80094f4:	4603      	mov	r3, r0
 80094f6:	2b00      	cmp	r3, #0
 80094f8:	d002      	beq.n	8009500 <test_005_006_execute+0x40>
 80094fa:	f7ff fc91 	bl	8008e20 <osalSysUnlock>
 80094fe:	e0dd      	b.n	80096bc <test_005_006_execute+0x1fc>
 8009500:	f7ff fc8e 	bl	8008e20 <osalSysUnlock>
  }

  /* [5.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 8009504:	4b6e      	ldr	r3, [pc, #440]	; (80096c0 <test_005_006_execute+0x200>)
 8009506:	2202      	movs	r2, #2
 8009508:	601a      	str	r2, [r3, #0]
  {
    chBSemReset(&bsem, true);
 800950a:	ab02      	add	r3, sp, #8
 800950c:	4618      	mov	r0, r3
 800950e:	2101      	movs	r1, #1
 8009510:	f7ff fc36 	bl	8008d80 <chBSemReset>
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8009514:	f7ff fc7c 	bl	8008e10 <osalSysLock>
 8009518:	ab02      	add	r3, sp, #8
 800951a:	4618      	mov	r0, r3
 800951c:	f7ff fc68 	bl	8008df0 <chBSemGetStateI>
 8009520:	4603      	mov	r3, r0
 8009522:	2b00      	cmp	r3, #0
 8009524:	bf14      	ite	ne
 8009526:	2301      	movne	r3, #1
 8009528:	2300      	moveq	r3, #0
 800952a:	b2db      	uxtb	r3, r3
 800952c:	4618      	mov	r0, r3
 800952e:	4965      	ldr	r1, [pc, #404]	; (80096c4 <test_005_006_execute+0x204>)
 8009530:	f7fe f85e 	bl	80075f0 <_test_assert>
 8009534:	4603      	mov	r3, r0
 8009536:	2b00      	cmp	r3, #0
 8009538:	d002      	beq.n	8009540 <test_005_006_execute+0x80>
 800953a:	f7ff fc71 	bl	8008e20 <osalSysUnlock>
 800953e:	e0bd      	b.n	80096bc <test_005_006_execute+0x1fc>
 8009540:	f7ff fc6e 	bl	8008e20 <osalSysUnlock>
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8009544:	4b5e      	ldr	r3, [pc, #376]	; (80096c0 <test_005_006_execute+0x200>)
 8009546:	2203      	movs	r2, #3
 8009548:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800954a:	4b5f      	ldr	r3, [pc, #380]	; (80096c8 <test_005_006_execute+0x208>)
 800954c:	681c      	ldr	r4, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
 800954e:	f7ff fbdf 	bl	8008d10 <chThdGetPriorityX>
 8009552:	4603      	mov	r3, r0
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8009554:	1e5a      	subs	r2, r3, #1
 8009556:	ab02      	add	r3, sp, #8
 8009558:	9300      	str	r3, [sp, #0]
 800955a:	4620      	mov	r0, r4
 800955c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009560:	4b5a      	ldr	r3, [pc, #360]	; (80096cc <test_005_006_execute+0x20c>)
 8009562:	f7f7 ff75 	bl	8001450 <chThdCreateStatic>
 8009566:	4602      	mov	r2, r0
 8009568:	4b59      	ldr	r3, [pc, #356]	; (80096d0 <test_005_006_execute+0x210>)
 800956a:	601a      	str	r2, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [5.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 800956c:	4b54      	ldr	r3, [pc, #336]	; (80096c0 <test_005_006_execute+0x200>)
 800956e:	2204      	movs	r2, #4
 8009570:	601a      	str	r2, [r3, #0]
  {
    msg = chBSemWait(&bsem);
 8009572:	ab02      	add	r3, sp, #8
 8009574:	4618      	mov	r0, r3
 8009576:	f7ff fbf3 	bl	8008d60 <chBSemWait>
 800957a:	9005      	str	r0, [sp, #20]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800957c:	f7ff fc48 	bl	8008e10 <osalSysLock>
 8009580:	ab02      	add	r3, sp, #8
 8009582:	4618      	mov	r0, r3
 8009584:	f7ff fc34 	bl	8008df0 <chBSemGetStateI>
 8009588:	4603      	mov	r3, r0
 800958a:	2b00      	cmp	r3, #0
 800958c:	bf14      	ite	ne
 800958e:	2301      	movne	r3, #1
 8009590:	2300      	moveq	r3, #0
 8009592:	b2db      	uxtb	r3, r3
 8009594:	4618      	mov	r0, r3
 8009596:	494b      	ldr	r1, [pc, #300]	; (80096c4 <test_005_006_execute+0x204>)
 8009598:	f7fe f82a 	bl	80075f0 <_test_assert>
 800959c:	4603      	mov	r3, r0
 800959e:	2b00      	cmp	r3, #0
 80095a0:	d002      	beq.n	80095a8 <test_005_006_execute+0xe8>
 80095a2:	f7ff fc3d 	bl	8008e20 <osalSysUnlock>
 80095a6:	e089      	b.n	80096bc <test_005_006_execute+0x1fc>
 80095a8:	f7ff fc3a 	bl	8008e20 <osalSysUnlock>
    test_assert(msg == MSG_OK, "unexpected message");
 80095ac:	9b05      	ldr	r3, [sp, #20]
 80095ae:	2b00      	cmp	r3, #0
 80095b0:	bf0c      	ite	eq
 80095b2:	2301      	moveq	r3, #1
 80095b4:	2300      	movne	r3, #0
 80095b6:	b2db      	uxtb	r3, r3
 80095b8:	4618      	mov	r0, r3
 80095ba:	4946      	ldr	r1, [pc, #280]	; (80096d4 <test_005_006_execute+0x214>)
 80095bc:	f7fe f818 	bl	80075f0 <_test_assert>
 80095c0:	4603      	mov	r3, r0
 80095c2:	2b00      	cmp	r3, #0
 80095c4:	d000      	beq.n	80095c8 <test_005_006_execute+0x108>
 80095c6:	e079      	b.n	80096bc <test_005_006_execute+0x1fc>
  }

  /* [5.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 80095c8:	4b3d      	ldr	r3, [pc, #244]	; (80096c0 <test_005_006_execute+0x200>)
 80095ca:	2205      	movs	r2, #5
 80095cc:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
 80095ce:	ab02      	add	r3, sp, #8
 80095d0:	4618      	mov	r0, r3
 80095d2:	f7ff fbfd 	bl	8008dd0 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 80095d6:	f7ff fc1b 	bl	8008e10 <osalSysLock>
 80095da:	ab02      	add	r3, sp, #8
 80095dc:	4618      	mov	r0, r3
 80095de:	f7ff fc07 	bl	8008df0 <chBSemGetStateI>
 80095e2:	4603      	mov	r3, r0
 80095e4:	2b00      	cmp	r3, #0
 80095e6:	bf14      	ite	ne
 80095e8:	2301      	movne	r3, #1
 80095ea:	2300      	moveq	r3, #0
 80095ec:	b2db      	uxtb	r3, r3
 80095ee:	f083 0301 	eor.w	r3, r3, #1
 80095f2:	b2db      	uxtb	r3, r3
 80095f4:	f003 0301 	and.w	r3, r3, #1
 80095f8:	b2db      	uxtb	r3, r3
 80095fa:	4618      	mov	r0, r3
 80095fc:	4936      	ldr	r1, [pc, #216]	; (80096d8 <test_005_006_execute+0x218>)
 80095fe:	f7fd fff7 	bl	80075f0 <_test_assert>
 8009602:	4603      	mov	r3, r0
 8009604:	2b00      	cmp	r3, #0
 8009606:	d002      	beq.n	800960e <test_005_006_execute+0x14e>
 8009608:	f7ff fc0a 	bl	8008e20 <osalSysUnlock>
 800960c:	e056      	b.n	80096bc <test_005_006_execute+0x1fc>
 800960e:	f7ff fc07 	bl	8008e20 <osalSysUnlock>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8009612:	f7ff fbfd 	bl	8008e10 <osalSysLock>
 8009616:	ab02      	add	r3, sp, #8
 8009618:	4618      	mov	r0, r3
 800961a:	f7ff fb81 	bl	8008d20 <chSemGetCounterI>
 800961e:	4603      	mov	r3, r0
 8009620:	2b01      	cmp	r3, #1
 8009622:	bf0c      	ite	eq
 8009624:	2301      	moveq	r3, #1
 8009626:	2300      	movne	r3, #0
 8009628:	b2db      	uxtb	r3, r3
 800962a:	4618      	mov	r0, r3
 800962c:	492b      	ldr	r1, [pc, #172]	; (80096dc <test_005_006_execute+0x21c>)
 800962e:	f7fd ffdf 	bl	80075f0 <_test_assert>
 8009632:	4603      	mov	r3, r0
 8009634:	2b00      	cmp	r3, #0
 8009636:	d002      	beq.n	800963e <test_005_006_execute+0x17e>
 8009638:	f7ff fbf2 	bl	8008e20 <osalSysUnlock>
 800963c:	e03e      	b.n	80096bc <test_005_006_execute+0x1fc>
 800963e:	f7ff fbef 	bl	8008e20 <osalSysUnlock>
  }

  /* [5.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8009642:	4b1f      	ldr	r3, [pc, #124]	; (80096c0 <test_005_006_execute+0x200>)
 8009644:	2206      	movs	r2, #6
 8009646:	601a      	str	r2, [r3, #0]
  {
    chBSemSignal(&bsem);
 8009648:	ab02      	add	r3, sp, #8
 800964a:	4618      	mov	r0, r3
 800964c:	f7ff fbc0 	bl	8008dd0 <chBSemSignal>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8009650:	f7ff fbde 	bl	8008e10 <osalSysLock>
 8009654:	ab02      	add	r3, sp, #8
 8009656:	4618      	mov	r0, r3
 8009658:	f7ff fbca 	bl	8008df0 <chBSemGetStateI>
 800965c:	4603      	mov	r3, r0
 800965e:	2b00      	cmp	r3, #0
 8009660:	bf14      	ite	ne
 8009662:	2301      	movne	r3, #1
 8009664:	2300      	moveq	r3, #0
 8009666:	b2db      	uxtb	r3, r3
 8009668:	f083 0301 	eor.w	r3, r3, #1
 800966c:	b2db      	uxtb	r3, r3
 800966e:	f003 0301 	and.w	r3, r3, #1
 8009672:	b2db      	uxtb	r3, r3
 8009674:	4618      	mov	r0, r3
 8009676:	491a      	ldr	r1, [pc, #104]	; (80096e0 <test_005_006_execute+0x220>)
 8009678:	f7fd ffba 	bl	80075f0 <_test_assert>
 800967c:	4603      	mov	r3, r0
 800967e:	2b00      	cmp	r3, #0
 8009680:	d002      	beq.n	8009688 <test_005_006_execute+0x1c8>
 8009682:	f7ff fbcd 	bl	8008e20 <osalSysUnlock>
 8009686:	e019      	b.n	80096bc <test_005_006_execute+0x1fc>
 8009688:	f7ff fbca 	bl	8008e20 <osalSysUnlock>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 800968c:	f7ff fbc0 	bl	8008e10 <osalSysLock>
 8009690:	ab02      	add	r3, sp, #8
 8009692:	4618      	mov	r0, r3
 8009694:	f7ff fb44 	bl	8008d20 <chSemGetCounterI>
 8009698:	4603      	mov	r3, r0
 800969a:	2b01      	cmp	r3, #1
 800969c:	bf0c      	ite	eq
 800969e:	2301      	moveq	r3, #1
 80096a0:	2300      	movne	r3, #0
 80096a2:	b2db      	uxtb	r3, r3
 80096a4:	4618      	mov	r0, r3
 80096a6:	490d      	ldr	r1, [pc, #52]	; (80096dc <test_005_006_execute+0x21c>)
 80096a8:	f7fd ffa2 	bl	80075f0 <_test_assert>
 80096ac:	4603      	mov	r3, r0
 80096ae:	2b00      	cmp	r3, #0
 80096b0:	d002      	beq.n	80096b8 <test_005_006_execute+0x1f8>
 80096b2:	f7ff fbb5 	bl	8008e20 <osalSysUnlock>
 80096b6:	e001      	b.n	80096bc <test_005_006_execute+0x1fc>
 80096b8:	f7ff fbb2 	bl	8008e20 <osalSysUnlock>
  }
}
 80096bc:	b006      	add	sp, #24
 80096be:	bd10      	pop	{r4, pc}
 80096c0:	20000cac 	.word	0x20000cac
 80096c4:	0800ed58 	.word	0x0800ed58
 80096c8:	0800e298 	.word	0x0800e298
 80096cc:	08008ea1 	.word	0x08008ea1
 80096d0:	20000cb0 	.word	0x20000cb0
 80096d4:	0800ed64 	.word	0x0800ed64
 80096d8:	0800ed78 	.word	0x0800ed78
 80096dc:	0800ed84 	.word	0x0800ed84
 80096e0:	0800ed98 	.word	0x0800ed98
	...

080096f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80096f0:	b082      	sub	sp, #8
 80096f2:	2320      	movs	r3, #32
 80096f4:	9301      	str	r3, [sp, #4]
 80096f6:	9b01      	ldr	r3, [sp, #4]
 80096f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80096fc:	b002      	add	sp, #8
 80096fe:	4770      	bx	lr

08009700 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009700:	b082      	sub	sp, #8
 8009702:	2300      	movs	r3, #0
 8009704:	9301      	str	r3, [sp, #4]
 8009706:	9b01      	ldr	r3, [sp, #4]
 8009708:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800970c:	b002      	add	sp, #8
 800970e:	4770      	bx	lr

08009710 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8009710:	b082      	sub	sp, #8
 8009712:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->next == (const thread_t *)tqp);
 8009714:	9b01      	ldr	r3, [sp, #4]
 8009716:	681a      	ldr	r2, [r3, #0]
 8009718:	9b01      	ldr	r3, [sp, #4]
 800971a:	429a      	cmp	r2, r3
 800971c:	bf0c      	ite	eq
 800971e:	2301      	moveq	r3, #1
 8009720:	2300      	movne	r3, #0
 8009722:	b2db      	uxtb	r3, r3
}
 8009724:	4618      	mov	r0, r3
 8009726:	b002      	add	sp, #8
 8009728:	4770      	bx	lr
 800972a:	bf00      	nop
 800972c:	f3af 8000 	nop.w

08009730 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009730:	b508      	push	{r3, lr}

  port_lock();
 8009732:	f7ff ffdd 	bl	80096f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8009736:	bd08      	pop	{r3, pc}
 8009738:	f3af 8000 	nop.w
 800973c:	f3af 8000 	nop.w

08009740 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009740:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 8009742:	f7ff ffdd 	bl	8009700 <port_unlock>
}
 8009746:	bd08      	pop	{r3, pc}
 8009748:	f3af 8000 	nop.w
 800974c:	f3af 8000 	nop.w

08009750 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8009750:	4b01      	ldr	r3, [pc, #4]	; (8009758 <chThdGetSelfX+0x8>)
 8009752:	699b      	ldr	r3, [r3, #24]
}
 8009754:	4618      	mov	r0, r3
 8009756:	4770      	bx	lr
 8009758:	20000af8 	.word	0x20000af8
 800975c:	f3af 8000 	nop.w

08009760 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8009760:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 8009762:	f7ff fff5 	bl	8009750 <chThdGetSelfX>
 8009766:	4603      	mov	r3, r0
 8009768:	689b      	ldr	r3, [r3, #8]
}
 800976a:	4618      	mov	r0, r3
 800976c:	bd08      	pop	{r3, pc}
 800976e:	bf00      	nop

08009770 <thread1>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8009770:	b500      	push	{lr}
 8009772:	b083      	sub	sp, #12
 8009774:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8009776:	4807      	ldr	r0, [pc, #28]	; (8009794 <thread1+0x24>)
 8009778:	f7f8 fd0a 	bl	8002190 <chMtxLock>
  test_emit_token(*(char *)p);
 800977c:	9b01      	ldr	r3, [sp, #4]
 800977e:	781b      	ldrb	r3, [r3, #0]
 8009780:	4618      	mov	r0, r3
 8009782:	f7fe f815 	bl	80077b0 <test_emit_token>
  chMtxUnlock(&m1);
 8009786:	4803      	ldr	r0, [pc, #12]	; (8009794 <thread1+0x24>)
 8009788:	f7f8 fdaa 	bl	80022e0 <chMtxUnlock>
}
 800978c:	b003      	add	sp, #12
 800978e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009792:	bf00      	nop
 8009794:	2000083c 	.word	0x2000083c
 8009798:	f3af 8000 	nop.w
 800979c:	f3af 8000 	nop.w

080097a0 <thread4A>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 80097a0:	b500      	push	{lr}
 80097a2:	b083      	sub	sp, #12
 80097a4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 80097a6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80097aa:	f7f7 ffb9 	bl	8001720 <chThdSleep>
  chMtxLock(&m1);
 80097ae:	4804      	ldr	r0, [pc, #16]	; (80097c0 <thread4A+0x20>)
 80097b0:	f7f8 fcee 	bl	8002190 <chMtxLock>
  chMtxUnlock(&m1);
 80097b4:	4802      	ldr	r0, [pc, #8]	; (80097c0 <thread4A+0x20>)
 80097b6:	f7f8 fd93 	bl	80022e0 <chMtxUnlock>
}
 80097ba:	b003      	add	sp, #12
 80097bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80097c0:	2000083c 	.word	0x2000083c
 80097c4:	f3af 8000 	nop.w
 80097c8:	f3af 8000 	nop.w
 80097cc:	f3af 8000 	nop.w

080097d0 <thread4B>:

static THD_FUNCTION(thread4B, p) {
 80097d0:	b500      	push	{lr}
 80097d2:	b083      	sub	sp, #12
 80097d4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 80097d6:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80097da:	f7f7 ffa1 	bl	8001720 <chThdSleep>
  chSysLock();
 80097de:	f7ff ffa7 	bl	8009730 <chSysLock>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 80097e2:	4806      	ldr	r0, [pc, #24]	; (80097fc <thread4B+0x2c>)
 80097e4:	f7f8 fce4 	bl	80021b0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 80097e8:	4804      	ldr	r0, [pc, #16]	; (80097fc <thread4B+0x2c>)
 80097ea:	f7f8 fdd1 	bl	8002390 <chMtxUnlockS>
  chSchRescheduleS();
 80097ee:	f7f7 fbcf 	bl	8000f90 <chSchRescheduleS>
  chSysUnlock();
 80097f2:	f7ff ffa5 	bl	8009740 <chSysUnlock>
}
 80097f6:	b003      	add	sp, #12
 80097f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80097fc:	2000084c 	.word	0x2000084c

08009800 <thread6>:

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8009800:	b500      	push	{lr}
 8009802:	b083      	sub	sp, #12
 8009804:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8009806:	4808      	ldr	r0, [pc, #32]	; (8009828 <thread6+0x28>)
 8009808:	f7f8 fcc2 	bl	8002190 <chMtxLock>
  chCondWait(&c1);
 800980c:	4807      	ldr	r0, [pc, #28]	; (800982c <thread6+0x2c>)
 800980e:	f7f8 ff8f 	bl	8002730 <chCondWait>
  test_emit_token(*(char *)p);
 8009812:	9b01      	ldr	r3, [sp, #4]
 8009814:	781b      	ldrb	r3, [r3, #0]
 8009816:	4618      	mov	r0, r3
 8009818:	f7fd ffca 	bl	80077b0 <test_emit_token>
  chMtxUnlock(&m1);
 800981c:	4802      	ldr	r0, [pc, #8]	; (8009828 <thread6+0x28>)
 800981e:	f7f8 fd5f 	bl	80022e0 <chMtxUnlock>
}
 8009822:	b003      	add	sp, #12
 8009824:	f85d fb04 	ldr.w	pc, [sp], #4
 8009828:	2000083c 	.word	0x2000083c
 800982c:	2000085c 	.word	0x2000085c

08009830 <thread8>:

static THD_FUNCTION(thread8, p) {
 8009830:	b500      	push	{lr}
 8009832:	b083      	sub	sp, #12
 8009834:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8009836:	480c      	ldr	r0, [pc, #48]	; (8009868 <thread8+0x38>)
 8009838:	f7f8 fcaa 	bl	8002190 <chMtxLock>
  chMtxLock(&m1);
 800983c:	480b      	ldr	r0, [pc, #44]	; (800986c <thread8+0x3c>)
 800983e:	f7f8 fca7 	bl	8002190 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8009842:	480b      	ldr	r0, [pc, #44]	; (8009870 <thread8+0x40>)
 8009844:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009848:	f7f8 ffaa 	bl	80027a0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800984c:	9b01      	ldr	r3, [sp, #4]
 800984e:	781b      	ldrb	r3, [r3, #0]
 8009850:	4618      	mov	r0, r3
 8009852:	f7fd ffad 	bl	80077b0 <test_emit_token>
  chMtxUnlock(&m1);
 8009856:	4805      	ldr	r0, [pc, #20]	; (800986c <thread8+0x3c>)
 8009858:	f7f8 fd42 	bl	80022e0 <chMtxUnlock>
  chMtxUnlock(&m2);
 800985c:	4802      	ldr	r0, [pc, #8]	; (8009868 <thread8+0x38>)
 800985e:	f7f8 fd3f 	bl	80022e0 <chMtxUnlock>
}
 8009862:	b003      	add	sp, #12
 8009864:	f85d fb04 	ldr.w	pc, [sp], #4
 8009868:	2000084c 	.word	0x2000084c
 800986c:	2000083c 	.word	0x2000083c
 8009870:	2000085c 	.word	0x2000085c
 8009874:	f3af 8000 	nop.w
 8009878:	f3af 8000 	nop.w
 800987c:	f3af 8000 	nop.w

08009880 <thread9>:

static THD_FUNCTION(thread9, p) {
 8009880:	b500      	push	{lr}
 8009882:	b083      	sub	sp, #12
 8009884:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8009886:	4807      	ldr	r0, [pc, #28]	; (80098a4 <thread9+0x24>)
 8009888:	f7f8 fc82 	bl	8002190 <chMtxLock>
  test_emit_token(*(char *)p);
 800988c:	9b01      	ldr	r3, [sp, #4]
 800988e:	781b      	ldrb	r3, [r3, #0]
 8009890:	4618      	mov	r0, r3
 8009892:	f7fd ff8d 	bl	80077b0 <test_emit_token>
  chMtxUnlock(&m2);
 8009896:	4803      	ldr	r0, [pc, #12]	; (80098a4 <thread9+0x24>)
 8009898:	f7f8 fd22 	bl	80022e0 <chMtxUnlock>
}
 800989c:	b003      	add	sp, #12
 800989e:	f85d fb04 	ldr.w	pc, [sp], #4
 80098a2:	bf00      	nop
 80098a4:	2000084c 	.word	0x2000084c
 80098a8:	f3af 8000 	nop.w
 80098ac:	f3af 8000 	nop.w

080098b0 <test_006_001_setup>:
 * - [6.1.4] Unlocking the mutex, the threads will wakeup in priority
 *   order because the mutext queue is an ordered one.
 * .
 */

static void test_006_001_setup(void) {
 80098b0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 80098b2:	4802      	ldr	r0, [pc, #8]	; (80098bc <test_006_001_setup+0xc>)
 80098b4:	f7f8 fc5c 	bl	8002170 <chMtxObjectInit>
}
 80098b8:	bd08      	pop	{r3, pc}
 80098ba:	bf00      	nop
 80098bc:	2000083c 	.word	0x2000083c

080098c0 <test_006_001_execute>:

static void test_006_001_execute(void) {
 80098c0:	b500      	push	{lr}
 80098c2:	b085      	sub	sp, #20
  tprio_t prio;

  /* [6.1.1] Getting the initial priority.*/
  test_set_step(1);
 80098c4:	4b3e      	ldr	r3, [pc, #248]	; (80099c0 <test_006_001_execute+0x100>)
 80098c6:	2201      	movs	r2, #1
 80098c8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 80098ca:	f7ff ff49 	bl	8009760 <chThdGetPriorityX>
 80098ce:	9003      	str	r0, [sp, #12]
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80098d0:	4b3b      	ldr	r3, [pc, #236]	; (80099c0 <test_006_001_execute+0x100>)
 80098d2:	2202      	movs	r2, #2
 80098d4:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
 80098d6:	483b      	ldr	r0, [pc, #236]	; (80099c4 <test_006_001_execute+0x104>)
 80098d8:	f7f8 fc5a 	bl	8002190 <chMtxLock>
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80098dc:	4b38      	ldr	r3, [pc, #224]	; (80099c0 <test_006_001_execute+0x100>)
 80098de:	2203      	movs	r2, #3
 80098e0:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80098e2:	4b39      	ldr	r3, [pc, #228]	; (80099c8 <test_006_001_execute+0x108>)
 80098e4:	6819      	ldr	r1, [r3, #0]
 80098e6:	9b03      	ldr	r3, [sp, #12]
 80098e8:	1c5a      	adds	r2, r3, #1
 80098ea:	4b38      	ldr	r3, [pc, #224]	; (80099cc <test_006_001_execute+0x10c>)
 80098ec:	9300      	str	r3, [sp, #0]
 80098ee:	4608      	mov	r0, r1
 80098f0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80098f4:	4b36      	ldr	r3, [pc, #216]	; (80099d0 <test_006_001_execute+0x110>)
 80098f6:	f7f7 fdab 	bl	8001450 <chThdCreateStatic>
 80098fa:	4602      	mov	r2, r0
 80098fc:	4b35      	ldr	r3, [pc, #212]	; (80099d4 <test_006_001_execute+0x114>)
 80098fe:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8009900:	4b31      	ldr	r3, [pc, #196]	; (80099c8 <test_006_001_execute+0x108>)
 8009902:	6859      	ldr	r1, [r3, #4]
 8009904:	9b03      	ldr	r3, [sp, #12]
 8009906:	1c9a      	adds	r2, r3, #2
 8009908:	4b33      	ldr	r3, [pc, #204]	; (80099d8 <test_006_001_execute+0x118>)
 800990a:	9300      	str	r3, [sp, #0]
 800990c:	4608      	mov	r0, r1
 800990e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009912:	4b2f      	ldr	r3, [pc, #188]	; (80099d0 <test_006_001_execute+0x110>)
 8009914:	f7f7 fd9c 	bl	8001450 <chThdCreateStatic>
 8009918:	4602      	mov	r2, r0
 800991a:	4b2e      	ldr	r3, [pc, #184]	; (80099d4 <test_006_001_execute+0x114>)
 800991c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800991e:	4b2a      	ldr	r3, [pc, #168]	; (80099c8 <test_006_001_execute+0x108>)
 8009920:	6899      	ldr	r1, [r3, #8]
 8009922:	9b03      	ldr	r3, [sp, #12]
 8009924:	1cda      	adds	r2, r3, #3
 8009926:	4b2d      	ldr	r3, [pc, #180]	; (80099dc <test_006_001_execute+0x11c>)
 8009928:	9300      	str	r3, [sp, #0]
 800992a:	4608      	mov	r0, r1
 800992c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009930:	4b27      	ldr	r3, [pc, #156]	; (80099d0 <test_006_001_execute+0x110>)
 8009932:	f7f7 fd8d 	bl	8001450 <chThdCreateStatic>
 8009936:	4602      	mov	r2, r0
 8009938:	4b26      	ldr	r3, [pc, #152]	; (80099d4 <test_006_001_execute+0x114>)
 800993a:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800993c:	4b22      	ldr	r3, [pc, #136]	; (80099c8 <test_006_001_execute+0x108>)
 800993e:	68d9      	ldr	r1, [r3, #12]
 8009940:	9b03      	ldr	r3, [sp, #12]
 8009942:	1d1a      	adds	r2, r3, #4
 8009944:	4b26      	ldr	r3, [pc, #152]	; (80099e0 <test_006_001_execute+0x120>)
 8009946:	9300      	str	r3, [sp, #0]
 8009948:	4608      	mov	r0, r1
 800994a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800994e:	4b20      	ldr	r3, [pc, #128]	; (80099d0 <test_006_001_execute+0x110>)
 8009950:	f7f7 fd7e 	bl	8001450 <chThdCreateStatic>
 8009954:	4602      	mov	r2, r0
 8009956:	4b1f      	ldr	r3, [pc, #124]	; (80099d4 <test_006_001_execute+0x114>)
 8009958:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800995a:	4b1b      	ldr	r3, [pc, #108]	; (80099c8 <test_006_001_execute+0x108>)
 800995c:	6919      	ldr	r1, [r3, #16]
 800995e:	9b03      	ldr	r3, [sp, #12]
 8009960:	1d5a      	adds	r2, r3, #5
 8009962:	4b20      	ldr	r3, [pc, #128]	; (80099e4 <test_006_001_execute+0x124>)
 8009964:	9300      	str	r3, [sp, #0]
 8009966:	4608      	mov	r0, r1
 8009968:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800996c:	4b18      	ldr	r3, [pc, #96]	; (80099d0 <test_006_001_execute+0x110>)
 800996e:	f7f7 fd6f 	bl	8001450 <chThdCreateStatic>
 8009972:	4602      	mov	r2, r0
 8009974:	4b17      	ldr	r3, [pc, #92]	; (80099d4 <test_006_001_execute+0x114>)
 8009976:	611a      	str	r2, [r3, #16]
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8009978:	4b11      	ldr	r3, [pc, #68]	; (80099c0 <test_006_001_execute+0x100>)
 800997a:	2204      	movs	r2, #4
 800997c:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 800997e:	4811      	ldr	r0, [pc, #68]	; (80099c4 <test_006_001_execute+0x104>)
 8009980:	f7f8 fcae 	bl	80022e0 <chMtxUnlock>
    test_wait_threads();
 8009984:	f7fe f8cc 	bl	8007b20 <test_wait_threads>
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8009988:	f7ff feea 	bl	8009760 <chThdGetPriorityX>
 800998c:	4602      	mov	r2, r0
 800998e:	9b03      	ldr	r3, [sp, #12]
 8009990:	429a      	cmp	r2, r3
 8009992:	bf0c      	ite	eq
 8009994:	2301      	moveq	r3, #1
 8009996:	2300      	movne	r3, #0
 8009998:	b2db      	uxtb	r3, r3
 800999a:	4618      	mov	r0, r3
 800999c:	4912      	ldr	r1, [pc, #72]	; (80099e8 <test_006_001_execute+0x128>)
 800999e:	f7fd fe27 	bl	80075f0 <_test_assert>
 80099a2:	4603      	mov	r3, r0
 80099a4:	2b00      	cmp	r3, #0
 80099a6:	d000      	beq.n	80099aa <test_006_001_execute+0xea>
 80099a8:	e007      	b.n	80099ba <test_006_001_execute+0xfa>
    test_assert_sequence("ABCDE", "invalid sequence");
 80099aa:	4810      	ldr	r0, [pc, #64]	; (80099ec <test_006_001_execute+0x12c>)
 80099ac:	4910      	ldr	r1, [pc, #64]	; (80099f0 <test_006_001_execute+0x130>)
 80099ae:	f7fd fe37 	bl	8007620 <_test_assert_sequence>
 80099b2:	4603      	mov	r3, r0
 80099b4:	2b00      	cmp	r3, #0
 80099b6:	d000      	beq.n	80099ba <test_006_001_execute+0xfa>
 80099b8:	bf00      	nop
  }
}
 80099ba:	b005      	add	sp, #20
 80099bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80099c0:	20000cac 	.word	0x20000cac
 80099c4:	2000083c 	.word	0x2000083c
 80099c8:	0800e298 	.word	0x0800e298
 80099cc:	0800edf4 	.word	0x0800edf4
 80099d0:	08009771 	.word	0x08009771
 80099d4:	20000cb0 	.word	0x20000cb0
 80099d8:	0800edf8 	.word	0x0800edf8
 80099dc:	0800edfc 	.word	0x0800edfc
 80099e0:	0800ee00 	.word	0x0800ee00
 80099e4:	0800ee04 	.word	0x0800ee04
 80099e8:	0800ee08 	.word	0x0800ee08
 80099ec:	0800ee20 	.word	0x0800ee20
 80099f0:	0800ee28 	.word	0x0800ee28
 80099f4:	f3af 8000 	nop.w
 80099f8:	f3af 8000 	nop.w
 80099fc:	f3af 8000 	nop.w

08009a00 <test_006_004_setup>:
 * - [6.4.7] Unlocking M2, the priority should fall back to P(A).
 * - [6.4.8] Unlocking M1, the priority should fall back to P(0).
 * .
 */

static void test_006_004_setup(void) {
 8009a00:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8009a02:	4803      	ldr	r0, [pc, #12]	; (8009a10 <test_006_004_setup+0x10>)
 8009a04:	f7f8 fbb4 	bl	8002170 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8009a08:	4802      	ldr	r0, [pc, #8]	; (8009a14 <test_006_004_setup+0x14>)
 8009a0a:	f7f8 fbb1 	bl	8002170 <chMtxObjectInit>
}
 8009a0e:	bd08      	pop	{r3, pc}
 8009a10:	2000083c 	.word	0x2000083c
 8009a14:	2000084c 	.word	0x2000084c
 8009a18:	f3af 8000 	nop.w
 8009a1c:	f3af 8000 	nop.w

08009a20 <test_006_004_teardown>:

static void test_006_004_teardown(void) {
 8009a20:	b508      	push	{r3, lr}
  test_wait_threads();
 8009a22:	f7fe f87d 	bl	8007b20 <test_wait_threads>
}
 8009a26:	bd08      	pop	{r3, pc}
 8009a28:	f3af 8000 	nop.w
 8009a2c:	f3af 8000 	nop.w

08009a30 <test_006_004_execute>:

static void test_006_004_execute(void) {
 8009a30:	b500      	push	{lr}
 8009a32:	b087      	sub	sp, #28
  tprio_t p, pa, pb;

  /* [6.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
 8009a34:	4b5c      	ldr	r3, [pc, #368]	; (8009ba8 <test_006_004_execute+0x178>)
 8009a36:	2201      	movs	r2, #1
 8009a38:	601a      	str	r2, [r3, #0]
  {
    p = chThdGetPriorityX();
 8009a3a:	f7ff fe91 	bl	8009760 <chThdGetPriorityX>
 8009a3e:	9005      	str	r0, [sp, #20]
    pa = p + 1;
 8009a40:	9b05      	ldr	r3, [sp, #20]
 8009a42:	3301      	adds	r3, #1
 8009a44:	9304      	str	r3, [sp, #16]
    pb = p + 2;
 8009a46:	9b05      	ldr	r3, [sp, #20]
 8009a48:	3302      	adds	r3, #2
 8009a4a:	9303      	str	r3, [sp, #12]
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8009a4c:	4b56      	ldr	r3, [pc, #344]	; (8009ba8 <test_006_004_execute+0x178>)
 8009a4e:	2202      	movs	r2, #2
 8009a50:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8009a52:	4b56      	ldr	r3, [pc, #344]	; (8009bac <test_006_004_execute+0x17c>)
 8009a54:	681a      	ldr	r2, [r3, #0]
 8009a56:	4b56      	ldr	r3, [pc, #344]	; (8009bb0 <test_006_004_execute+0x180>)
 8009a58:	9300      	str	r3, [sp, #0]
 8009a5a:	4610      	mov	r0, r2
 8009a5c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009a60:	9a04      	ldr	r2, [sp, #16]
 8009a62:	4b54      	ldr	r3, [pc, #336]	; (8009bb4 <test_006_004_execute+0x184>)
 8009a64:	f7f7 fcf4 	bl	8001450 <chThdCreateStatic>
 8009a68:	4602      	mov	r2, r0
 8009a6a:	4b53      	ldr	r3, [pc, #332]	; (8009bb8 <test_006_004_execute+0x188>)
 8009a6c:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8009a6e:	4b4f      	ldr	r3, [pc, #316]	; (8009bac <test_006_004_execute+0x17c>)
 8009a70:	685a      	ldr	r2, [r3, #4]
 8009a72:	4b52      	ldr	r3, [pc, #328]	; (8009bbc <test_006_004_execute+0x18c>)
 8009a74:	9300      	str	r3, [sp, #0]
 8009a76:	4610      	mov	r0, r2
 8009a78:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009a7c:	9a03      	ldr	r2, [sp, #12]
 8009a7e:	4b50      	ldr	r3, [pc, #320]	; (8009bc0 <test_006_004_execute+0x190>)
 8009a80:	f7f7 fce6 	bl	8001450 <chThdCreateStatic>
 8009a84:	4602      	mov	r2, r0
 8009a86:	4b4c      	ldr	r3, [pc, #304]	; (8009bb8 <test_006_004_execute+0x188>)
 8009a88:	605a      	str	r2, [r3, #4]
  }

  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8009a8a:	4b47      	ldr	r3, [pc, #284]	; (8009ba8 <test_006_004_execute+0x178>)
 8009a8c:	2203      	movs	r2, #3
 8009a8e:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m1);
 8009a90:	484c      	ldr	r0, [pc, #304]	; (8009bc4 <test_006_004_execute+0x194>)
 8009a92:	f7f8 fb7d 	bl	8002190 <chMtxLock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8009a96:	f7ff fe63 	bl	8009760 <chThdGetPriorityX>
 8009a9a:	4602      	mov	r2, r0
 8009a9c:	9b05      	ldr	r3, [sp, #20]
 8009a9e:	429a      	cmp	r2, r3
 8009aa0:	bf0c      	ite	eq
 8009aa2:	2301      	moveq	r3, #1
 8009aa4:	2300      	movne	r3, #0
 8009aa6:	b2db      	uxtb	r3, r3
 8009aa8:	4618      	mov	r0, r3
 8009aaa:	4947      	ldr	r1, [pc, #284]	; (8009bc8 <test_006_004_execute+0x198>)
 8009aac:	f7fd fda0 	bl	80075f0 <_test_assert>
 8009ab0:	4603      	mov	r3, r0
 8009ab2:	2b00      	cmp	r3, #0
 8009ab4:	d000      	beq.n	8009ab8 <test_006_004_execute+0x88>
 8009ab6:	e074      	b.n	8009ba2 <test_006_004_execute+0x172>
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8009ab8:	4b3b      	ldr	r3, [pc, #236]	; (8009ba8 <test_006_004_execute+0x178>)
 8009aba:	2204      	movs	r2, #4
 8009abc:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
 8009abe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009ac2:	f7f7 fe2d 	bl	8001720 <chThdSleep>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8009ac6:	f7ff fe4b 	bl	8009760 <chThdGetPriorityX>
 8009aca:	4602      	mov	r2, r0
 8009acc:	9b04      	ldr	r3, [sp, #16]
 8009ace:	429a      	cmp	r2, r3
 8009ad0:	bf0c      	ite	eq
 8009ad2:	2301      	moveq	r3, #1
 8009ad4:	2300      	movne	r3, #0
 8009ad6:	b2db      	uxtb	r3, r3
 8009ad8:	4618      	mov	r0, r3
 8009ada:	493b      	ldr	r1, [pc, #236]	; (8009bc8 <test_006_004_execute+0x198>)
 8009adc:	f7fd fd88 	bl	80075f0 <_test_assert>
 8009ae0:	4603      	mov	r3, r0
 8009ae2:	2b00      	cmp	r3, #0
 8009ae4:	d000      	beq.n	8009ae8 <test_006_004_execute+0xb8>
 8009ae6:	e05c      	b.n	8009ba2 <test_006_004_execute+0x172>
  }

  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 8009ae8:	4b2f      	ldr	r3, [pc, #188]	; (8009ba8 <test_006_004_execute+0x178>)
 8009aea:	2205      	movs	r2, #5
 8009aec:	601a      	str	r2, [r3, #0]
  {
    chMtxLock(&m2);
 8009aee:	4837      	ldr	r0, [pc, #220]	; (8009bcc <test_006_004_execute+0x19c>)
 8009af0:	f7f8 fb4e 	bl	8002190 <chMtxLock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8009af4:	f7ff fe34 	bl	8009760 <chThdGetPriorityX>
 8009af8:	4602      	mov	r2, r0
 8009afa:	9b04      	ldr	r3, [sp, #16]
 8009afc:	429a      	cmp	r2, r3
 8009afe:	bf0c      	ite	eq
 8009b00:	2301      	moveq	r3, #1
 8009b02:	2300      	movne	r3, #0
 8009b04:	b2db      	uxtb	r3, r3
 8009b06:	4618      	mov	r0, r3
 8009b08:	492f      	ldr	r1, [pc, #188]	; (8009bc8 <test_006_004_execute+0x198>)
 8009b0a:	f7fd fd71 	bl	80075f0 <_test_assert>
 8009b0e:	4603      	mov	r3, r0
 8009b10:	2b00      	cmp	r3, #0
 8009b12:	d000      	beq.n	8009b16 <test_006_004_execute+0xe6>
 8009b14:	e045      	b.n	8009ba2 <test_006_004_execute+0x172>
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8009b16:	4b24      	ldr	r3, [pc, #144]	; (8009ba8 <test_006_004_execute+0x178>)
 8009b18:	2206      	movs	r2, #6
 8009b1a:	601a      	str	r2, [r3, #0]
  {
    chThdSleepMilliseconds(100);
 8009b1c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009b20:	f7f7 fdfe 	bl	8001720 <chThdSleep>
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8009b24:	f7ff fe1c 	bl	8009760 <chThdGetPriorityX>
 8009b28:	4602      	mov	r2, r0
 8009b2a:	9b03      	ldr	r3, [sp, #12]
 8009b2c:	429a      	cmp	r2, r3
 8009b2e:	bf0c      	ite	eq
 8009b30:	2301      	moveq	r3, #1
 8009b32:	2300      	movne	r3, #0
 8009b34:	b2db      	uxtb	r3, r3
 8009b36:	4618      	mov	r0, r3
 8009b38:	4923      	ldr	r1, [pc, #140]	; (8009bc8 <test_006_004_execute+0x198>)
 8009b3a:	f7fd fd59 	bl	80075f0 <_test_assert>
 8009b3e:	4603      	mov	r3, r0
 8009b40:	2b00      	cmp	r3, #0
 8009b42:	d000      	beq.n	8009b46 <test_006_004_execute+0x116>
 8009b44:	e02d      	b.n	8009ba2 <test_006_004_execute+0x172>
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8009b46:	4b18      	ldr	r3, [pc, #96]	; (8009ba8 <test_006_004_execute+0x178>)
 8009b48:	2207      	movs	r2, #7
 8009b4a:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m2);
 8009b4c:	481f      	ldr	r0, [pc, #124]	; (8009bcc <test_006_004_execute+0x19c>)
 8009b4e:	f7f8 fbc7 	bl	80022e0 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8009b52:	f7ff fe05 	bl	8009760 <chThdGetPriorityX>
 8009b56:	4602      	mov	r2, r0
 8009b58:	9b04      	ldr	r3, [sp, #16]
 8009b5a:	429a      	cmp	r2, r3
 8009b5c:	bf0c      	ite	eq
 8009b5e:	2301      	moveq	r3, #1
 8009b60:	2300      	movne	r3, #0
 8009b62:	b2db      	uxtb	r3, r3
 8009b64:	4618      	mov	r0, r3
 8009b66:	4918      	ldr	r1, [pc, #96]	; (8009bc8 <test_006_004_execute+0x198>)
 8009b68:	f7fd fd42 	bl	80075f0 <_test_assert>
 8009b6c:	4603      	mov	r3, r0
 8009b6e:	2b00      	cmp	r3, #0
 8009b70:	d000      	beq.n	8009b74 <test_006_004_execute+0x144>
 8009b72:	e016      	b.n	8009ba2 <test_006_004_execute+0x172>
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8009b74:	4b0c      	ldr	r3, [pc, #48]	; (8009ba8 <test_006_004_execute+0x178>)
 8009b76:	2208      	movs	r2, #8
 8009b78:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 8009b7a:	4812      	ldr	r0, [pc, #72]	; (8009bc4 <test_006_004_execute+0x194>)
 8009b7c:	f7f8 fbb0 	bl	80022e0 <chMtxUnlock>
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8009b80:	f7ff fdee 	bl	8009760 <chThdGetPriorityX>
 8009b84:	4602      	mov	r2, r0
 8009b86:	9b05      	ldr	r3, [sp, #20]
 8009b88:	429a      	cmp	r2, r3
 8009b8a:	bf0c      	ite	eq
 8009b8c:	2301      	moveq	r3, #1
 8009b8e:	2300      	movne	r3, #0
 8009b90:	b2db      	uxtb	r3, r3
 8009b92:	4618      	mov	r0, r3
 8009b94:	490c      	ldr	r1, [pc, #48]	; (8009bc8 <test_006_004_execute+0x198>)
 8009b96:	f7fd fd2b 	bl	80075f0 <_test_assert>
 8009b9a:	4603      	mov	r3, r0
 8009b9c:	2b00      	cmp	r3, #0
 8009b9e:	d000      	beq.n	8009ba2 <test_006_004_execute+0x172>
 8009ba0:	bf00      	nop
  }
}
 8009ba2:	b007      	add	sp, #28
 8009ba4:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ba8:	20000cac 	.word	0x20000cac
 8009bac:	0800e298 	.word	0x0800e298
 8009bb0:	0800ee04 	.word	0x0800ee04
 8009bb4:	080097a1 	.word	0x080097a1
 8009bb8:	20000cb0 	.word	0x20000cb0
 8009bbc:	0800ee00 	.word	0x0800ee00
 8009bc0:	080097d1 	.word	0x080097d1
 8009bc4:	2000083c 	.word	0x2000083c
 8009bc8:	0800ee08 	.word	0x0800ee08
 8009bcc:	2000084c 	.word	0x2000084c

08009bd0 <test_006_005_setup>:
 * - [6.5.6] Testing chMtxUnlockAll() behavior.
 * - [6.5.7] Testing that priority has not changed after operations.
 * .
 */

static void test_006_005_setup(void) {
 8009bd0:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8009bd2:	4802      	ldr	r0, [pc, #8]	; (8009bdc <test_006_005_setup+0xc>)
 8009bd4:	f7f8 facc 	bl	8002170 <chMtxObjectInit>
}
 8009bd8:	bd08      	pop	{r3, pc}
 8009bda:	bf00      	nop
 8009bdc:	2000083c 	.word	0x2000083c

08009be0 <test_006_005_execute>:

static void test_006_005_execute(void) {
 8009be0:	b500      	push	{lr}
 8009be2:	b083      	sub	sp, #12
  bool b;
  tprio_t prio;

  /* [6.5.1] Getting current thread priority for later checks.*/
  test_set_step(1);
 8009be4:	4b66      	ldr	r3, [pc, #408]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009be6:	2201      	movs	r2, #1
 8009be8:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 8009bea:	f7ff fdb9 	bl	8009760 <chThdGetPriorityX>
 8009bee:	9001      	str	r0, [sp, #4]
  }

  /* [6.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 8009bf0:	4b63      	ldr	r3, [pc, #396]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009bf2:	2202      	movs	r2, #2
 8009bf4:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 8009bf6:	4863      	ldr	r0, [pc, #396]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009bf8:	f7f8 fb3a 	bl	8002270 <chMtxTryLock>
 8009bfc:	4603      	mov	r3, r0
 8009bfe:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
 8009c02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c06:	4618      	mov	r0, r3
 8009c08:	495f      	ldr	r1, [pc, #380]	; (8009d88 <test_006_005_execute+0x1a8>)
 8009c0a:	f7fd fcf1 	bl	80075f0 <_test_assert>
 8009c0e:	4603      	mov	r3, r0
 8009c10:	2b00      	cmp	r3, #0
 8009c12:	d000      	beq.n	8009c16 <test_006_005_execute+0x36>
 8009c14:	e0b1      	b.n	8009d7a <test_006_005_execute+0x19a>
  }

  /* [6.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 8009c16:	4b5a      	ldr	r3, [pc, #360]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009c18:	2203      	movs	r2, #3
 8009c1a:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 8009c1c:	4859      	ldr	r0, [pc, #356]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009c1e:	f7f8 fb27 	bl	8002270 <chMtxTryLock>
 8009c22:	4603      	mov	r3, r0
 8009c24:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
 8009c28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c2c:	2b00      	cmp	r3, #0
 8009c2e:	bf14      	ite	ne
 8009c30:	2301      	movne	r3, #1
 8009c32:	2300      	moveq	r3, #0
 8009c34:	b2db      	uxtb	r3, r3
 8009c36:	f083 0301 	eor.w	r3, r3, #1
 8009c3a:	b2db      	uxtb	r3, r3
 8009c3c:	f003 0301 	and.w	r3, r3, #1
 8009c40:	b2db      	uxtb	r3, r3
 8009c42:	4618      	mov	r0, r3
 8009c44:	4951      	ldr	r1, [pc, #324]	; (8009d8c <test_006_005_execute+0x1ac>)
 8009c46:	f7fd fcd3 	bl	80075f0 <_test_assert>
 8009c4a:	4603      	mov	r3, r0
 8009c4c:	2b00      	cmp	r3, #0
 8009c4e:	d000      	beq.n	8009c52 <test_006_005_execute+0x72>
 8009c50:	e093      	b.n	8009d7a <test_006_005_execute+0x19a>
  }

  /* [6.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8009c52:	4b4b      	ldr	r3, [pc, #300]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009c54:	2204      	movs	r2, #4
 8009c56:	601a      	str	r2, [r3, #0]
  {
    chMtxUnlock(&m1);
 8009c58:	484a      	ldr	r0, [pc, #296]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009c5a:	f7f8 fb41 	bl	80022e0 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8009c5e:	4b49      	ldr	r3, [pc, #292]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009c60:	689b      	ldr	r3, [r3, #8]
 8009c62:	2b00      	cmp	r3, #0
 8009c64:	bf0c      	ite	eq
 8009c66:	2301      	moveq	r3, #1
 8009c68:	2300      	movne	r3, #0
 8009c6a:	b2db      	uxtb	r3, r3
 8009c6c:	4618      	mov	r0, r3
 8009c6e:	4948      	ldr	r1, [pc, #288]	; (8009d90 <test_006_005_execute+0x1b0>)
 8009c70:	f7fd fcbe 	bl	80075f0 <_test_assert>
 8009c74:	4603      	mov	r3, r0
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	d000      	beq.n	8009c7c <test_006_005_execute+0x9c>
 8009c7a:	e07e      	b.n	8009d7a <test_006_005_execute+0x19a>
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8009c7c:	4841      	ldr	r0, [pc, #260]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009c7e:	f7ff fd47 	bl	8009710 <queue_isempty>
 8009c82:	4603      	mov	r3, r0
 8009c84:	4618      	mov	r0, r3
 8009c86:	4943      	ldr	r1, [pc, #268]	; (8009d94 <test_006_005_execute+0x1b4>)
 8009c88:	f7fd fcb2 	bl	80075f0 <_test_assert>
 8009c8c:	4603      	mov	r3, r0
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	d000      	beq.n	8009c94 <test_006_005_execute+0xb4>
 8009c92:	e072      	b.n	8009d7a <test_006_005_execute+0x19a>
  }

  /* [6.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8009c94:	4b3a      	ldr	r3, [pc, #232]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009c96:	2205      	movs	r2, #5
 8009c98:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8009c9a:	f7ff fd61 	bl	8009760 <chThdGetPriorityX>
 8009c9e:	4602      	mov	r2, r0
 8009ca0:	9b01      	ldr	r3, [sp, #4]
 8009ca2:	429a      	cmp	r2, r3
 8009ca4:	bf0c      	ite	eq
 8009ca6:	2301      	moveq	r3, #1
 8009ca8:	2300      	movne	r3, #0
 8009caa:	b2db      	uxtb	r3, r3
 8009cac:	4618      	mov	r0, r3
 8009cae:	493a      	ldr	r1, [pc, #232]	; (8009d98 <test_006_005_execute+0x1b8>)
 8009cb0:	f7fd fc9e 	bl	80075f0 <_test_assert>
 8009cb4:	4603      	mov	r3, r0
 8009cb6:	2b00      	cmp	r3, #0
 8009cb8:	d000      	beq.n	8009cbc <test_006_005_execute+0xdc>
 8009cba:	e05e      	b.n	8009d7a <test_006_005_execute+0x19a>
  }

  /* [6.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8009cbc:	4b30      	ldr	r3, [pc, #192]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009cbe:	2206      	movs	r2, #6
 8009cc0:	601a      	str	r2, [r3, #0]
  {
    b = chMtxTryLock(&m1);
 8009cc2:	4830      	ldr	r0, [pc, #192]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009cc4:	f7f8 fad4 	bl	8002270 <chMtxTryLock>
 8009cc8:	4603      	mov	r3, r0
 8009cca:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(b, "already locked");
 8009cce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009cd2:	4618      	mov	r0, r3
 8009cd4:	492c      	ldr	r1, [pc, #176]	; (8009d88 <test_006_005_execute+0x1a8>)
 8009cd6:	f7fd fc8b 	bl	80075f0 <_test_assert>
 8009cda:	4603      	mov	r3, r0
 8009cdc:	2b00      	cmp	r3, #0
 8009cde:	d000      	beq.n	8009ce2 <test_006_005_execute+0x102>
 8009ce0:	e04b      	b.n	8009d7a <test_006_005_execute+0x19a>
    b = chMtxTryLock(&m1);
 8009ce2:	4828      	ldr	r0, [pc, #160]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009ce4:	f7f8 fac4 	bl	8002270 <chMtxTryLock>
 8009ce8:	4603      	mov	r3, r0
 8009cea:	f88d 3003 	strb.w	r3, [sp, #3]
    test_assert(!b, "not locked");
 8009cee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009cf2:	2b00      	cmp	r3, #0
 8009cf4:	bf14      	ite	ne
 8009cf6:	2301      	movne	r3, #1
 8009cf8:	2300      	moveq	r3, #0
 8009cfa:	b2db      	uxtb	r3, r3
 8009cfc:	f083 0301 	eor.w	r3, r3, #1
 8009d00:	b2db      	uxtb	r3, r3
 8009d02:	f003 0301 	and.w	r3, r3, #1
 8009d06:	b2db      	uxtb	r3, r3
 8009d08:	4618      	mov	r0, r3
 8009d0a:	4920      	ldr	r1, [pc, #128]	; (8009d8c <test_006_005_execute+0x1ac>)
 8009d0c:	f7fd fc70 	bl	80075f0 <_test_assert>
 8009d10:	4603      	mov	r3, r0
 8009d12:	2b00      	cmp	r3, #0
 8009d14:	d000      	beq.n	8009d18 <test_006_005_execute+0x138>
 8009d16:	e030      	b.n	8009d7a <test_006_005_execute+0x19a>

    chMtxUnlockAll();
 8009d18:	f7f8 fbc2 	bl	80024a0 <chMtxUnlockAll>
    test_assert(m1.owner == NULL, "still owned");
 8009d1c:	4b19      	ldr	r3, [pc, #100]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009d1e:	689b      	ldr	r3, [r3, #8]
 8009d20:	2b00      	cmp	r3, #0
 8009d22:	bf0c      	ite	eq
 8009d24:	2301      	moveq	r3, #1
 8009d26:	2300      	movne	r3, #0
 8009d28:	b2db      	uxtb	r3, r3
 8009d2a:	4618      	mov	r0, r3
 8009d2c:	4918      	ldr	r1, [pc, #96]	; (8009d90 <test_006_005_execute+0x1b0>)
 8009d2e:	f7fd fc5f 	bl	80075f0 <_test_assert>
 8009d32:	4603      	mov	r3, r0
 8009d34:	2b00      	cmp	r3, #0
 8009d36:	d000      	beq.n	8009d3a <test_006_005_execute+0x15a>
 8009d38:	e01f      	b.n	8009d7a <test_006_005_execute+0x19a>
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8009d3a:	4812      	ldr	r0, [pc, #72]	; (8009d84 <test_006_005_execute+0x1a4>)
 8009d3c:	f7ff fce8 	bl	8009710 <queue_isempty>
 8009d40:	4603      	mov	r3, r0
 8009d42:	4618      	mov	r0, r3
 8009d44:	4913      	ldr	r1, [pc, #76]	; (8009d94 <test_006_005_execute+0x1b4>)
 8009d46:	f7fd fc53 	bl	80075f0 <_test_assert>
 8009d4a:	4603      	mov	r3, r0
 8009d4c:	2b00      	cmp	r3, #0
 8009d4e:	d000      	beq.n	8009d52 <test_006_005_execute+0x172>
 8009d50:	e013      	b.n	8009d7a <test_006_005_execute+0x19a>
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8009d52:	4b0b      	ldr	r3, [pc, #44]	; (8009d80 <test_006_005_execute+0x1a0>)
 8009d54:	2207      	movs	r2, #7
 8009d56:	601a      	str	r2, [r3, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8009d58:	f7ff fd02 	bl	8009760 <chThdGetPriorityX>
 8009d5c:	4602      	mov	r2, r0
 8009d5e:	9b01      	ldr	r3, [sp, #4]
 8009d60:	429a      	cmp	r2, r3
 8009d62:	bf0c      	ite	eq
 8009d64:	2301      	moveq	r3, #1
 8009d66:	2300      	movne	r3, #0
 8009d68:	b2db      	uxtb	r3, r3
 8009d6a:	4618      	mov	r0, r3
 8009d6c:	490a      	ldr	r1, [pc, #40]	; (8009d98 <test_006_005_execute+0x1b8>)
 8009d6e:	f7fd fc3f 	bl	80075f0 <_test_assert>
 8009d72:	4603      	mov	r3, r0
 8009d74:	2b00      	cmp	r3, #0
 8009d76:	d000      	beq.n	8009d7a <test_006_005_execute+0x19a>
 8009d78:	bf00      	nop
  }
}
 8009d7a:	b003      	add	sp, #12
 8009d7c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d80:	20000cac 	.word	0x20000cac
 8009d84:	2000083c 	.word	0x2000083c
 8009d88:	0800ee94 	.word	0x0800ee94
 8009d8c:	0800eea4 	.word	0x0800eea4
 8009d90:	0800eeb0 	.word	0x0800eeb0
 8009d94:	0800eebc 	.word	0x0800eebc
 8009d98:	0800ee08 	.word	0x0800ee08
 8009d9c:	f3af 8000 	nop.w

08009da0 <test_006_007_setup>:
 *   then waiting for the threads to terminate in priority order, the
 *   order is tested.
 * .
 */

static void test_006_007_setup(void) {
 8009da0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8009da2:	4803      	ldr	r0, [pc, #12]	; (8009db0 <test_006_007_setup+0x10>)
 8009da4:	f7f8 fc4c 	bl	8002640 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8009da8:	4802      	ldr	r0, [pc, #8]	; (8009db4 <test_006_007_setup+0x14>)
 8009daa:	f7f8 f9e1 	bl	8002170 <chMtxObjectInit>
}
 8009dae:	bd08      	pop	{r3, pc}
 8009db0:	2000085c 	.word	0x2000085c
 8009db4:	2000083c 	.word	0x2000083c
 8009db8:	f3af 8000 	nop.w
 8009dbc:	f3af 8000 	nop.w

08009dc0 <test_006_007_execute>:

static void test_006_007_execute(void) {
 8009dc0:	b500      	push	{lr}
 8009dc2:	b085      	sub	sp, #20

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8009dc4:	4b3a      	ldr	r3, [pc, #232]	; (8009eb0 <test_006_007_execute+0xf0>)
 8009dc6:	2201      	movs	r2, #1
 8009dc8:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
 8009dca:	f7ff fcc9 	bl	8009760 <chThdGetPriorityX>
 8009dce:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009dd0:	4b38      	ldr	r3, [pc, #224]	; (8009eb4 <test_006_007_execute+0xf4>)
 8009dd2:	6819      	ldr	r1, [r3, #0]
 8009dd4:	9b03      	ldr	r3, [sp, #12]
 8009dd6:	1c5a      	adds	r2, r3, #1
 8009dd8:	4b37      	ldr	r3, [pc, #220]	; (8009eb8 <test_006_007_execute+0xf8>)
 8009dda:	9300      	str	r3, [sp, #0]
 8009ddc:	4608      	mov	r0, r1
 8009dde:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009de2:	4b36      	ldr	r3, [pc, #216]	; (8009ebc <test_006_007_execute+0xfc>)
 8009de4:	f7f7 fb34 	bl	8001450 <chThdCreateStatic>
 8009de8:	4602      	mov	r2, r0
 8009dea:	4b35      	ldr	r3, [pc, #212]	; (8009ec0 <test_006_007_execute+0x100>)
 8009dec:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009dee:	4b31      	ldr	r3, [pc, #196]	; (8009eb4 <test_006_007_execute+0xf4>)
 8009df0:	6859      	ldr	r1, [r3, #4]
 8009df2:	9b03      	ldr	r3, [sp, #12]
 8009df4:	1c9a      	adds	r2, r3, #2
 8009df6:	4b33      	ldr	r3, [pc, #204]	; (8009ec4 <test_006_007_execute+0x104>)
 8009df8:	9300      	str	r3, [sp, #0]
 8009dfa:	4608      	mov	r0, r1
 8009dfc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009e00:	4b2e      	ldr	r3, [pc, #184]	; (8009ebc <test_006_007_execute+0xfc>)
 8009e02:	f7f7 fb25 	bl	8001450 <chThdCreateStatic>
 8009e06:	4602      	mov	r2, r0
 8009e08:	4b2d      	ldr	r3, [pc, #180]	; (8009ec0 <test_006_007_execute+0x100>)
 8009e0a:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009e0c:	4b29      	ldr	r3, [pc, #164]	; (8009eb4 <test_006_007_execute+0xf4>)
 8009e0e:	6899      	ldr	r1, [r3, #8]
 8009e10:	9b03      	ldr	r3, [sp, #12]
 8009e12:	1cda      	adds	r2, r3, #3
 8009e14:	4b2c      	ldr	r3, [pc, #176]	; (8009ec8 <test_006_007_execute+0x108>)
 8009e16:	9300      	str	r3, [sp, #0]
 8009e18:	4608      	mov	r0, r1
 8009e1a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009e1e:	4b27      	ldr	r3, [pc, #156]	; (8009ebc <test_006_007_execute+0xfc>)
 8009e20:	f7f7 fb16 	bl	8001450 <chThdCreateStatic>
 8009e24:	4602      	mov	r2, r0
 8009e26:	4b26      	ldr	r3, [pc, #152]	; (8009ec0 <test_006_007_execute+0x100>)
 8009e28:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009e2a:	4b22      	ldr	r3, [pc, #136]	; (8009eb4 <test_006_007_execute+0xf4>)
 8009e2c:	68d9      	ldr	r1, [r3, #12]
 8009e2e:	9b03      	ldr	r3, [sp, #12]
 8009e30:	1d1a      	adds	r2, r3, #4
 8009e32:	4b26      	ldr	r3, [pc, #152]	; (8009ecc <test_006_007_execute+0x10c>)
 8009e34:	9300      	str	r3, [sp, #0]
 8009e36:	4608      	mov	r0, r1
 8009e38:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009e3c:	4b1f      	ldr	r3, [pc, #124]	; (8009ebc <test_006_007_execute+0xfc>)
 8009e3e:	f7f7 fb07 	bl	8001450 <chThdCreateStatic>
 8009e42:	4602      	mov	r2, r0
 8009e44:	4b1e      	ldr	r3, [pc, #120]	; (8009ec0 <test_006_007_execute+0x100>)
 8009e46:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009e48:	4b1a      	ldr	r3, [pc, #104]	; (8009eb4 <test_006_007_execute+0xf4>)
 8009e4a:	6919      	ldr	r1, [r3, #16]
 8009e4c:	9b03      	ldr	r3, [sp, #12]
 8009e4e:	1d5a      	adds	r2, r3, #5
 8009e50:	4b1f      	ldr	r3, [pc, #124]	; (8009ed0 <test_006_007_execute+0x110>)
 8009e52:	9300      	str	r3, [sp, #0]
 8009e54:	4608      	mov	r0, r1
 8009e56:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009e5a:	4b18      	ldr	r3, [pc, #96]	; (8009ebc <test_006_007_execute+0xfc>)
 8009e5c:	f7f7 faf8 	bl	8001450 <chThdCreateStatic>
 8009e60:	4602      	mov	r2, r0
 8009e62:	4b17      	ldr	r3, [pc, #92]	; (8009ec0 <test_006_007_execute+0x100>)
 8009e64:	611a      	str	r2, [r3, #16]
  }

  /* [6.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8009e66:	4b12      	ldr	r3, [pc, #72]	; (8009eb0 <test_006_007_execute+0xf0>)
 8009e68:	2202      	movs	r2, #2
 8009e6a:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 8009e6c:	f7ff fc60 	bl	8009730 <chSysLock>
    chCondSignalI(&c1);
 8009e70:	4818      	ldr	r0, [pc, #96]	; (8009ed4 <test_006_007_execute+0x114>)
 8009e72:	f7f8 fc15 	bl	80026a0 <chCondSignalI>
    chCondSignalI(&c1);
 8009e76:	4817      	ldr	r0, [pc, #92]	; (8009ed4 <test_006_007_execute+0x114>)
 8009e78:	f7f8 fc12 	bl	80026a0 <chCondSignalI>
    chCondSignalI(&c1);
 8009e7c:	4815      	ldr	r0, [pc, #84]	; (8009ed4 <test_006_007_execute+0x114>)
 8009e7e:	f7f8 fc0f 	bl	80026a0 <chCondSignalI>
    chCondSignalI(&c1);
 8009e82:	4814      	ldr	r0, [pc, #80]	; (8009ed4 <test_006_007_execute+0x114>)
 8009e84:	f7f8 fc0c 	bl	80026a0 <chCondSignalI>
    chCondSignalI(&c1);
 8009e88:	4812      	ldr	r0, [pc, #72]	; (8009ed4 <test_006_007_execute+0x114>)
 8009e8a:	f7f8 fc09 	bl	80026a0 <chCondSignalI>
    chSchRescheduleS();
 8009e8e:	f7f7 f87f 	bl	8000f90 <chSchRescheduleS>
    chSysUnlock();
 8009e92:	f7ff fc55 	bl	8009740 <chSysUnlock>
    test_wait_threads();
 8009e96:	f7fd fe43 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8009e9a:	480f      	ldr	r0, [pc, #60]	; (8009ed8 <test_006_007_execute+0x118>)
 8009e9c:	490f      	ldr	r1, [pc, #60]	; (8009edc <test_006_007_execute+0x11c>)
 8009e9e:	f7fd fbbf 	bl	8007620 <_test_assert_sequence>
 8009ea2:	4603      	mov	r3, r0
 8009ea4:	2b00      	cmp	r3, #0
 8009ea6:	d000      	beq.n	8009eaa <test_006_007_execute+0xea>
 8009ea8:	bf00      	nop
  }
}
 8009eaa:	b005      	add	sp, #20
 8009eac:	f85d fb04 	ldr.w	pc, [sp], #4
 8009eb0:	20000cac 	.word	0x20000cac
 8009eb4:	0800e298 	.word	0x0800e298
 8009eb8:	0800edf4 	.word	0x0800edf4
 8009ebc:	08009801 	.word	0x08009801
 8009ec0:	20000cb0 	.word	0x20000cb0
 8009ec4:	0800edf8 	.word	0x0800edf8
 8009ec8:	0800edfc 	.word	0x0800edfc
 8009ecc:	0800ee00 	.word	0x0800ee00
 8009ed0:	0800ee04 	.word	0x0800ee04
 8009ed4:	2000085c 	.word	0x2000085c
 8009ed8:	0800ee20 	.word	0x0800ee20
 8009edc:	0800ee28 	.word	0x0800ee28

08009ee0 <test_006_008_setup>:
 * - [6.8.2] Broarcasting on the condition variable then waiting for
 *   the threads to terminate in priority order, the order is tested.
 * .
 */

static void test_006_008_setup(void) {
 8009ee0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8009ee2:	4803      	ldr	r0, [pc, #12]	; (8009ef0 <test_006_008_setup+0x10>)
 8009ee4:	f7f8 fbac 	bl	8002640 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8009ee8:	4802      	ldr	r0, [pc, #8]	; (8009ef4 <test_006_008_setup+0x14>)
 8009eea:	f7f8 f941 	bl	8002170 <chMtxObjectInit>
}
 8009eee:	bd08      	pop	{r3, pc}
 8009ef0:	2000085c 	.word	0x2000085c
 8009ef4:	2000083c 	.word	0x2000083c
 8009ef8:	f3af 8000 	nop.w
 8009efc:	f3af 8000 	nop.w

08009f00 <test_006_008_execute>:

static void test_006_008_execute(void) {
 8009f00:	b500      	push	{lr}
 8009f02:	b085      	sub	sp, #20

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8009f04:	4b31      	ldr	r3, [pc, #196]	; (8009fcc <test_006_008_execute+0xcc>)
 8009f06:	2201      	movs	r2, #1
 8009f08:	601a      	str	r2, [r3, #0]
  {
    tprio_t prio = chThdGetPriorityX();
 8009f0a:	f7ff fc29 	bl	8009760 <chThdGetPriorityX>
 8009f0e:	9003      	str	r0, [sp, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8009f10:	4b2f      	ldr	r3, [pc, #188]	; (8009fd0 <test_006_008_execute+0xd0>)
 8009f12:	6819      	ldr	r1, [r3, #0]
 8009f14:	9b03      	ldr	r3, [sp, #12]
 8009f16:	1c5a      	adds	r2, r3, #1
 8009f18:	4b2e      	ldr	r3, [pc, #184]	; (8009fd4 <test_006_008_execute+0xd4>)
 8009f1a:	9300      	str	r3, [sp, #0]
 8009f1c:	4608      	mov	r0, r1
 8009f1e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009f22:	4b2d      	ldr	r3, [pc, #180]	; (8009fd8 <test_006_008_execute+0xd8>)
 8009f24:	f7f7 fa94 	bl	8001450 <chThdCreateStatic>
 8009f28:	4602      	mov	r2, r0
 8009f2a:	4b2c      	ldr	r3, [pc, #176]	; (8009fdc <test_006_008_execute+0xdc>)
 8009f2c:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8009f2e:	4b28      	ldr	r3, [pc, #160]	; (8009fd0 <test_006_008_execute+0xd0>)
 8009f30:	6859      	ldr	r1, [r3, #4]
 8009f32:	9b03      	ldr	r3, [sp, #12]
 8009f34:	1c9a      	adds	r2, r3, #2
 8009f36:	4b2a      	ldr	r3, [pc, #168]	; (8009fe0 <test_006_008_execute+0xe0>)
 8009f38:	9300      	str	r3, [sp, #0]
 8009f3a:	4608      	mov	r0, r1
 8009f3c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009f40:	4b25      	ldr	r3, [pc, #148]	; (8009fd8 <test_006_008_execute+0xd8>)
 8009f42:	f7f7 fa85 	bl	8001450 <chThdCreateStatic>
 8009f46:	4602      	mov	r2, r0
 8009f48:	4b24      	ldr	r3, [pc, #144]	; (8009fdc <test_006_008_execute+0xdc>)
 8009f4a:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8009f4c:	4b20      	ldr	r3, [pc, #128]	; (8009fd0 <test_006_008_execute+0xd0>)
 8009f4e:	6899      	ldr	r1, [r3, #8]
 8009f50:	9b03      	ldr	r3, [sp, #12]
 8009f52:	1cda      	adds	r2, r3, #3
 8009f54:	4b23      	ldr	r3, [pc, #140]	; (8009fe4 <test_006_008_execute+0xe4>)
 8009f56:	9300      	str	r3, [sp, #0]
 8009f58:	4608      	mov	r0, r1
 8009f5a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009f5e:	4b1e      	ldr	r3, [pc, #120]	; (8009fd8 <test_006_008_execute+0xd8>)
 8009f60:	f7f7 fa76 	bl	8001450 <chThdCreateStatic>
 8009f64:	4602      	mov	r2, r0
 8009f66:	4b1d      	ldr	r3, [pc, #116]	; (8009fdc <test_006_008_execute+0xdc>)
 8009f68:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8009f6a:	4b19      	ldr	r3, [pc, #100]	; (8009fd0 <test_006_008_execute+0xd0>)
 8009f6c:	68d9      	ldr	r1, [r3, #12]
 8009f6e:	9b03      	ldr	r3, [sp, #12]
 8009f70:	1d1a      	adds	r2, r3, #4
 8009f72:	4b1d      	ldr	r3, [pc, #116]	; (8009fe8 <test_006_008_execute+0xe8>)
 8009f74:	9300      	str	r3, [sp, #0]
 8009f76:	4608      	mov	r0, r1
 8009f78:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009f7c:	4b16      	ldr	r3, [pc, #88]	; (8009fd8 <test_006_008_execute+0xd8>)
 8009f7e:	f7f7 fa67 	bl	8001450 <chThdCreateStatic>
 8009f82:	4602      	mov	r2, r0
 8009f84:	4b15      	ldr	r3, [pc, #84]	; (8009fdc <test_006_008_execute+0xdc>)
 8009f86:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8009f88:	4b11      	ldr	r3, [pc, #68]	; (8009fd0 <test_006_008_execute+0xd0>)
 8009f8a:	6919      	ldr	r1, [r3, #16]
 8009f8c:	9b03      	ldr	r3, [sp, #12]
 8009f8e:	1d5a      	adds	r2, r3, #5
 8009f90:	4b16      	ldr	r3, [pc, #88]	; (8009fec <test_006_008_execute+0xec>)
 8009f92:	9300      	str	r3, [sp, #0]
 8009f94:	4608      	mov	r0, r1
 8009f96:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8009f9a:	4b0f      	ldr	r3, [pc, #60]	; (8009fd8 <test_006_008_execute+0xd8>)
 8009f9c:	f7f7 fa58 	bl	8001450 <chThdCreateStatic>
 8009fa0:	4602      	mov	r2, r0
 8009fa2:	4b0e      	ldr	r3, [pc, #56]	; (8009fdc <test_006_008_execute+0xdc>)
 8009fa4:	611a      	str	r2, [r3, #16]
  }

  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8009fa6:	4b09      	ldr	r3, [pc, #36]	; (8009fcc <test_006_008_execute+0xcc>)
 8009fa8:	2202      	movs	r2, #2
 8009faa:	601a      	str	r2, [r3, #0]
  {
    chCondBroadcast(&c1);
 8009fac:	4810      	ldr	r0, [pc, #64]	; (8009ff0 <test_006_008_execute+0xf0>)
 8009fae:	f7f8 fb8f 	bl	80026d0 <chCondBroadcast>
    test_wait_threads();
 8009fb2:	f7fd fdb5 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8009fb6:	480f      	ldr	r0, [pc, #60]	; (8009ff4 <test_006_008_execute+0xf4>)
 8009fb8:	490f      	ldr	r1, [pc, #60]	; (8009ff8 <test_006_008_execute+0xf8>)
 8009fba:	f7fd fb31 	bl	8007620 <_test_assert_sequence>
 8009fbe:	4603      	mov	r3, r0
 8009fc0:	2b00      	cmp	r3, #0
 8009fc2:	d000      	beq.n	8009fc6 <test_006_008_execute+0xc6>
 8009fc4:	bf00      	nop
  }
}
 8009fc6:	b005      	add	sp, #20
 8009fc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8009fcc:	20000cac 	.word	0x20000cac
 8009fd0:	0800e298 	.word	0x0800e298
 8009fd4:	0800edf4 	.word	0x0800edf4
 8009fd8:	08009801 	.word	0x08009801
 8009fdc:	20000cb0 	.word	0x20000cb0
 8009fe0:	0800edf8 	.word	0x0800edf8
 8009fe4:	0800edfc 	.word	0x0800edfc
 8009fe8:	0800ee00 	.word	0x0800ee00
 8009fec:	0800ee04 	.word	0x0800ee04
 8009ff0:	2000085c 	.word	0x2000085c
 8009ff4:	0800ee20 	.word	0x0800ee20
 8009ff8:	0800ee28 	.word	0x0800ee28
 8009ffc:	f3af 8000 	nop.w

0800a000 <test_006_009_setup>:
 * - [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.
 * - [6.9.7] Checking the order of operations.
 * .
 */

static void test_006_009_setup(void) {
 800a000:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 800a002:	4805      	ldr	r0, [pc, #20]	; (800a018 <test_006_009_setup+0x18>)
 800a004:	f7f8 fb1c 	bl	8002640 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800a008:	4804      	ldr	r0, [pc, #16]	; (800a01c <test_006_009_setup+0x1c>)
 800a00a:	f7f8 f8b1 	bl	8002170 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800a00e:	4804      	ldr	r0, [pc, #16]	; (800a020 <test_006_009_setup+0x20>)
 800a010:	f7f8 f8ae 	bl	8002170 <chMtxObjectInit>
}
 800a014:	bd08      	pop	{r3, pc}
 800a016:	bf00      	nop
 800a018:	2000085c 	.word	0x2000085c
 800a01c:	2000083c 	.word	0x2000083c
 800a020:	2000084c 	.word	0x2000084c
 800a024:	f3af 8000 	nop.w
 800a028:	f3af 8000 	nop.w
 800a02c:	f3af 8000 	nop.w

0800a030 <test_006_009_execute>:

static void test_006_009_execute(void) {
 800a030:	b500      	push	{lr}
 800a032:	b085      	sub	sp, #20
  tprio_t prio;

  /* [6.9.1] Reading current base priority.*/
  test_set_step(1);
 800a034:	4b2b      	ldr	r3, [pc, #172]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a036:	2201      	movs	r2, #1
 800a038:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800a03a:	f7ff fb91 	bl	8009760 <chThdGetPriorityX>
 800a03e:	9003      	str	r0, [sp, #12]
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 800a040:	4b28      	ldr	r3, [pc, #160]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a042:	2202      	movs	r2, #2
 800a044:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 800a046:	4b28      	ldr	r3, [pc, #160]	; (800a0e8 <test_006_009_execute+0xb8>)
 800a048:	6819      	ldr	r1, [r3, #0]
 800a04a:	9b03      	ldr	r3, [sp, #12]
 800a04c:	1c5a      	adds	r2, r3, #1
 800a04e:	4b27      	ldr	r3, [pc, #156]	; (800a0ec <test_006_009_execute+0xbc>)
 800a050:	9300      	str	r3, [sp, #0]
 800a052:	4608      	mov	r0, r1
 800a054:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a058:	4b25      	ldr	r3, [pc, #148]	; (800a0f0 <test_006_009_execute+0xc0>)
 800a05a:	f7f7 f9f9 	bl	8001450 <chThdCreateStatic>
 800a05e:	4602      	mov	r2, r0
 800a060:	4b24      	ldr	r3, [pc, #144]	; (800a0f4 <test_006_009_execute+0xc4>)
 800a062:	601a      	str	r2, [r3, #0]
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 800a064:	4b1f      	ldr	r3, [pc, #124]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a066:	2203      	movs	r2, #3
 800a068:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 800a06a:	4b1f      	ldr	r3, [pc, #124]	; (800a0e8 <test_006_009_execute+0xb8>)
 800a06c:	6859      	ldr	r1, [r3, #4]
 800a06e:	9b03      	ldr	r3, [sp, #12]
 800a070:	1c9a      	adds	r2, r3, #2
 800a072:	4b21      	ldr	r3, [pc, #132]	; (800a0f8 <test_006_009_execute+0xc8>)
 800a074:	9300      	str	r3, [sp, #0]
 800a076:	4608      	mov	r0, r1
 800a078:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a07c:	4b1f      	ldr	r3, [pc, #124]	; (800a0fc <test_006_009_execute+0xcc>)
 800a07e:	f7f7 f9e7 	bl	8001450 <chThdCreateStatic>
 800a082:	4602      	mov	r2, r0
 800a084:	4b1b      	ldr	r3, [pc, #108]	; (800a0f4 <test_006_009_execute+0xc4>)
 800a086:	605a      	str	r2, [r3, #4]
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 800a088:	4b16      	ldr	r3, [pc, #88]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a08a:	2204      	movs	r2, #4
 800a08c:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800a08e:	4b16      	ldr	r3, [pc, #88]	; (800a0e8 <test_006_009_execute+0xb8>)
 800a090:	6899      	ldr	r1, [r3, #8]
 800a092:	9b03      	ldr	r3, [sp, #12]
 800a094:	1cda      	adds	r2, r3, #3
 800a096:	4b1a      	ldr	r3, [pc, #104]	; (800a100 <test_006_009_execute+0xd0>)
 800a098:	9300      	str	r3, [sp, #0]
 800a09a:	4608      	mov	r0, r1
 800a09c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a0a0:	4b18      	ldr	r3, [pc, #96]	; (800a104 <test_006_009_execute+0xd4>)
 800a0a2:	f7f7 f9d5 	bl	8001450 <chThdCreateStatic>
 800a0a6:	4602      	mov	r2, r0
 800a0a8:	4b12      	ldr	r3, [pc, #72]	; (800a0f4 <test_006_009_execute+0xc4>)
 800a0aa:	609a      	str	r2, [r3, #8]
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 800a0ac:	4b0d      	ldr	r3, [pc, #52]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a0ae:	2205      	movs	r2, #5
 800a0b0:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
 800a0b2:	4815      	ldr	r0, [pc, #84]	; (800a108 <test_006_009_execute+0xd8>)
 800a0b4:	f7f8 fad4 	bl	8002660 <chCondSignal>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 800a0b8:	4b0a      	ldr	r3, [pc, #40]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a0ba:	2206      	movs	r2, #6
 800a0bc:	601a      	str	r2, [r3, #0]
  {
    chCondSignal(&c1);
 800a0be:	4812      	ldr	r0, [pc, #72]	; (800a108 <test_006_009_execute+0xd8>)
 800a0c0:	f7f8 face 	bl	8002660 <chCondSignal>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 800a0c4:	4b07      	ldr	r3, [pc, #28]	; (800a0e4 <test_006_009_execute+0xb4>)
 800a0c6:	2207      	movs	r2, #7
 800a0c8:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 800a0ca:	f7fd fd29 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 800a0ce:	480f      	ldr	r0, [pc, #60]	; (800a10c <test_006_009_execute+0xdc>)
 800a0d0:	490f      	ldr	r1, [pc, #60]	; (800a110 <test_006_009_execute+0xe0>)
 800a0d2:	f7fd faa5 	bl	8007620 <_test_assert_sequence>
 800a0d6:	4603      	mov	r3, r0
 800a0d8:	2b00      	cmp	r3, #0
 800a0da:	d000      	beq.n	800a0de <test_006_009_execute+0xae>
 800a0dc:	bf00      	nop
  }
}
 800a0de:	b005      	add	sp, #20
 800a0e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0e4:	20000cac 	.word	0x20000cac
 800a0e8:	0800e298 	.word	0x0800e298
 800a0ec:	0800ee04 	.word	0x0800ee04
 800a0f0:	08009831 	.word	0x08009831
 800a0f4:	20000cb0 	.word	0x20000cb0
 800a0f8:	0800edfc 	.word	0x0800edfc
 800a0fc:	08009801 	.word	0x08009801
 800a100:	0800ee00 	.word	0x0800ee00
 800a104:	08009881 	.word	0x08009881
 800a108:	2000085c 	.word	0x2000085c
 800a10c:	0800ef68 	.word	0x0800ef68
 800a110:	0800ee28 	.word	0x0800ee28
	...

0800a120 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800a120:	4b01      	ldr	r3, [pc, #4]	; (800a128 <chThdGetSelfX+0x8>)
 800a122:	699b      	ldr	r3, [r3, #24]
}
 800a124:	4618      	mov	r0, r3
 800a126:	4770      	bx	lr
 800a128:	20000af8 	.word	0x20000af8
 800a12c:	f3af 8000 	nop.w

0800a130 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800a130:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 800a132:	f7ff fff5 	bl	800a120 <chThdGetSelfX>
 800a136:	4603      	mov	r3, r0
 800a138:	689b      	ldr	r3, [r3, #8]
}
 800a13a:	4618      	mov	r0, r3
 800a13c:	bd08      	pop	{r3, pc}
 800a13e:	bf00      	nop

0800a140 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800a140:	b082      	sub	sp, #8
 800a142:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");

  return tp->u.sentmsg;
 800a144:	9b01      	ldr	r3, [sp, #4]
 800a146:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800a148:	4618      	mov	r0, r3
 800a14a:	b002      	add	sp, #8
 800a14c:	4770      	bx	lr
 800a14e:	bf00      	nop

0800a150 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 800a150:	b500      	push	{lr}
 800a152:	b083      	sub	sp, #12
 800a154:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 800a156:	9801      	ldr	r0, [sp, #4]
 800a158:	2141      	movs	r1, #65	; 0x41
 800a15a:	f7f8 fe99 	bl	8002e90 <chMsgSend>
  chMsgSend(p, 'B');
 800a15e:	9801      	ldr	r0, [sp, #4]
 800a160:	2142      	movs	r1, #66	; 0x42
 800a162:	f7f8 fe95 	bl	8002e90 <chMsgSend>
  chMsgSend(p, 'C');
 800a166:	9801      	ldr	r0, [sp, #4]
 800a168:	2143      	movs	r1, #67	; 0x43
 800a16a:	f7f8 fe91 	bl	8002e90 <chMsgSend>
  chMsgSend(p, 'D');
 800a16e:	9801      	ldr	r0, [sp, #4]
 800a170:	2144      	movs	r1, #68	; 0x44
 800a172:	f7f8 fe8d 	bl	8002e90 <chMsgSend>
}
 800a176:	b003      	add	sp, #12
 800a178:	f85d fb04 	ldr.w	pc, [sp], #4
 800a17c:	f3af 8000 	nop.w

0800a180 <test_007_001_execute>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_007_001_execute(void) {
 800a180:	b530      	push	{r4, r5, lr}
 800a182:	b087      	sub	sp, #28
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 800a184:	4b1f      	ldr	r3, [pc, #124]	; (800a204 <test_007_001_execute+0x84>)
 800a186:	2201      	movs	r2, #1
 800a188:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800a18a:	4b1f      	ldr	r3, [pc, #124]	; (800a208 <test_007_001_execute+0x88>)
 800a18c:	681d      	ldr	r5, [r3, #0]
 800a18e:	f7ff ffcf 	bl	800a130 <chThdGetPriorityX>
 800a192:	4603      	mov	r3, r0
 800a194:	1c5c      	adds	r4, r3, #1
                                   msg_thread1, chThdGetSelfX());
 800a196:	f7ff ffc3 	bl	800a120 <chThdGetSelfX>
 800a19a:	4603      	mov	r3, r0
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800a19c:	9300      	str	r3, [sp, #0]
 800a19e:	4628      	mov	r0, r5
 800a1a0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a1a4:	4622      	mov	r2, r4
 800a1a6:	4b19      	ldr	r3, [pc, #100]	; (800a20c <test_007_001_execute+0x8c>)
 800a1a8:	f7f7 f952 	bl	8001450 <chThdCreateStatic>
 800a1ac:	4602      	mov	r2, r0
 800a1ae:	4b18      	ldr	r3, [pc, #96]	; (800a210 <test_007_001_execute+0x90>)
 800a1b0:	601a      	str	r2, [r3, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 800a1b2:	4b14      	ldr	r3, [pc, #80]	; (800a204 <test_007_001_execute+0x84>)
 800a1b4:	2202      	movs	r2, #2
 800a1b6:	601a      	str	r2, [r3, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 800a1b8:	2300      	movs	r3, #0
 800a1ba:	9305      	str	r3, [sp, #20]
 800a1bc:	e012      	b.n	800a1e4 <test_007_001_execute+0x64>
      tp = chMsgWait();
 800a1be:	f7f8 fe97 	bl	8002ef0 <chMsgWait>
 800a1c2:	9004      	str	r0, [sp, #16]
      msg = chMsgGet(tp);
 800a1c4:	9804      	ldr	r0, [sp, #16]
 800a1c6:	f7ff ffbb 	bl	800a140 <chMsgGet>
 800a1ca:	9003      	str	r0, [sp, #12]
      chMsgRelease(tp, msg);
 800a1cc:	9804      	ldr	r0, [sp, #16]
 800a1ce:	9903      	ldr	r1, [sp, #12]
 800a1d0:	f7f8 feb6 	bl	8002f40 <chMsgRelease>
      test_emit_token(msg);
 800a1d4:	9b03      	ldr	r3, [sp, #12]
 800a1d6:	b2db      	uxtb	r3, r3
 800a1d8:	4618      	mov	r0, r3
 800a1da:	f7fd fae9 	bl	80077b0 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 800a1de:	9b05      	ldr	r3, [sp, #20]
 800a1e0:	3301      	adds	r3, #1
 800a1e2:	9305      	str	r3, [sp, #20]
 800a1e4:	9b05      	ldr	r3, [sp, #20]
 800a1e6:	2b03      	cmp	r3, #3
 800a1e8:	d9e9      	bls.n	800a1be <test_007_001_execute+0x3e>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 800a1ea:	f7fd fc99 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800a1ee:	4809      	ldr	r0, [pc, #36]	; (800a214 <test_007_001_execute+0x94>)
 800a1f0:	4909      	ldr	r1, [pc, #36]	; (800a218 <test_007_001_execute+0x98>)
 800a1f2:	f7fd fa15 	bl	8007620 <_test_assert_sequence>
 800a1f6:	4603      	mov	r3, r0
 800a1f8:	2b00      	cmp	r3, #0
 800a1fa:	d000      	beq.n	800a1fe <test_007_001_execute+0x7e>
 800a1fc:	bf00      	nop
  }
}
 800a1fe:	b007      	add	sp, #28
 800a200:	bd30      	pop	{r4, r5, pc}
 800a202:	bf00      	nop
 800a204:	20000cac 	.word	0x20000cac
 800a208:	0800e298 	.word	0x0800e298
 800a20c:	0800a151 	.word	0x0800a151
 800a210:	20000cb0 	.word	0x20000cb0
 800a214:	0800efc0 	.word	0x0800efc0
 800a218:	0800efc8 	.word	0x0800efc8
 800a21c:	00000000 	.word	0x00000000

0800a220 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a220:	b082      	sub	sp, #8
 800a222:	2320      	movs	r3, #32
 800a224:	9301      	str	r3, [sp, #4]
 800a226:	9b01      	ldr	r3, [sp, #4]
 800a228:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a22c:	b002      	add	sp, #8
 800a22e:	4770      	bx	lr

0800a230 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a230:	b082      	sub	sp, #8
 800a232:	2300      	movs	r3, #0
 800a234:	9301      	str	r3, [sp, #4]
 800a236:	9b01      	ldr	r3, [sp, #4]
 800a238:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a23c:	b002      	add	sp, #8
 800a23e:	4770      	bx	lr

0800a240 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a240:	b508      	push	{r3, lr}

  port_lock();
 800a242:	f7ff ffed 	bl	800a220 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800a246:	bd08      	pop	{r3, pc}
 800a248:	f3af 8000 	nop.w
 800a24c:	f3af 8000 	nop.w

0800a250 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a250:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800a252:	f7ff ffed 	bl	800a230 <port_unlock>
}
 800a256:	bd08      	pop	{r3, pc}
 800a258:	f3af 8000 	nop.w
 800a25c:	f3af 8000 	nop.w

0800a260 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800a260:	4b01      	ldr	r3, [pc, #4]	; (800a268 <chThdGetSelfX+0x8>)
 800a262:	699b      	ldr	r3, [r3, #24]
}
 800a264:	4618      	mov	r0, r3
 800a266:	4770      	bx	lr
 800a268:	20000af8 	.word	0x20000af8
 800a26c:	f3af 8000 	nop.w

0800a270 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800a270:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 800a272:	f7ff fff5 	bl	800a260 <chThdGetSelfX>
 800a276:	4603      	mov	r3, r0
 800a278:	689b      	ldr	r3, [r3, #8]
}
 800a27a:	4618      	mov	r0, r3
 800a27c:	bd08      	pop	{r3, pc}
 800a27e:	bf00      	nop

0800a280 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800a280:	b082      	sub	sp, #8
 800a282:	9001      	str	r0, [sp, #4]

  esp->next = (event_listener_t *)esp;
 800a284:	9b01      	ldr	r3, [sp, #4]
 800a286:	9a01      	ldr	r2, [sp, #4]
 800a288:	601a      	str	r2, [r3, #0]
}
 800a28a:	b002      	add	sp, #8
 800a28c:	4770      	bx	lr
 800a28e:	bf00      	nop

0800a290 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 800a290:	b500      	push	{lr}
 800a292:	b085      	sub	sp, #20
 800a294:	9003      	str	r0, [sp, #12]
 800a296:	9102      	str	r1, [sp, #8]
 800a298:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800a29a:	9803      	ldr	r0, [sp, #12]
 800a29c:	9902      	ldr	r1, [sp, #8]
 800a29e:	9a01      	ldr	r2, [sp, #4]
 800a2a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a2a4:	f7f8 fadc 	bl	8002860 <chEvtRegisterMaskWithFlags>
}
 800a2a8:	b005      	add	sp, #20
 800a2aa:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2ae:	bf00      	nop

0800a2b0 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 800a2b0:	b082      	sub	sp, #8
 800a2b2:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->next);
 800a2b4:	9b01      	ldr	r3, [sp, #4]
 800a2b6:	681a      	ldr	r2, [r3, #0]
 800a2b8:	9b01      	ldr	r3, [sp, #4]
 800a2ba:	429a      	cmp	r2, r3
 800a2bc:	bf14      	ite	ne
 800a2be:	2301      	movne	r3, #1
 800a2c0:	2300      	moveq	r3, #0
 800a2c2:	b2db      	uxtb	r3, r3
}
 800a2c4:	4618      	mov	r0, r3
 800a2c6:	b002      	add	sp, #8
 800a2c8:	4770      	bx	lr
 800a2ca:	bf00      	nop
 800a2cc:	f3af 8000 	nop.w

0800a2d0 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 800a2d0:	b500      	push	{lr}
 800a2d2:	b083      	sub	sp, #12
 800a2d4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 800a2d6:	9801      	ldr	r0, [sp, #4]
 800a2d8:	2100      	movs	r1, #0
 800a2da:	f7f8 fbd9 	bl	8002a90 <chEvtBroadcastFlags>
}
 800a2de:	b003      	add	sp, #12
 800a2e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2e4:	f3af 8000 	nop.w
 800a2e8:	f3af 8000 	nop.w
 800a2ec:	f3af 8000 	nop.w

0800a2f0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a2f0:	b508      	push	{r3, lr}

  chSysLock();
 800a2f2:	f7ff ffa5 	bl	800a240 <chSysLock>
}
 800a2f6:	bd08      	pop	{r3, pc}
 800a2f8:	f3af 8000 	nop.w
 800a2fc:	f3af 8000 	nop.w

0800a300 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a300:	b508      	push	{r3, lr}

  chSysUnlock();
 800a302:	f7ff ffa5 	bl	800a250 <chSysUnlock>
}
 800a306:	bd08      	pop	{r3, pc}
 800a308:	f3af 8000 	nop.w
 800a30c:	f3af 8000 	nop.w

0800a310 <h1>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 800a310:	b500      	push	{lr}
 800a312:	b083      	sub	sp, #12
 800a314:	9001      	str	r0, [sp, #4]
 800a316:	2041      	movs	r0, #65	; 0x41
 800a318:	f7fd fa4a 	bl	80077b0 <test_emit_token>
 800a31c:	b003      	add	sp, #12
 800a31e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a322:	bf00      	nop
 800a324:	f3af 8000 	nop.w
 800a328:	f3af 8000 	nop.w
 800a32c:	f3af 8000 	nop.w

0800a330 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 800a330:	b500      	push	{lr}
 800a332:	b083      	sub	sp, #12
 800a334:	9001      	str	r0, [sp, #4]
 800a336:	2042      	movs	r0, #66	; 0x42
 800a338:	f7fd fa3a 	bl	80077b0 <test_emit_token>
 800a33c:	b003      	add	sp, #12
 800a33e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a342:	bf00      	nop
 800a344:	f3af 8000 	nop.w
 800a348:	f3af 8000 	nop.w
 800a34c:	f3af 8000 	nop.w

0800a350 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 800a350:	b500      	push	{lr}
 800a352:	b083      	sub	sp, #12
 800a354:	9001      	str	r0, [sp, #4]
 800a356:	2043      	movs	r0, #67	; 0x43
 800a358:	f7fd fa2a 	bl	80077b0 <test_emit_token>
 800a35c:	b003      	add	sp, #12
 800a35e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a362:	bf00      	nop
 800a364:	f3af 8000 	nop.w
 800a368:	f3af 8000 	nop.w
 800a36c:	f3af 8000 	nop.w

0800a370 <evt_thread3>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 800a370:	b500      	push	{lr}
 800a372:	b083      	sub	sp, #12
 800a374:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 800a376:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800a37a:	f7f7 f9d1 	bl	8001720 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800a37e:	9801      	ldr	r0, [sp, #4]
 800a380:	2101      	movs	r1, #1
 800a382:	f7f8 fb3d 	bl	8002a00 <chEvtSignal>
}
 800a386:	b003      	add	sp, #12
 800a388:	f85d fb04 	ldr.w	pc, [sp], #4
 800a38c:	f3af 8000 	nop.w

0800a390 <evt_thread7>:

static THD_FUNCTION(evt_thread7, p) {
 800a390:	b500      	push	{lr}
 800a392:	b083      	sub	sp, #12
 800a394:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 800a396:	4806      	ldr	r0, [pc, #24]	; (800a3b0 <evt_thread7+0x20>)
 800a398:	f7ff ff9a 	bl	800a2d0 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 800a39c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800a3a0:	f7f7 f9be 	bl	8001720 <chThdSleep>
  chEvtBroadcast(&es2);
 800a3a4:	4803      	ldr	r0, [pc, #12]	; (800a3b4 <evt_thread7+0x24>)
 800a3a6:	f7ff ff93 	bl	800a2d0 <chEvtBroadcast>
}
 800a3aa:	b003      	add	sp, #12
 800a3ac:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3b0:	20000864 	.word	0x20000864
 800a3b4:	20000868 	.word	0x20000868
 800a3b8:	f3af 8000 	nop.w
 800a3bc:	f3af 8000 	nop.w

0800a3c0 <test_008_001_execute>:
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_008_001_execute(void) {
 800a3c0:	b500      	push	{lr}
 800a3c2:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /* [8.1.1] An Event Source is initialized.*/
  test_set_step(1);
 800a3c4:	4b34      	ldr	r3, [pc, #208]	; (800a498 <test_008_001_execute+0xd8>)
 800a3c6:	2201      	movs	r2, #1
 800a3c8:	601a      	str	r2, [r3, #0]
  {
    chEvtObjectInit(&es1);
 800a3ca:	4834      	ldr	r0, [pc, #208]	; (800a49c <test_008_001_execute+0xdc>)
 800a3cc:	f7ff ff58 	bl	800a280 <chEvtObjectInit>
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 800a3d0:	4b31      	ldr	r3, [pc, #196]	; (800a498 <test_008_001_execute+0xd8>)
 800a3d2:	2202      	movs	r2, #2
 800a3d4:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
 800a3d6:	ab05      	add	r3, sp, #20
 800a3d8:	4830      	ldr	r0, [pc, #192]	; (800a49c <test_008_001_execute+0xdc>)
 800a3da:	4619      	mov	r1, r3
 800a3dc:	2201      	movs	r2, #1
 800a3de:	f7ff ff57 	bl	800a290 <chEvtRegisterMask>
    chEvtRegisterMask(&es1, &el2, 2);
 800a3e2:	466b      	mov	r3, sp
 800a3e4:	482d      	ldr	r0, [pc, #180]	; (800a49c <test_008_001_execute+0xdc>)
 800a3e6:	4619      	mov	r1, r3
 800a3e8:	2202      	movs	r2, #2
 800a3ea:	f7ff ff51 	bl	800a290 <chEvtRegisterMask>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 800a3ee:	f7ff ff7f 	bl	800a2f0 <osalSysLock>
 800a3f2:	482a      	ldr	r0, [pc, #168]	; (800a49c <test_008_001_execute+0xdc>)
 800a3f4:	f7ff ff5c 	bl	800a2b0 <chEvtIsListeningI>
 800a3f8:	4603      	mov	r3, r0
 800a3fa:	4618      	mov	r0, r3
 800a3fc:	4928      	ldr	r1, [pc, #160]	; (800a4a0 <test_008_001_execute+0xe0>)
 800a3fe:	f7fd f8f7 	bl	80075f0 <_test_assert>
 800a402:	4603      	mov	r3, r0
 800a404:	2b00      	cmp	r3, #0
 800a406:	d002      	beq.n	800a40e <test_008_001_execute+0x4e>
 800a408:	f7ff ff7a 	bl	800a300 <osalSysUnlock>
 800a40c:	e040      	b.n	800a490 <test_008_001_execute+0xd0>
 800a40e:	f7ff ff77 	bl	800a300 <osalSysUnlock>
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 800a412:	4b21      	ldr	r3, [pc, #132]	; (800a498 <test_008_001_execute+0xd8>)
 800a414:	2203      	movs	r2, #3
 800a416:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
 800a418:	ab05      	add	r3, sp, #20
 800a41a:	4820      	ldr	r0, [pc, #128]	; (800a49c <test_008_001_execute+0xdc>)
 800a41c:	4619      	mov	r1, r3
 800a41e:	f7f8 fa47 	bl	80028b0 <chEvtUnregister>
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 800a422:	f7ff ff65 	bl	800a2f0 <osalSysLock>
 800a426:	481d      	ldr	r0, [pc, #116]	; (800a49c <test_008_001_execute+0xdc>)
 800a428:	f7ff ff42 	bl	800a2b0 <chEvtIsListeningI>
 800a42c:	4603      	mov	r3, r0
 800a42e:	4618      	mov	r0, r3
 800a430:	491b      	ldr	r1, [pc, #108]	; (800a4a0 <test_008_001_execute+0xe0>)
 800a432:	f7fd f8dd 	bl	80075f0 <_test_assert>
 800a436:	4603      	mov	r3, r0
 800a438:	2b00      	cmp	r3, #0
 800a43a:	d002      	beq.n	800a442 <test_008_001_execute+0x82>
 800a43c:	f7ff ff60 	bl	800a300 <osalSysUnlock>
 800a440:	e026      	b.n	800a490 <test_008_001_execute+0xd0>
 800a442:	f7ff ff5d 	bl	800a300 <osalSysUnlock>
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 800a446:	4b14      	ldr	r3, [pc, #80]	; (800a498 <test_008_001_execute+0xd8>)
 800a448:	2204      	movs	r2, #4
 800a44a:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el2);
 800a44c:	466b      	mov	r3, sp
 800a44e:	4813      	ldr	r0, [pc, #76]	; (800a49c <test_008_001_execute+0xdc>)
 800a450:	4619      	mov	r1, r3
 800a452:	f7f8 fa2d 	bl	80028b0 <chEvtUnregister>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 800a456:	f7ff ff4b 	bl	800a2f0 <osalSysLock>
 800a45a:	4810      	ldr	r0, [pc, #64]	; (800a49c <test_008_001_execute+0xdc>)
 800a45c:	f7ff ff28 	bl	800a2b0 <chEvtIsListeningI>
 800a460:	4603      	mov	r3, r0
 800a462:	2b00      	cmp	r3, #0
 800a464:	bf14      	ite	ne
 800a466:	2301      	movne	r3, #1
 800a468:	2300      	moveq	r3, #0
 800a46a:	b2db      	uxtb	r3, r3
 800a46c:	f083 0301 	eor.w	r3, r3, #1
 800a470:	b2db      	uxtb	r3, r3
 800a472:	f003 0301 	and.w	r3, r3, #1
 800a476:	b2db      	uxtb	r3, r3
 800a478:	4618      	mov	r0, r3
 800a47a:	490a      	ldr	r1, [pc, #40]	; (800a4a4 <test_008_001_execute+0xe4>)
 800a47c:	f7fd f8b8 	bl	80075f0 <_test_assert>
 800a480:	4603      	mov	r3, r0
 800a482:	2b00      	cmp	r3, #0
 800a484:	d002      	beq.n	800a48c <test_008_001_execute+0xcc>
 800a486:	f7ff ff3b 	bl	800a300 <osalSysUnlock>
 800a48a:	e001      	b.n	800a490 <test_008_001_execute+0xd0>
 800a48c:	f7ff ff38 	bl	800a300 <osalSysUnlock>
  }
}
 800a490:	b00b      	add	sp, #44	; 0x2c
 800a492:	f85d fb04 	ldr.w	pc, [sp], #4
 800a496:	bf00      	nop
 800a498:	20000cac 	.word	0x20000cac
 800a49c:	20000864 	.word	0x20000864
 800a4a0:	0800f018 	.word	0x0800f018
 800a4a4:	0800f024 	.word	0x0800f024
 800a4a8:	f3af 8000 	nop.w
 800a4ac:	f3af 8000 	nop.w

0800a4b0 <test_008_002_setup>:
 * - [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void test_008_002_setup(void) {
 800a4b0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800a4b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a4b6:	f7f8 fa1b 	bl	80028f0 <chEvtGetAndClearEvents>
}
 800a4ba:	bd08      	pop	{r3, pc}
 800a4bc:	f3af 8000 	nop.w

0800a4c0 <test_008_002_execute>:

static void test_008_002_execute(void) {
 800a4c0:	b508      	push	{r3, lr}

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 800a4c2:	4b08      	ldr	r3, [pc, #32]	; (800a4e4 <test_008_002_execute+0x24>)
 800a4c4:	2201      	movs	r2, #1
 800a4c6:	601a      	str	r2, [r3, #0]
  {
    chEvtDispatch(evhndl, 7);
 800a4c8:	4807      	ldr	r0, [pc, #28]	; (800a4e8 <test_008_002_execute+0x28>)
 800a4ca:	2107      	movs	r1, #7
 800a4cc:	f7f8 fb08 	bl	8002ae0 <chEvtDispatch>
    test_assert_sequence("ABC", "invalid sequence");
 800a4d0:	4806      	ldr	r0, [pc, #24]	; (800a4ec <test_008_002_execute+0x2c>)
 800a4d2:	4907      	ldr	r1, [pc, #28]	; (800a4f0 <test_008_002_execute+0x30>)
 800a4d4:	f7fd f8a4 	bl	8007620 <_test_assert_sequence>
 800a4d8:	4603      	mov	r3, r0
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d000      	beq.n	800a4e0 <test_008_002_execute+0x20>
 800a4de:	bf00      	nop
  }
}
 800a4e0:	bd08      	pop	{r3, pc}
 800a4e2:	bf00      	nop
 800a4e4:	20000cac 	.word	0x20000cac
 800a4e8:	0800f00c 	.word	0x0800f00c
 800a4ec:	0800f058 	.word	0x0800f058
 800a4f0:	0800f05c 	.word	0x0800f05c
 800a4f4:	f3af 8000 	nop.w
 800a4f8:	f3af 8000 	nop.w
 800a4fc:	f3af 8000 	nop.w

0800a500 <test_008_003_setup>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void test_008_003_setup(void) {
 800a500:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800a502:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a506:	f7f8 f9f3 	bl	80028f0 <chEvtGetAndClearEvents>
}
 800a50a:	bd08      	pop	{r3, pc}
 800a50c:	f3af 8000 	nop.w

0800a510 <test_008_003_execute>:

static void test_008_003_execute(void) {
 800a510:	b530      	push	{r4, r5, lr}
 800a512:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 800a514:	4b54      	ldr	r3, [pc, #336]	; (800a668 <test_008_003_execute+0x158>)
 800a516:	2201      	movs	r2, #1
 800a518:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(7);
 800a51a:	2007      	movs	r0, #7
 800a51c:	f7f8 fa08 	bl	8002930 <chEvtAddEvents>
  }

  /* [8.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 800a520:	4b51      	ldr	r3, [pc, #324]	; (800a668 <test_008_003_execute+0x158>)
 800a522:	2202      	movs	r2, #2
 800a524:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 800a526:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a52a:	f7f8 fb01 	bl	8002b30 <chEvtWaitOne>
 800a52e:	9003      	str	r0, [sp, #12]
    test_assert(m == 1, "single event error");
 800a530:	9b03      	ldr	r3, [sp, #12]
 800a532:	2b01      	cmp	r3, #1
 800a534:	bf0c      	ite	eq
 800a536:	2301      	moveq	r3, #1
 800a538:	2300      	movne	r3, #0
 800a53a:	b2db      	uxtb	r3, r3
 800a53c:	4618      	mov	r0, r3
 800a53e:	494b      	ldr	r1, [pc, #300]	; (800a66c <test_008_003_execute+0x15c>)
 800a540:	f7fd f856 	bl	80075f0 <_test_assert>
 800a544:	4603      	mov	r3, r0
 800a546:	2b00      	cmp	r3, #0
 800a548:	d000      	beq.n	800a54c <test_008_003_execute+0x3c>
 800a54a:	e08b      	b.n	800a664 <test_008_003_execute+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
 800a54c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a550:	f7f8 faee 	bl	8002b30 <chEvtWaitOne>
 800a554:	9003      	str	r0, [sp, #12]
    test_assert(m == 2, "single event error");
 800a556:	9b03      	ldr	r3, [sp, #12]
 800a558:	2b02      	cmp	r3, #2
 800a55a:	bf0c      	ite	eq
 800a55c:	2301      	moveq	r3, #1
 800a55e:	2300      	movne	r3, #0
 800a560:	b2db      	uxtb	r3, r3
 800a562:	4618      	mov	r0, r3
 800a564:	4941      	ldr	r1, [pc, #260]	; (800a66c <test_008_003_execute+0x15c>)
 800a566:	f7fd f843 	bl	80075f0 <_test_assert>
 800a56a:	4603      	mov	r3, r0
 800a56c:	2b00      	cmp	r3, #0
 800a56e:	d000      	beq.n	800a572 <test_008_003_execute+0x62>
 800a570:	e078      	b.n	800a664 <test_008_003_execute+0x154>
    m = chEvtWaitOne(ALL_EVENTS);
 800a572:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a576:	f7f8 fadb 	bl	8002b30 <chEvtWaitOne>
 800a57a:	9003      	str	r0, [sp, #12]
    test_assert(m == 4, "single event error");
 800a57c:	9b03      	ldr	r3, [sp, #12]
 800a57e:	2b04      	cmp	r3, #4
 800a580:	bf0c      	ite	eq
 800a582:	2301      	moveq	r3, #1
 800a584:	2300      	movne	r3, #0
 800a586:	b2db      	uxtb	r3, r3
 800a588:	4618      	mov	r0, r3
 800a58a:	4938      	ldr	r1, [pc, #224]	; (800a66c <test_008_003_execute+0x15c>)
 800a58c:	f7fd f830 	bl	80075f0 <_test_assert>
 800a590:	4603      	mov	r3, r0
 800a592:	2b00      	cmp	r3, #0
 800a594:	d000      	beq.n	800a598 <test_008_003_execute+0x88>
 800a596:	e065      	b.n	800a664 <test_008_003_execute+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a598:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a59c:	f7f8 f9a8 	bl	80028f0 <chEvtGetAndClearEvents>
 800a5a0:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a5a2:	9b03      	ldr	r3, [sp, #12]
 800a5a4:	2b00      	cmp	r3, #0
 800a5a6:	bf0c      	ite	eq
 800a5a8:	2301      	moveq	r3, #1
 800a5aa:	2300      	movne	r3, #0
 800a5ac:	b2db      	uxtb	r3, r3
 800a5ae:	4618      	mov	r0, r3
 800a5b0:	492f      	ldr	r1, [pc, #188]	; (800a670 <test_008_003_execute+0x160>)
 800a5b2:	f7fd f81d 	bl	80075f0 <_test_assert>
 800a5b6:	4603      	mov	r3, r0
 800a5b8:	2b00      	cmp	r3, #0
 800a5ba:	d000      	beq.n	800a5be <test_008_003_execute+0xae>
 800a5bc:	e052      	b.n	800a664 <test_008_003_execute+0x154>
  }

  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 800a5be:	4b2a      	ldr	r3, [pc, #168]	; (800a668 <test_008_003_execute+0x158>)
 800a5c0:	2203      	movs	r2, #3
 800a5c2:	601a      	str	r2, [r3, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 800a5c4:	f7fd fad4 	bl	8007b70 <test_wait_tick>
 800a5c8:	4603      	mov	r3, r0
 800a5ca:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800a5ce:	9302      	str	r3, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a5d0:	4b28      	ldr	r3, [pc, #160]	; (800a674 <test_008_003_execute+0x164>)
 800a5d2:	681d      	ldr	r5, [r3, #0]
 800a5d4:	f7ff fe4c 	bl	800a270 <chThdGetPriorityX>
 800a5d8:	4603      	mov	r3, r0
 800a5da:	1e5c      	subs	r4, r3, #1
                                   evt_thread3, chThdGetSelfX());
 800a5dc:	f7ff fe40 	bl	800a260 <chThdGetSelfX>
 800a5e0:	4603      	mov	r3, r0
  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a5e2:	9300      	str	r3, [sp, #0]
 800a5e4:	4628      	mov	r0, r5
 800a5e6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a5ea:	4622      	mov	r2, r4
 800a5ec:	4b22      	ldr	r3, [pc, #136]	; (800a678 <test_008_003_execute+0x168>)
 800a5ee:	f7f6 ff2f 	bl	8001450 <chThdCreateStatic>
 800a5f2:	4602      	mov	r2, r0
 800a5f4:	4b21      	ldr	r3, [pc, #132]	; (800a67c <test_008_003_execute+0x16c>)
 800a5f6:	601a      	str	r2, [r3, #0]
  }

  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 800a5f8:	4b1b      	ldr	r3, [pc, #108]	; (800a668 <test_008_003_execute+0x158>)
 800a5fa:	2204      	movs	r2, #4
 800a5fc:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 800a5fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a602:	f7f8 fa95 	bl	8002b30 <chEvtWaitOne>
 800a606:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800a608:	9b02      	ldr	r3, [sp, #8]
 800a60a:	3314      	adds	r3, #20
 800a60c:	9802      	ldr	r0, [sp, #8]
 800a60e:	4619      	mov	r1, r3
 800a610:	4a1b      	ldr	r2, [pc, #108]	; (800a680 <test_008_003_execute+0x170>)
 800a612:	f7fd f835 	bl	8007680 <_test_assert_time_window>
 800a616:	4603      	mov	r3, r0
 800a618:	2b00      	cmp	r3, #0
 800a61a:	d000      	beq.n	800a61e <test_008_003_execute+0x10e>
 800a61c:	e022      	b.n	800a664 <test_008_003_execute+0x154>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 800a61e:	9b03      	ldr	r3, [sp, #12]
 800a620:	2b01      	cmp	r3, #1
 800a622:	bf0c      	ite	eq
 800a624:	2301      	moveq	r3, #1
 800a626:	2300      	movne	r3, #0
 800a628:	b2db      	uxtb	r3, r3
 800a62a:	4618      	mov	r0, r3
 800a62c:	4915      	ldr	r1, [pc, #84]	; (800a684 <test_008_003_execute+0x174>)
 800a62e:	f7fc ffdf 	bl	80075f0 <_test_assert>
 800a632:	4603      	mov	r3, r0
 800a634:	2b00      	cmp	r3, #0
 800a636:	d000      	beq.n	800a63a <test_008_003_execute+0x12a>
 800a638:	e014      	b.n	800a664 <test_008_003_execute+0x154>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a63a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a63e:	f7f8 f957 	bl	80028f0 <chEvtGetAndClearEvents>
 800a642:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a644:	9b03      	ldr	r3, [sp, #12]
 800a646:	2b00      	cmp	r3, #0
 800a648:	bf0c      	ite	eq
 800a64a:	2301      	moveq	r3, #1
 800a64c:	2300      	movne	r3, #0
 800a64e:	b2db      	uxtb	r3, r3
 800a650:	4618      	mov	r0, r3
 800a652:	4907      	ldr	r1, [pc, #28]	; (800a670 <test_008_003_execute+0x160>)
 800a654:	f7fc ffcc 	bl	80075f0 <_test_assert>
 800a658:	4603      	mov	r3, r0
 800a65a:	2b00      	cmp	r3, #0
 800a65c:	d000      	beq.n	800a660 <test_008_003_execute+0x150>
 800a65e:	e001      	b.n	800a664 <test_008_003_execute+0x154>
    test_wait_threads();
 800a660:	f7fd fa5e 	bl	8007b20 <test_wait_threads>
  }
}
 800a664:	b005      	add	sp, #20
 800a666:	bd30      	pop	{r4, r5, pc}
 800a668:	20000cac 	.word	0x20000cac
 800a66c:	0800f098 	.word	0x0800f098
 800a670:	0800f0ac 	.word	0x0800f0ac
 800a674:	0800e298 	.word	0x0800e298
 800a678:	0800a371 	.word	0x0800a371
 800a67c:	20000cb0 	.word	0x20000cb0
 800a680:	0800f0b8 	.word	0x0800f0b8
 800a684:	0800f0cc 	.word	0x0800f0cc
 800a688:	f3af 8000 	nop.w
 800a68c:	f3af 8000 	nop.w

0800a690 <test_008_004_setup>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void test_008_004_setup(void) {
 800a690:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800a692:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a696:	f7f8 f92b 	bl	80028f0 <chEvtGetAndClearEvents>
}
 800a69a:	bd08      	pop	{r3, pc}
 800a69c:	f3af 8000 	nop.w

0800a6a0 <test_008_004_execute>:

static void test_008_004_execute(void) {
 800a6a0:	b530      	push	{r4, r5, lr}
 800a6a2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 800a6a4:	4b41      	ldr	r3, [pc, #260]	; (800a7ac <test_008_004_execute+0x10c>)
 800a6a6:	2201      	movs	r2, #1
 800a6a8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
 800a6aa:	2005      	movs	r0, #5
 800a6ac:	f7f8 f940 	bl	8002930 <chEvtAddEvents>
  }

  /* [8.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800a6b0:	4b3e      	ldr	r3, [pc, #248]	; (800a7ac <test_008_004_execute+0x10c>)
 800a6b2:	2202      	movs	r2, #2
 800a6b4:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 800a6b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a6ba:	f7f8 fa69 	bl	8002b90 <chEvtWaitAny>
 800a6be:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
 800a6c0:	9b03      	ldr	r3, [sp, #12]
 800a6c2:	2b05      	cmp	r3, #5
 800a6c4:	bf0c      	ite	eq
 800a6c6:	2301      	moveq	r3, #1
 800a6c8:	2300      	movne	r3, #0
 800a6ca:	b2db      	uxtb	r3, r3
 800a6cc:	4618      	mov	r0, r3
 800a6ce:	4938      	ldr	r1, [pc, #224]	; (800a7b0 <test_008_004_execute+0x110>)
 800a6d0:	f7fc ff8e 	bl	80075f0 <_test_assert>
 800a6d4:	4603      	mov	r3, r0
 800a6d6:	2b00      	cmp	r3, #0
 800a6d8:	d000      	beq.n	800a6dc <test_008_004_execute+0x3c>
 800a6da:	e065      	b.n	800a7a8 <test_008_004_execute+0x108>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a6dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a6e0:	f7f8 f906 	bl	80028f0 <chEvtGetAndClearEvents>
 800a6e4:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a6e6:	9b03      	ldr	r3, [sp, #12]
 800a6e8:	2b00      	cmp	r3, #0
 800a6ea:	bf0c      	ite	eq
 800a6ec:	2301      	moveq	r3, #1
 800a6ee:	2300      	movne	r3, #0
 800a6f0:	b2db      	uxtb	r3, r3
 800a6f2:	4618      	mov	r0, r3
 800a6f4:	492f      	ldr	r1, [pc, #188]	; (800a7b4 <test_008_004_execute+0x114>)
 800a6f6:	f7fc ff7b 	bl	80075f0 <_test_assert>
 800a6fa:	4603      	mov	r3, r0
 800a6fc:	2b00      	cmp	r3, #0
 800a6fe:	d000      	beq.n	800a702 <test_008_004_execute+0x62>
 800a700:	e052      	b.n	800a7a8 <test_008_004_execute+0x108>
  }

  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 800a702:	4b2a      	ldr	r3, [pc, #168]	; (800a7ac <test_008_004_execute+0x10c>)
 800a704:	2203      	movs	r2, #3
 800a706:	601a      	str	r2, [r3, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 800a708:	f7fd fa32 	bl	8007b70 <test_wait_tick>
 800a70c:	4603      	mov	r3, r0
 800a70e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800a712:	9302      	str	r3, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a714:	4b28      	ldr	r3, [pc, #160]	; (800a7b8 <test_008_004_execute+0x118>)
 800a716:	681d      	ldr	r5, [r3, #0]
 800a718:	f7ff fdaa 	bl	800a270 <chThdGetPriorityX>
 800a71c:	4603      	mov	r3, r0
 800a71e:	1e5c      	subs	r4, r3, #1
                                   evt_thread3, chThdGetSelfX());
 800a720:	f7ff fd9e 	bl	800a260 <chThdGetSelfX>
 800a724:	4603      	mov	r3, r0
  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a726:	9300      	str	r3, [sp, #0]
 800a728:	4628      	mov	r0, r5
 800a72a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a72e:	4622      	mov	r2, r4
 800a730:	4b22      	ldr	r3, [pc, #136]	; (800a7bc <test_008_004_execute+0x11c>)
 800a732:	f7f6 fe8d 	bl	8001450 <chThdCreateStatic>
 800a736:	4602      	mov	r2, r0
 800a738:	4b21      	ldr	r3, [pc, #132]	; (800a7c0 <test_008_004_execute+0x120>)
 800a73a:	601a      	str	r2, [r3, #0]
  }

  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 800a73c:	4b1b      	ldr	r3, [pc, #108]	; (800a7ac <test_008_004_execute+0x10c>)
 800a73e:	2204      	movs	r2, #4
 800a740:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 800a742:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a746:	f7f8 fa23 	bl	8002b90 <chEvtWaitAny>
 800a74a:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800a74c:	9b02      	ldr	r3, [sp, #8]
 800a74e:	3314      	adds	r3, #20
 800a750:	9802      	ldr	r0, [sp, #8]
 800a752:	4619      	mov	r1, r3
 800a754:	4a1b      	ldr	r2, [pc, #108]	; (800a7c4 <test_008_004_execute+0x124>)
 800a756:	f7fc ff93 	bl	8007680 <_test_assert_time_window>
 800a75a:	4603      	mov	r3, r0
 800a75c:	2b00      	cmp	r3, #0
 800a75e:	d000      	beq.n	800a762 <test_008_004_execute+0xc2>
 800a760:	e022      	b.n	800a7a8 <test_008_004_execute+0x108>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 800a762:	9b03      	ldr	r3, [sp, #12]
 800a764:	2b01      	cmp	r3, #1
 800a766:	bf0c      	ite	eq
 800a768:	2301      	moveq	r3, #1
 800a76a:	2300      	movne	r3, #0
 800a76c:	b2db      	uxtb	r3, r3
 800a76e:	4618      	mov	r0, r3
 800a770:	4915      	ldr	r1, [pc, #84]	; (800a7c8 <test_008_004_execute+0x128>)
 800a772:	f7fc ff3d 	bl	80075f0 <_test_assert>
 800a776:	4603      	mov	r3, r0
 800a778:	2b00      	cmp	r3, #0
 800a77a:	d000      	beq.n	800a77e <test_008_004_execute+0xde>
 800a77c:	e014      	b.n	800a7a8 <test_008_004_execute+0x108>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a77e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a782:	f7f8 f8b5 	bl	80028f0 <chEvtGetAndClearEvents>
 800a786:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a788:	9b03      	ldr	r3, [sp, #12]
 800a78a:	2b00      	cmp	r3, #0
 800a78c:	bf0c      	ite	eq
 800a78e:	2301      	moveq	r3, #1
 800a790:	2300      	movne	r3, #0
 800a792:	b2db      	uxtb	r3, r3
 800a794:	4618      	mov	r0, r3
 800a796:	4907      	ldr	r1, [pc, #28]	; (800a7b4 <test_008_004_execute+0x114>)
 800a798:	f7fc ff2a 	bl	80075f0 <_test_assert>
 800a79c:	4603      	mov	r3, r0
 800a79e:	2b00      	cmp	r3, #0
 800a7a0:	d000      	beq.n	800a7a4 <test_008_004_execute+0x104>
 800a7a2:	e001      	b.n	800a7a8 <test_008_004_execute+0x108>
    test_wait_threads();
 800a7a4:	f7fd f9bc 	bl	8007b20 <test_wait_threads>
  }
}
 800a7a8:	b005      	add	sp, #20
 800a7aa:	bd30      	pop	{r4, r5, pc}
 800a7ac:	20000cac 	.word	0x20000cac
 800a7b0:	0800f118 	.word	0x0800f118
 800a7b4:	0800f0ac 	.word	0x0800f0ac
 800a7b8:	0800e298 	.word	0x0800e298
 800a7bc:	0800a371 	.word	0x0800a371
 800a7c0:	20000cb0 	.word	0x20000cb0
 800a7c4:	0800f0b8 	.word	0x0800f0b8
 800a7c8:	0800f0cc 	.word	0x0800f0cc
 800a7cc:	f3af 8000 	nop.w

0800a7d0 <test_008_005_setup>:
 *   flags have been received after 50mS and that the event flags mask
 *   has been emptied.
 * .
 */

static void test_008_005_setup(void) {
 800a7d0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800a7d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a7d6:	f7f8 f88b 	bl	80028f0 <chEvtGetAndClearEvents>
}
 800a7da:	bd08      	pop	{r3, pc}
 800a7dc:	f3af 8000 	nop.w

0800a7e0 <test_008_005_execute>:

static void test_008_005_execute(void) {
 800a7e0:	b530      	push	{r4, r5, lr}
 800a7e2:	b085      	sub	sp, #20
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 800a7e4:	4b43      	ldr	r3, [pc, #268]	; (800a8f4 <test_008_005_execute+0x114>)
 800a7e6:	2201      	movs	r2, #1
 800a7e8:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(5);
 800a7ea:	2005      	movs	r0, #5
 800a7ec:	f7f8 f8a0 	bl	8002930 <chEvtAddEvents>
  }

  /* [8.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800a7f0:	4b40      	ldr	r3, [pc, #256]	; (800a8f4 <test_008_005_execute+0x114>)
 800a7f2:	2202      	movs	r2, #2
 800a7f4:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 800a7f6:	2005      	movs	r0, #5
 800a7f8:	f7f8 f9fa 	bl	8002bf0 <chEvtWaitAll>
 800a7fc:	9003      	str	r0, [sp, #12]
    test_assert(m == 5, "unexpected pending bit");
 800a7fe:	9b03      	ldr	r3, [sp, #12]
 800a800:	2b05      	cmp	r3, #5
 800a802:	bf0c      	ite	eq
 800a804:	2301      	moveq	r3, #1
 800a806:	2300      	movne	r3, #0
 800a808:	b2db      	uxtb	r3, r3
 800a80a:	4618      	mov	r0, r3
 800a80c:	493a      	ldr	r1, [pc, #232]	; (800a8f8 <test_008_005_execute+0x118>)
 800a80e:	f7fc feef 	bl	80075f0 <_test_assert>
 800a812:	4603      	mov	r3, r0
 800a814:	2b00      	cmp	r3, #0
 800a816:	d000      	beq.n	800a81a <test_008_005_execute+0x3a>
 800a818:	e06a      	b.n	800a8f0 <test_008_005_execute+0x110>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a81a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a81e:	f7f8 f867 	bl	80028f0 <chEvtGetAndClearEvents>
 800a822:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a824:	9b03      	ldr	r3, [sp, #12]
 800a826:	2b00      	cmp	r3, #0
 800a828:	bf0c      	ite	eq
 800a82a:	2301      	moveq	r3, #1
 800a82c:	2300      	movne	r3, #0
 800a82e:	b2db      	uxtb	r3, r3
 800a830:	4618      	mov	r0, r3
 800a832:	4932      	ldr	r1, [pc, #200]	; (800a8fc <test_008_005_execute+0x11c>)
 800a834:	f7fc fedc 	bl	80075f0 <_test_assert>
 800a838:	4603      	mov	r3, r0
 800a83a:	2b00      	cmp	r3, #0
 800a83c:	d000      	beq.n	800a840 <test_008_005_execute+0x60>
 800a83e:	e057      	b.n	800a8f0 <test_008_005_execute+0x110>
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 800a840:	4b2c      	ldr	r3, [pc, #176]	; (800a8f4 <test_008_005_execute+0x114>)
 800a842:	2203      	movs	r2, #3
 800a844:	601a      	str	r2, [r3, #0]
  {
    chEvtAddEvents(4);
 800a846:	2004      	movs	r0, #4
 800a848:	f7f8 f872 	bl	8002930 <chEvtAddEvents>
  }

  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 800a84c:	4b29      	ldr	r3, [pc, #164]	; (800a8f4 <test_008_005_execute+0x114>)
 800a84e:	2204      	movs	r2, #4
 800a850:	601a      	str	r2, [r3, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 800a852:	f7fd f98d 	bl	8007b70 <test_wait_tick>
 800a856:	4603      	mov	r3, r0
 800a858:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800a85c:	9302      	str	r3, [sp, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a85e:	4b28      	ldr	r3, [pc, #160]	; (800a900 <test_008_005_execute+0x120>)
 800a860:	681d      	ldr	r5, [r3, #0]
 800a862:	f7ff fd05 	bl	800a270 <chThdGetPriorityX>
 800a866:	4603      	mov	r3, r0
 800a868:	1e5c      	subs	r4, r3, #1
                                   evt_thread3, chThdGetSelfX());
 800a86a:	f7ff fcf9 	bl	800a260 <chThdGetSelfX>
 800a86e:	4603      	mov	r3, r0
  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800a870:	9300      	str	r3, [sp, #0]
 800a872:	4628      	mov	r0, r5
 800a874:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800a878:	4622      	mov	r2, r4
 800a87a:	4b22      	ldr	r3, [pc, #136]	; (800a904 <test_008_005_execute+0x124>)
 800a87c:	f7f6 fde8 	bl	8001450 <chThdCreateStatic>
 800a880:	4602      	mov	r2, r0
 800a882:	4b21      	ldr	r3, [pc, #132]	; (800a908 <test_008_005_execute+0x128>)
 800a884:	601a      	str	r2, [r3, #0]
  }

  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 800a886:	4b1b      	ldr	r3, [pc, #108]	; (800a8f4 <test_008_005_execute+0x114>)
 800a888:	2205      	movs	r2, #5
 800a88a:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 800a88c:	2005      	movs	r0, #5
 800a88e:	f7f8 f9af 	bl	8002bf0 <chEvtWaitAll>
 800a892:	9003      	str	r0, [sp, #12]
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800a894:	9b02      	ldr	r3, [sp, #8]
 800a896:	3314      	adds	r3, #20
 800a898:	9802      	ldr	r0, [sp, #8]
 800a89a:	4619      	mov	r1, r3
 800a89c:	4a1b      	ldr	r2, [pc, #108]	; (800a90c <test_008_005_execute+0x12c>)
 800a89e:	f7fc feef 	bl	8007680 <_test_assert_time_window>
 800a8a2:	4603      	mov	r3, r0
 800a8a4:	2b00      	cmp	r3, #0
 800a8a6:	d000      	beq.n	800a8aa <test_008_005_execute+0xca>
 800a8a8:	e022      	b.n	800a8f0 <test_008_005_execute+0x110>
                            "out of time window");
    test_assert(m == 5, "event flags error");
 800a8aa:	9b03      	ldr	r3, [sp, #12]
 800a8ac:	2b05      	cmp	r3, #5
 800a8ae:	bf0c      	ite	eq
 800a8b0:	2301      	moveq	r3, #1
 800a8b2:	2300      	movne	r3, #0
 800a8b4:	b2db      	uxtb	r3, r3
 800a8b6:	4618      	mov	r0, r3
 800a8b8:	4915      	ldr	r1, [pc, #84]	; (800a910 <test_008_005_execute+0x130>)
 800a8ba:	f7fc fe99 	bl	80075f0 <_test_assert>
 800a8be:	4603      	mov	r3, r0
 800a8c0:	2b00      	cmp	r3, #0
 800a8c2:	d000      	beq.n	800a8c6 <test_008_005_execute+0xe6>
 800a8c4:	e014      	b.n	800a8f0 <test_008_005_execute+0x110>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800a8c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a8ca:	f7f8 f811 	bl	80028f0 <chEvtGetAndClearEvents>
 800a8ce:	9003      	str	r0, [sp, #12]
    test_assert(m == 0, "stuck event");
 800a8d0:	9b03      	ldr	r3, [sp, #12]
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	bf0c      	ite	eq
 800a8d6:	2301      	moveq	r3, #1
 800a8d8:	2300      	movne	r3, #0
 800a8da:	b2db      	uxtb	r3, r3
 800a8dc:	4618      	mov	r0, r3
 800a8de:	4907      	ldr	r1, [pc, #28]	; (800a8fc <test_008_005_execute+0x11c>)
 800a8e0:	f7fc fe86 	bl	80075f0 <_test_assert>
 800a8e4:	4603      	mov	r3, r0
 800a8e6:	2b00      	cmp	r3, #0
 800a8e8:	d000      	beq.n	800a8ec <test_008_005_execute+0x10c>
 800a8ea:	e001      	b.n	800a8f0 <test_008_005_execute+0x110>
    test_wait_threads();
 800a8ec:	f7fd f918 	bl	8007b20 <test_wait_threads>
  }
}
 800a8f0:	b005      	add	sp, #20
 800a8f2:	bd30      	pop	{r4, r5, pc}
 800a8f4:	20000cac 	.word	0x20000cac
 800a8f8:	0800f118 	.word	0x0800f118
 800a8fc:	0800f0ac 	.word	0x0800f0ac
 800a900:	0800e298 	.word	0x0800e298
 800a904:	0800a371 	.word	0x0800a371
 800a908:	20000cb0 	.word	0x20000cb0
 800a90c:	0800f0b8 	.word	0x0800f0b8
 800a910:	0800f168 	.word	0x0800f168
 800a914:	f3af 8000 	nop.w
 800a918:	f3af 8000 	nop.w
 800a91c:	f3af 8000 	nop.w

0800a920 <test_008_006_setup>:
 * - [8.6.2] The functions are invoked first with a 50mS timeout, the
 *   timeout condition is tested.
 * .
 */

static void test_008_006_setup(void) {
 800a920:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800a922:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a926:	f7f7 ffe3 	bl	80028f0 <chEvtGetAndClearEvents>
}
 800a92a:	bd08      	pop	{r3, pc}
 800a92c:	f3af 8000 	nop.w

0800a930 <test_008_006_execute>:

static void test_008_006_execute(void) {
 800a930:	b500      	push	{lr}
 800a932:	b083      	sub	sp, #12
  eventmask_t m;

  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 800a934:	4b41      	ldr	r3, [pc, #260]	; (800aa3c <test_008_006_execute+0x10c>)
 800a936:	2201      	movs	r2, #1
 800a938:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800a93a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a93e:	2100      	movs	r1, #0
 800a940:	f7f8 f97e 	bl	8002c40 <chEvtWaitOneTimeout>
 800a944:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800a946:	9b01      	ldr	r3, [sp, #4]
 800a948:	2b00      	cmp	r3, #0
 800a94a:	bf0c      	ite	eq
 800a94c:	2301      	moveq	r3, #1
 800a94e:	2300      	movne	r3, #0
 800a950:	b2db      	uxtb	r3, r3
 800a952:	4618      	mov	r0, r3
 800a954:	493a      	ldr	r1, [pc, #232]	; (800aa40 <test_008_006_execute+0x110>)
 800a956:	f7fc fe4b 	bl	80075f0 <_test_assert>
 800a95a:	4603      	mov	r3, r0
 800a95c:	2b00      	cmp	r3, #0
 800a95e:	d000      	beq.n	800a962 <test_008_006_execute+0x32>
 800a960:	e069      	b.n	800aa36 <test_008_006_execute+0x106>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800a962:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a966:	2100      	movs	r1, #0
 800a968:	f7f8 f9aa 	bl	8002cc0 <chEvtWaitAnyTimeout>
 800a96c:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800a96e:	9b01      	ldr	r3, [sp, #4]
 800a970:	2b00      	cmp	r3, #0
 800a972:	bf0c      	ite	eq
 800a974:	2301      	moveq	r3, #1
 800a976:	2300      	movne	r3, #0
 800a978:	b2db      	uxtb	r3, r3
 800a97a:	4618      	mov	r0, r3
 800a97c:	4930      	ldr	r1, [pc, #192]	; (800aa40 <test_008_006_execute+0x110>)
 800a97e:	f7fc fe37 	bl	80075f0 <_test_assert>
 800a982:	4603      	mov	r3, r0
 800a984:	2b00      	cmp	r3, #0
 800a986:	d000      	beq.n	800a98a <test_008_006_execute+0x5a>
 800a988:	e055      	b.n	800aa36 <test_008_006_execute+0x106>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800a98a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a98e:	2100      	movs	r1, #0
 800a990:	f7f8 f9d6 	bl	8002d40 <chEvtWaitAllTimeout>
 800a994:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800a996:	9b01      	ldr	r3, [sp, #4]
 800a998:	2b00      	cmp	r3, #0
 800a99a:	bf0c      	ite	eq
 800a99c:	2301      	moveq	r3, #1
 800a99e:	2300      	movne	r3, #0
 800a9a0:	b2db      	uxtb	r3, r3
 800a9a2:	4618      	mov	r0, r3
 800a9a4:	4926      	ldr	r1, [pc, #152]	; (800aa40 <test_008_006_execute+0x110>)
 800a9a6:	f7fc fe23 	bl	80075f0 <_test_assert>
 800a9aa:	4603      	mov	r3, r0
 800a9ac:	2b00      	cmp	r3, #0
 800a9ae:	d000      	beq.n	800a9b2 <test_008_006_execute+0x82>
 800a9b0:	e041      	b.n	800aa36 <test_008_006_execute+0x106>
  }

  /* [8.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 800a9b2:	4b22      	ldr	r3, [pc, #136]	; (800aa3c <test_008_006_execute+0x10c>)
 800a9b4:	2202      	movs	r2, #2
 800a9b6:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
 800a9b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a9bc:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800a9c0:	f7f8 f93e 	bl	8002c40 <chEvtWaitOneTimeout>
 800a9c4:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800a9c6:	9b01      	ldr	r3, [sp, #4]
 800a9c8:	2b00      	cmp	r3, #0
 800a9ca:	bf0c      	ite	eq
 800a9cc:	2301      	moveq	r3, #1
 800a9ce:	2300      	movne	r3, #0
 800a9d0:	b2db      	uxtb	r3, r3
 800a9d2:	4618      	mov	r0, r3
 800a9d4:	491a      	ldr	r1, [pc, #104]	; (800aa40 <test_008_006_execute+0x110>)
 800a9d6:	f7fc fe0b 	bl	80075f0 <_test_assert>
 800a9da:	4603      	mov	r3, r0
 800a9dc:	2b00      	cmp	r3, #0
 800a9de:	d000      	beq.n	800a9e2 <test_008_006_execute+0xb2>
 800a9e0:	e029      	b.n	800aa36 <test_008_006_execute+0x106>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
 800a9e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a9e6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800a9ea:	f7f8 f969 	bl	8002cc0 <chEvtWaitAnyTimeout>
 800a9ee:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800a9f0:	9b01      	ldr	r3, [sp, #4]
 800a9f2:	2b00      	cmp	r3, #0
 800a9f4:	bf0c      	ite	eq
 800a9f6:	2301      	moveq	r3, #1
 800a9f8:	2300      	movne	r3, #0
 800a9fa:	b2db      	uxtb	r3, r3
 800a9fc:	4618      	mov	r0, r3
 800a9fe:	4910      	ldr	r1, [pc, #64]	; (800aa40 <test_008_006_execute+0x110>)
 800aa00:	f7fc fdf6 	bl	80075f0 <_test_assert>
 800aa04:	4603      	mov	r3, r0
 800aa06:	2b00      	cmp	r3, #0
 800aa08:	d000      	beq.n	800aa0c <test_008_006_execute+0xdc>
 800aa0a:	e014      	b.n	800aa36 <test_008_006_execute+0x106>
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
 800aa0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800aa10:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800aa14:	f7f8 f994 	bl	8002d40 <chEvtWaitAllTimeout>
 800aa18:	9001      	str	r0, [sp, #4]
    test_assert(m == 0, "spurious event");
 800aa1a:	9b01      	ldr	r3, [sp, #4]
 800aa1c:	2b00      	cmp	r3, #0
 800aa1e:	bf0c      	ite	eq
 800aa20:	2301      	moveq	r3, #1
 800aa22:	2300      	movne	r3, #0
 800aa24:	b2db      	uxtb	r3, r3
 800aa26:	4618      	mov	r0, r3
 800aa28:	4905      	ldr	r1, [pc, #20]	; (800aa40 <test_008_006_execute+0x110>)
 800aa2a:	f7fc fde1 	bl	80075f0 <_test_assert>
 800aa2e:	4603      	mov	r3, r0
 800aa30:	2b00      	cmp	r3, #0
 800aa32:	d000      	beq.n	800aa36 <test_008_006_execute+0x106>
 800aa34:	bf00      	nop
  }
}
 800aa36:	b003      	add	sp, #12
 800aa38:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa3c:	20000cac 	.word	0x20000cac
 800aa40:	0800f1b4 	.word	0x0800f1b4
 800aa44:	f3af 8000 	nop.w
 800aa48:	f3af 8000 	nop.w
 800aa4c:	f3af 8000 	nop.w

0800aa50 <test_008_007_setup>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_008_007_setup(void) {
 800aa50:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 800aa52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800aa56:	f7f7 ff4b 	bl	80028f0 <chEvtGetAndClearEvents>
  chEvtObjectInit(&es1);
 800aa5a:	4803      	ldr	r0, [pc, #12]	; (800aa68 <test_008_007_setup+0x18>)
 800aa5c:	f7ff fc10 	bl	800a280 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 800aa60:	4802      	ldr	r0, [pc, #8]	; (800aa6c <test_008_007_setup+0x1c>)
 800aa62:	f7ff fc0d 	bl	800a280 <chEvtObjectInit>
}
 800aa66:	bd08      	pop	{r3, pc}
 800aa68:	20000864 	.word	0x20000864
 800aa6c:	20000868 	.word	0x20000868

0800aa70 <test_008_007_execute>:

static void test_008_007_execute(void) {
 800aa70:	b510      	push	{r4, lr}
 800aa72:	b08e      	sub	sp, #56	; 0x38
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 800aa74:	4b46      	ldr	r3, [pc, #280]	; (800ab90 <test_008_007_execute+0x120>)
 800aa76:	2201      	movs	r2, #1
 800aa78:	601a      	str	r2, [r3, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
 800aa7a:	ab07      	add	r3, sp, #28
 800aa7c:	4845      	ldr	r0, [pc, #276]	; (800ab94 <test_008_007_execute+0x124>)
 800aa7e:	4619      	mov	r1, r3
 800aa80:	2201      	movs	r2, #1
 800aa82:	f7ff fc05 	bl	800a290 <chEvtRegisterMask>
    chEvtRegisterMask(&es2, &el2, 4);
 800aa86:	ab02      	add	r3, sp, #8
 800aa88:	4843      	ldr	r0, [pc, #268]	; (800ab98 <test_008_007_execute+0x128>)
 800aa8a:	4619      	mov	r1, r3
 800aa8c:	2204      	movs	r2, #4
 800aa8e:	f7ff fbff 	bl	800a290 <chEvtRegisterMask>
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 800aa92:	4b3f      	ldr	r3, [pc, #252]	; (800ab90 <test_008_007_execute+0x120>)
 800aa94:	2202      	movs	r2, #2
 800aa96:	601a      	str	r2, [r3, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 800aa98:	f7fd f86a 	bl	8007b70 <test_wait_tick>
 800aa9c:	4603      	mov	r3, r0
 800aa9e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800aaa2:	930d      	str	r3, [sp, #52]	; 0x34
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800aaa4:	4b3d      	ldr	r3, [pc, #244]	; (800ab9c <test_008_007_execute+0x12c>)
 800aaa6:	681c      	ldr	r4, [r3, #0]
 800aaa8:	f7ff fbe2 	bl	800a270 <chThdGetPriorityX>
 800aaac:	4603      	mov	r3, r0
 800aaae:	1e5a      	subs	r2, r3, #1
 800aab0:	4b3b      	ldr	r3, [pc, #236]	; (800aba0 <test_008_007_execute+0x130>)
 800aab2:	9300      	str	r3, [sp, #0]
 800aab4:	4620      	mov	r0, r4
 800aab6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800aaba:	4b3a      	ldr	r3, [pc, #232]	; (800aba4 <test_008_007_execute+0x134>)
 800aabc:	f7f6 fcc8 	bl	8001450 <chThdCreateStatic>
 800aac0:	4602      	mov	r2, r0
 800aac2:	4b39      	ldr	r3, [pc, #228]	; (800aba8 <test_008_007_execute+0x138>)
 800aac4:	601a      	str	r2, [r3, #0]
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 800aac6:	4b32      	ldr	r3, [pc, #200]	; (800ab90 <test_008_007_execute+0x120>)
 800aac8:	2203      	movs	r2, #3
 800aaca:	601a      	str	r2, [r3, #0]
  {
    m = chEvtWaitAll(5);
 800aacc:	2005      	movs	r0, #5
 800aace:	f7f8 f88f 	bl	8002bf0 <chEvtWaitAll>
 800aad2:	900c      	str	r0, [sp, #48]	; 0x30
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800aad4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800aad6:	3314      	adds	r3, #20
 800aad8:	980d      	ldr	r0, [sp, #52]	; 0x34
 800aada:	4619      	mov	r1, r3
 800aadc:	4a33      	ldr	r2, [pc, #204]	; (800abac <test_008_007_execute+0x13c>)
 800aade:	f7fc fdcf 	bl	8007680 <_test_assert_time_window>
 800aae2:	4603      	mov	r3, r0
 800aae4:	2b00      	cmp	r3, #0
 800aae6:	d000      	beq.n	800aaea <test_008_007_execute+0x7a>
 800aae8:	e04f      	b.n	800ab8a <test_008_007_execute+0x11a>
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800aaea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800aaee:	f7f7 feff 	bl	80028f0 <chEvtGetAndClearEvents>
 800aaf2:	900c      	str	r0, [sp, #48]	; 0x30
    test_assert(m == 0, "stuck event");
 800aaf4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800aaf6:	2b00      	cmp	r3, #0
 800aaf8:	bf0c      	ite	eq
 800aafa:	2301      	moveq	r3, #1
 800aafc:	2300      	movne	r3, #0
 800aafe:	b2db      	uxtb	r3, r3
 800ab00:	4618      	mov	r0, r3
 800ab02:	492b      	ldr	r1, [pc, #172]	; (800abb0 <test_008_007_execute+0x140>)
 800ab04:	f7fc fd74 	bl	80075f0 <_test_assert>
 800ab08:	4603      	mov	r3, r0
 800ab0a:	2b00      	cmp	r3, #0
 800ab0c:	d000      	beq.n	800ab10 <test_008_007_execute+0xa0>
 800ab0e:	e03c      	b.n	800ab8a <test_008_007_execute+0x11a>
    test_wait_threads();
 800ab10:	f7fd f806 	bl	8007b20 <test_wait_threads>
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 800ab14:	4b1e      	ldr	r3, [pc, #120]	; (800ab90 <test_008_007_execute+0x120>)
 800ab16:	2204      	movs	r2, #4
 800ab18:	601a      	str	r2, [r3, #0]
  {
    chEvtUnregister(&es1, &el1);
 800ab1a:	ab07      	add	r3, sp, #28
 800ab1c:	481d      	ldr	r0, [pc, #116]	; (800ab94 <test_008_007_execute+0x124>)
 800ab1e:	4619      	mov	r1, r3
 800ab20:	f7f7 fec6 	bl	80028b0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 800ab24:	ab02      	add	r3, sp, #8
 800ab26:	481c      	ldr	r0, [pc, #112]	; (800ab98 <test_008_007_execute+0x128>)
 800ab28:	4619      	mov	r1, r3
 800ab2a:	f7f7 fec1 	bl	80028b0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 800ab2e:	4819      	ldr	r0, [pc, #100]	; (800ab94 <test_008_007_execute+0x124>)
 800ab30:	f7ff fbbe 	bl	800a2b0 <chEvtIsListeningI>
 800ab34:	4603      	mov	r3, r0
 800ab36:	2b00      	cmp	r3, #0
 800ab38:	bf14      	ite	ne
 800ab3a:	2301      	movne	r3, #1
 800ab3c:	2300      	moveq	r3, #0
 800ab3e:	b2db      	uxtb	r3, r3
 800ab40:	f083 0301 	eor.w	r3, r3, #1
 800ab44:	b2db      	uxtb	r3, r3
 800ab46:	f003 0301 	and.w	r3, r3, #1
 800ab4a:	b2db      	uxtb	r3, r3
 800ab4c:	4618      	mov	r0, r3
 800ab4e:	4919      	ldr	r1, [pc, #100]	; (800abb4 <test_008_007_execute+0x144>)
 800ab50:	f7fc fd4e 	bl	80075f0 <_test_assert>
 800ab54:	4603      	mov	r3, r0
 800ab56:	2b00      	cmp	r3, #0
 800ab58:	d000      	beq.n	800ab5c <test_008_007_execute+0xec>
 800ab5a:	e016      	b.n	800ab8a <test_008_007_execute+0x11a>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 800ab5c:	480e      	ldr	r0, [pc, #56]	; (800ab98 <test_008_007_execute+0x128>)
 800ab5e:	f7ff fba7 	bl	800a2b0 <chEvtIsListeningI>
 800ab62:	4603      	mov	r3, r0
 800ab64:	2b00      	cmp	r3, #0
 800ab66:	bf14      	ite	ne
 800ab68:	2301      	movne	r3, #1
 800ab6a:	2300      	moveq	r3, #0
 800ab6c:	b2db      	uxtb	r3, r3
 800ab6e:	f083 0301 	eor.w	r3, r3, #1
 800ab72:	b2db      	uxtb	r3, r3
 800ab74:	f003 0301 	and.w	r3, r3, #1
 800ab78:	b2db      	uxtb	r3, r3
 800ab7a:	4618      	mov	r0, r3
 800ab7c:	490d      	ldr	r1, [pc, #52]	; (800abb4 <test_008_007_execute+0x144>)
 800ab7e:	f7fc fd37 	bl	80075f0 <_test_assert>
 800ab82:	4603      	mov	r3, r0
 800ab84:	2b00      	cmp	r3, #0
 800ab86:	d000      	beq.n	800ab8a <test_008_007_execute+0x11a>
 800ab88:	bf00      	nop
  }
}
 800ab8a:	b00e      	add	sp, #56	; 0x38
 800ab8c:	bd10      	pop	{r4, pc}
 800ab8e:	bf00      	nop
 800ab90:	20000cac 	.word	0x20000cac
 800ab94:	20000864 	.word	0x20000864
 800ab98:	20000868 	.word	0x20000868
 800ab9c:	0800e298 	.word	0x0800e298
 800aba0:	0800f1f0 	.word	0x0800f1f0
 800aba4:	0800a391 	.word	0x0800a391
 800aba8:	20000cb0 	.word	0x20000cb0
 800abac:	0800f0b8 	.word	0x0800f0b8
 800abb0:	0800f0ac 	.word	0x0800f0ac
 800abb4:	0800f024 	.word	0x0800f024
	...

0800abc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800abc0:	b082      	sub	sp, #8
 800abc2:	2320      	movs	r3, #32
 800abc4:	9301      	str	r3, [sp, #4]
 800abc6:	9b01      	ldr	r3, [sp, #4]
 800abc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800abcc:	b002      	add	sp, #8
 800abce:	4770      	bx	lr

0800abd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800abd0:	b082      	sub	sp, #8
 800abd2:	2300      	movs	r3, #0
 800abd4:	9301      	str	r3, [sp, #4]
 800abd6:	9b01      	ldr	r3, [sp, #4]
 800abd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800abdc:	b002      	add	sp, #8
 800abde:	4770      	bx	lr

0800abe0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800abe0:	b508      	push	{r3, lr}

  port_lock();
 800abe2:	f7ff ffed 	bl	800abc0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800abe6:	bd08      	pop	{r3, pc}
 800abe8:	f3af 8000 	nop.w
 800abec:	f3af 8000 	nop.w

0800abf0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800abf0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800abf2:	f7ff ffed 	bl	800abd0 <port_unlock>
}
 800abf6:	bd08      	pop	{r3, pc}
 800abf8:	f3af 8000 	nop.w
 800abfc:	f3af 8000 	nop.w

0800ac00 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {
 800ac00:	b082      	sub	sp, #8
 800ac02:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 800ac04:	9b01      	ldr	r3, [sp, #4]
 800ac06:	685b      	ldr	r3, [r3, #4]
 800ac08:	461a      	mov	r2, r3
 800ac0a:	9b01      	ldr	r3, [sp, #4]
 800ac0c:	681b      	ldr	r3, [r3, #0]
 800ac0e:	1ad3      	subs	r3, r2, r3
 800ac10:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 800ac12:	4618      	mov	r0, r3
 800ac14:	b002      	add	sp, #8
 800ac16:	4770      	bx	lr
 800ac18:	f3af 8000 	nop.w
 800ac1c:	f3af 8000 	nop.w

0800ac20 <chMBGetUsedCountI>:
 * @return              The number of queued messages.
 * @retval QUEUE_RESET  if the queue is in reset state.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(const mailbox_t *mbp) {
 800ac20:	b082      	sub	sp, #8
 800ac22:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return mbp->cnt;
 800ac24:	9b01      	ldr	r3, [sp, #4]
 800ac26:	691b      	ldr	r3, [r3, #16]
}
 800ac28:	4618      	mov	r0, r3
 800ac2a:	b002      	add	sp, #8
 800ac2c:	4770      	bx	lr
 800ac2e:	bf00      	nop

0800ac30 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 800ac30:	b510      	push	{r4, lr}
 800ac32:	b082      	sub	sp, #8
 800ac34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800ac36:	9801      	ldr	r0, [sp, #4]
 800ac38:	f7ff ffe2 	bl	800ac00 <chMBGetSizeI>
 800ac3c:	4604      	mov	r4, r0
 800ac3e:	9801      	ldr	r0, [sp, #4]
 800ac40:	f7ff ffee 	bl	800ac20 <chMBGetUsedCountI>
 800ac44:	4603      	mov	r3, r0
 800ac46:	1ae3      	subs	r3, r4, r3
}
 800ac48:	4618      	mov	r0, r3
 800ac4a:	b002      	add	sp, #8
 800ac4c:	bd10      	pop	{r4, pc}
 800ac4e:	bf00      	nop

0800ac50 <chMBResumeX>:
 *
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {
 800ac50:	b082      	sub	sp, #8
 800ac52:	9001      	str	r0, [sp, #4]

  mbp->reset = false;
 800ac54:	9b01      	ldr	r3, [sp, #4]
 800ac56:	2200      	movs	r2, #0
 800ac58:	751a      	strb	r2, [r3, #20]
}
 800ac5a:	b002      	add	sp, #8
 800ac5c:	4770      	bx	lr
 800ac5e:	bf00      	nop

0800ac60 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800ac60:	b508      	push	{r3, lr}

  chSysLock();
 800ac62:	f7ff ffbd 	bl	800abe0 <chSysLock>
}
 800ac66:	bd08      	pop	{r3, pc}
 800ac68:	f3af 8000 	nop.w
 800ac6c:	f3af 8000 	nop.w

0800ac70 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800ac70:	b508      	push	{r3, lr}

  chSysUnlock();
 800ac72:	f7ff ffbd 	bl	800abf0 <chSysUnlock>
}
 800ac76:	bd08      	pop	{r3, pc}
 800ac78:	f3af 8000 	nop.w
 800ac7c:	f3af 8000 	nop.w

0800ac80 <test_009_001_setup>:
 * - [9.1.8] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_009_001_setup(void) {
 800ac80:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 800ac82:	4803      	ldr	r0, [pc, #12]	; (800ac90 <test_009_001_setup+0x10>)
 800ac84:	4903      	ldr	r1, [pc, #12]	; (800ac94 <test_009_001_setup+0x14>)
 800ac86:	2204      	movs	r2, #4
 800ac88:	f7f8 fa62 	bl	8003150 <chMBObjectInit>
}
 800ac8c:	bd08      	pop	{r3, pc}
 800ac8e:	bf00      	nop
 800ac90:	2000086c 	.word	0x2000086c
 800ac94:	2000098c 	.word	0x2000098c
 800ac98:	f3af 8000 	nop.w
 800ac9c:	f3af 8000 	nop.w

0800aca0 <test_009_001_teardown>:

static void test_009_001_teardown(void) {
 800aca0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 800aca2:	4802      	ldr	r0, [pc, #8]	; (800acac <test_009_001_teardown+0xc>)
 800aca4:	f7f8 fa7c 	bl	80031a0 <chMBReset>
}
 800aca8:	bd08      	pop	{r3, pc}
 800acaa:	bf00      	nop
 800acac:	2000086c 	.word	0x2000086c

0800acb0 <test_009_001_execute>:

static void test_009_001_execute(void) {
 800acb0:	b500      	push	{lr}
 800acb2:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [9.1.1] Testing the mailbox size.*/
  test_set_step(1);
 800acb4:	4ba5      	ldr	r3, [pc, #660]	; (800af4c <test_009_001_execute+0x29c>)
 800acb6:	2201      	movs	r2, #1
 800acb8:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800acba:	f7ff ffd1 	bl	800ac60 <osalSysLock>
 800acbe:	48a4      	ldr	r0, [pc, #656]	; (800af50 <test_009_001_execute+0x2a0>)
 800acc0:	f7ff ffb6 	bl	800ac30 <chMBGetFreeCountI>
 800acc4:	4603      	mov	r3, r0
 800acc6:	2b04      	cmp	r3, #4
 800acc8:	bf0c      	ite	eq
 800acca:	2301      	moveq	r3, #1
 800accc:	2300      	movne	r3, #0
 800acce:	b2db      	uxtb	r3, r3
 800acd0:	4618      	mov	r0, r3
 800acd2:	49a0      	ldr	r1, [pc, #640]	; (800af54 <test_009_001_execute+0x2a4>)
 800acd4:	f7fc fc8c 	bl	80075f0 <_test_assert>
 800acd8:	4603      	mov	r3, r0
 800acda:	2b00      	cmp	r3, #0
 800acdc:	d002      	beq.n	800ace4 <test_009_001_execute+0x34>
 800acde:	f7ff ffc7 	bl	800ac70 <osalSysUnlock>
 800ace2:	e1f7      	b.n	800b0d4 <test_009_001_execute+0x424>
 800ace4:	f7ff ffc4 	bl	800ac70 <osalSysUnlock>
  }

  /* [9.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 800ace8:	4b98      	ldr	r3, [pc, #608]	; (800af4c <test_009_001_execute+0x29c>)
 800acea:	2202      	movs	r2, #2
 800acec:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
 800acee:	4898      	ldr	r0, [pc, #608]	; (800af50 <test_009_001_execute+0x2a0>)
 800acf0:	f7f8 fa56 	bl	80031a0 <chMBReset>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800acf4:	f7ff ffb4 	bl	800ac60 <osalSysLock>
 800acf8:	4895      	ldr	r0, [pc, #596]	; (800af50 <test_009_001_execute+0x2a0>)
 800acfa:	f7ff ff99 	bl	800ac30 <chMBGetFreeCountI>
 800acfe:	4603      	mov	r3, r0
 800ad00:	2b04      	cmp	r3, #4
 800ad02:	bf0c      	ite	eq
 800ad04:	2301      	moveq	r3, #1
 800ad06:	2300      	movne	r3, #0
 800ad08:	b2db      	uxtb	r3, r3
 800ad0a:	4618      	mov	r0, r3
 800ad0c:	4992      	ldr	r1, [pc, #584]	; (800af58 <test_009_001_execute+0x2a8>)
 800ad0e:	f7fc fc6f 	bl	80075f0 <_test_assert>
 800ad12:	4603      	mov	r3, r0
 800ad14:	2b00      	cmp	r3, #0
 800ad16:	d002      	beq.n	800ad1e <test_009_001_execute+0x6e>
 800ad18:	f7ff ffaa 	bl	800ac70 <osalSysUnlock>
 800ad1c:	e1da      	b.n	800b0d4 <test_009_001_execute+0x424>
 800ad1e:	f7ff ffa7 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800ad22:	f7ff ff9d 	bl	800ac60 <osalSysLock>
 800ad26:	488a      	ldr	r0, [pc, #552]	; (800af50 <test_009_001_execute+0x2a0>)
 800ad28:	f7ff ff7a 	bl	800ac20 <chMBGetUsedCountI>
 800ad2c:	4603      	mov	r3, r0
 800ad2e:	2b00      	cmp	r3, #0
 800ad30:	bf0c      	ite	eq
 800ad32:	2301      	moveq	r3, #1
 800ad34:	2300      	movne	r3, #0
 800ad36:	b2db      	uxtb	r3, r3
 800ad38:	4618      	mov	r0, r3
 800ad3a:	4988      	ldr	r1, [pc, #544]	; (800af5c <test_009_001_execute+0x2ac>)
 800ad3c:	f7fc fc58 	bl	80075f0 <_test_assert>
 800ad40:	4603      	mov	r3, r0
 800ad42:	2b00      	cmp	r3, #0
 800ad44:	d002      	beq.n	800ad4c <test_009_001_execute+0x9c>
 800ad46:	f7ff ff93 	bl	800ac70 <osalSysUnlock>
 800ad4a:	e1c3      	b.n	800b0d4 <test_009_001_execute+0x424>
 800ad4c:	f7ff ff90 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800ad50:	f7ff ff86 	bl	800ac60 <osalSysLock>
 800ad54:	4b7e      	ldr	r3, [pc, #504]	; (800af50 <test_009_001_execute+0x2a0>)
 800ad56:	681a      	ldr	r2, [r3, #0]
 800ad58:	4b7d      	ldr	r3, [pc, #500]	; (800af50 <test_009_001_execute+0x2a0>)
 800ad5a:	689b      	ldr	r3, [r3, #8]
 800ad5c:	429a      	cmp	r2, r3
 800ad5e:	bf0c      	ite	eq
 800ad60:	2301      	moveq	r3, #1
 800ad62:	2300      	movne	r3, #0
 800ad64:	b2db      	uxtb	r3, r3
 800ad66:	4618      	mov	r0, r3
 800ad68:	497d      	ldr	r1, [pc, #500]	; (800af60 <test_009_001_execute+0x2b0>)
 800ad6a:	f7fc fc41 	bl	80075f0 <_test_assert>
 800ad6e:	4603      	mov	r3, r0
 800ad70:	2b00      	cmp	r3, #0
 800ad72:	d002      	beq.n	800ad7a <test_009_001_execute+0xca>
 800ad74:	f7ff ff7c 	bl	800ac70 <osalSysUnlock>
 800ad78:	e1ac      	b.n	800b0d4 <test_009_001_execute+0x424>
 800ad7a:	f7ff ff79 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800ad7e:	f7ff ff6f 	bl	800ac60 <osalSysLock>
 800ad82:	4b73      	ldr	r3, [pc, #460]	; (800af50 <test_009_001_execute+0x2a0>)
 800ad84:	681a      	ldr	r2, [r3, #0]
 800ad86:	4b72      	ldr	r3, [pc, #456]	; (800af50 <test_009_001_execute+0x2a0>)
 800ad88:	68db      	ldr	r3, [r3, #12]
 800ad8a:	429a      	cmp	r2, r3
 800ad8c:	bf0c      	ite	eq
 800ad8e:	2301      	moveq	r3, #1
 800ad90:	2300      	movne	r3, #0
 800ad92:	b2db      	uxtb	r3, r3
 800ad94:	4618      	mov	r0, r3
 800ad96:	4973      	ldr	r1, [pc, #460]	; (800af64 <test_009_001_execute+0x2b4>)
 800ad98:	f7fc fc2a 	bl	80075f0 <_test_assert>
 800ad9c:	4603      	mov	r3, r0
 800ad9e:	2b00      	cmp	r3, #0
 800ada0:	d002      	beq.n	800ada8 <test_009_001_execute+0xf8>
 800ada2:	f7ff ff65 	bl	800ac70 <osalSysUnlock>
 800ada6:	e195      	b.n	800b0d4 <test_009_001_execute+0x424>
 800ada8:	f7ff ff62 	bl	800ac70 <osalSysUnlock>
  }

  /* [9.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 800adac:	4b67      	ldr	r3, [pc, #412]	; (800af4c <test_009_001_execute+0x29c>)
 800adae:	2203      	movs	r2, #3
 800adb0:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
 800adb2:	4867      	ldr	r0, [pc, #412]	; (800af50 <test_009_001_execute+0x2a0>)
 800adb4:	2100      	movs	r1, #0
 800adb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800adba:	f7f8 fa29 	bl	8003210 <chMBPost>
 800adbe:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800adc0:	9b02      	ldr	r3, [sp, #8]
 800adc2:	f113 0f02 	cmn.w	r3, #2
 800adc6:	bf0c      	ite	eq
 800adc8:	2301      	moveq	r3, #1
 800adca:	2300      	movne	r3, #0
 800adcc:	b2db      	uxtb	r3, r3
 800adce:	4618      	mov	r0, r3
 800add0:	4965      	ldr	r1, [pc, #404]	; (800af68 <test_009_001_execute+0x2b8>)
 800add2:	f7fc fc0d 	bl	80075f0 <_test_assert>
 800add6:	4603      	mov	r3, r0
 800add8:	2b00      	cmp	r3, #0
 800adda:	d000      	beq.n	800adde <test_009_001_execute+0x12e>
 800addc:	e17a      	b.n	800b0d4 <test_009_001_execute+0x424>
    msg1 = chMBPostAhead(&mb1, (msg_t)0, TIME_INFINITE);
 800adde:	485c      	ldr	r0, [pc, #368]	; (800af50 <test_009_001_execute+0x2a0>)
 800ade0:	2100      	movs	r1, #0
 800ade2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ade6:	f7f8 faab 	bl	8003340 <chMBPostAhead>
 800adea:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800adec:	9b02      	ldr	r3, [sp, #8]
 800adee:	f113 0f02 	cmn.w	r3, #2
 800adf2:	bf0c      	ite	eq
 800adf4:	2301      	moveq	r3, #1
 800adf6:	2300      	movne	r3, #0
 800adf8:	b2db      	uxtb	r3, r3
 800adfa:	4618      	mov	r0, r3
 800adfc:	495a      	ldr	r1, [pc, #360]	; (800af68 <test_009_001_execute+0x2b8>)
 800adfe:	f7fc fbf7 	bl	80075f0 <_test_assert>
 800ae02:	4603      	mov	r3, r0
 800ae04:	2b00      	cmp	r3, #0
 800ae06:	d000      	beq.n	800ae0a <test_009_001_execute+0x15a>
 800ae08:	e164      	b.n	800b0d4 <test_009_001_execute+0x424>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800ae0a:	ab01      	add	r3, sp, #4
 800ae0c:	4850      	ldr	r0, [pc, #320]	; (800af50 <test_009_001_execute+0x2a0>)
 800ae0e:	4619      	mov	r1, r3
 800ae10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ae14:	f7f8 fb2c 	bl	8003470 <chMBFetch>
 800ae18:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800ae1a:	9b02      	ldr	r3, [sp, #8]
 800ae1c:	f113 0f02 	cmn.w	r3, #2
 800ae20:	bf0c      	ite	eq
 800ae22:	2301      	moveq	r3, #1
 800ae24:	2300      	movne	r3, #0
 800ae26:	b2db      	uxtb	r3, r3
 800ae28:	4618      	mov	r0, r3
 800ae2a:	494f      	ldr	r1, [pc, #316]	; (800af68 <test_009_001_execute+0x2b8>)
 800ae2c:	f7fc fbe0 	bl	80075f0 <_test_assert>
 800ae30:	4603      	mov	r3, r0
 800ae32:	2b00      	cmp	r3, #0
 800ae34:	d000      	beq.n	800ae38 <test_009_001_execute+0x188>
 800ae36:	e14d      	b.n	800b0d4 <test_009_001_execute+0x424>
    chMBResumeX(&mb1);
 800ae38:	4845      	ldr	r0, [pc, #276]	; (800af50 <test_009_001_execute+0x2a0>)
 800ae3a:	f7ff ff09 	bl	800ac50 <chMBResumeX>
  }

  /* [9.1.4] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(4);
 800ae3e:	4b43      	ldr	r3, [pc, #268]	; (800af4c <test_009_001_execute+0x29c>)
 800ae40:	2204      	movs	r2, #4
 800ae42:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 800ae44:	2300      	movs	r3, #0
 800ae46:	9303      	str	r3, [sp, #12]
 800ae48:	e019      	b.n	800ae7e <test_009_001_execute+0x1ce>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800ae4a:	9b03      	ldr	r3, [sp, #12]
 800ae4c:	3342      	adds	r3, #66	; 0x42
 800ae4e:	4840      	ldr	r0, [pc, #256]	; (800af50 <test_009_001_execute+0x2a0>)
 800ae50:	4619      	mov	r1, r3
 800ae52:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ae56:	f7f8 f9db 	bl	8003210 <chMBPost>
 800ae5a:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800ae5c:	9b02      	ldr	r3, [sp, #8]
 800ae5e:	2b00      	cmp	r3, #0
 800ae60:	bf0c      	ite	eq
 800ae62:	2301      	moveq	r3, #1
 800ae64:	2300      	movne	r3, #0
 800ae66:	b2db      	uxtb	r3, r3
 800ae68:	4618      	mov	r0, r3
 800ae6a:	4940      	ldr	r1, [pc, #256]	; (800af6c <test_009_001_execute+0x2bc>)
 800ae6c:	f7fc fbc0 	bl	80075f0 <_test_assert>
 800ae70:	4603      	mov	r3, r0
 800ae72:	2b00      	cmp	r3, #0
 800ae74:	d000      	beq.n	800ae78 <test_009_001_execute+0x1c8>
 800ae76:	e12d      	b.n	800b0d4 <test_009_001_execute+0x424>

  /* [9.1.4] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(4);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 800ae78:	9b03      	ldr	r3, [sp, #12]
 800ae7a:	3301      	adds	r3, #1
 800ae7c:	9303      	str	r3, [sp, #12]
 800ae7e:	9b03      	ldr	r3, [sp, #12]
 800ae80:	2b02      	cmp	r3, #2
 800ae82:	d9e2      	bls.n	800ae4a <test_009_001_execute+0x19a>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800ae84:	4832      	ldr	r0, [pc, #200]	; (800af50 <test_009_001_execute+0x2a0>)
 800ae86:	2141      	movs	r1, #65	; 0x41
 800ae88:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ae8c:	f7f8 fa58 	bl	8003340 <chMBPostAhead>
 800ae90:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800ae92:	9b02      	ldr	r3, [sp, #8]
 800ae94:	2b00      	cmp	r3, #0
 800ae96:	bf0c      	ite	eq
 800ae98:	2301      	moveq	r3, #1
 800ae9a:	2300      	movne	r3, #0
 800ae9c:	b2db      	uxtb	r3, r3
 800ae9e:	4618      	mov	r0, r3
 800aea0:	4932      	ldr	r1, [pc, #200]	; (800af6c <test_009_001_execute+0x2bc>)
 800aea2:	f7fc fba5 	bl	80075f0 <_test_assert>
 800aea6:	4603      	mov	r3, r0
 800aea8:	2b00      	cmp	r3, #0
 800aeaa:	d000      	beq.n	800aeae <test_009_001_execute+0x1fe>
 800aeac:	e112      	b.n	800b0d4 <test_009_001_execute+0x424>
  }

  /* [9.1.5] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(5);
 800aeae:	4b27      	ldr	r3, [pc, #156]	; (800af4c <test_009_001_execute+0x29c>)
 800aeb0:	2205      	movs	r2, #5
 800aeb2:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 800aeb4:	f7ff fed4 	bl	800ac60 <osalSysLock>
 800aeb8:	4825      	ldr	r0, [pc, #148]	; (800af50 <test_009_001_execute+0x2a0>)
 800aeba:	f7ff feb9 	bl	800ac30 <chMBGetFreeCountI>
 800aebe:	4603      	mov	r3, r0
 800aec0:	2b00      	cmp	r3, #0
 800aec2:	bf0c      	ite	eq
 800aec4:	2301      	moveq	r3, #1
 800aec6:	2300      	movne	r3, #0
 800aec8:	b2db      	uxtb	r3, r3
 800aeca:	4618      	mov	r0, r3
 800aecc:	4928      	ldr	r1, [pc, #160]	; (800af70 <test_009_001_execute+0x2c0>)
 800aece:	f7fc fb8f 	bl	80075f0 <_test_assert>
 800aed2:	4603      	mov	r3, r0
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	d002      	beq.n	800aede <test_009_001_execute+0x22e>
 800aed8:	f7ff feca 	bl	800ac70 <osalSysUnlock>
 800aedc:	e0fa      	b.n	800b0d4 <test_009_001_execute+0x424>
 800aede:	f7ff fec7 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800aee2:	f7ff febd 	bl	800ac60 <osalSysLock>
 800aee6:	481a      	ldr	r0, [pc, #104]	; (800af50 <test_009_001_execute+0x2a0>)
 800aee8:	f7ff fe9a 	bl	800ac20 <chMBGetUsedCountI>
 800aeec:	4603      	mov	r3, r0
 800aeee:	2b04      	cmp	r3, #4
 800aef0:	bf0c      	ite	eq
 800aef2:	2301      	moveq	r3, #1
 800aef4:	2300      	movne	r3, #0
 800aef6:	b2db      	uxtb	r3, r3
 800aef8:	4618      	mov	r0, r3
 800aefa:	491e      	ldr	r1, [pc, #120]	; (800af74 <test_009_001_execute+0x2c4>)
 800aefc:	f7fc fb78 	bl	80075f0 <_test_assert>
 800af00:	4603      	mov	r3, r0
 800af02:	2b00      	cmp	r3, #0
 800af04:	d002      	beq.n	800af0c <test_009_001_execute+0x25c>
 800af06:	f7ff feb3 	bl	800ac70 <osalSysUnlock>
 800af0a:	e0e3      	b.n	800b0d4 <test_009_001_execute+0x424>
 800af0c:	f7ff feb0 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 800af10:	f7ff fea6 	bl	800ac60 <osalSysLock>
 800af14:	4b0e      	ldr	r3, [pc, #56]	; (800af50 <test_009_001_execute+0x2a0>)
 800af16:	68da      	ldr	r2, [r3, #12]
 800af18:	4b0d      	ldr	r3, [pc, #52]	; (800af50 <test_009_001_execute+0x2a0>)
 800af1a:	689b      	ldr	r3, [r3, #8]
 800af1c:	429a      	cmp	r2, r3
 800af1e:	bf0c      	ite	eq
 800af20:	2301      	moveq	r3, #1
 800af22:	2300      	movne	r3, #0
 800af24:	b2db      	uxtb	r3, r3
 800af26:	4618      	mov	r0, r3
 800af28:	4913      	ldr	r1, [pc, #76]	; (800af78 <test_009_001_execute+0x2c8>)
 800af2a:	f7fc fb61 	bl	80075f0 <_test_assert>
 800af2e:	4603      	mov	r3, r0
 800af30:	2b00      	cmp	r3, #0
 800af32:	d002      	beq.n	800af3a <test_009_001_execute+0x28a>
 800af34:	f7ff fe9c 	bl	800ac70 <osalSysUnlock>
 800af38:	e0cc      	b.n	800b0d4 <test_009_001_execute+0x424>
 800af3a:	f7ff fe99 	bl	800ac70 <osalSysUnlock>
  }

  /* [9.1.6] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(6);
 800af3e:	4b03      	ldr	r3, [pc, #12]	; (800af4c <test_009_001_execute+0x29c>)
 800af40:	2206      	movs	r2, #6
 800af42:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 800af44:	2300      	movs	r3, #0
 800af46:	9303      	str	r3, [sp, #12]
 800af48:	e036      	b.n	800afb8 <test_009_001_execute+0x308>
 800af4a:	bf00      	nop
 800af4c:	20000cac 	.word	0x20000cac
 800af50:	2000086c 	.word	0x2000086c
 800af54:	0800f248 	.word	0x0800f248
 800af58:	0800f254 	.word	0x0800f254
 800af5c:	0800f260 	.word	0x0800f260
 800af60:	0800f26c 	.word	0x0800f26c
 800af64:	0800f290 	.word	0x0800f290
 800af68:	0800f2b4 	.word	0x0800f2b4
 800af6c:	0800f2c8 	.word	0x0800f2c8
 800af70:	0800f2e0 	.word	0x0800f2e0
 800af74:	0800f2ec 	.word	0x0800f2ec
 800af78:	0800f2f8 	.word	0x0800f2f8
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800af7c:	ab01      	add	r3, sp, #4
 800af7e:	4857      	ldr	r0, [pc, #348]	; (800b0dc <test_009_001_execute+0x42c>)
 800af80:	4619      	mov	r1, r3
 800af82:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800af86:	f7f8 fa73 	bl	8003470 <chMBFetch>
 800af8a:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800af8c:	9b02      	ldr	r3, [sp, #8]
 800af8e:	2b00      	cmp	r3, #0
 800af90:	bf0c      	ite	eq
 800af92:	2301      	moveq	r3, #1
 800af94:	2300      	movne	r3, #0
 800af96:	b2db      	uxtb	r3, r3
 800af98:	4618      	mov	r0, r3
 800af9a:	4951      	ldr	r1, [pc, #324]	; (800b0e0 <test_009_001_execute+0x430>)
 800af9c:	f7fc fb28 	bl	80075f0 <_test_assert>
 800afa0:	4603      	mov	r3, r0
 800afa2:	2b00      	cmp	r3, #0
 800afa4:	d000      	beq.n	800afa8 <test_009_001_execute+0x2f8>
 800afa6:	e095      	b.n	800b0d4 <test_009_001_execute+0x424>
      test_emit_token(msg2);
 800afa8:	9b01      	ldr	r3, [sp, #4]
 800afaa:	b2db      	uxtb	r3, r3
 800afac:	4618      	mov	r0, r3
 800afae:	f7fc fbff 	bl	80077b0 <test_emit_token>

  /* [9.1.6] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(6);
  {
    for (i = 0; i < MB_SIZE; i++) {
 800afb2:	9b03      	ldr	r3, [sp, #12]
 800afb4:	3301      	adds	r3, #1
 800afb6:	9303      	str	r3, [sp, #12]
 800afb8:	9b03      	ldr	r3, [sp, #12]
 800afba:	2b03      	cmp	r3, #3
 800afbc:	d9de      	bls.n	800af7c <test_009_001_execute+0x2cc>
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 800afbe:	4849      	ldr	r0, [pc, #292]	; (800b0e4 <test_009_001_execute+0x434>)
 800afc0:	4949      	ldr	r1, [pc, #292]	; (800b0e8 <test_009_001_execute+0x438>)
 800afc2:	f7fc fb2d 	bl	8007620 <_test_assert_sequence>
 800afc6:	4603      	mov	r3, r0
 800afc8:	2b00      	cmp	r3, #0
 800afca:	d000      	beq.n	800afce <test_009_001_execute+0x31e>
 800afcc:	e082      	b.n	800b0d4 <test_009_001_execute+0x424>
  }

  /* [9.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 800afce:	4b47      	ldr	r3, [pc, #284]	; (800b0ec <test_009_001_execute+0x43c>)
 800afd0:	2207      	movs	r2, #7
 800afd2:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800afd4:	9b03      	ldr	r3, [sp, #12]
 800afd6:	3342      	adds	r3, #66	; 0x42
 800afd8:	4840      	ldr	r0, [pc, #256]	; (800b0dc <test_009_001_execute+0x42c>)
 800afda:	4619      	mov	r1, r3
 800afdc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800afe0:	f7f8 f916 	bl	8003210 <chMBPost>
 800afe4:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800afe6:	9b02      	ldr	r3, [sp, #8]
 800afe8:	2b00      	cmp	r3, #0
 800afea:	bf0c      	ite	eq
 800afec:	2301      	moveq	r3, #1
 800afee:	2300      	movne	r3, #0
 800aff0:	b2db      	uxtb	r3, r3
 800aff2:	4618      	mov	r0, r3
 800aff4:	493a      	ldr	r1, [pc, #232]	; (800b0e0 <test_009_001_execute+0x430>)
 800aff6:	f7fc fafb 	bl	80075f0 <_test_assert>
 800affa:	4603      	mov	r3, r0
 800affc:	2b00      	cmp	r3, #0
 800affe:	d000      	beq.n	800b002 <test_009_001_execute+0x352>
 800b000:	e068      	b.n	800b0d4 <test_009_001_execute+0x424>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800b002:	ab01      	add	r3, sp, #4
 800b004:	4835      	ldr	r0, [pc, #212]	; (800b0dc <test_009_001_execute+0x42c>)
 800b006:	4619      	mov	r1, r3
 800b008:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b00c:	f7f8 fa30 	bl	8003470 <chMBFetch>
 800b010:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b012:	9b02      	ldr	r3, [sp, #8]
 800b014:	2b00      	cmp	r3, #0
 800b016:	bf0c      	ite	eq
 800b018:	2301      	moveq	r3, #1
 800b01a:	2300      	movne	r3, #0
 800b01c:	b2db      	uxtb	r3, r3
 800b01e:	4618      	mov	r0, r3
 800b020:	492f      	ldr	r1, [pc, #188]	; (800b0e0 <test_009_001_execute+0x430>)
 800b022:	f7fc fae5 	bl	80075f0 <_test_assert>
 800b026:	4603      	mov	r3, r0
 800b028:	2b00      	cmp	r3, #0
 800b02a:	d000      	beq.n	800b02e <test_009_001_execute+0x37e>
 800b02c:	e052      	b.n	800b0d4 <test_009_001_execute+0x424>
  }

  /* [9.1.8] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(8);
 800b02e:	4b2f      	ldr	r3, [pc, #188]	; (800b0ec <test_009_001_execute+0x43c>)
 800b030:	2208      	movs	r2, #8
 800b032:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800b034:	f7ff fe14 	bl	800ac60 <osalSysLock>
 800b038:	4828      	ldr	r0, [pc, #160]	; (800b0dc <test_009_001_execute+0x42c>)
 800b03a:	f7ff fdf9 	bl	800ac30 <chMBGetFreeCountI>
 800b03e:	4603      	mov	r3, r0
 800b040:	2b04      	cmp	r3, #4
 800b042:	bf0c      	ite	eq
 800b044:	2301      	moveq	r3, #1
 800b046:	2300      	movne	r3, #0
 800b048:	b2db      	uxtb	r3, r3
 800b04a:	4618      	mov	r0, r3
 800b04c:	4928      	ldr	r1, [pc, #160]	; (800b0f0 <test_009_001_execute+0x440>)
 800b04e:	f7fc facf 	bl	80075f0 <_test_assert>
 800b052:	4603      	mov	r3, r0
 800b054:	2b00      	cmp	r3, #0
 800b056:	d002      	beq.n	800b05e <test_009_001_execute+0x3ae>
 800b058:	f7ff fe0a 	bl	800ac70 <osalSysUnlock>
 800b05c:	e03a      	b.n	800b0d4 <test_009_001_execute+0x424>
 800b05e:	f7ff fe07 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800b062:	f7ff fdfd 	bl	800ac60 <osalSysLock>
 800b066:	481d      	ldr	r0, [pc, #116]	; (800b0dc <test_009_001_execute+0x42c>)
 800b068:	f7ff fdda 	bl	800ac20 <chMBGetUsedCountI>
 800b06c:	4603      	mov	r3, r0
 800b06e:	2b00      	cmp	r3, #0
 800b070:	bf0c      	ite	eq
 800b072:	2301      	moveq	r3, #1
 800b074:	2300      	movne	r3, #0
 800b076:	b2db      	uxtb	r3, r3
 800b078:	4618      	mov	r0, r3
 800b07a:	491e      	ldr	r1, [pc, #120]	; (800b0f4 <test_009_001_execute+0x444>)
 800b07c:	f7fc fab8 	bl	80075f0 <_test_assert>
 800b080:	4603      	mov	r3, r0
 800b082:	2b00      	cmp	r3, #0
 800b084:	d002      	beq.n	800b08c <test_009_001_execute+0x3dc>
 800b086:	f7ff fdf3 	bl	800ac70 <osalSysUnlock>
 800b08a:	e023      	b.n	800b0d4 <test_009_001_execute+0x424>
 800b08c:	f7ff fdf0 	bl	800ac70 <osalSysUnlock>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800b090:	4b12      	ldr	r3, [pc, #72]	; (800b0dc <test_009_001_execute+0x42c>)
 800b092:	681a      	ldr	r2, [r3, #0]
 800b094:	4b11      	ldr	r3, [pc, #68]	; (800b0dc <test_009_001_execute+0x42c>)
 800b096:	689b      	ldr	r3, [r3, #8]
 800b098:	429a      	cmp	r2, r3
 800b09a:	bf0c      	ite	eq
 800b09c:	2301      	moveq	r3, #1
 800b09e:	2300      	movne	r3, #0
 800b0a0:	b2db      	uxtb	r3, r3
 800b0a2:	4618      	mov	r0, r3
 800b0a4:	4914      	ldr	r1, [pc, #80]	; (800b0f8 <test_009_001_execute+0x448>)
 800b0a6:	f7fc faa3 	bl	80075f0 <_test_assert>
 800b0aa:	4603      	mov	r3, r0
 800b0ac:	2b00      	cmp	r3, #0
 800b0ae:	d000      	beq.n	800b0b2 <test_009_001_execute+0x402>
 800b0b0:	e010      	b.n	800b0d4 <test_009_001_execute+0x424>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800b0b2:	4b0a      	ldr	r3, [pc, #40]	; (800b0dc <test_009_001_execute+0x42c>)
 800b0b4:	681a      	ldr	r2, [r3, #0]
 800b0b6:	4b09      	ldr	r3, [pc, #36]	; (800b0dc <test_009_001_execute+0x42c>)
 800b0b8:	68db      	ldr	r3, [r3, #12]
 800b0ba:	429a      	cmp	r2, r3
 800b0bc:	bf0c      	ite	eq
 800b0be:	2301      	moveq	r3, #1
 800b0c0:	2300      	movne	r3, #0
 800b0c2:	b2db      	uxtb	r3, r3
 800b0c4:	4618      	mov	r0, r3
 800b0c6:	490d      	ldr	r1, [pc, #52]	; (800b0fc <test_009_001_execute+0x44c>)
 800b0c8:	f7fc fa92 	bl	80075f0 <_test_assert>
 800b0cc:	4603      	mov	r3, r0
 800b0ce:	2b00      	cmp	r3, #0
 800b0d0:	d000      	beq.n	800b0d4 <test_009_001_execute+0x424>
 800b0d2:	bf00      	nop
  }
}
 800b0d4:	b005      	add	sp, #20
 800b0d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800b0da:	bf00      	nop
 800b0dc:	2000086c 	.word	0x2000086c
 800b0e0:	0800f2c8 	.word	0x0800f2c8
 800b0e4:	0800f310 	.word	0x0800f310
 800b0e8:	0800f318 	.word	0x0800f318
 800b0ec:	20000cac 	.word	0x20000cac
 800b0f0:	0800f254 	.word	0x0800f254
 800b0f4:	0800f260 	.word	0x0800f260
 800b0f8:	0800f26c 	.word	0x0800f26c
 800b0fc:	0800f290 	.word	0x0800f290

0800b100 <test_009_002_setup>:
 * - [9.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_009_002_setup(void) {
 800b100:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 800b102:	4803      	ldr	r0, [pc, #12]	; (800b110 <test_009_002_setup+0x10>)
 800b104:	4903      	ldr	r1, [pc, #12]	; (800b114 <test_009_002_setup+0x14>)
 800b106:	2204      	movs	r2, #4
 800b108:	f7f8 f822 	bl	8003150 <chMBObjectInit>
}
 800b10c:	bd08      	pop	{r3, pc}
 800b10e:	bf00      	nop
 800b110:	2000086c 	.word	0x2000086c
 800b114:	2000098c 	.word	0x2000098c
 800b118:	f3af 8000 	nop.w
 800b11c:	f3af 8000 	nop.w

0800b120 <test_009_002_teardown>:

static void test_009_002_teardown(void) {
 800b120:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 800b122:	4802      	ldr	r0, [pc, #8]	; (800b12c <test_009_002_teardown+0xc>)
 800b124:	f7f8 f83c 	bl	80031a0 <chMBReset>
}
 800b128:	bd08      	pop	{r3, pc}
 800b12a:	bf00      	nop
 800b12c:	2000086c 	.word	0x2000086c

0800b130 <test_009_002_execute>:

static void test_009_002_execute(void) {
 800b130:	b500      	push	{lr}
 800b132:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [9.2.1] Testing the mailbox size.*/
  test_set_step(1);
 800b134:	4ba8      	ldr	r3, [pc, #672]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b136:	2201      	movs	r2, #1
 800b138:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800b13a:	f7ff fd91 	bl	800ac60 <osalSysLock>
 800b13e:	48a7      	ldr	r0, [pc, #668]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b140:	f7ff fd76 	bl	800ac30 <chMBGetFreeCountI>
 800b144:	4603      	mov	r3, r0
 800b146:	2b04      	cmp	r3, #4
 800b148:	bf0c      	ite	eq
 800b14a:	2301      	moveq	r3, #1
 800b14c:	2300      	movne	r3, #0
 800b14e:	b2db      	uxtb	r3, r3
 800b150:	4618      	mov	r0, r3
 800b152:	49a3      	ldr	r1, [pc, #652]	; (800b3e0 <test_009_002_execute+0x2b0>)
 800b154:	f7fc fa4c 	bl	80075f0 <_test_assert>
 800b158:	4603      	mov	r3, r0
 800b15a:	2b00      	cmp	r3, #0
 800b15c:	d002      	beq.n	800b164 <test_009_002_execute+0x34>
 800b15e:	f7ff fd87 	bl	800ac70 <osalSysUnlock>
 800b162:	e1bc      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b164:	f7ff fd84 	bl	800ac70 <osalSysUnlock>
  }

  /* [9.2.2] Resetting the mailbox, conditions are checked, no errors
     expected. The mailbox is then returned in active state.*/
  test_set_step(2);
 800b168:	4b9b      	ldr	r3, [pc, #620]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b16a:	2202      	movs	r2, #2
 800b16c:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800b16e:	f7ff fd37 	bl	800abe0 <chSysLock>
    chMBResetI(&mb1);
 800b172:	489a      	ldr	r0, [pc, #616]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b174:	f7f8 f824 	bl	80031c0 <chMBResetI>
    chSysUnlock();
 800b178:	f7ff fd3a 	bl	800abf0 <chSysUnlock>
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800b17c:	f7ff fd70 	bl	800ac60 <osalSysLock>
 800b180:	4896      	ldr	r0, [pc, #600]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b182:	f7ff fd55 	bl	800ac30 <chMBGetFreeCountI>
 800b186:	4603      	mov	r3, r0
 800b188:	2b04      	cmp	r3, #4
 800b18a:	bf0c      	ite	eq
 800b18c:	2301      	moveq	r3, #1
 800b18e:	2300      	movne	r3, #0
 800b190:	b2db      	uxtb	r3, r3
 800b192:	4618      	mov	r0, r3
 800b194:	4993      	ldr	r1, [pc, #588]	; (800b3e4 <test_009_002_execute+0x2b4>)
 800b196:	f7fc fa2b 	bl	80075f0 <_test_assert>
 800b19a:	4603      	mov	r3, r0
 800b19c:	2b00      	cmp	r3, #0
 800b19e:	d002      	beq.n	800b1a6 <test_009_002_execute+0x76>
 800b1a0:	f7ff fd66 	bl	800ac70 <osalSysUnlock>
 800b1a4:	e19b      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b1a6:	f7ff fd63 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800b1aa:	f7ff fd59 	bl	800ac60 <osalSysLock>
 800b1ae:	488b      	ldr	r0, [pc, #556]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b1b0:	f7ff fd36 	bl	800ac20 <chMBGetUsedCountI>
 800b1b4:	4603      	mov	r3, r0
 800b1b6:	2b00      	cmp	r3, #0
 800b1b8:	bf0c      	ite	eq
 800b1ba:	2301      	moveq	r3, #1
 800b1bc:	2300      	movne	r3, #0
 800b1be:	b2db      	uxtb	r3, r3
 800b1c0:	4618      	mov	r0, r3
 800b1c2:	4989      	ldr	r1, [pc, #548]	; (800b3e8 <test_009_002_execute+0x2b8>)
 800b1c4:	f7fc fa14 	bl	80075f0 <_test_assert>
 800b1c8:	4603      	mov	r3, r0
 800b1ca:	2b00      	cmp	r3, #0
 800b1cc:	d002      	beq.n	800b1d4 <test_009_002_execute+0xa4>
 800b1ce:	f7ff fd4f 	bl	800ac70 <osalSysUnlock>
 800b1d2:	e184      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b1d4:	f7ff fd4c 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800b1d8:	f7ff fd42 	bl	800ac60 <osalSysLock>
 800b1dc:	4b7f      	ldr	r3, [pc, #508]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b1de:	681a      	ldr	r2, [r3, #0]
 800b1e0:	4b7e      	ldr	r3, [pc, #504]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b1e2:	689b      	ldr	r3, [r3, #8]
 800b1e4:	429a      	cmp	r2, r3
 800b1e6:	bf0c      	ite	eq
 800b1e8:	2301      	moveq	r3, #1
 800b1ea:	2300      	movne	r3, #0
 800b1ec:	b2db      	uxtb	r3, r3
 800b1ee:	4618      	mov	r0, r3
 800b1f0:	497e      	ldr	r1, [pc, #504]	; (800b3ec <test_009_002_execute+0x2bc>)
 800b1f2:	f7fc f9fd 	bl	80075f0 <_test_assert>
 800b1f6:	4603      	mov	r3, r0
 800b1f8:	2b00      	cmp	r3, #0
 800b1fa:	d002      	beq.n	800b202 <test_009_002_execute+0xd2>
 800b1fc:	f7ff fd38 	bl	800ac70 <osalSysUnlock>
 800b200:	e16d      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b202:	f7ff fd35 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800b206:	f7ff fd2b 	bl	800ac60 <osalSysLock>
 800b20a:	4b74      	ldr	r3, [pc, #464]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b20c:	681a      	ldr	r2, [r3, #0]
 800b20e:	4b73      	ldr	r3, [pc, #460]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b210:	68db      	ldr	r3, [r3, #12]
 800b212:	429a      	cmp	r2, r3
 800b214:	bf0c      	ite	eq
 800b216:	2301      	moveq	r3, #1
 800b218:	2300      	movne	r3, #0
 800b21a:	b2db      	uxtb	r3, r3
 800b21c:	4618      	mov	r0, r3
 800b21e:	4974      	ldr	r1, [pc, #464]	; (800b3f0 <test_009_002_execute+0x2c0>)
 800b220:	f7fc f9e6 	bl	80075f0 <_test_assert>
 800b224:	4603      	mov	r3, r0
 800b226:	2b00      	cmp	r3, #0
 800b228:	d002      	beq.n	800b230 <test_009_002_execute+0x100>
 800b22a:	f7ff fd21 	bl	800ac70 <osalSysUnlock>
 800b22e:	e156      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b230:	f7ff fd1e 	bl	800ac70 <osalSysUnlock>
    chMBResumeX(&mb1);
 800b234:	4869      	ldr	r0, [pc, #420]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b236:	f7ff fd0b 	bl	800ac50 <chMBResumeX>
  }

  /* [9.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 800b23a:	4b67      	ldr	r3, [pc, #412]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b23c:	2203      	movs	r2, #3
 800b23e:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 800b240:	2300      	movs	r3, #0
 800b242:	9303      	str	r3, [sp, #12]
 800b244:	e01b      	b.n	800b27e <test_009_002_execute+0x14e>
      chSysLock();
 800b246:	f7ff fccb 	bl	800abe0 <chSysLock>
      msg1 = chMBPostI(&mb1, 'B' + i);
 800b24a:	9b03      	ldr	r3, [sp, #12]
 800b24c:	3342      	adds	r3, #66	; 0x42
 800b24e:	4863      	ldr	r0, [pc, #396]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b250:	4619      	mov	r1, r3
 800b252:	f7f8 f83d 	bl	80032d0 <chMBPostI>
 800b256:	9002      	str	r0, [sp, #8]
      chSysUnlock();
 800b258:	f7ff fcca 	bl	800abf0 <chSysUnlock>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b25c:	9b02      	ldr	r3, [sp, #8]
 800b25e:	2b00      	cmp	r3, #0
 800b260:	bf0c      	ite	eq
 800b262:	2301      	moveq	r3, #1
 800b264:	2300      	movne	r3, #0
 800b266:	b2db      	uxtb	r3, r3
 800b268:	4618      	mov	r0, r3
 800b26a:	4962      	ldr	r1, [pc, #392]	; (800b3f4 <test_009_002_execute+0x2c4>)
 800b26c:	f7fc f9c0 	bl	80075f0 <_test_assert>
 800b270:	4603      	mov	r3, r0
 800b272:	2b00      	cmp	r3, #0
 800b274:	d000      	beq.n	800b278 <test_009_002_execute+0x148>
 800b276:	e132      	b.n	800b4de <test_009_002_execute+0x3ae>

  /* [9.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 800b278:	9b03      	ldr	r3, [sp, #12]
 800b27a:	3301      	adds	r3, #1
 800b27c:	9303      	str	r3, [sp, #12]
 800b27e:	9b03      	ldr	r3, [sp, #12]
 800b280:	2b02      	cmp	r3, #2
 800b282:	d9e0      	bls.n	800b246 <test_009_002_execute+0x116>
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    chSysLock();
 800b284:	f7ff fcac 	bl	800abe0 <chSysLock>
    msg1 = chMBPostAheadI(&mb1, 'A');
 800b288:	4854      	ldr	r0, [pc, #336]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b28a:	2141      	movs	r1, #65	; 0x41
 800b28c:	f7f8 f8b8 	bl	8003400 <chMBPostAheadI>
 800b290:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800b292:	f7ff fcad 	bl	800abf0 <chSysUnlock>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b296:	9b02      	ldr	r3, [sp, #8]
 800b298:	2b00      	cmp	r3, #0
 800b29a:	bf0c      	ite	eq
 800b29c:	2301      	moveq	r3, #1
 800b29e:	2300      	movne	r3, #0
 800b2a0:	b2db      	uxtb	r3, r3
 800b2a2:	4618      	mov	r0, r3
 800b2a4:	4953      	ldr	r1, [pc, #332]	; (800b3f4 <test_009_002_execute+0x2c4>)
 800b2a6:	f7fc f9a3 	bl	80075f0 <_test_assert>
 800b2aa:	4603      	mov	r3, r0
 800b2ac:	2b00      	cmp	r3, #0
 800b2ae:	d000      	beq.n	800b2b2 <test_009_002_execute+0x182>
 800b2b0:	e115      	b.n	800b4de <test_009_002_execute+0x3ae>
  }

  /* [9.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 800b2b2:	4b49      	ldr	r3, [pc, #292]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b2b4:	2204      	movs	r2, #4
 800b2b6:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 800b2b8:	f7ff fcd2 	bl	800ac60 <osalSysLock>
 800b2bc:	4847      	ldr	r0, [pc, #284]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b2be:	f7ff fcb7 	bl	800ac30 <chMBGetFreeCountI>
 800b2c2:	4603      	mov	r3, r0
 800b2c4:	2b00      	cmp	r3, #0
 800b2c6:	bf0c      	ite	eq
 800b2c8:	2301      	moveq	r3, #1
 800b2ca:	2300      	movne	r3, #0
 800b2cc:	b2db      	uxtb	r3, r3
 800b2ce:	4618      	mov	r0, r3
 800b2d0:	4949      	ldr	r1, [pc, #292]	; (800b3f8 <test_009_002_execute+0x2c8>)
 800b2d2:	f7fc f98d 	bl	80075f0 <_test_assert>
 800b2d6:	4603      	mov	r3, r0
 800b2d8:	2b00      	cmp	r3, #0
 800b2da:	d002      	beq.n	800b2e2 <test_009_002_execute+0x1b2>
 800b2dc:	f7ff fcc8 	bl	800ac70 <osalSysUnlock>
 800b2e0:	e0fd      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b2e2:	f7ff fcc5 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800b2e6:	f7ff fcbb 	bl	800ac60 <osalSysLock>
 800b2ea:	483c      	ldr	r0, [pc, #240]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b2ec:	f7ff fc98 	bl	800ac20 <chMBGetUsedCountI>
 800b2f0:	4603      	mov	r3, r0
 800b2f2:	2b04      	cmp	r3, #4
 800b2f4:	bf0c      	ite	eq
 800b2f6:	2301      	moveq	r3, #1
 800b2f8:	2300      	movne	r3, #0
 800b2fa:	b2db      	uxtb	r3, r3
 800b2fc:	4618      	mov	r0, r3
 800b2fe:	493f      	ldr	r1, [pc, #252]	; (800b3fc <test_009_002_execute+0x2cc>)
 800b300:	f7fc f976 	bl	80075f0 <_test_assert>
 800b304:	4603      	mov	r3, r0
 800b306:	2b00      	cmp	r3, #0
 800b308:	d002      	beq.n	800b310 <test_009_002_execute+0x1e0>
 800b30a:	f7ff fcb1 	bl	800ac70 <osalSysUnlock>
 800b30e:	e0e6      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b310:	f7ff fcae 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 800b314:	f7ff fca4 	bl	800ac60 <osalSysLock>
 800b318:	4b30      	ldr	r3, [pc, #192]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b31a:	68da      	ldr	r2, [r3, #12]
 800b31c:	4b2f      	ldr	r3, [pc, #188]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b31e:	689b      	ldr	r3, [r3, #8]
 800b320:	429a      	cmp	r2, r3
 800b322:	bf0c      	ite	eq
 800b324:	2301      	moveq	r3, #1
 800b326:	2300      	movne	r3, #0
 800b328:	b2db      	uxtb	r3, r3
 800b32a:	4618      	mov	r0, r3
 800b32c:	4934      	ldr	r1, [pc, #208]	; (800b400 <test_009_002_execute+0x2d0>)
 800b32e:	f7fc f95f 	bl	80075f0 <_test_assert>
 800b332:	4603      	mov	r3, r0
 800b334:	2b00      	cmp	r3, #0
 800b336:	d002      	beq.n	800b33e <test_009_002_execute+0x20e>
 800b338:	f7ff fc9a 	bl	800ac70 <osalSysUnlock>
 800b33c:	e0cf      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b33e:	f7ff fc97 	bl	800ac70 <osalSysUnlock>
  }

  /* [9.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 800b342:	4b25      	ldr	r3, [pc, #148]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b344:	2205      	movs	r2, #5
 800b346:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 800b348:	2300      	movs	r3, #0
 800b34a:	9303      	str	r3, [sp, #12]
 800b34c:	e01f      	b.n	800b38e <test_009_002_execute+0x25e>
      chSysLock();
 800b34e:	f7ff fc47 	bl	800abe0 <chSysLock>
      msg1 = chMBFetchI(&mb1, &msg2);
 800b352:	ab01      	add	r3, sp, #4
 800b354:	4821      	ldr	r0, [pc, #132]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b356:	4619      	mov	r1, r3
 800b358:	f7f8 f8ea 	bl	8003530 <chMBFetchI>
 800b35c:	9002      	str	r0, [sp, #8]
      chSysUnlock();
 800b35e:	f7ff fc47 	bl	800abf0 <chSysUnlock>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b362:	9b02      	ldr	r3, [sp, #8]
 800b364:	2b00      	cmp	r3, #0
 800b366:	bf0c      	ite	eq
 800b368:	2301      	moveq	r3, #1
 800b36a:	2300      	movne	r3, #0
 800b36c:	b2db      	uxtb	r3, r3
 800b36e:	4618      	mov	r0, r3
 800b370:	4920      	ldr	r1, [pc, #128]	; (800b3f4 <test_009_002_execute+0x2c4>)
 800b372:	f7fc f93d 	bl	80075f0 <_test_assert>
 800b376:	4603      	mov	r3, r0
 800b378:	2b00      	cmp	r3, #0
 800b37a:	d000      	beq.n	800b37e <test_009_002_execute+0x24e>
 800b37c:	e0af      	b.n	800b4de <test_009_002_execute+0x3ae>
      test_emit_token(msg2);
 800b37e:	9b01      	ldr	r3, [sp, #4]
 800b380:	b2db      	uxtb	r3, r3
 800b382:	4618      	mov	r0, r3
 800b384:	f7fc fa14 	bl	80077b0 <test_emit_token>

  /* [9.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 800b388:	9b03      	ldr	r3, [sp, #12]
 800b38a:	3301      	adds	r3, #1
 800b38c:	9303      	str	r3, [sp, #12]
 800b38e:	9b03      	ldr	r3, [sp, #12]
 800b390:	2b03      	cmp	r3, #3
 800b392:	d9dc      	bls.n	800b34e <test_009_002_execute+0x21e>
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 800b394:	481b      	ldr	r0, [pc, #108]	; (800b404 <test_009_002_execute+0x2d4>)
 800b396:	491c      	ldr	r1, [pc, #112]	; (800b408 <test_009_002_execute+0x2d8>)
 800b398:	f7fc f942 	bl	8007620 <_test_assert_sequence>
 800b39c:	4603      	mov	r3, r0
 800b39e:	2b00      	cmp	r3, #0
 800b3a0:	d000      	beq.n	800b3a4 <test_009_002_execute+0x274>
 800b3a2:	e09c      	b.n	800b4de <test_009_002_execute+0x3ae>
  }

  /* [9.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800b3a4:	4b0c      	ldr	r3, [pc, #48]	; (800b3d8 <test_009_002_execute+0x2a8>)
 800b3a6:	2206      	movs	r2, #6
 800b3a8:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800b3aa:	9b03      	ldr	r3, [sp, #12]
 800b3ac:	3342      	adds	r3, #66	; 0x42
 800b3ae:	480b      	ldr	r0, [pc, #44]	; (800b3dc <test_009_002_execute+0x2ac>)
 800b3b0:	4619      	mov	r1, r3
 800b3b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b3b6:	f7f7 ff2b 	bl	8003210 <chMBPost>
 800b3ba:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b3bc:	9b02      	ldr	r3, [sp, #8]
 800b3be:	2b00      	cmp	r3, #0
 800b3c0:	bf0c      	ite	eq
 800b3c2:	2301      	moveq	r3, #1
 800b3c4:	2300      	movne	r3, #0
 800b3c6:	b2db      	uxtb	r3, r3
 800b3c8:	4618      	mov	r0, r3
 800b3ca:	490a      	ldr	r1, [pc, #40]	; (800b3f4 <test_009_002_execute+0x2c4>)
 800b3cc:	f7fc f910 	bl	80075f0 <_test_assert>
 800b3d0:	4603      	mov	r3, r0
 800b3d2:	2b00      	cmp	r3, #0
 800b3d4:	d01a      	beq.n	800b40c <test_009_002_execute+0x2dc>
 800b3d6:	e082      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b3d8:	20000cac 	.word	0x20000cac
 800b3dc:	2000086c 	.word	0x2000086c
 800b3e0:	0800f248 	.word	0x0800f248
 800b3e4:	0800f254 	.word	0x0800f254
 800b3e8:	0800f260 	.word	0x0800f260
 800b3ec:	0800f26c 	.word	0x0800f26c
 800b3f0:	0800f290 	.word	0x0800f290
 800b3f4:	0800f2c8 	.word	0x0800f2c8
 800b3f8:	0800f2e0 	.word	0x0800f2e0
 800b3fc:	0800f2ec 	.word	0x0800f2ec
 800b400:	0800f2f8 	.word	0x0800f2f8
 800b404:	0800f310 	.word	0x0800f310
 800b408:	0800f318 	.word	0x0800f318
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800b40c:	ab01      	add	r3, sp, #4
 800b40e:	4835      	ldr	r0, [pc, #212]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b410:	4619      	mov	r1, r3
 800b412:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b416:	f7f8 f82b 	bl	8003470 <chMBFetch>
 800b41a:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b41c:	9b02      	ldr	r3, [sp, #8]
 800b41e:	2b00      	cmp	r3, #0
 800b420:	bf0c      	ite	eq
 800b422:	2301      	moveq	r3, #1
 800b424:	2300      	movne	r3, #0
 800b426:	b2db      	uxtb	r3, r3
 800b428:	4618      	mov	r0, r3
 800b42a:	492f      	ldr	r1, [pc, #188]	; (800b4e8 <test_009_002_execute+0x3b8>)
 800b42c:	f7fc f8e0 	bl	80075f0 <_test_assert>
 800b430:	4603      	mov	r3, r0
 800b432:	2b00      	cmp	r3, #0
 800b434:	d000      	beq.n	800b438 <test_009_002_execute+0x308>
 800b436:	e052      	b.n	800b4de <test_009_002_execute+0x3ae>
  }

  /* [9.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 800b438:	4b2c      	ldr	r3, [pc, #176]	; (800b4ec <test_009_002_execute+0x3bc>)
 800b43a:	2207      	movs	r2, #7
 800b43c:	601a      	str	r2, [r3, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800b43e:	f7ff fc0f 	bl	800ac60 <osalSysLock>
 800b442:	4828      	ldr	r0, [pc, #160]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b444:	f7ff fbf4 	bl	800ac30 <chMBGetFreeCountI>
 800b448:	4603      	mov	r3, r0
 800b44a:	2b04      	cmp	r3, #4
 800b44c:	bf0c      	ite	eq
 800b44e:	2301      	moveq	r3, #1
 800b450:	2300      	movne	r3, #0
 800b452:	b2db      	uxtb	r3, r3
 800b454:	4618      	mov	r0, r3
 800b456:	4926      	ldr	r1, [pc, #152]	; (800b4f0 <test_009_002_execute+0x3c0>)
 800b458:	f7fc f8ca 	bl	80075f0 <_test_assert>
 800b45c:	4603      	mov	r3, r0
 800b45e:	2b00      	cmp	r3, #0
 800b460:	d002      	beq.n	800b468 <test_009_002_execute+0x338>
 800b462:	f7ff fc05 	bl	800ac70 <osalSysUnlock>
 800b466:	e03a      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b468:	f7ff fc02 	bl	800ac70 <osalSysUnlock>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800b46c:	f7ff fbf8 	bl	800ac60 <osalSysLock>
 800b470:	481c      	ldr	r0, [pc, #112]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b472:	f7ff fbd5 	bl	800ac20 <chMBGetUsedCountI>
 800b476:	4603      	mov	r3, r0
 800b478:	2b00      	cmp	r3, #0
 800b47a:	bf0c      	ite	eq
 800b47c:	2301      	moveq	r3, #1
 800b47e:	2300      	movne	r3, #0
 800b480:	b2db      	uxtb	r3, r3
 800b482:	4618      	mov	r0, r3
 800b484:	491b      	ldr	r1, [pc, #108]	; (800b4f4 <test_009_002_execute+0x3c4>)
 800b486:	f7fc f8b3 	bl	80075f0 <_test_assert>
 800b48a:	4603      	mov	r3, r0
 800b48c:	2b00      	cmp	r3, #0
 800b48e:	d002      	beq.n	800b496 <test_009_002_execute+0x366>
 800b490:	f7ff fbee 	bl	800ac70 <osalSysUnlock>
 800b494:	e023      	b.n	800b4de <test_009_002_execute+0x3ae>
 800b496:	f7ff fbeb 	bl	800ac70 <osalSysUnlock>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800b49a:	4b12      	ldr	r3, [pc, #72]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b49c:	681a      	ldr	r2, [r3, #0]
 800b49e:	4b11      	ldr	r3, [pc, #68]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b4a0:	689b      	ldr	r3, [r3, #8]
 800b4a2:	429a      	cmp	r2, r3
 800b4a4:	bf0c      	ite	eq
 800b4a6:	2301      	moveq	r3, #1
 800b4a8:	2300      	movne	r3, #0
 800b4aa:	b2db      	uxtb	r3, r3
 800b4ac:	4618      	mov	r0, r3
 800b4ae:	4912      	ldr	r1, [pc, #72]	; (800b4f8 <test_009_002_execute+0x3c8>)
 800b4b0:	f7fc f89e 	bl	80075f0 <_test_assert>
 800b4b4:	4603      	mov	r3, r0
 800b4b6:	2b00      	cmp	r3, #0
 800b4b8:	d000      	beq.n	800b4bc <test_009_002_execute+0x38c>
 800b4ba:	e010      	b.n	800b4de <test_009_002_execute+0x3ae>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800b4bc:	4b09      	ldr	r3, [pc, #36]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b4be:	681a      	ldr	r2, [r3, #0]
 800b4c0:	4b08      	ldr	r3, [pc, #32]	; (800b4e4 <test_009_002_execute+0x3b4>)
 800b4c2:	68db      	ldr	r3, [r3, #12]
 800b4c4:	429a      	cmp	r2, r3
 800b4c6:	bf0c      	ite	eq
 800b4c8:	2301      	moveq	r3, #1
 800b4ca:	2300      	movne	r3, #0
 800b4cc:	b2db      	uxtb	r3, r3
 800b4ce:	4618      	mov	r0, r3
 800b4d0:	490a      	ldr	r1, [pc, #40]	; (800b4fc <test_009_002_execute+0x3cc>)
 800b4d2:	f7fc f88d 	bl	80075f0 <_test_assert>
 800b4d6:	4603      	mov	r3, r0
 800b4d8:	2b00      	cmp	r3, #0
 800b4da:	d000      	beq.n	800b4de <test_009_002_execute+0x3ae>
 800b4dc:	bf00      	nop
  }
}
 800b4de:	b005      	add	sp, #20
 800b4e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800b4e4:	2000086c 	.word	0x2000086c
 800b4e8:	0800f2c8 	.word	0x0800f2c8
 800b4ec:	20000cac 	.word	0x20000cac
 800b4f0:	0800f254 	.word	0x0800f254
 800b4f4:	0800f260 	.word	0x0800f260
 800b4f8:	0800f26c 	.word	0x0800f26c
 800b4fc:	0800f290 	.word	0x0800f290

0800b500 <test_009_003_setup>:
 *   active state.
 * - [9.3.4] Testing chMBFetch() and chMBFetchI() timeout.
 * .
 */

static void test_009_003_setup(void) {
 800b500:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 800b502:	4803      	ldr	r0, [pc, #12]	; (800b510 <test_009_003_setup+0x10>)
 800b504:	4903      	ldr	r1, [pc, #12]	; (800b514 <test_009_003_setup+0x14>)
 800b506:	2204      	movs	r2, #4
 800b508:	f7f7 fe22 	bl	8003150 <chMBObjectInit>
}
 800b50c:	bd08      	pop	{r3, pc}
 800b50e:	bf00      	nop
 800b510:	2000086c 	.word	0x2000086c
 800b514:	2000098c 	.word	0x2000098c
 800b518:	f3af 8000 	nop.w
 800b51c:	f3af 8000 	nop.w

0800b520 <test_009_003_teardown>:

static void test_009_003_teardown(void) {
 800b520:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 800b522:	4802      	ldr	r0, [pc, #8]	; (800b52c <test_009_003_teardown+0xc>)
 800b524:	f7f7 fe3c 	bl	80031a0 <chMBReset>
}
 800b528:	bd08      	pop	{r3, pc}
 800b52a:	bf00      	nop
 800b52c:	2000086c 	.word	0x2000086c

0800b530 <test_009_003_execute>:

static void test_009_003_execute(void) {
 800b530:	b500      	push	{lr}
 800b532:	b085      	sub	sp, #20
  msg_t msg1, msg2;
  unsigned i;

  /* [9.3.1] Filling the mailbox.*/
  test_set_step(1);
 800b534:	4b5e      	ldr	r3, [pc, #376]	; (800b6b0 <test_009_003_execute+0x180>)
 800b536:	2201      	movs	r2, #1
 800b538:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 800b53a:	2300      	movs	r3, #0
 800b53c:	9303      	str	r3, [sp, #12]
 800b53e:	e019      	b.n	800b574 <test_009_003_execute+0x44>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800b540:	9b03      	ldr	r3, [sp, #12]
 800b542:	3342      	adds	r3, #66	; 0x42
 800b544:	485b      	ldr	r0, [pc, #364]	; (800b6b4 <test_009_003_execute+0x184>)
 800b546:	4619      	mov	r1, r3
 800b548:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b54c:	f7f7 fe60 	bl	8003210 <chMBPost>
 800b550:	9002      	str	r0, [sp, #8]
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800b552:	9b02      	ldr	r3, [sp, #8]
 800b554:	2b00      	cmp	r3, #0
 800b556:	bf0c      	ite	eq
 800b558:	2301      	moveq	r3, #1
 800b55a:	2300      	movne	r3, #0
 800b55c:	b2db      	uxtb	r3, r3
 800b55e:	4618      	mov	r0, r3
 800b560:	4955      	ldr	r1, [pc, #340]	; (800b6b8 <test_009_003_execute+0x188>)
 800b562:	f7fc f845 	bl	80075f0 <_test_assert>
 800b566:	4603      	mov	r3, r0
 800b568:	2b00      	cmp	r3, #0
 800b56a:	d000      	beq.n	800b56e <test_009_003_execute+0x3e>
 800b56c:	e09d      	b.n	800b6aa <test_009_003_execute+0x17a>
  unsigned i;

  /* [9.3.1] Filling the mailbox.*/
  test_set_step(1);
  {
    for (i = 0; i < MB_SIZE; i++) {
 800b56e:	9b03      	ldr	r3, [sp, #12]
 800b570:	3301      	adds	r3, #1
 800b572:	9303      	str	r3, [sp, #12]
 800b574:	9b03      	ldr	r3, [sp, #12]
 800b576:	2b03      	cmp	r3, #3
 800b578:	d9e2      	bls.n	800b540 <test_009_003_execute+0x10>
    }
  }

  /* [9.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 800b57a:	4b4d      	ldr	r3, [pc, #308]	; (800b6b0 <test_009_003_execute+0x180>)
 800b57c:	2202      	movs	r2, #2
 800b57e:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 800b580:	484c      	ldr	r0, [pc, #304]	; (800b6b4 <test_009_003_execute+0x184>)
 800b582:	2158      	movs	r1, #88	; 0x58
 800b584:	2201      	movs	r2, #1
 800b586:	f7f7 fe43 	bl	8003210 <chMBPost>
 800b58a:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b58c:	9b02      	ldr	r3, [sp, #8]
 800b58e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b592:	bf0c      	ite	eq
 800b594:	2301      	moveq	r3, #1
 800b596:	2300      	movne	r3, #0
 800b598:	b2db      	uxtb	r3, r3
 800b59a:	4618      	mov	r0, r3
 800b59c:	4946      	ldr	r1, [pc, #280]	; (800b6b8 <test_009_003_execute+0x188>)
 800b59e:	f7fc f827 	bl	80075f0 <_test_assert>
 800b5a2:	4603      	mov	r3, r0
 800b5a4:	2b00      	cmp	r3, #0
 800b5a6:	d000      	beq.n	800b5aa <test_009_003_execute+0x7a>
 800b5a8:	e07f      	b.n	800b6aa <test_009_003_execute+0x17a>
    chSysLock();
 800b5aa:	f7ff fb19 	bl	800abe0 <chSysLock>
    msg1 = chMBPostI(&mb1, 'X');
 800b5ae:	4841      	ldr	r0, [pc, #260]	; (800b6b4 <test_009_003_execute+0x184>)
 800b5b0:	2158      	movs	r1, #88	; 0x58
 800b5b2:	f7f7 fe8d 	bl	80032d0 <chMBPostI>
 800b5b6:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800b5b8:	f7ff fb1a 	bl	800abf0 <chSysUnlock>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b5bc:	9b02      	ldr	r3, [sp, #8]
 800b5be:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b5c2:	bf0c      	ite	eq
 800b5c4:	2301      	moveq	r3, #1
 800b5c6:	2300      	movne	r3, #0
 800b5c8:	b2db      	uxtb	r3, r3
 800b5ca:	4618      	mov	r0, r3
 800b5cc:	493a      	ldr	r1, [pc, #232]	; (800b6b8 <test_009_003_execute+0x188>)
 800b5ce:	f7fc f80f 	bl	80075f0 <_test_assert>
 800b5d2:	4603      	mov	r3, r0
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d000      	beq.n	800b5da <test_009_003_execute+0xaa>
 800b5d8:	e067      	b.n	800b6aa <test_009_003_execute+0x17a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 800b5da:	4836      	ldr	r0, [pc, #216]	; (800b6b4 <test_009_003_execute+0x184>)
 800b5dc:	2158      	movs	r1, #88	; 0x58
 800b5de:	2201      	movs	r2, #1
 800b5e0:	f7f7 feae 	bl	8003340 <chMBPostAhead>
 800b5e4:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b5e6:	9b02      	ldr	r3, [sp, #8]
 800b5e8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b5ec:	bf0c      	ite	eq
 800b5ee:	2301      	moveq	r3, #1
 800b5f0:	2300      	movne	r3, #0
 800b5f2:	b2db      	uxtb	r3, r3
 800b5f4:	4618      	mov	r0, r3
 800b5f6:	4930      	ldr	r1, [pc, #192]	; (800b6b8 <test_009_003_execute+0x188>)
 800b5f8:	f7fb fffa 	bl	80075f0 <_test_assert>
 800b5fc:	4603      	mov	r3, r0
 800b5fe:	2b00      	cmp	r3, #0
 800b600:	d000      	beq.n	800b604 <test_009_003_execute+0xd4>
 800b602:	e052      	b.n	800b6aa <test_009_003_execute+0x17a>
    chSysLock();
 800b604:	f7ff faec 	bl	800abe0 <chSysLock>
    msg1 = chMBPostAheadI(&mb1, 'X');
 800b608:	482a      	ldr	r0, [pc, #168]	; (800b6b4 <test_009_003_execute+0x184>)
 800b60a:	2158      	movs	r1, #88	; 0x58
 800b60c:	f7f7 fef8 	bl	8003400 <chMBPostAheadI>
 800b610:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800b612:	f7ff faed 	bl	800abf0 <chSysUnlock>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b616:	9b02      	ldr	r3, [sp, #8]
 800b618:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b61c:	bf0c      	ite	eq
 800b61e:	2301      	moveq	r3, #1
 800b620:	2300      	movne	r3, #0
 800b622:	b2db      	uxtb	r3, r3
 800b624:	4618      	mov	r0, r3
 800b626:	4924      	ldr	r1, [pc, #144]	; (800b6b8 <test_009_003_execute+0x188>)
 800b628:	f7fb ffe2 	bl	80075f0 <_test_assert>
 800b62c:	4603      	mov	r3, r0
 800b62e:	2b00      	cmp	r3, #0
 800b630:	d000      	beq.n	800b634 <test_009_003_execute+0x104>
 800b632:	e03a      	b.n	800b6aa <test_009_003_execute+0x17a>
  }

  /* [9.3.3] Resetting the mailbox. The mailbox is then returned in
     active state.*/
  test_set_step(3);
 800b634:	4b1e      	ldr	r3, [pc, #120]	; (800b6b0 <test_009_003_execute+0x180>)
 800b636:	2203      	movs	r2, #3
 800b638:	601a      	str	r2, [r3, #0]
  {
    chMBReset(&mb1);
 800b63a:	481e      	ldr	r0, [pc, #120]	; (800b6b4 <test_009_003_execute+0x184>)
 800b63c:	f7f7 fdb0 	bl	80031a0 <chMBReset>
    chMBResumeX(&mb1);
 800b640:	481c      	ldr	r0, [pc, #112]	; (800b6b4 <test_009_003_execute+0x184>)
 800b642:	f7ff fb05 	bl	800ac50 <chMBResumeX>
  }

  /* [9.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 800b646:	4b1a      	ldr	r3, [pc, #104]	; (800b6b0 <test_009_003_execute+0x180>)
 800b648:	2204      	movs	r2, #4
 800b64a:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 800b64c:	ab01      	add	r3, sp, #4
 800b64e:	4819      	ldr	r0, [pc, #100]	; (800b6b4 <test_009_003_execute+0x184>)
 800b650:	4619      	mov	r1, r3
 800b652:	2201      	movs	r2, #1
 800b654:	f7f7 ff0c 	bl	8003470 <chMBFetch>
 800b658:	9002      	str	r0, [sp, #8]
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b65a:	9b02      	ldr	r3, [sp, #8]
 800b65c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b660:	bf0c      	ite	eq
 800b662:	2301      	moveq	r3, #1
 800b664:	2300      	movne	r3, #0
 800b666:	b2db      	uxtb	r3, r3
 800b668:	4618      	mov	r0, r3
 800b66a:	4913      	ldr	r1, [pc, #76]	; (800b6b8 <test_009_003_execute+0x188>)
 800b66c:	f7fb ffc0 	bl	80075f0 <_test_assert>
 800b670:	4603      	mov	r3, r0
 800b672:	2b00      	cmp	r3, #0
 800b674:	d000      	beq.n	800b678 <test_009_003_execute+0x148>
 800b676:	e018      	b.n	800b6aa <test_009_003_execute+0x17a>
    chSysLock();
 800b678:	f7ff fab2 	bl	800abe0 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800b67c:	ab01      	add	r3, sp, #4
 800b67e:	480d      	ldr	r0, [pc, #52]	; (800b6b4 <test_009_003_execute+0x184>)
 800b680:	4619      	mov	r1, r3
 800b682:	f7f7 ff55 	bl	8003530 <chMBFetchI>
 800b686:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800b688:	f7ff fab2 	bl	800abf0 <chSysUnlock>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800b68c:	9b02      	ldr	r3, [sp, #8]
 800b68e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800b692:	bf0c      	ite	eq
 800b694:	2301      	moveq	r3, #1
 800b696:	2300      	movne	r3, #0
 800b698:	b2db      	uxtb	r3, r3
 800b69a:	4618      	mov	r0, r3
 800b69c:	4906      	ldr	r1, [pc, #24]	; (800b6b8 <test_009_003_execute+0x188>)
 800b69e:	f7fb ffa7 	bl	80075f0 <_test_assert>
 800b6a2:	4603      	mov	r3, r0
 800b6a4:	2b00      	cmp	r3, #0
 800b6a6:	d000      	beq.n	800b6aa <test_009_003_execute+0x17a>
 800b6a8:	bf00      	nop
  }
}
 800b6aa:	b005      	add	sp, #20
 800b6ac:	f85d fb04 	ldr.w	pc, [sp], #4
 800b6b0:	20000cac 	.word	0x20000cac
 800b6b4:	2000086c 	.word	0x2000086c
 800b6b8:	0800f2c8 	.word	0x0800f2c8
 800b6bc:	00000000 	.word	0x00000000

0800b6c0 <null_provider>:

#if CH_CFG_USE_SEMAPHORES
static GUARDEDMEMORYPOOL_DECL(gmp1, sizeof (uint32_t));
#endif

static void *null_provider(size_t size, unsigned align) {
 800b6c0:	b082      	sub	sp, #8
 800b6c2:	9001      	str	r0, [sp, #4]
 800b6c4:	9100      	str	r1, [sp, #0]

  (void)size;
  (void)align;

  return NULL;
 800b6c6:	2300      	movs	r3, #0
}
 800b6c8:	4618      	mov	r0, r3
 800b6ca:	b002      	add	sp, #8
 800b6cc:	4770      	bx	lr
 800b6ce:	bf00      	nop

0800b6d0 <test_010_001_setup>:
 * - [10.1.7] Covering the case where a provider is unable to return
 *   more memory.
 * .
 */

static void test_010_001_setup(void) {
 800b6d0:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
 800b6d2:	4803      	ldr	r0, [pc, #12]	; (800b6e0 <test_010_001_setup+0x10>)
 800b6d4:	2104      	movs	r1, #4
 800b6d6:	2200      	movs	r2, #0
 800b6d8:	f7f8 fa12 	bl	8003b00 <chPoolObjectInit>
}
 800b6dc:	bd08      	pop	{r3, pc}
 800b6de:	bf00      	nop
 800b6e0:	20000894 	.word	0x20000894
 800b6e4:	f3af 8000 	nop.w
 800b6e8:	f3af 8000 	nop.w
 800b6ec:	f3af 8000 	nop.w

0800b6f0 <test_010_001_execute>:

static void test_010_001_execute(void) {
 800b6f0:	b500      	push	{lr}
 800b6f2:	b083      	sub	sp, #12
  unsigned i;

  /* [10.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 800b6f4:	4b4c      	ldr	r3, [pc, #304]	; (800b828 <test_010_001_execute+0x138>)
 800b6f6:	2201      	movs	r2, #1
 800b6f8:	601a      	str	r2, [r3, #0]
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 800b6fa:	484c      	ldr	r0, [pc, #304]	; (800b82c <test_010_001_execute+0x13c>)
 800b6fc:	494c      	ldr	r1, [pc, #304]	; (800b830 <test_010_001_execute+0x140>)
 800b6fe:	2204      	movs	r2, #4
 800b700:	f7f8 fa0e 	bl	8003b20 <chPoolLoadArray>
  }

  /* [10.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 800b704:	4b48      	ldr	r3, [pc, #288]	; (800b828 <test_010_001_execute+0x138>)
 800b706:	2202      	movs	r2, #2
 800b708:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b70a:	2300      	movs	r3, #0
 800b70c:	9301      	str	r3, [sp, #4]
 800b70e:	e013      	b.n	800b738 <test_010_001_execute+0x48>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800b710:	4846      	ldr	r0, [pc, #280]	; (800b82c <test_010_001_execute+0x13c>)
 800b712:	f7f8 fa3d 	bl	8003b90 <chPoolAlloc>
 800b716:	4603      	mov	r3, r0
 800b718:	2b00      	cmp	r3, #0
 800b71a:	bf14      	ite	ne
 800b71c:	2301      	movne	r3, #1
 800b71e:	2300      	moveq	r3, #0
 800b720:	b2db      	uxtb	r3, r3
 800b722:	4618      	mov	r0, r3
 800b724:	4943      	ldr	r1, [pc, #268]	; (800b834 <test_010_001_execute+0x144>)
 800b726:	f7fb ff63 	bl	80075f0 <_test_assert>
 800b72a:	4603      	mov	r3, r0
 800b72c:	2b00      	cmp	r3, #0
 800b72e:	d000      	beq.n	800b732 <test_010_001_execute+0x42>
 800b730:	e077      	b.n	800b822 <test_010_001_execute+0x132>
  }

  /* [10.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b732:	9b01      	ldr	r3, [sp, #4]
 800b734:	3301      	adds	r3, #1
 800b736:	9301      	str	r3, [sp, #4]
 800b738:	9b01      	ldr	r3, [sp, #4]
 800b73a:	2b03      	cmp	r3, #3
 800b73c:	d9e8      	bls.n	800b710 <test_010_001_execute+0x20>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
 800b73e:	4b3a      	ldr	r3, [pc, #232]	; (800b828 <test_010_001_execute+0x138>)
 800b740:	2203      	movs	r2, #3
 800b742:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800b744:	4839      	ldr	r0, [pc, #228]	; (800b82c <test_010_001_execute+0x13c>)
 800b746:	f7f8 fa23 	bl	8003b90 <chPoolAlloc>
 800b74a:	4603      	mov	r3, r0
 800b74c:	2b00      	cmp	r3, #0
 800b74e:	bf0c      	ite	eq
 800b750:	2301      	moveq	r3, #1
 800b752:	2300      	movne	r3, #0
 800b754:	b2db      	uxtb	r3, r3
 800b756:	4618      	mov	r0, r3
 800b758:	4937      	ldr	r1, [pc, #220]	; (800b838 <test_010_001_execute+0x148>)
 800b75a:	f7fb ff49 	bl	80075f0 <_test_assert>
 800b75e:	4603      	mov	r3, r0
 800b760:	2b00      	cmp	r3, #0
 800b762:	d000      	beq.n	800b766 <test_010_001_execute+0x76>
 800b764:	e05d      	b.n	800b822 <test_010_001_execute+0x132>
  }

  /* [10.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 800b766:	4b30      	ldr	r3, [pc, #192]	; (800b828 <test_010_001_execute+0x138>)
 800b768:	2204      	movs	r2, #4
 800b76a:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b76c:	2300      	movs	r3, #0
 800b76e:	9301      	str	r3, [sp, #4]
 800b770:	e00a      	b.n	800b788 <test_010_001_execute+0x98>
      chPoolFree(&mp1, &objects[i]);
 800b772:	9b01      	ldr	r3, [sp, #4]
 800b774:	009b      	lsls	r3, r3, #2
 800b776:	4a2e      	ldr	r2, [pc, #184]	; (800b830 <test_010_001_execute+0x140>)
 800b778:	4413      	add	r3, r2
 800b77a:	482c      	ldr	r0, [pc, #176]	; (800b82c <test_010_001_execute+0x13c>)
 800b77c:	4619      	mov	r1, r3
 800b77e:	f7f8 fa27 	bl	8003bd0 <chPoolFree>
  }

  /* [10.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b782:	9b01      	ldr	r3, [sp, #4]
 800b784:	3301      	adds	r3, #1
 800b786:	9301      	str	r3, [sp, #4]
 800b788:	9b01      	ldr	r3, [sp, #4]
 800b78a:	2b03      	cmp	r3, #3
 800b78c:	d9f1      	bls.n	800b772 <test_010_001_execute+0x82>
      chPoolFree(&mp1, &objects[i]);
  }

  /* [10.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 800b78e:	4b26      	ldr	r3, [pc, #152]	; (800b828 <test_010_001_execute+0x138>)
 800b790:	2205      	movs	r2, #5
 800b792:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b794:	2300      	movs	r3, #0
 800b796:	9301      	str	r3, [sp, #4]
 800b798:	e013      	b.n	800b7c2 <test_010_001_execute+0xd2>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800b79a:	4824      	ldr	r0, [pc, #144]	; (800b82c <test_010_001_execute+0x13c>)
 800b79c:	f7f8 f9f8 	bl	8003b90 <chPoolAlloc>
 800b7a0:	4603      	mov	r3, r0
 800b7a2:	2b00      	cmp	r3, #0
 800b7a4:	bf14      	ite	ne
 800b7a6:	2301      	movne	r3, #1
 800b7a8:	2300      	moveq	r3, #0
 800b7aa:	b2db      	uxtb	r3, r3
 800b7ac:	4618      	mov	r0, r3
 800b7ae:	4921      	ldr	r1, [pc, #132]	; (800b834 <test_010_001_execute+0x144>)
 800b7b0:	f7fb ff1e 	bl	80075f0 <_test_assert>
 800b7b4:	4603      	mov	r3, r0
 800b7b6:	2b00      	cmp	r3, #0
 800b7b8:	d000      	beq.n	800b7bc <test_010_001_execute+0xcc>
 800b7ba:	e032      	b.n	800b822 <test_010_001_execute+0x132>
  }

  /* [10.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b7bc:	9b01      	ldr	r3, [sp, #4]
 800b7be:	3301      	adds	r3, #1
 800b7c0:	9301      	str	r3, [sp, #4]
 800b7c2:	9b01      	ldr	r3, [sp, #4]
 800b7c4:	2b03      	cmp	r3, #3
 800b7c6:	d9e8      	bls.n	800b79a <test_010_001_execute+0xaa>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.6] Now must be empty again.*/
  test_set_step(6);
 800b7c8:	4b17      	ldr	r3, [pc, #92]	; (800b828 <test_010_001_execute+0x138>)
 800b7ca:	2206      	movs	r2, #6
 800b7cc:	601a      	str	r2, [r3, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800b7ce:	4817      	ldr	r0, [pc, #92]	; (800b82c <test_010_001_execute+0x13c>)
 800b7d0:	f7f8 f9de 	bl	8003b90 <chPoolAlloc>
 800b7d4:	4603      	mov	r3, r0
 800b7d6:	2b00      	cmp	r3, #0
 800b7d8:	bf0c      	ite	eq
 800b7da:	2301      	moveq	r3, #1
 800b7dc:	2300      	movne	r3, #0
 800b7de:	b2db      	uxtb	r3, r3
 800b7e0:	4618      	mov	r0, r3
 800b7e2:	4915      	ldr	r1, [pc, #84]	; (800b838 <test_010_001_execute+0x148>)
 800b7e4:	f7fb ff04 	bl	80075f0 <_test_assert>
 800b7e8:	4603      	mov	r3, r0
 800b7ea:	2b00      	cmp	r3, #0
 800b7ec:	d000      	beq.n	800b7f0 <test_010_001_execute+0x100>
 800b7ee:	e018      	b.n	800b822 <test_010_001_execute+0x132>
  }

  /* [10.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 800b7f0:	4b0d      	ldr	r3, [pc, #52]	; (800b828 <test_010_001_execute+0x138>)
 800b7f2:	2207      	movs	r2, #7
 800b7f4:	601a      	str	r2, [r3, #0]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
 800b7f6:	480d      	ldr	r0, [pc, #52]	; (800b82c <test_010_001_execute+0x13c>)
 800b7f8:	2104      	movs	r1, #4
 800b7fa:	4a10      	ldr	r2, [pc, #64]	; (800b83c <test_010_001_execute+0x14c>)
 800b7fc:	f7f8 f980 	bl	8003b00 <chPoolObjectInit>
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800b800:	480a      	ldr	r0, [pc, #40]	; (800b82c <test_010_001_execute+0x13c>)
 800b802:	f7f8 f9c5 	bl	8003b90 <chPoolAlloc>
 800b806:	4603      	mov	r3, r0
 800b808:	2b00      	cmp	r3, #0
 800b80a:	bf0c      	ite	eq
 800b80c:	2301      	moveq	r3, #1
 800b80e:	2300      	movne	r3, #0
 800b810:	b2db      	uxtb	r3, r3
 800b812:	4618      	mov	r0, r3
 800b814:	490a      	ldr	r1, [pc, #40]	; (800b840 <test_010_001_execute+0x150>)
 800b816:	f7fb feeb 	bl	80075f0 <_test_assert>
 800b81a:	4603      	mov	r3, r0
 800b81c:	2b00      	cmp	r3, #0
 800b81e:	d000      	beq.n	800b822 <test_010_001_execute+0x132>
 800b820:	bf00      	nop
  }
}
 800b822:	b003      	add	sp, #12
 800b824:	f85d fb04 	ldr.w	pc, [sp], #4
 800b828:	20000cac 	.word	0x20000cac
 800b82c:	20000894 	.word	0x20000894
 800b830:	2000099c 	.word	0x2000099c
 800b834:	0800f3d0 	.word	0x0800f3d0
 800b838:	0800f3dc 	.word	0x0800f3dc
 800b83c:	0800b6c1 	.word	0x0800b6c1
 800b840:	0800f3ec 	.word	0x0800f3ec
 800b844:	f3af 8000 	nop.w
 800b848:	f3af 8000 	nop.w
 800b84c:	f3af 8000 	nop.w

0800b850 <test_010_002_setup>:
 *   again.
 * - [10.2.6] Now must be empty again.
 * .
 */

static void test_010_002_setup(void) {
 800b850:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
 800b852:	4802      	ldr	r0, [pc, #8]	; (800b85c <test_010_002_setup+0xc>)
 800b854:	2104      	movs	r1, #4
 800b856:	f7f8 f9cb 	bl	8003bf0 <chGuardedPoolObjectInit>
}
 800b85a:	bd08      	pop	{r3, pc}
 800b85c:	200008a0 	.word	0x200008a0

0800b860 <test_010_002_execute>:

static void test_010_002_execute(void) {
 800b860:	b500      	push	{lr}
 800b862:	b083      	sub	sp, #12
  unsigned i;

  /* [10.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 800b864:	4b42      	ldr	r3, [pc, #264]	; (800b970 <test_010_002_execute+0x110>)
 800b866:	2201      	movs	r2, #1
 800b868:	601a      	str	r2, [r3, #0]
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 800b86a:	4842      	ldr	r0, [pc, #264]	; (800b974 <test_010_002_execute+0x114>)
 800b86c:	4942      	ldr	r1, [pc, #264]	; (800b978 <test_010_002_execute+0x118>)
 800b86e:	2204      	movs	r2, #4
 800b870:	f7f8 f9d6 	bl	8003c20 <chGuardedPoolLoadArray>
  }

  /* [10.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 800b874:	4b3e      	ldr	r3, [pc, #248]	; (800b970 <test_010_002_execute+0x110>)
 800b876:	2202      	movs	r2, #2
 800b878:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b87a:	2300      	movs	r3, #0
 800b87c:	9301      	str	r3, [sp, #4]
 800b87e:	e014      	b.n	800b8aa <test_010_002_execute+0x4a>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800b880:	483c      	ldr	r0, [pc, #240]	; (800b974 <test_010_002_execute+0x114>)
 800b882:	2100      	movs	r1, #0
 800b884:	f7f8 fa04 	bl	8003c90 <chGuardedPoolAllocTimeout>
 800b888:	4603      	mov	r3, r0
 800b88a:	2b00      	cmp	r3, #0
 800b88c:	bf14      	ite	ne
 800b88e:	2301      	movne	r3, #1
 800b890:	2300      	moveq	r3, #0
 800b892:	b2db      	uxtb	r3, r3
 800b894:	4618      	mov	r0, r3
 800b896:	4939      	ldr	r1, [pc, #228]	; (800b97c <test_010_002_execute+0x11c>)
 800b898:	f7fb feaa 	bl	80075f0 <_test_assert>
 800b89c:	4603      	mov	r3, r0
 800b89e:	2b00      	cmp	r3, #0
 800b8a0:	d000      	beq.n	800b8a4 <test_010_002_execute+0x44>
 800b8a2:	e061      	b.n	800b968 <test_010_002_execute+0x108>
  }

  /* [10.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b8a4:	9b01      	ldr	r3, [sp, #4]
 800b8a6:	3301      	adds	r3, #1
 800b8a8:	9301      	str	r3, [sp, #4]
 800b8aa:	9b01      	ldr	r3, [sp, #4]
 800b8ac:	2b03      	cmp	r3, #3
 800b8ae:	d9e7      	bls.n	800b880 <test_010_002_execute+0x20>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.3] Now must be empty.*/
  test_set_step(3);
 800b8b0:	4b2f      	ldr	r3, [pc, #188]	; (800b970 <test_010_002_execute+0x110>)
 800b8b2:	2203      	movs	r2, #3
 800b8b4:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800b8b6:	482f      	ldr	r0, [pc, #188]	; (800b974 <test_010_002_execute+0x114>)
 800b8b8:	2100      	movs	r1, #0
 800b8ba:	f7f8 f9e9 	bl	8003c90 <chGuardedPoolAllocTimeout>
 800b8be:	4603      	mov	r3, r0
 800b8c0:	2b00      	cmp	r3, #0
 800b8c2:	bf0c      	ite	eq
 800b8c4:	2301      	moveq	r3, #1
 800b8c6:	2300      	movne	r3, #0
 800b8c8:	b2db      	uxtb	r3, r3
 800b8ca:	4618      	mov	r0, r3
 800b8cc:	492c      	ldr	r1, [pc, #176]	; (800b980 <test_010_002_execute+0x120>)
 800b8ce:	f7fb fe8f 	bl	80075f0 <_test_assert>
 800b8d2:	4603      	mov	r3, r0
 800b8d4:	2b00      	cmp	r3, #0
 800b8d6:	d000      	beq.n	800b8da <test_010_002_execute+0x7a>
 800b8d8:	e046      	b.n	800b968 <test_010_002_execute+0x108>
  }

  /* [10.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 800b8da:	4b25      	ldr	r3, [pc, #148]	; (800b970 <test_010_002_execute+0x110>)
 800b8dc:	2204      	movs	r2, #4
 800b8de:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b8e0:	2300      	movs	r3, #0
 800b8e2:	9301      	str	r3, [sp, #4]
 800b8e4:	e00a      	b.n	800b8fc <test_010_002_execute+0x9c>
      chGuardedPoolFree(&gmp1, &objects[i]);
 800b8e6:	9b01      	ldr	r3, [sp, #4]
 800b8e8:	009b      	lsls	r3, r3, #2
 800b8ea:	4a23      	ldr	r2, [pc, #140]	; (800b978 <test_010_002_execute+0x118>)
 800b8ec:	4413      	add	r3, r2
 800b8ee:	4821      	ldr	r0, [pc, #132]	; (800b974 <test_010_002_execute+0x114>)
 800b8f0:	4619      	mov	r1, r3
 800b8f2:	f7f8 f9fd 	bl	8003cf0 <chGuardedPoolFree>

  /* [10.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b8f6:	9b01      	ldr	r3, [sp, #4]
 800b8f8:	3301      	adds	r3, #1
 800b8fa:	9301      	str	r3, [sp, #4]
 800b8fc:	9b01      	ldr	r3, [sp, #4]
 800b8fe:	2b03      	cmp	r3, #3
 800b900:	d9f1      	bls.n	800b8e6 <test_010_002_execute+0x86>
      chGuardedPoolFree(&gmp1, &objects[i]);
  }

  /* [10.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 800b902:	4b1b      	ldr	r3, [pc, #108]	; (800b970 <test_010_002_execute+0x110>)
 800b904:	2205      	movs	r2, #5
 800b906:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b908:	2300      	movs	r3, #0
 800b90a:	9301      	str	r3, [sp, #4]
 800b90c:	e014      	b.n	800b938 <test_010_002_execute+0xd8>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800b90e:	4819      	ldr	r0, [pc, #100]	; (800b974 <test_010_002_execute+0x114>)
 800b910:	2100      	movs	r1, #0
 800b912:	f7f8 f9bd 	bl	8003c90 <chGuardedPoolAllocTimeout>
 800b916:	4603      	mov	r3, r0
 800b918:	2b00      	cmp	r3, #0
 800b91a:	bf14      	ite	ne
 800b91c:	2301      	movne	r3, #1
 800b91e:	2300      	moveq	r3, #0
 800b920:	b2db      	uxtb	r3, r3
 800b922:	4618      	mov	r0, r3
 800b924:	4915      	ldr	r1, [pc, #84]	; (800b97c <test_010_002_execute+0x11c>)
 800b926:	f7fb fe63 	bl	80075f0 <_test_assert>
 800b92a:	4603      	mov	r3, r0
 800b92c:	2b00      	cmp	r3, #0
 800b92e:	d000      	beq.n	800b932 <test_010_002_execute+0xd2>
 800b930:	e01a      	b.n	800b968 <test_010_002_execute+0x108>

  /* [10.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800b932:	9b01      	ldr	r3, [sp, #4]
 800b934:	3301      	adds	r3, #1
 800b936:	9301      	str	r3, [sp, #4]
 800b938:	9b01      	ldr	r3, [sp, #4]
 800b93a:	2b03      	cmp	r3, #3
 800b93c:	d9e7      	bls.n	800b90e <test_010_002_execute+0xae>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.6] Now must be empty again.*/
  test_set_step(6);
 800b93e:	4b0c      	ldr	r3, [pc, #48]	; (800b970 <test_010_002_execute+0x110>)
 800b940:	2206      	movs	r2, #6
 800b942:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800b944:	480b      	ldr	r0, [pc, #44]	; (800b974 <test_010_002_execute+0x114>)
 800b946:	2100      	movs	r1, #0
 800b948:	f7f8 f9a2 	bl	8003c90 <chGuardedPoolAllocTimeout>
 800b94c:	4603      	mov	r3, r0
 800b94e:	2b00      	cmp	r3, #0
 800b950:	bf0c      	ite	eq
 800b952:	2301      	moveq	r3, #1
 800b954:	2300      	movne	r3, #0
 800b956:	b2db      	uxtb	r3, r3
 800b958:	4618      	mov	r0, r3
 800b95a:	4909      	ldr	r1, [pc, #36]	; (800b980 <test_010_002_execute+0x120>)
 800b95c:	f7fb fe48 	bl	80075f0 <_test_assert>
 800b960:	4603      	mov	r3, r0
 800b962:	2b00      	cmp	r3, #0
 800b964:	d000      	beq.n	800b968 <test_010_002_execute+0x108>
 800b966:	bf00      	nop
  }
}
 800b968:	b003      	add	sp, #12
 800b96a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b96e:	bf00      	nop
 800b970:	20000cac 	.word	0x20000cac
 800b974:	200008a0 	.word	0x200008a0
 800b978:	2000099c 	.word	0x2000099c
 800b97c:	0800f3d0 	.word	0x0800f3d0
 800b980:	0800f3dc 	.word	0x0800f3dc
 800b984:	f3af 8000 	nop.w
 800b988:	f3af 8000 	nop.w
 800b98c:	f3af 8000 	nop.w

0800b990 <test_010_003_setup>:
 * - [10.3.1] Trying to allocate with 100mS timeout, must fail because
 *   the pool is empty.
 * .
 */

static void test_010_003_setup(void) {
 800b990:	b508      	push	{r3, lr}
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
 800b992:	4802      	ldr	r0, [pc, #8]	; (800b99c <test_010_003_setup+0xc>)
 800b994:	2104      	movs	r1, #4
 800b996:	f7f8 f92b 	bl	8003bf0 <chGuardedPoolObjectInit>
}
 800b99a:	bd08      	pop	{r3, pc}
 800b99c:	200008a0 	.word	0x200008a0

0800b9a0 <test_010_003_execute>:

static void test_010_003_execute(void) {
 800b9a0:	b508      	push	{r3, lr}

  /* [10.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 800b9a2:	4b0b      	ldr	r3, [pc, #44]	; (800b9d0 <test_010_003_execute+0x30>)
 800b9a4:	2201      	movs	r2, #1
 800b9a6:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 800b9a8:	480a      	ldr	r0, [pc, #40]	; (800b9d4 <test_010_003_execute+0x34>)
 800b9aa:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800b9ae:	f7f8 f96f 	bl	8003c90 <chGuardedPoolAllocTimeout>
 800b9b2:	4603      	mov	r3, r0
 800b9b4:	2b00      	cmp	r3, #0
 800b9b6:	bf0c      	ite	eq
 800b9b8:	2301      	moveq	r3, #1
 800b9ba:	2300      	movne	r3, #0
 800b9bc:	b2db      	uxtb	r3, r3
 800b9be:	4618      	mov	r0, r3
 800b9c0:	4905      	ldr	r1, [pc, #20]	; (800b9d8 <test_010_003_execute+0x38>)
 800b9c2:	f7fb fe15 	bl	80075f0 <_test_assert>
 800b9c6:	4603      	mov	r3, r0
 800b9c8:	2b00      	cmp	r3, #0
 800b9ca:	d000      	beq.n	800b9ce <test_010_003_execute+0x2e>
 800b9cc:	bf00      	nop
  }
}
 800b9ce:	bd08      	pop	{r3, pc}
 800b9d0:	20000cac 	.word	0x20000cac
 800b9d4:	200008a0 	.word	0x200008a0
 800b9d8:	0800f3dc 	.word	0x0800f3dc
 800b9dc:	00000000 	.word	0x00000000

0800b9e0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 800b9e0:	b500      	push	{lr}
 800b9e2:	b083      	sub	sp, #12
 800b9e4:	9001      	str	r0, [sp, #4]
 800b9e6:	9100      	str	r1, [sp, #0]

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 800b9e8:	9801      	ldr	r0, [sp, #4]
 800b9ea:	9900      	ldr	r1, [sp, #0]
 800b9ec:	2208      	movs	r2, #8
 800b9ee:	f7f7 feaf 	bl	8003750 <chHeapAllocAligned>
 800b9f2:	4603      	mov	r3, r0
}
 800b9f4:	4618      	mov	r0, r3
 800b9f6:	b003      	add	sp, #12
 800b9f8:	f85d fb04 	ldr.w	pc, [sp], #4
 800b9fc:	f3af 8000 	nop.w

0800ba00 <test_011_001_setup>:
 * - [11.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void test_011_001_setup(void) {
 800ba00:	b508      	push	{r3, lr}
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
 800ba02:	4803      	ldr	r0, [pc, #12]	; (800ba10 <test_011_001_setup+0x10>)
 800ba04:	4903      	ldr	r1, [pc, #12]	; (800ba14 <test_011_001_setup+0x14>)
 800ba06:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800ba0a:	f7f7 fe71 	bl	80036f0 <chHeapObjectInit>
}
 800ba0e:	bd08      	pop	{r3, pc}
 800ba10:	20001330 	.word	0x20001330
 800ba14:	20000cc8 	.word	0x20000cc8
 800ba18:	f3af 8000 	nop.w
 800ba1c:	f3af 8000 	nop.w

0800ba20 <test_011_001_execute>:

static void test_011_001_execute(void) {
 800ba20:	b500      	push	{lr}
 800ba22:	b089      	sub	sp, #36	; 0x24
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [11.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 800ba24:	4b9f      	ldr	r3, [pc, #636]	; (800bca4 <test_011_001_execute+0x284>)
 800ba26:	2201      	movs	r2, #1
 800ba28:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800ba2a:	ab03      	add	r3, sp, #12
 800ba2c:	489e      	ldr	r0, [pc, #632]	; (800bca8 <test_011_001_execute+0x288>)
 800ba2e:	4619      	mov	r1, r3
 800ba30:	2200      	movs	r2, #0
 800ba32:	f7f7 ffd5 	bl	80039e0 <chHeapStatus>
 800ba36:	4603      	mov	r3, r0
 800ba38:	2b01      	cmp	r3, #1
 800ba3a:	bf0c      	ite	eq
 800ba3c:	2301      	moveq	r3, #1
 800ba3e:	2300      	movne	r3, #0
 800ba40:	b2db      	uxtb	r3, r3
 800ba42:	4618      	mov	r0, r3
 800ba44:	4999      	ldr	r1, [pc, #612]	; (800bcac <test_011_001_execute+0x28c>)
 800ba46:	f7fb fdd3 	bl	80075f0 <_test_assert>
 800ba4a:	4603      	mov	r3, r0
 800ba4c:	2b00      	cmp	r3, #0
 800ba4e:	d000      	beq.n	800ba52 <test_011_001_execute+0x32>
 800ba50:	e1d4      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 800ba52:	4b94      	ldr	r3, [pc, #592]	; (800bca4 <test_011_001_execute+0x284>)
 800ba54:	2202      	movs	r2, #2
 800ba56:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
 800ba58:	4893      	ldr	r0, [pc, #588]	; (800bca8 <test_011_001_execute+0x288>)
 800ba5a:	f44f 614d 	mov.w	r1, #3280	; 0xcd0
 800ba5e:	f7ff ffbf 	bl	800b9e0 <chHeapAlloc>
 800ba62:	9007      	str	r0, [sp, #28]
    test_assert(p1 == NULL, "allocation not failed");
 800ba64:	9b07      	ldr	r3, [sp, #28]
 800ba66:	2b00      	cmp	r3, #0
 800ba68:	bf0c      	ite	eq
 800ba6a:	2301      	moveq	r3, #1
 800ba6c:	2300      	movne	r3, #0
 800ba6e:	b2db      	uxtb	r3, r3
 800ba70:	4618      	mov	r0, r3
 800ba72:	498f      	ldr	r1, [pc, #572]	; (800bcb0 <test_011_001_execute+0x290>)
 800ba74:	f7fb fdbc 	bl	80075f0 <_test_assert>
 800ba78:	4603      	mov	r3, r0
 800ba7a:	2b00      	cmp	r3, #0
 800ba7c:	d000      	beq.n	800ba80 <test_011_001_execute+0x60>
 800ba7e:	e1bd      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.3] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 800ba80:	4b88      	ldr	r3, [pc, #544]	; (800bca4 <test_011_001_execute+0x284>)
 800ba82:	2203      	movs	r2, #3
 800ba84:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800ba86:	4888      	ldr	r0, [pc, #544]	; (800bca8 <test_011_001_execute+0x288>)
 800ba88:	2110      	movs	r1, #16
 800ba8a:	f7ff ffa9 	bl	800b9e0 <chHeapAlloc>
 800ba8e:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
 800ba90:	9b07      	ldr	r3, [sp, #28]
 800ba92:	2b00      	cmp	r3, #0
 800ba94:	bf14      	ite	ne
 800ba96:	2301      	movne	r3, #1
 800ba98:	2300      	moveq	r3, #0
 800ba9a:	b2db      	uxtb	r3, r3
 800ba9c:	4618      	mov	r0, r3
 800ba9e:	4985      	ldr	r1, [pc, #532]	; (800bcb4 <test_011_001_execute+0x294>)
 800baa0:	f7fb fda6 	bl	80075f0 <_test_assert>
 800baa4:	4603      	mov	r3, r0
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	d000      	beq.n	800baac <test_011_001_execute+0x8c>
 800baaa:	e1a7      	b.n	800bdfc <test_011_001_execute+0x3dc>
    chHeapFree(p1);
 800baac:	9807      	ldr	r0, [sp, #28]
 800baae:	f7f7 ff27 	bl	8003900 <chHeapFree>
  }

  /* [11.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 800bab2:	4b7c      	ldr	r3, [pc, #496]	; (800bca4 <test_011_001_execute+0x284>)
 800bab4:	2204      	movs	r2, #4
 800bab6:	601a      	str	r2, [r3, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800bab8:	aa02      	add	r2, sp, #8
 800baba:	ab01      	add	r3, sp, #4
 800babc:	487a      	ldr	r0, [pc, #488]	; (800bca8 <test_011_001_execute+0x288>)
 800babe:	4611      	mov	r1, r2
 800bac0:	461a      	mov	r2, r3
 800bac2:	f7f7 ff8d 	bl	80039e0 <chHeapStatus>
 800bac6:	4603      	mov	r3, r0
 800bac8:	9304      	str	r3, [sp, #16]
    test_assert(n == 1, "missing free block");
 800baca:	9b04      	ldr	r3, [sp, #16]
 800bacc:	2b01      	cmp	r3, #1
 800bace:	bf0c      	ite	eq
 800bad0:	2301      	moveq	r3, #1
 800bad2:	2300      	movne	r3, #0
 800bad4:	b2db      	uxtb	r3, r3
 800bad6:	4618      	mov	r0, r3
 800bad8:	4977      	ldr	r1, [pc, #476]	; (800bcb8 <test_011_001_execute+0x298>)
 800bada:	f7fb fd89 	bl	80075f0 <_test_assert>
 800bade:	4603      	mov	r3, r0
 800bae0:	2b00      	cmp	r3, #0
 800bae2:	d000      	beq.n	800bae6 <test_011_001_execute+0xc6>
 800bae4:	e18a      	b.n	800bdfc <test_011_001_execute+0x3dc>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 800bae6:	9b02      	ldr	r3, [sp, #8]
 800bae8:	2b0f      	cmp	r3, #15
 800baea:	bf8c      	ite	hi
 800baec:	2301      	movhi	r3, #1
 800baee:	2300      	movls	r3, #0
 800baf0:	b2db      	uxtb	r3, r3
 800baf2:	4618      	mov	r0, r3
 800baf4:	4971      	ldr	r1, [pc, #452]	; (800bcbc <test_011_001_execute+0x29c>)
 800baf6:	f7fb fd7b 	bl	80075f0 <_test_assert>
 800bafa:	4603      	mov	r3, r0
 800bafc:	2b00      	cmp	r3, #0
 800bafe:	d000      	beq.n	800bb02 <test_011_001_execute+0xe2>
 800bb00:	e17c      	b.n	800bdfc <test_011_001_execute+0x3dc>
    test_assert(total_size == largest_size, "unexpected heap state");
 800bb02:	9a02      	ldr	r2, [sp, #8]
 800bb04:	9b01      	ldr	r3, [sp, #4]
 800bb06:	429a      	cmp	r2, r3
 800bb08:	bf0c      	ite	eq
 800bb0a:	2301      	moveq	r3, #1
 800bb0c:	2300      	movne	r3, #0
 800bb0e:	b2db      	uxtb	r3, r3
 800bb10:	4618      	mov	r0, r3
 800bb12:	496a      	ldr	r1, [pc, #424]	; (800bcbc <test_011_001_execute+0x29c>)
 800bb14:	f7fb fd6c 	bl	80075f0 <_test_assert>
 800bb18:	4603      	mov	r3, r0
 800bb1a:	2b00      	cmp	r3, #0
 800bb1c:	d001      	beq.n	800bb22 <test_011_001_execute+0x102>
 800bb1e:	bf00      	nop
 800bb20:	e16c      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 800bb22:	4b60      	ldr	r3, [pc, #384]	; (800bca4 <test_011_001_execute+0x284>)
 800bb24:	2205      	movs	r2, #5
 800bb26:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb28:	485f      	ldr	r0, [pc, #380]	; (800bca8 <test_011_001_execute+0x288>)
 800bb2a:	2110      	movs	r1, #16
 800bb2c:	f7ff ff58 	bl	800b9e0 <chHeapAlloc>
 800bb30:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb32:	485d      	ldr	r0, [pc, #372]	; (800bca8 <test_011_001_execute+0x288>)
 800bb34:	2110      	movs	r1, #16
 800bb36:	f7ff ff53 	bl	800b9e0 <chHeapAlloc>
 800bb3a:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb3c:	485a      	ldr	r0, [pc, #360]	; (800bca8 <test_011_001_execute+0x288>)
 800bb3e:	2110      	movs	r1, #16
 800bb40:	f7ff ff4e 	bl	800b9e0 <chHeapAlloc>
 800bb44:	9005      	str	r0, [sp, #20]
    chHeapFree(p1);                                 /* Does not merge.*/
 800bb46:	9807      	ldr	r0, [sp, #28]
 800bb48:	f7f7 feda 	bl	8003900 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 800bb4c:	9806      	ldr	r0, [sp, #24]
 800bb4e:	f7f7 fed7 	bl	8003900 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 800bb52:	9805      	ldr	r0, [sp, #20]
 800bb54:	f7f7 fed4 	bl	8003900 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800bb58:	ab04      	add	r3, sp, #16
 800bb5a:	4853      	ldr	r0, [pc, #332]	; (800bca8 <test_011_001_execute+0x288>)
 800bb5c:	4619      	mov	r1, r3
 800bb5e:	2200      	movs	r2, #0
 800bb60:	f7f7 ff3e 	bl	80039e0 <chHeapStatus>
 800bb64:	4603      	mov	r3, r0
 800bb66:	2b01      	cmp	r3, #1
 800bb68:	bf0c      	ite	eq
 800bb6a:	2301      	moveq	r3, #1
 800bb6c:	2300      	movne	r3, #0
 800bb6e:	b2db      	uxtb	r3, r3
 800bb70:	4618      	mov	r0, r3
 800bb72:	494e      	ldr	r1, [pc, #312]	; (800bcac <test_011_001_execute+0x28c>)
 800bb74:	f7fb fd3c 	bl	80075f0 <_test_assert>
 800bb78:	4603      	mov	r3, r0
 800bb7a:	2b00      	cmp	r3, #0
 800bb7c:	d000      	beq.n	800bb80 <test_011_001_execute+0x160>
 800bb7e:	e13d      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 800bb80:	4b48      	ldr	r3, [pc, #288]	; (800bca4 <test_011_001_execute+0x284>)
 800bb82:	2206      	movs	r2, #6
 800bb84:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb86:	4848      	ldr	r0, [pc, #288]	; (800bca8 <test_011_001_execute+0x288>)
 800bb88:	2110      	movs	r1, #16
 800bb8a:	f7ff ff29 	bl	800b9e0 <chHeapAlloc>
 800bb8e:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb90:	4845      	ldr	r0, [pc, #276]	; (800bca8 <test_011_001_execute+0x288>)
 800bb92:	2110      	movs	r1, #16
 800bb94:	f7ff ff24 	bl	800b9e0 <chHeapAlloc>
 800bb98:	9006      	str	r0, [sp, #24]
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bb9a:	4843      	ldr	r0, [pc, #268]	; (800bca8 <test_011_001_execute+0x288>)
 800bb9c:	2110      	movs	r1, #16
 800bb9e:	f7ff ff1f 	bl	800b9e0 <chHeapAlloc>
 800bba2:	9005      	str	r0, [sp, #20]
    chHeapFree(p3);                                 /* Merges forward.*/
 800bba4:	9805      	ldr	r0, [sp, #20]
 800bba6:	f7f7 feab 	bl	8003900 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 800bbaa:	9806      	ldr	r0, [sp, #24]
 800bbac:	f7f7 fea8 	bl	8003900 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 800bbb0:	9807      	ldr	r0, [sp, #28]
 800bbb2:	f7f7 fea5 	bl	8003900 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800bbb6:	ab04      	add	r3, sp, #16
 800bbb8:	483b      	ldr	r0, [pc, #236]	; (800bca8 <test_011_001_execute+0x288>)
 800bbba:	4619      	mov	r1, r3
 800bbbc:	2200      	movs	r2, #0
 800bbbe:	f7f7 ff0f 	bl	80039e0 <chHeapStatus>
 800bbc2:	4603      	mov	r3, r0
 800bbc4:	2b01      	cmp	r3, #1
 800bbc6:	bf0c      	ite	eq
 800bbc8:	2301      	moveq	r3, #1
 800bbca:	2300      	movne	r3, #0
 800bbcc:	b2db      	uxtb	r3, r3
 800bbce:	4618      	mov	r0, r3
 800bbd0:	4936      	ldr	r1, [pc, #216]	; (800bcac <test_011_001_execute+0x28c>)
 800bbd2:	f7fb fd0d 	bl	80075f0 <_test_assert>
 800bbd6:	4603      	mov	r3, r0
 800bbd8:	2b00      	cmp	r3, #0
 800bbda:	d000      	beq.n	800bbde <test_011_001_execute+0x1be>
 800bbdc:	e10e      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 800bbde:	4b31      	ldr	r3, [pc, #196]	; (800bca4 <test_011_001_execute+0x284>)
 800bbe0:	2207      	movs	r2, #7
 800bbe2:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
 800bbe4:	4830      	ldr	r0, [pc, #192]	; (800bca8 <test_011_001_execute+0x288>)
 800bbe6:	2111      	movs	r1, #17
 800bbe8:	f7ff fefa 	bl	800b9e0 <chHeapAlloc>
 800bbec:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bbee:	482e      	ldr	r0, [pc, #184]	; (800bca8 <test_011_001_execute+0x288>)
 800bbf0:	2110      	movs	r1, #16
 800bbf2:	f7ff fef5 	bl	800b9e0 <chHeapAlloc>
 800bbf6:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
 800bbf8:	9807      	ldr	r0, [sp, #28]
 800bbfa:	f7f7 fe81 	bl	8003900 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800bbfe:	ab04      	add	r3, sp, #16
 800bc00:	4829      	ldr	r0, [pc, #164]	; (800bca8 <test_011_001_execute+0x288>)
 800bc02:	4619      	mov	r1, r3
 800bc04:	2200      	movs	r2, #0
 800bc06:	f7f7 feeb 	bl	80039e0 <chHeapStatus>
 800bc0a:	4603      	mov	r3, r0
 800bc0c:	2b02      	cmp	r3, #2
 800bc0e:	bf0c      	ite	eq
 800bc10:	2301      	moveq	r3, #1
 800bc12:	2300      	movne	r3, #0
 800bc14:	b2db      	uxtb	r3, r3
 800bc16:	4618      	mov	r0, r3
 800bc18:	4929      	ldr	r1, [pc, #164]	; (800bcc0 <test_011_001_execute+0x2a0>)
 800bc1a:	f7fb fce9 	bl	80075f0 <_test_assert>
 800bc1e:	4603      	mov	r3, r0
 800bc20:	2b00      	cmp	r3, #0
 800bc22:	d000      	beq.n	800bc26 <test_011_001_execute+0x206>
 800bc24:	e0ea      	b.n	800bdfc <test_011_001_execute+0x3dc>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bc26:	4820      	ldr	r0, [pc, #128]	; (800bca8 <test_011_001_execute+0x288>)
 800bc28:	2110      	movs	r1, #16
 800bc2a:	f7ff fed9 	bl	800b9e0 <chHeapAlloc>
 800bc2e:	9007      	str	r0, [sp, #28]
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 800bc30:	ab04      	add	r3, sp, #16
 800bc32:	481d      	ldr	r0, [pc, #116]	; (800bca8 <test_011_001_execute+0x288>)
 800bc34:	4619      	mov	r1, r3
 800bc36:	2200      	movs	r2, #0
 800bc38:	f7f7 fed2 	bl	80039e0 <chHeapStatus>
 800bc3c:	4603      	mov	r3, r0
 800bc3e:	2b01      	cmp	r3, #1
 800bc40:	d008      	beq.n	800bc54 <test_011_001_execute+0x234>
 800bc42:	ab04      	add	r3, sp, #16
 800bc44:	4818      	ldr	r0, [pc, #96]	; (800bca8 <test_011_001_execute+0x288>)
 800bc46:	4619      	mov	r1, r3
 800bc48:	2200      	movs	r2, #0
 800bc4a:	f7f7 fec9 	bl	80039e0 <chHeapStatus>
 800bc4e:	4603      	mov	r3, r0
 800bc50:	2b02      	cmp	r3, #2
 800bc52:	d101      	bne.n	800bc58 <test_011_001_execute+0x238>
 800bc54:	2301      	movs	r3, #1
 800bc56:	e000      	b.n	800bc5a <test_011_001_execute+0x23a>
 800bc58:	2300      	movs	r3, #0
 800bc5a:	f003 0301 	and.w	r3, r3, #1
 800bc5e:	b2db      	uxtb	r3, r3
 800bc60:	4618      	mov	r0, r3
 800bc62:	4912      	ldr	r1, [pc, #72]	; (800bcac <test_011_001_execute+0x28c>)
 800bc64:	f7fb fcc4 	bl	80075f0 <_test_assert>
 800bc68:	4603      	mov	r3, r0
 800bc6a:	2b00      	cmp	r3, #0
 800bc6c:	d000      	beq.n	800bc70 <test_011_001_execute+0x250>
 800bc6e:	e0c5      	b.n	800bdfc <test_011_001_execute+0x3dc>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 800bc70:	9806      	ldr	r0, [sp, #24]
 800bc72:	f7f7 fe45 	bl	8003900 <chHeapFree>
    chHeapFree(p1);
 800bc76:	9807      	ldr	r0, [sp, #28]
 800bc78:	f7f7 fe42 	bl	8003900 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800bc7c:	ab04      	add	r3, sp, #16
 800bc7e:	480a      	ldr	r0, [pc, #40]	; (800bca8 <test_011_001_execute+0x288>)
 800bc80:	4619      	mov	r1, r3
 800bc82:	2200      	movs	r2, #0
 800bc84:	f7f7 feac 	bl	80039e0 <chHeapStatus>
 800bc88:	4603      	mov	r3, r0
 800bc8a:	2b01      	cmp	r3, #1
 800bc8c:	bf0c      	ite	eq
 800bc8e:	2301      	moveq	r3, #1
 800bc90:	2300      	movne	r3, #0
 800bc92:	b2db      	uxtb	r3, r3
 800bc94:	4618      	mov	r0, r3
 800bc96:	4905      	ldr	r1, [pc, #20]	; (800bcac <test_011_001_execute+0x28c>)
 800bc98:	f7fb fcaa 	bl	80075f0 <_test_assert>
 800bc9c:	4603      	mov	r3, r0
 800bc9e:	2b00      	cmp	r3, #0
 800bca0:	d010      	beq.n	800bcc4 <test_011_001_execute+0x2a4>
 800bca2:	e0ab      	b.n	800bdfc <test_011_001_execute+0x3dc>
 800bca4:	20000cac 	.word	0x20000cac
 800bca8:	20001330 	.word	0x20001330
 800bcac:	0800f4c8 	.word	0x0800f4c8
 800bcb0:	0800f4d8 	.word	0x0800f4d8
 800bcb4:	0800f4f0 	.word	0x0800f4f0
 800bcb8:	0800f504 	.word	0x0800f504
 800bcbc:	0800f518 	.word	0x0800f518
 800bcc0:	0800f530 	.word	0x0800f530
  }

  /* [11.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 800bcc4:	4b4f      	ldr	r3, [pc, #316]	; (800be04 <test_011_001_execute+0x3e4>)
 800bcc6:	2208      	movs	r2, #8
 800bcc8:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bcca:	484f      	ldr	r0, [pc, #316]	; (800be08 <test_011_001_execute+0x3e8>)
 800bccc:	2110      	movs	r1, #16
 800bcce:	f7ff fe87 	bl	800b9e0 <chHeapAlloc>
 800bcd2:	9007      	str	r0, [sp, #28]
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800bcd4:	484c      	ldr	r0, [pc, #304]	; (800be08 <test_011_001_execute+0x3e8>)
 800bcd6:	2110      	movs	r1, #16
 800bcd8:	f7ff fe82 	bl	800b9e0 <chHeapAlloc>
 800bcdc:	9006      	str	r0, [sp, #24]
    chHeapFree(p1);
 800bcde:	9807      	ldr	r0, [sp, #28]
 800bce0:	f7f7 fe0e 	bl	8003900 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800bce4:	ab04      	add	r3, sp, #16
 800bce6:	4848      	ldr	r0, [pc, #288]	; (800be08 <test_011_001_execute+0x3e8>)
 800bce8:	4619      	mov	r1, r3
 800bcea:	2200      	movs	r2, #0
 800bcec:	f7f7 fe78 	bl	80039e0 <chHeapStatus>
 800bcf0:	4603      	mov	r3, r0
 800bcf2:	2b02      	cmp	r3, #2
 800bcf4:	bf0c      	ite	eq
 800bcf6:	2301      	moveq	r3, #1
 800bcf8:	2300      	movne	r3, #0
 800bcfa:	b2db      	uxtb	r3, r3
 800bcfc:	4618      	mov	r0, r3
 800bcfe:	4943      	ldr	r1, [pc, #268]	; (800be0c <test_011_001_execute+0x3ec>)
 800bd00:	f7fb fc76 	bl	80075f0 <_test_assert>
 800bd04:	4603      	mov	r3, r0
 800bd06:	2b00      	cmp	r3, #0
 800bd08:	d000      	beq.n	800bd0c <test_011_001_execute+0x2ec>
 800bd0a:	e077      	b.n	800bdfc <test_011_001_execute+0x3dc>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
 800bd0c:	483e      	ldr	r0, [pc, #248]	; (800be08 <test_011_001_execute+0x3e8>)
 800bd0e:	2120      	movs	r1, #32
 800bd10:	f7ff fe66 	bl	800b9e0 <chHeapAlloc>
 800bd14:	9007      	str	r0, [sp, #28]
    chHeapFree(p1);
 800bd16:	9807      	ldr	r0, [sp, #28]
 800bd18:	f7f7 fdf2 	bl	8003900 <chHeapFree>
    chHeapFree(p2);
 800bd1c:	9806      	ldr	r0, [sp, #24]
 800bd1e:	f7f7 fdef 	bl	8003900 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800bd22:	ab04      	add	r3, sp, #16
 800bd24:	4838      	ldr	r0, [pc, #224]	; (800be08 <test_011_001_execute+0x3e8>)
 800bd26:	4619      	mov	r1, r3
 800bd28:	2200      	movs	r2, #0
 800bd2a:	f7f7 fe59 	bl	80039e0 <chHeapStatus>
 800bd2e:	4603      	mov	r3, r0
 800bd30:	2b01      	cmp	r3, #1
 800bd32:	bf0c      	ite	eq
 800bd34:	2301      	moveq	r3, #1
 800bd36:	2300      	movne	r3, #0
 800bd38:	b2db      	uxtb	r3, r3
 800bd3a:	4618      	mov	r0, r3
 800bd3c:	4934      	ldr	r1, [pc, #208]	; (800be10 <test_011_001_execute+0x3f0>)
 800bd3e:	f7fb fc57 	bl	80075f0 <_test_assert>
 800bd42:	4603      	mov	r3, r0
 800bd44:	2b00      	cmp	r3, #0
 800bd46:	d000      	beq.n	800bd4a <test_011_001_execute+0x32a>
 800bd48:	e058      	b.n	800bdfc <test_011_001_execute+0x3dc>
  }

  /* [11.1.9] Allocating the whole available space.*/
  test_set_step(9);
 800bd4a:	4b2e      	ldr	r3, [pc, #184]	; (800be04 <test_011_001_execute+0x3e4>)
 800bd4c:	2209      	movs	r2, #9
 800bd4e:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 800bd50:	ab04      	add	r3, sp, #16
 800bd52:	482d      	ldr	r0, [pc, #180]	; (800be08 <test_011_001_execute+0x3e8>)
 800bd54:	4619      	mov	r1, r3
 800bd56:	2200      	movs	r2, #0
 800bd58:	f7f7 fe42 	bl	80039e0 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, n);
 800bd5c:	9b04      	ldr	r3, [sp, #16]
 800bd5e:	482a      	ldr	r0, [pc, #168]	; (800be08 <test_011_001_execute+0x3e8>)
 800bd60:	4619      	mov	r1, r3
 800bd62:	f7ff fe3d 	bl	800b9e0 <chHeapAlloc>
 800bd66:	9007      	str	r0, [sp, #28]
    test_assert(p1 != NULL, "allocation failed");
 800bd68:	9b07      	ldr	r3, [sp, #28]
 800bd6a:	2b00      	cmp	r3, #0
 800bd6c:	bf14      	ite	ne
 800bd6e:	2301      	movne	r3, #1
 800bd70:	2300      	moveq	r3, #0
 800bd72:	b2db      	uxtb	r3, r3
 800bd74:	4618      	mov	r0, r3
 800bd76:	4927      	ldr	r1, [pc, #156]	; (800be14 <test_011_001_execute+0x3f4>)
 800bd78:	f7fb fc3a 	bl	80075f0 <_test_assert>
 800bd7c:	4603      	mov	r3, r0
 800bd7e:	2b00      	cmp	r3, #0
 800bd80:	d000      	beq.n	800bd84 <test_011_001_execute+0x364>
 800bd82:	e03b      	b.n	800bdfc <test_011_001_execute+0x3dc>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 800bd84:	4820      	ldr	r0, [pc, #128]	; (800be08 <test_011_001_execute+0x3e8>)
 800bd86:	2100      	movs	r1, #0
 800bd88:	2200      	movs	r2, #0
 800bd8a:	f7f7 fe29 	bl	80039e0 <chHeapStatus>
 800bd8e:	4603      	mov	r3, r0
 800bd90:	2b00      	cmp	r3, #0
 800bd92:	bf0c      	ite	eq
 800bd94:	2301      	moveq	r3, #1
 800bd96:	2300      	movne	r3, #0
 800bd98:	b2db      	uxtb	r3, r3
 800bd9a:	4618      	mov	r0, r3
 800bd9c:	491e      	ldr	r1, [pc, #120]	; (800be18 <test_011_001_execute+0x3f8>)
 800bd9e:	f7fb fc27 	bl	80075f0 <_test_assert>
 800bda2:	4603      	mov	r3, r0
 800bda4:	2b00      	cmp	r3, #0
 800bda6:	d000      	beq.n	800bdaa <test_011_001_execute+0x38a>
 800bda8:	e028      	b.n	800bdfc <test_011_001_execute+0x3dc>
    chHeapFree(p1);
 800bdaa:	9807      	ldr	r0, [sp, #28]
 800bdac:	f7f7 fda8 	bl	8003900 <chHeapFree>
  }

  /* [11.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 800bdb0:	4b14      	ldr	r3, [pc, #80]	; (800be04 <test_011_001_execute+0x3e4>)
 800bdb2:	220a      	movs	r2, #10
 800bdb4:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800bdb6:	ab04      	add	r3, sp, #16
 800bdb8:	4813      	ldr	r0, [pc, #76]	; (800be08 <test_011_001_execute+0x3e8>)
 800bdba:	4619      	mov	r1, r3
 800bdbc:	2200      	movs	r2, #0
 800bdbe:	f7f7 fe0f 	bl	80039e0 <chHeapStatus>
 800bdc2:	4603      	mov	r3, r0
 800bdc4:	2b01      	cmp	r3, #1
 800bdc6:	bf0c      	ite	eq
 800bdc8:	2301      	moveq	r3, #1
 800bdca:	2300      	movne	r3, #0
 800bdcc:	b2db      	uxtb	r3, r3
 800bdce:	4618      	mov	r0, r3
 800bdd0:	490f      	ldr	r1, [pc, #60]	; (800be10 <test_011_001_execute+0x3f0>)
 800bdd2:	f7fb fc0d 	bl	80075f0 <_test_assert>
 800bdd6:	4603      	mov	r3, r0
 800bdd8:	2b00      	cmp	r3, #0
 800bdda:	d000      	beq.n	800bdde <test_011_001_execute+0x3be>
 800bddc:	e00e      	b.n	800bdfc <test_011_001_execute+0x3dc>
    test_assert(n == sz, "size changed");
 800bdde:	9a04      	ldr	r2, [sp, #16]
 800bde0:	9b03      	ldr	r3, [sp, #12]
 800bde2:	429a      	cmp	r2, r3
 800bde4:	bf0c      	ite	eq
 800bde6:	2301      	moveq	r3, #1
 800bde8:	2300      	movne	r3, #0
 800bdea:	b2db      	uxtb	r3, r3
 800bdec:	4618      	mov	r0, r3
 800bdee:	490b      	ldr	r1, [pc, #44]	; (800be1c <test_011_001_execute+0x3fc>)
 800bdf0:	f7fb fbfe 	bl	80075f0 <_test_assert>
 800bdf4:	4603      	mov	r3, r0
 800bdf6:	2b00      	cmp	r3, #0
 800bdf8:	d000      	beq.n	800bdfc <test_011_001_execute+0x3dc>
 800bdfa:	bf00      	nop
  }
}
 800bdfc:	b009      	add	sp, #36	; 0x24
 800bdfe:	f85d fb04 	ldr.w	pc, [sp], #4
 800be02:	bf00      	nop
 800be04:	20000cac 	.word	0x20000cac
 800be08:	20001330 	.word	0x20001330
 800be0c:	0800f530 	.word	0x0800f530
 800be10:	0800f4c8 	.word	0x0800f4c8
 800be14:	0800f4f0 	.word	0x0800f4f0
 800be18:	0800f540 	.word	0x0800f540
 800be1c:	0800f54c 	.word	0x0800f54c

0800be20 <test_011_002_execute>:
 *   block is freed using chHeapFree(), must not fail.
 * - [11.2.2] Testing allocation failure.
 * .
 */

static void test_011_002_execute(void) {
 800be20:	b500      	push	{lr}
 800be22:	b085      	sub	sp, #20
  void *p1;
  size_t total_size, largest_size;

  /* [11.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 800be24:	4b1c      	ldr	r3, [pc, #112]	; (800be98 <test_011_002_execute+0x78>)
 800be26:	2201      	movs	r2, #1
 800be28:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 800be2a:	aa02      	add	r2, sp, #8
 800be2c:	ab01      	add	r3, sp, #4
 800be2e:	2000      	movs	r0, #0
 800be30:	4611      	mov	r1, r2
 800be32:	461a      	mov	r2, r3
 800be34:	f7f7 fdd4 	bl	80039e0 <chHeapStatus>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
 800be38:	4818      	ldr	r0, [pc, #96]	; (800be9c <test_011_002_execute+0x7c>)
 800be3a:	2110      	movs	r1, #16
 800be3c:	f7ff fdd0 	bl	800b9e0 <chHeapAlloc>
 800be40:	9003      	str	r0, [sp, #12]
    test_assert(p1 != NULL, "allocation failed");
 800be42:	9b03      	ldr	r3, [sp, #12]
 800be44:	2b00      	cmp	r3, #0
 800be46:	bf14      	ite	ne
 800be48:	2301      	movne	r3, #1
 800be4a:	2300      	moveq	r3, #0
 800be4c:	b2db      	uxtb	r3, r3
 800be4e:	4618      	mov	r0, r3
 800be50:	4913      	ldr	r1, [pc, #76]	; (800bea0 <test_011_002_execute+0x80>)
 800be52:	f7fb fbcd 	bl	80075f0 <_test_assert>
 800be56:	4603      	mov	r3, r0
 800be58:	2b00      	cmp	r3, #0
 800be5a:	d000      	beq.n	800be5e <test_011_002_execute+0x3e>
 800be5c:	e019      	b.n	800be92 <test_011_002_execute+0x72>
    chHeapFree(p1);
 800be5e:	9803      	ldr	r0, [sp, #12]
 800be60:	f7f7 fd4e 	bl	8003900 <chHeapFree>
  }

  /* [11.2.2] Testing allocation failure.*/
  test_set_step(2);
 800be64:	4b0c      	ldr	r3, [pc, #48]	; (800be98 <test_011_002_execute+0x78>)
 800be66:	2202      	movs	r2, #2
 800be68:	601a      	str	r2, [r3, #0]
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
 800be6a:	2000      	movs	r0, #0
 800be6c:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800be70:	f7ff fdb6 	bl	800b9e0 <chHeapAlloc>
 800be74:	9003      	str	r0, [sp, #12]
    test_assert(p1 == NULL, "allocation not failed");
 800be76:	9b03      	ldr	r3, [sp, #12]
 800be78:	2b00      	cmp	r3, #0
 800be7a:	bf0c      	ite	eq
 800be7c:	2301      	moveq	r3, #1
 800be7e:	2300      	movne	r3, #0
 800be80:	b2db      	uxtb	r3, r3
 800be82:	4618      	mov	r0, r3
 800be84:	4907      	ldr	r1, [pc, #28]	; (800bea4 <test_011_002_execute+0x84>)
 800be86:	f7fb fbb3 	bl	80075f0 <_test_assert>
 800be8a:	4603      	mov	r3, r0
 800be8c:	2b00      	cmp	r3, #0
 800be8e:	d000      	beq.n	800be92 <test_011_002_execute+0x72>
 800be90:	bf00      	nop
  }
}
 800be92:	b005      	add	sp, #20
 800be94:	f85d fb04 	ldr.w	pc, [sp], #4
 800be98:	20000cac 	.word	0x20000cac
 800be9c:	20001330 	.word	0x20001330
 800bea0:	0800f4f0 	.word	0x0800f4f0
 800bea4:	0800f4d8 	.word	0x0800f4d8
	...

0800beb0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800beb0:	4b01      	ldr	r3, [pc, #4]	; (800beb8 <chThdGetSelfX+0x8>)
 800beb2:	699b      	ldr	r3, [r3, #24]
}
 800beb4:	4618      	mov	r0, r3
 800beb6:	4770      	bx	lr
 800beb8:	20000af8 	.word	0x20000af8
 800bebc:	f3af 8000 	nop.w

0800bec0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800bec0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 800bec2:	f7ff fff5 	bl	800beb0 <chThdGetSelfX>
 800bec6:	4603      	mov	r3, r0
 800bec8:	689b      	ldr	r3, [r3, #8]
}
 800beca:	4618      	mov	r0, r3
 800becc:	bd08      	pop	{r3, pc}
 800bece:	bf00      	nop

0800bed0 <dyn_thread1>:
#endif
#if CH_CFG_USE_MEMPOOLS
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {
 800bed0:	b500      	push	{lr}
 800bed2:	b083      	sub	sp, #12
 800bed4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800bed6:	9b01      	ldr	r3, [sp, #4]
 800bed8:	781b      	ldrb	r3, [r3, #0]
 800beda:	4618      	mov	r0, r3
 800bedc:	f7fb fc68 	bl	80077b0 <test_emit_token>
}
 800bee0:	b003      	add	sp, #12
 800bee2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bee6:	bf00      	nop
 800bee8:	f3af 8000 	nop.w
 800beec:	f3af 8000 	nop.w

0800bef0 <test_012_001_setup>:
 *   freeing memory.
 * - [12.1.7] Getting heap info again for verification.
 * .
 */

static void test_012_001_setup(void) {
 800bef0:	b508      	push	{r3, lr}
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
 800bef2:	4803      	ldr	r0, [pc, #12]	; (800bf00 <test_012_001_setup+0x10>)
 800bef4:	4903      	ldr	r1, [pc, #12]	; (800bf04 <test_012_001_setup+0x14>)
 800bef6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800befa:	f7f7 fbf9 	bl	80036f0 <chHeapObjectInit>
}
 800befe:	bd08      	pop	{r3, pc}
 800bf00:	200009b0 	.word	0x200009b0
 800bf04:	20000cc8 	.word	0x20000cc8
 800bf08:	f3af 8000 	nop.w
 800bf0c:	f3af 8000 	nop.w

0800bf10 <test_012_001_execute>:

static void test_012_001_execute(void) {
 800bf10:	b510      	push	{r4, lr}
 800bf12:	b08a      	sub	sp, #40	; 0x28
  size_t n1, total1, largest1;
  size_t n2, total2, largest2;
  tprio_t prio;

  /* [12.1.1] Getting base priority for threads.*/
  test_set_step(1);
 800bf14:	4b65      	ldr	r3, [pc, #404]	; (800c0ac <test_012_001_execute+0x19c>)
 800bf16:	2201      	movs	r2, #1
 800bf18:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800bf1a:	f7ff ffd1 	bl	800bec0 <chThdGetPriorityX>
 800bf1e:	9009      	str	r0, [sp, #36]	; 0x24
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
 800bf20:	4b62      	ldr	r3, [pc, #392]	; (800c0ac <test_012_001_execute+0x19c>)
 800bf22:	2202      	movs	r2, #2
 800bf24:	601a      	str	r2, [r3, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800bf26:	aa06      	add	r2, sp, #24
 800bf28:	ab05      	add	r3, sp, #20
 800bf2a:	4861      	ldr	r0, [pc, #388]	; (800c0b0 <test_012_001_execute+0x1a0>)
 800bf2c:	4611      	mov	r1, r2
 800bf2e:	461a      	mov	r2, r3
 800bf30:	f7f7 fd56 	bl	80039e0 <chHeapStatus>
 800bf34:	9008      	str	r0, [sp, #32]
    test_assert(n1 == 1, "heap fragmented");
 800bf36:	9b08      	ldr	r3, [sp, #32]
 800bf38:	2b01      	cmp	r3, #1
 800bf3a:	bf0c      	ite	eq
 800bf3c:	2301      	moveq	r3, #1
 800bf3e:	2300      	movne	r3, #0
 800bf40:	b2db      	uxtb	r3, r3
 800bf42:	4618      	mov	r0, r3
 800bf44:	495b      	ldr	r1, [pc, #364]	; (800c0b4 <test_012_001_execute+0x1a4>)
 800bf46:	f7fb fb53 	bl	80075f0 <_test_assert>
 800bf4a:	4603      	mov	r3, r0
 800bf4c:	2b00      	cmp	r3, #0
 800bf4e:	d000      	beq.n	800bf52 <test_012_001_execute+0x42>
 800bf50:	e0a9      	b.n	800c0a6 <test_012_001_execute+0x196>
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 800bf52:	4b56      	ldr	r3, [pc, #344]	; (800c0ac <test_012_001_execute+0x19c>)
 800bf54:	2203      	movs	r2, #3
 800bf56:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 800bf58:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bf5a:	1e5c      	subs	r4, r3, #1
 800bf5c:	4b56      	ldr	r3, [pc, #344]	; (800c0b8 <test_012_001_execute+0x1a8>)
 800bf5e:	9300      	str	r3, [sp, #0]
 800bf60:	4b56      	ldr	r3, [pc, #344]	; (800c0bc <test_012_001_execute+0x1ac>)
 800bf62:	9301      	str	r3, [sp, #4]
 800bf64:	4852      	ldr	r0, [pc, #328]	; (800c0b0 <test_012_001_execute+0x1a0>)
 800bf66:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bf6a:	4a55      	ldr	r2, [pc, #340]	; (800c0c0 <test_012_001_execute+0x1b0>)
 800bf6c:	4623      	mov	r3, r4
 800bf6e:	f7f7 f817 	bl	8002fa0 <chThdCreateFromHeap>
 800bf72:	4602      	mov	r2, r0
 800bf74:	4b53      	ldr	r3, [pc, #332]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800bf76:	601a      	str	r2, [r3, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 800bf78:	4b52      	ldr	r3, [pc, #328]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800bf7a:	681b      	ldr	r3, [r3, #0]
 800bf7c:	2b00      	cmp	r3, #0
 800bf7e:	bf14      	ite	ne
 800bf80:	2301      	movne	r3, #1
 800bf82:	2300      	moveq	r3, #0
 800bf84:	b2db      	uxtb	r3, r3
 800bf86:	4618      	mov	r0, r3
 800bf88:	494f      	ldr	r1, [pc, #316]	; (800c0c8 <test_012_001_execute+0x1b8>)
 800bf8a:	f7fb fb31 	bl	80075f0 <_test_assert>
 800bf8e:	4603      	mov	r3, r0
 800bf90:	2b00      	cmp	r3, #0
 800bf92:	d000      	beq.n	800bf96 <test_012_001_execute+0x86>
 800bf94:	e087      	b.n	800c0a6 <test_012_001_execute+0x196>
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 800bf96:	4b45      	ldr	r3, [pc, #276]	; (800c0ac <test_012_001_execute+0x19c>)
 800bf98:	2204      	movs	r2, #4
 800bf9a:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 800bf9c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bf9e:	1e9c      	subs	r4, r3, #2
 800bfa0:	4b45      	ldr	r3, [pc, #276]	; (800c0b8 <test_012_001_execute+0x1a8>)
 800bfa2:	9300      	str	r3, [sp, #0]
 800bfa4:	4b49      	ldr	r3, [pc, #292]	; (800c0cc <test_012_001_execute+0x1bc>)
 800bfa6:	9301      	str	r3, [sp, #4]
 800bfa8:	4841      	ldr	r0, [pc, #260]	; (800c0b0 <test_012_001_execute+0x1a0>)
 800bfaa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800bfae:	4a48      	ldr	r2, [pc, #288]	; (800c0d0 <test_012_001_execute+0x1c0>)
 800bfb0:	4623      	mov	r3, r4
 800bfb2:	f7f6 fff5 	bl	8002fa0 <chThdCreateFromHeap>
 800bfb6:	4602      	mov	r2, r0
 800bfb8:	4b42      	ldr	r3, [pc, #264]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800bfba:	605a      	str	r2, [r3, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 800bfbc:	4b41      	ldr	r3, [pc, #260]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800bfbe:	685b      	ldr	r3, [r3, #4]
 800bfc0:	2b00      	cmp	r3, #0
 800bfc2:	bf14      	ite	ne
 800bfc4:	2301      	movne	r3, #1
 800bfc6:	2300      	moveq	r3, #0
 800bfc8:	b2db      	uxtb	r3, r3
 800bfca:	4618      	mov	r0, r3
 800bfcc:	493e      	ldr	r1, [pc, #248]	; (800c0c8 <test_012_001_execute+0x1b8>)
 800bfce:	f7fb fb0f 	bl	80075f0 <_test_assert>
 800bfd2:	4603      	mov	r3, r0
 800bfd4:	2b00      	cmp	r3, #0
 800bfd6:	d000      	beq.n	800bfda <test_012_001_execute+0xca>
 800bfd8:	e065      	b.n	800c0a6 <test_012_001_execute+0x196>
  }

  /* [12.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 800bfda:	4b34      	ldr	r3, [pc, #208]	; (800c0ac <test_012_001_execute+0x19c>)
 800bfdc:	2205      	movs	r2, #5
 800bfde:	601a      	str	r2, [r3, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 800bfe0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bfe2:	1edc      	subs	r4, r3, #3
 800bfe4:	4b34      	ldr	r3, [pc, #208]	; (800c0b8 <test_012_001_execute+0x1a8>)
 800bfe6:	9300      	str	r3, [sp, #0]
 800bfe8:	4b3a      	ldr	r3, [pc, #232]	; (800c0d4 <test_012_001_execute+0x1c4>)
 800bfea:	9301      	str	r3, [sp, #4]
 800bfec:	4830      	ldr	r0, [pc, #192]	; (800c0b0 <test_012_001_execute+0x1a0>)
 800bfee:	493a      	ldr	r1, [pc, #232]	; (800c0d8 <test_012_001_execute+0x1c8>)
 800bff0:	4a3a      	ldr	r2, [pc, #232]	; (800c0dc <test_012_001_execute+0x1cc>)
 800bff2:	4623      	mov	r3, r4
 800bff4:	f7f6 ffd4 	bl	8002fa0 <chThdCreateFromHeap>
 800bff8:	4602      	mov	r2, r0
 800bffa:	4b32      	ldr	r3, [pc, #200]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800bffc:	609a      	str	r2, [r3, #8]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 800bffe:	4b31      	ldr	r3, [pc, #196]	; (800c0c4 <test_012_001_execute+0x1b4>)
 800c000:	689b      	ldr	r3, [r3, #8]
 800c002:	2b00      	cmp	r3, #0
 800c004:	bf0c      	ite	eq
 800c006:	2301      	moveq	r3, #1
 800c008:	2300      	movne	r3, #0
 800c00a:	b2db      	uxtb	r3, r3
 800c00c:	4618      	mov	r0, r3
 800c00e:	4934      	ldr	r1, [pc, #208]	; (800c0e0 <test_012_001_execute+0x1d0>)
 800c010:	f7fb faee 	bl	80075f0 <_test_assert>
 800c014:	4603      	mov	r3, r0
 800c016:	2b00      	cmp	r3, #0
 800c018:	d000      	beq.n	800c01c <test_012_001_execute+0x10c>
 800c01a:	e044      	b.n	800c0a6 <test_012_001_execute+0x196>
  }

  /* [12.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 800c01c:	4b23      	ldr	r3, [pc, #140]	; (800c0ac <test_012_001_execute+0x19c>)
 800c01e:	2206      	movs	r2, #6
 800c020:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 800c022:	f7fb fd7d 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 800c026:	482f      	ldr	r0, [pc, #188]	; (800c0e4 <test_012_001_execute+0x1d4>)
 800c028:	492f      	ldr	r1, [pc, #188]	; (800c0e8 <test_012_001_execute+0x1d8>)
 800c02a:	f7fb faf9 	bl	8007620 <_test_assert_sequence>
 800c02e:	4603      	mov	r3, r0
 800c030:	2b00      	cmp	r3, #0
 800c032:	d000      	beq.n	800c036 <test_012_001_execute+0x126>
 800c034:	e037      	b.n	800c0a6 <test_012_001_execute+0x196>
  }

  /* [12.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 800c036:	4b1d      	ldr	r3, [pc, #116]	; (800c0ac <test_012_001_execute+0x19c>)
 800c038:	2207      	movs	r2, #7
 800c03a:	601a      	str	r2, [r3, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 800c03c:	aa04      	add	r2, sp, #16
 800c03e:	ab03      	add	r3, sp, #12
 800c040:	481b      	ldr	r0, [pc, #108]	; (800c0b0 <test_012_001_execute+0x1a0>)
 800c042:	4611      	mov	r1, r2
 800c044:	461a      	mov	r2, r3
 800c046:	f7f7 fccb 	bl	80039e0 <chHeapStatus>
 800c04a:	9007      	str	r0, [sp, #28]
    test_assert(n1 == n2, "fragmentation changed");
 800c04c:	9a08      	ldr	r2, [sp, #32]
 800c04e:	9b07      	ldr	r3, [sp, #28]
 800c050:	429a      	cmp	r2, r3
 800c052:	bf0c      	ite	eq
 800c054:	2301      	moveq	r3, #1
 800c056:	2300      	movne	r3, #0
 800c058:	b2db      	uxtb	r3, r3
 800c05a:	4618      	mov	r0, r3
 800c05c:	4923      	ldr	r1, [pc, #140]	; (800c0ec <test_012_001_execute+0x1dc>)
 800c05e:	f7fb fac7 	bl	80075f0 <_test_assert>
 800c062:	4603      	mov	r3, r0
 800c064:	2b00      	cmp	r3, #0
 800c066:	d000      	beq.n	800c06a <test_012_001_execute+0x15a>
 800c068:	e01d      	b.n	800c0a6 <test_012_001_execute+0x196>
    test_assert(total1 == total2, "total free space changed");
 800c06a:	9a06      	ldr	r2, [sp, #24]
 800c06c:	9b04      	ldr	r3, [sp, #16]
 800c06e:	429a      	cmp	r2, r3
 800c070:	bf0c      	ite	eq
 800c072:	2301      	moveq	r3, #1
 800c074:	2300      	movne	r3, #0
 800c076:	b2db      	uxtb	r3, r3
 800c078:	4618      	mov	r0, r3
 800c07a:	491d      	ldr	r1, [pc, #116]	; (800c0f0 <test_012_001_execute+0x1e0>)
 800c07c:	f7fb fab8 	bl	80075f0 <_test_assert>
 800c080:	4603      	mov	r3, r0
 800c082:	2b00      	cmp	r3, #0
 800c084:	d000      	beq.n	800c088 <test_012_001_execute+0x178>
 800c086:	e00e      	b.n	800c0a6 <test_012_001_execute+0x196>
    test_assert(largest1 == largest2, "largest fragment size changed");
 800c088:	9a05      	ldr	r2, [sp, #20]
 800c08a:	9b03      	ldr	r3, [sp, #12]
 800c08c:	429a      	cmp	r2, r3
 800c08e:	bf0c      	ite	eq
 800c090:	2301      	moveq	r3, #1
 800c092:	2300      	movne	r3, #0
 800c094:	b2db      	uxtb	r3, r3
 800c096:	4618      	mov	r0, r3
 800c098:	4916      	ldr	r1, [pc, #88]	; (800c0f4 <test_012_001_execute+0x1e4>)
 800c09a:	f7fb faa9 	bl	80075f0 <_test_assert>
 800c09e:	4603      	mov	r3, r0
 800c0a0:	2b00      	cmp	r3, #0
 800c0a2:	d000      	beq.n	800c0a6 <test_012_001_execute+0x196>
 800c0a4:	bf00      	nop
  }
}
 800c0a6:	b00a      	add	sp, #40	; 0x28
 800c0a8:	bd10      	pop	{r4, pc}
 800c0aa:	bf00      	nop
 800c0ac:	20000cac 	.word	0x20000cac
 800c0b0:	200009b0 	.word	0x200009b0
 800c0b4:	0800f5b8 	.word	0x0800f5b8
 800c0b8:	0800bed1 	.word	0x0800bed1
 800c0bc:	0800f5d0 	.word	0x0800f5d0
 800c0c0:	0800f5c8 	.word	0x0800f5c8
 800c0c4:	20000cb0 	.word	0x20000cb0
 800c0c8:	0800f5d4 	.word	0x0800f5d4
 800c0cc:	0800f5f4 	.word	0x0800f5f4
 800c0d0:	0800f5ec 	.word	0x0800f5ec
 800c0d4:	0800f600 	.word	0x0800f600
 800c0d8:	000200c8 	.word	0x000200c8
 800c0dc:	0800f5f8 	.word	0x0800f5f8
 800c0e0:	0800f604 	.word	0x0800f604
 800c0e4:	0800f620 	.word	0x0800f620
 800c0e8:	0800f624 	.word	0x0800f624
 800c0ec:	0800f638 	.word	0x0800f638
 800c0f0:	0800f650 	.word	0x0800f650
 800c0f4:	0800f66c 	.word	0x0800f66c
 800c0f8:	f3af 8000 	nop.w
 800c0fc:	f3af 8000 	nop.w

0800c100 <test_012_002_setup>:
 *   execution sequence.
 * - [12.2.6] Testing that the pool contains four elements again.
 * .
 */

static void test_012_002_setup(void) {
 800c100:	b508      	push	{r3, lr}
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800c102:	4803      	ldr	r0, [pc, #12]	; (800c110 <test_012_002_setup+0x10>)
 800c104:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c108:	2200      	movs	r2, #0
 800c10a:	f7f7 fcf9 	bl	8003b00 <chPoolObjectInit>
}
 800c10e:	bd08      	pop	{r3, pc}
 800c110:	200009d0 	.word	0x200009d0
 800c114:	f3af 8000 	nop.w
 800c118:	f3af 8000 	nop.w
 800c11c:	f3af 8000 	nop.w

0800c120 <test_012_002_execute>:

static void test_012_002_execute(void) {
 800c120:	b500      	push	{lr}
 800c122:	b085      	sub	sp, #20
  unsigned i;
  tprio_t prio;

  /* [12.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 800c124:	4b63      	ldr	r3, [pc, #396]	; (800c2b4 <test_012_002_execute+0x194>)
 800c126:	2201      	movs	r2, #1
 800c128:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 800c12a:	2300      	movs	r3, #0
 800c12c:	9303      	str	r3, [sp, #12]
 800c12e:	e00a      	b.n	800c146 <test_012_002_execute+0x26>
      chPoolFree(&mp1, wa[i]);
 800c130:	4a61      	ldr	r2, [pc, #388]	; (800c2b8 <test_012_002_execute+0x198>)
 800c132:	9b03      	ldr	r3, [sp, #12]
 800c134:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c138:	4860      	ldr	r0, [pc, #384]	; (800c2bc <test_012_002_execute+0x19c>)
 800c13a:	4619      	mov	r1, r3
 800c13c:	f7f7 fd48 	bl	8003bd0 <chPoolFree>
  tprio_t prio;

  /* [12.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 800c140:	9b03      	ldr	r3, [sp, #12]
 800c142:	3301      	adds	r3, #1
 800c144:	9303      	str	r3, [sp, #12]
 800c146:	9b03      	ldr	r3, [sp, #12]
 800c148:	2b03      	cmp	r3, #3
 800c14a:	d9f1      	bls.n	800c130 <test_012_002_execute+0x10>
      chPoolFree(&mp1, wa[i]);
  }

  /* [12.2.2] Getting base priority for threads.*/
  test_set_step(2);
 800c14c:	4b59      	ldr	r3, [pc, #356]	; (800c2b4 <test_012_002_execute+0x194>)
 800c14e:	2202      	movs	r2, #2
 800c150:	601a      	str	r2, [r3, #0]
  {
    prio = chThdGetPriorityX();
 800c152:	f7ff feb5 	bl	800bec0 <chThdGetPriorityX>
 800c156:	9002      	str	r0, [sp, #8]
  }

  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
 800c158:	4b56      	ldr	r3, [pc, #344]	; (800c2b4 <test_012_002_execute+0x194>)
 800c15a:	2203      	movs	r2, #3
 800c15c:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800c15e:	9b02      	ldr	r3, [sp, #8]
 800c160:	1e5a      	subs	r2, r3, #1
 800c162:	4b57      	ldr	r3, [pc, #348]	; (800c2c0 <test_012_002_execute+0x1a0>)
 800c164:	9300      	str	r3, [sp, #0]
 800c166:	4855      	ldr	r0, [pc, #340]	; (800c2bc <test_012_002_execute+0x19c>)
 800c168:	4956      	ldr	r1, [pc, #344]	; (800c2c4 <test_012_002_execute+0x1a4>)
 800c16a:	4b57      	ldr	r3, [pc, #348]	; (800c2c8 <test_012_002_execute+0x1a8>)
 800c16c:	f7f6 ff50 	bl	8003010 <chThdCreateFromMemoryPool>
 800c170:	4602      	mov	r2, r0
 800c172:	4b56      	ldr	r3, [pc, #344]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c174:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800c176:	9b02      	ldr	r3, [sp, #8]
 800c178:	1e9a      	subs	r2, r3, #2
 800c17a:	4b55      	ldr	r3, [pc, #340]	; (800c2d0 <test_012_002_execute+0x1b0>)
 800c17c:	9300      	str	r3, [sp, #0]
 800c17e:	484f      	ldr	r0, [pc, #316]	; (800c2bc <test_012_002_execute+0x19c>)
 800c180:	4954      	ldr	r1, [pc, #336]	; (800c2d4 <test_012_002_execute+0x1b4>)
 800c182:	4b51      	ldr	r3, [pc, #324]	; (800c2c8 <test_012_002_execute+0x1a8>)
 800c184:	f7f6 ff44 	bl	8003010 <chThdCreateFromMemoryPool>
 800c188:	4602      	mov	r2, r0
 800c18a:	4b50      	ldr	r3, [pc, #320]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c18c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800c18e:	9b02      	ldr	r3, [sp, #8]
 800c190:	1eda      	subs	r2, r3, #3
 800c192:	4b51      	ldr	r3, [pc, #324]	; (800c2d8 <test_012_002_execute+0x1b8>)
 800c194:	9300      	str	r3, [sp, #0]
 800c196:	4849      	ldr	r0, [pc, #292]	; (800c2bc <test_012_002_execute+0x19c>)
 800c198:	4950      	ldr	r1, [pc, #320]	; (800c2dc <test_012_002_execute+0x1bc>)
 800c19a:	4b4b      	ldr	r3, [pc, #300]	; (800c2c8 <test_012_002_execute+0x1a8>)
 800c19c:	f7f6 ff38 	bl	8003010 <chThdCreateFromMemoryPool>
 800c1a0:	4602      	mov	r2, r0
 800c1a2:	4b4a      	ldr	r3, [pc, #296]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1a4:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800c1a6:	9b02      	ldr	r3, [sp, #8]
 800c1a8:	1f1a      	subs	r2, r3, #4
 800c1aa:	4b4d      	ldr	r3, [pc, #308]	; (800c2e0 <test_012_002_execute+0x1c0>)
 800c1ac:	9300      	str	r3, [sp, #0]
 800c1ae:	4843      	ldr	r0, [pc, #268]	; (800c2bc <test_012_002_execute+0x19c>)
 800c1b0:	494c      	ldr	r1, [pc, #304]	; (800c2e4 <test_012_002_execute+0x1c4>)
 800c1b2:	4b45      	ldr	r3, [pc, #276]	; (800c2c8 <test_012_002_execute+0x1a8>)
 800c1b4:	f7f6 ff2c 	bl	8003010 <chThdCreateFromMemoryPool>
 800c1b8:	4602      	mov	r2, r0
 800c1ba:	4b44      	ldr	r3, [pc, #272]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1bc:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800c1be:	9b02      	ldr	r3, [sp, #8]
 800c1c0:	1f5a      	subs	r2, r3, #5
 800c1c2:	4b49      	ldr	r3, [pc, #292]	; (800c2e8 <test_012_002_execute+0x1c8>)
 800c1c4:	9300      	str	r3, [sp, #0]
 800c1c6:	483d      	ldr	r0, [pc, #244]	; (800c2bc <test_012_002_execute+0x19c>)
 800c1c8:	4948      	ldr	r1, [pc, #288]	; (800c2ec <test_012_002_execute+0x1cc>)
 800c1ca:	4b3f      	ldr	r3, [pc, #252]	; (800c2c8 <test_012_002_execute+0x1a8>)
 800c1cc:	f7f6 ff20 	bl	8003010 <chThdCreateFromMemoryPool>
 800c1d0:	4602      	mov	r2, r0
 800c1d2:	4b3e      	ldr	r3, [pc, #248]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1d4:	611a      	str	r2, [r3, #16]
  }

  /* [12.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 800c1d6:	4b37      	ldr	r3, [pc, #220]	; (800c2b4 <test_012_002_execute+0x194>)
 800c1d8:	2204      	movs	r2, #4
 800c1da:	601a      	str	r2, [r3, #0]
  {
    test_assert((threads[0] != NULL) &&
 800c1dc:	4b3b      	ldr	r3, [pc, #236]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1de:	681b      	ldr	r3, [r3, #0]
 800c1e0:	2b00      	cmp	r3, #0
 800c1e2:	d00d      	beq.n	800c200 <test_012_002_execute+0xe0>
 800c1e4:	4b39      	ldr	r3, [pc, #228]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1e6:	685b      	ldr	r3, [r3, #4]
 800c1e8:	2b00      	cmp	r3, #0
 800c1ea:	d009      	beq.n	800c200 <test_012_002_execute+0xe0>
 800c1ec:	4b37      	ldr	r3, [pc, #220]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1ee:	689b      	ldr	r3, [r3, #8]
 800c1f0:	2b00      	cmp	r3, #0
 800c1f2:	d005      	beq.n	800c200 <test_012_002_execute+0xe0>
 800c1f4:	4b35      	ldr	r3, [pc, #212]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c1f6:	68db      	ldr	r3, [r3, #12]
 800c1f8:	2b00      	cmp	r3, #0
 800c1fa:	d001      	beq.n	800c200 <test_012_002_execute+0xe0>
 800c1fc:	2301      	movs	r3, #1
 800c1fe:	e000      	b.n	800c202 <test_012_002_execute+0xe2>
 800c200:	2300      	movs	r3, #0
 800c202:	f003 0301 	and.w	r3, r3, #1
 800c206:	b2db      	uxtb	r3, r3
 800c208:	4618      	mov	r0, r3
 800c20a:	4939      	ldr	r1, [pc, #228]	; (800c2f0 <test_012_002_execute+0x1d0>)
 800c20c:	f7fb f9f0 	bl	80075f0 <_test_assert>
 800c210:	4603      	mov	r3, r0
 800c212:	2b00      	cmp	r3, #0
 800c214:	d000      	beq.n	800c218 <test_012_002_execute+0xf8>
 800c216:	e049      	b.n	800c2ac <test_012_002_execute+0x18c>
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 800c218:	4b2c      	ldr	r3, [pc, #176]	; (800c2cc <test_012_002_execute+0x1ac>)
 800c21a:	691b      	ldr	r3, [r3, #16]
 800c21c:	2b00      	cmp	r3, #0
 800c21e:	bf0c      	ite	eq
 800c220:	2301      	moveq	r3, #1
 800c222:	2300      	movne	r3, #0
 800c224:	b2db      	uxtb	r3, r3
 800c226:	4618      	mov	r0, r3
 800c228:	4932      	ldr	r1, [pc, #200]	; (800c2f4 <test_012_002_execute+0x1d4>)
 800c22a:	f7fb f9e1 	bl	80075f0 <_test_assert>
 800c22e:	4603      	mov	r3, r0
 800c230:	2b00      	cmp	r3, #0
 800c232:	d000      	beq.n	800c236 <test_012_002_execute+0x116>
 800c234:	e03a      	b.n	800c2ac <test_012_002_execute+0x18c>
                "thread creation not failed");
  }

  /* [12.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 800c236:	4b1f      	ldr	r3, [pc, #124]	; (800c2b4 <test_012_002_execute+0x194>)
 800c238:	2205      	movs	r2, #5
 800c23a:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 800c23c:	f7fb fc70 	bl	8007b20 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800c240:	482d      	ldr	r0, [pc, #180]	; (800c2f8 <test_012_002_execute+0x1d8>)
 800c242:	492e      	ldr	r1, [pc, #184]	; (800c2fc <test_012_002_execute+0x1dc>)
 800c244:	f7fb f9ec 	bl	8007620 <_test_assert_sequence>
 800c248:	4603      	mov	r3, r0
 800c24a:	2b00      	cmp	r3, #0
 800c24c:	d000      	beq.n	800c250 <test_012_002_execute+0x130>
 800c24e:	e02d      	b.n	800c2ac <test_012_002_execute+0x18c>
  }

  /* [12.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 800c250:	4b18      	ldr	r3, [pc, #96]	; (800c2b4 <test_012_002_execute+0x194>)
 800c252:	2206      	movs	r2, #6
 800c254:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 800c256:	2300      	movs	r3, #0
 800c258:	9303      	str	r3, [sp, #12]
 800c25a:	e013      	b.n	800c284 <test_012_002_execute+0x164>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 800c25c:	4817      	ldr	r0, [pc, #92]	; (800c2bc <test_012_002_execute+0x19c>)
 800c25e:	f7f7 fc97 	bl	8003b90 <chPoolAlloc>
 800c262:	4603      	mov	r3, r0
 800c264:	2b00      	cmp	r3, #0
 800c266:	bf14      	ite	ne
 800c268:	2301      	movne	r3, #1
 800c26a:	2300      	moveq	r3, #0
 800c26c:	b2db      	uxtb	r3, r3
 800c26e:	4618      	mov	r0, r3
 800c270:	4923      	ldr	r1, [pc, #140]	; (800c300 <test_012_002_execute+0x1e0>)
 800c272:	f7fb f9bd 	bl	80075f0 <_test_assert>
 800c276:	4603      	mov	r3, r0
 800c278:	2b00      	cmp	r3, #0
 800c27a:	d000      	beq.n	800c27e <test_012_002_execute+0x15e>
 800c27c:	e016      	b.n	800c2ac <test_012_002_execute+0x18c>
  }

  /* [12.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 800c27e:	9b03      	ldr	r3, [sp, #12]
 800c280:	3301      	adds	r3, #1
 800c282:	9303      	str	r3, [sp, #12]
 800c284:	9b03      	ldr	r3, [sp, #12]
 800c286:	2b03      	cmp	r3, #3
 800c288:	d9e8      	bls.n	800c25c <test_012_002_execute+0x13c>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800c28a:	480c      	ldr	r0, [pc, #48]	; (800c2bc <test_012_002_execute+0x19c>)
 800c28c:	f7f7 fc80 	bl	8003b90 <chPoolAlloc>
 800c290:	4603      	mov	r3, r0
 800c292:	2b00      	cmp	r3, #0
 800c294:	bf0c      	ite	eq
 800c296:	2301      	moveq	r3, #1
 800c298:	2300      	movne	r3, #0
 800c29a:	b2db      	uxtb	r3, r3
 800c29c:	4618      	mov	r0, r3
 800c29e:	4919      	ldr	r1, [pc, #100]	; (800c304 <test_012_002_execute+0x1e4>)
 800c2a0:	f7fb f9a6 	bl	80075f0 <_test_assert>
 800c2a4:	4603      	mov	r3, r0
 800c2a6:	2b00      	cmp	r3, #0
 800c2a8:	d000      	beq.n	800c2ac <test_012_002_execute+0x18c>
 800c2aa:	bf00      	nop
  }
}
 800c2ac:	b005      	add	sp, #20
 800c2ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2b2:	bf00      	nop
 800c2b4:	20000cac 	.word	0x20000cac
 800c2b8:	0800e298 	.word	0x0800e298
 800c2bc:	200009d0 	.word	0x200009d0
 800c2c0:	0800f5d0 	.word	0x0800f5d0
 800c2c4:	0800f5c8 	.word	0x0800f5c8
 800c2c8:	0800bed1 	.word	0x0800bed1
 800c2cc:	20000cb0 	.word	0x20000cb0
 800c2d0:	0800f5f4 	.word	0x0800f5f4
 800c2d4:	0800f5ec 	.word	0x0800f5ec
 800c2d8:	0800f600 	.word	0x0800f600
 800c2dc:	0800f5f8 	.word	0x0800f5f8
 800c2e0:	0800f6c8 	.word	0x0800f6c8
 800c2e4:	0800f6c0 	.word	0x0800f6c0
 800c2e8:	0800f6d4 	.word	0x0800f6d4
 800c2ec:	0800f6cc 	.word	0x0800f6cc
 800c2f0:	0800f5d4 	.word	0x0800f5d4
 800c2f4:	0800f604 	.word	0x0800f604
 800c2f8:	0800f6d8 	.word	0x0800f6d8
 800c2fc:	0800f624 	.word	0x0800f624
 800c300:	0800f6e0 	.word	0x0800f6e0
 800c304:	0800f6f0 	.word	0x0800f6f0
	...

0800c310 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c310:	b082      	sub	sp, #8
 800c312:	2320      	movs	r3, #32
 800c314:	9301      	str	r3, [sp, #4]
 800c316:	9b01      	ldr	r3, [sp, #4]
 800c318:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c31c:	b002      	add	sp, #8
 800c31e:	4770      	bx	lr

0800c320 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c320:	b082      	sub	sp, #8
 800c322:	2300      	movs	r3, #0
 800c324:	9301      	str	r3, [sp, #4]
 800c326:	9b01      	ldr	r3, [sp, #4]
 800c328:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c32c:	b002      	add	sp, #8
 800c32e:	4770      	bx	lr

0800c330 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800c330:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c334:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800c336:	4618      	mov	r0, r3
 800c338:	4770      	bx	lr
 800c33a:	bf00      	nop
 800c33c:	f3af 8000 	nop.w

0800c340 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800c340:	b508      	push	{r3, lr}

  return stGetCounter();
 800c342:	f7ff fff5 	bl	800c330 <st_lld_get_counter>
 800c346:	4603      	mov	r3, r0
}
 800c348:	4618      	mov	r0, r3
 800c34a:	bd08      	pop	{r3, pc}
 800c34c:	f3af 8000 	nop.w

0800c350 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c350:	b508      	push	{r3, lr}

  port_lock();
 800c352:	f7ff ffdd 	bl	800c310 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c356:	bd08      	pop	{r3, pc}
 800c358:	f3af 8000 	nop.w
 800c35c:	f3af 8000 	nop.w

0800c360 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c360:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
 800c362:	f7ff ffdd 	bl	800c320 <port_unlock>
}
 800c366:	bd08      	pop	{r3, pc}
 800c368:	f3af 8000 	nop.w
 800c36c:	f3af 8000 	nop.w

0800c370 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800c370:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800c372:	f7ff ffe5 	bl	800c340 <port_timer_get_time>
 800c376:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c378:	4618      	mov	r0, r3
 800c37a:	bd08      	pop	{r3, pc}
 800c37c:	f3af 8000 	nop.w

0800c380 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 800c380:	b084      	sub	sp, #16
 800c382:	9003      	str	r0, [sp, #12]
 800c384:	9102      	str	r1, [sp, #8]
 800c386:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800c388:	9a03      	ldr	r2, [sp, #12]
 800c38a:	9b02      	ldr	r3, [sp, #8]
 800c38c:	1ad2      	subs	r2, r2, r3
 800c38e:	9901      	ldr	r1, [sp, #4]
 800c390:	9b02      	ldr	r3, [sp, #8]
 800c392:	1acb      	subs	r3, r1, r3
 800c394:	429a      	cmp	r2, r3
 800c396:	bf34      	ite	cc
 800c398:	2301      	movcc	r3, #1
 800c39a:	2300      	movcs	r3, #0
 800c39c:	b2db      	uxtb	r3, r3
}
 800c39e:	4618      	mov	r0, r3
 800c3a0:	b004      	add	sp, #16
 800c3a2:	4770      	bx	lr
 800c3a4:	f3af 8000 	nop.w
 800c3a8:	f3af 8000 	nop.w
 800c3ac:	f3af 8000 	nop.w

0800c3b0 <chVTIsSystemTimeWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
static inline bool chVTIsSystemTimeWithinX(systime_t start, systime_t end) {
 800c3b0:	b500      	push	{lr}
 800c3b2:	b083      	sub	sp, #12
 800c3b4:	9001      	str	r0, [sp, #4]
 800c3b6:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTimeX(), start, end);
 800c3b8:	f7ff ffda 	bl	800c370 <chVTGetSystemTimeX>
 800c3bc:	4603      	mov	r3, r0
 800c3be:	4618      	mov	r0, r3
 800c3c0:	9901      	ldr	r1, [sp, #4]
 800c3c2:	9a00      	ldr	r2, [sp, #0]
 800c3c4:	f7ff ffdc 	bl	800c380 <chVTIsTimeWithinX>
 800c3c8:	4603      	mov	r3, r0
}
 800c3ca:	4618      	mov	r0, r3
 800c3cc:	b003      	add	sp, #12
 800c3ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800c3d2:	bf00      	nop
 800c3d4:	f3af 8000 	nop.w
 800c3d8:	f3af 8000 	nop.w
 800c3dc:	f3af 8000 	nop.w

0800c3e0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800c3e0:	4b01      	ldr	r3, [pc, #4]	; (800c3e8 <chThdGetSelfX+0x8>)
 800c3e2:	699b      	ldr	r3, [r3, #24]
}
 800c3e4:	4618      	mov	r0, r3
 800c3e6:	4770      	bx	lr
 800c3e8:	20000af8 	.word	0x20000af8
 800c3ec:	f3af 8000 	nop.w

0800c3f0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c3f0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->prio;
 800c3f2:	f7ff fff5 	bl	800c3e0 <chThdGetSelfX>
 800c3f6:	4603      	mov	r3, r0
 800c3f8:	689b      	ldr	r3, [r3, #8]
}
 800c3fa:	4618      	mov	r0, r3
 800c3fc:	bd08      	pop	{r3, pc}
 800c3fe:	bf00      	nop

0800c400 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 800c400:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800c402:	f7ff ffed 	bl	800c3e0 <chThdGetSelfX>
 800c406:	4603      	mov	r3, r0
 800c408:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800c40c:	f003 0304 	and.w	r3, r3, #4
 800c410:	2b00      	cmp	r3, #0
 800c412:	bf14      	ite	ne
 800c414:	2301      	movne	r3, #1
 800c416:	2300      	moveq	r3, #0
 800c418:	b2db      	uxtb	r3, r3
}
 800c41a:	4618      	mov	r0, r3
 800c41c:	bd08      	pop	{r3, pc}
 800c41e:	bf00      	nop

0800c420 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800c420:	b082      	sub	sp, #8
 800c422:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");

  return tp->u.sentmsg;
 800c424:	9b01      	ldr	r3, [sp, #4]
 800c426:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800c428:	4618      	mov	r0, r3
 800c42a:	b002      	add	sp, #8
 800c42c:	4770      	bx	lr
 800c42e:	bf00      	nop

0800c430 <tmo>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 800c430:	b082      	sub	sp, #8
 800c432:	9001      	str	r0, [sp, #4]
 800c434:	b002      	add	sp, #8
 800c436:	4770      	bx	lr
 800c438:	f3af 8000 	nop.w
 800c43c:	f3af 8000 	nop.w

0800c440 <bmk_thread1>:

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 800c440:	b500      	push	{lr}
 800c442:	b085      	sub	sp, #20
 800c444:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 800c446:	f7f6 fd53 	bl	8002ef0 <chMsgWait>
 800c44a:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 800c44c:	9803      	ldr	r0, [sp, #12]
 800c44e:	f7ff ffe7 	bl	800c420 <chMsgGet>
 800c452:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 800c454:	9803      	ldr	r0, [sp, #12]
 800c456:	9902      	ldr	r1, [sp, #8]
 800c458:	f7f6 fd72 	bl	8002f40 <chMsgRelease>
  } while (msg);
 800c45c:	9b02      	ldr	r3, [sp, #8]
 800c45e:	2b00      	cmp	r3, #0
 800c460:	d1f1      	bne.n	800c446 <bmk_thread1+0x6>
}
 800c462:	b005      	add	sp, #20
 800c464:	f85d fb04 	ldr.w	pc, [sp], #4
 800c468:	f3af 8000 	nop.w
 800c46c:	f3af 8000 	nop.w

0800c470 <msg_loop_test>:

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 800c470:	b500      	push	{lr}
 800c472:	b087      	sub	sp, #28
 800c474:	9001      	str	r0, [sp, #4]
  systime_t start, end;

  uint32_t n = 0;
 800c476:	2300      	movs	r3, #0
 800c478:	9305      	str	r3, [sp, #20]
  start = test_wait_tick();
 800c47a:	f7fb fb79 	bl	8007b70 <test_wait_tick>
 800c47e:	9004      	str	r0, [sp, #16]
  end = start + MS2ST(1000);
 800c480:	9b04      	ldr	r3, [sp, #16]
 800c482:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c486:	3310      	adds	r3, #16
 800c488:	9303      	str	r3, [sp, #12]
  do {
    (void)chMsgSend(tp, 1);
 800c48a:	9801      	ldr	r0, [sp, #4]
 800c48c:	2101      	movs	r1, #1
 800c48e:	f7f6 fcff 	bl	8002e90 <chMsgSend>
    n++;
 800c492:	9b05      	ldr	r3, [sp, #20]
 800c494:	3301      	adds	r3, #1
 800c496:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 800c498:	9804      	ldr	r0, [sp, #16]
 800c49a:	9903      	ldr	r1, [sp, #12]
 800c49c:	f7ff ff88 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800c4a0:	4603      	mov	r3, r0
 800c4a2:	2b00      	cmp	r3, #0
 800c4a4:	d1f1      	bne.n	800c48a <msg_loop_test+0x1a>
  (void)chMsgSend(tp, 0);
 800c4a6:	9801      	ldr	r0, [sp, #4]
 800c4a8:	2100      	movs	r1, #0
 800c4aa:	f7f6 fcf1 	bl	8002e90 <chMsgSend>
  return n;
 800c4ae:	9b05      	ldr	r3, [sp, #20]
}
 800c4b0:	4618      	mov	r0, r3
 800c4b2:	b007      	add	sp, #28
 800c4b4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c4b8:	f3af 8000 	nop.w
 800c4bc:	f3af 8000 	nop.w

0800c4c0 <bmk_thread3>:
#endif

static THD_FUNCTION(bmk_thread3, p) {
 800c4c0:	b500      	push	{lr}
 800c4c2:	b083      	sub	sp, #12
 800c4c4:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 800c4c6:	9b01      	ldr	r3, [sp, #4]
 800c4c8:	4618      	mov	r0, r3
 800c4ca:	f7f5 f869 	bl	80015a0 <chThdExit>
}
 800c4ce:	b003      	add	sp, #12
 800c4d0:	f85d fb04 	ldr.w	pc, [sp], #4
 800c4d4:	f3af 8000 	nop.w
 800c4d8:	f3af 8000 	nop.w
 800c4dc:	f3af 8000 	nop.w

0800c4e0 <bmk_thread4>:

static THD_FUNCTION(bmk_thread4, p) {
 800c4e0:	b500      	push	{lr}
 800c4e2:	b085      	sub	sp, #20
 800c4e4:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 800c4e6:	f7ff ff7b 	bl	800c3e0 <chThdGetSelfX>
 800c4ea:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 800c4ec:	f7ff ff30 	bl	800c350 <chSysLock>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800c4f0:	2003      	movs	r0, #3
 800c4f2:	f7f4 fc85 	bl	8000e00 <chSchGoSleepS>
    msg = self->u.rdymsg;
 800c4f6:	9b03      	ldr	r3, [sp, #12]
 800c4f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c4fa:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 800c4fc:	9b02      	ldr	r3, [sp, #8]
 800c4fe:	2b00      	cmp	r3, #0
 800c500:	d0f6      	beq.n	800c4f0 <bmk_thread4+0x10>
  chSysUnlock();
 800c502:	f7ff ff2d 	bl	800c360 <chSysUnlock>
}
 800c506:	b005      	add	sp, #20
 800c508:	f85d fb04 	ldr.w	pc, [sp], #4
 800c50c:	f3af 8000 	nop.w

0800c510 <bmk_thread7>:

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 800c510:	b500      	push	{lr}
 800c512:	b083      	sub	sp, #12
 800c514:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
 800c516:	e002      	b.n	800c51e <bmk_thread7+0xe>
    chSemWait(&sem1);
 800c518:	4806      	ldr	r0, [pc, #24]	; (800c534 <bmk_thread7+0x24>)
 800c51a:	f7f5 fc59 	bl	8001dd0 <chSemWait>

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 800c51e:	f7ff ff6f 	bl	800c400 <chThdShouldTerminateX>
 800c522:	4603      	mov	r3, r0
 800c524:	f083 0301 	eor.w	r3, r3, #1
 800c528:	b2db      	uxtb	r3, r3
 800c52a:	2b00      	cmp	r3, #0
 800c52c:	d1f4      	bne.n	800c518 <bmk_thread7+0x8>
    chSemWait(&sem1);
}
 800c52e:	b003      	add	sp, #12
 800c530:	f85d fb04 	ldr.w	pc, [sp], #4
 800c534:	200009dc 	.word	0x200009dc
 800c538:	f3af 8000 	nop.w
 800c53c:	f3af 8000 	nop.w

0800c540 <bmk_thread8>:
#endif

static THD_FUNCTION(bmk_thread8, p) {
 800c540:	b500      	push	{lr}
 800c542:	b083      	sub	sp, #12
 800c544:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 800c546:	f7f5 f933 	bl	80017b0 <chThdYield>
    chThdYield();
 800c54a:	f7f5 f931 	bl	80017b0 <chThdYield>
    chThdYield();
 800c54e:	f7f5 f92f 	bl	80017b0 <chThdYield>
    chThdYield();
 800c552:	f7f5 f92d 	bl	80017b0 <chThdYield>
    (*(uint32_t *)p) += 4;
 800c556:	9b01      	ldr	r3, [sp, #4]
 800c558:	681b      	ldr	r3, [r3, #0]
 800c55a:	1d1a      	adds	r2, r3, #4
 800c55c:	9b01      	ldr	r3, [sp, #4]
 800c55e:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 800c560:	f7ff ff4e 	bl	800c400 <chThdShouldTerminateX>
 800c564:	4603      	mov	r3, r0
 800c566:	f083 0301 	eor.w	r3, r3, #1
 800c56a:	b2db      	uxtb	r3, r3
 800c56c:	2b00      	cmp	r3, #0
 800c56e:	d1ea      	bne.n	800c546 <bmk_thread8+0x6>
}
 800c570:	b003      	add	sp, #12
 800c572:	f85d fb04 	ldr.w	pc, [sp], #4
 800c576:	bf00      	nop
 800c578:	f3af 8000 	nop.w
 800c57c:	f3af 8000 	nop.w

0800c580 <test_013_001_execute>:
 *   second time window.
 * - [13.1.3] Score is printed.
 * .
 */

static void test_013_001_execute(void) {
 800c580:	b510      	push	{r4, lr}
 800c582:	b084      	sub	sp, #16
  uint32_t n;

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 800c584:	4b1a      	ldr	r3, [pc, #104]	; (800c5f0 <test_013_001_execute+0x70>)
 800c586:	2201      	movs	r2, #1
 800c588:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 800c58a:	4b1a      	ldr	r3, [pc, #104]	; (800c5f4 <test_013_001_execute+0x74>)
 800c58c:	681c      	ldr	r4, [r3, #0]
 800c58e:	f7ff ff2f 	bl	800c3f0 <chThdGetPriorityX>
 800c592:	4603      	mov	r3, r0
 800c594:	1e5a      	subs	r2, r3, #1
 800c596:	2300      	movs	r3, #0
 800c598:	9300      	str	r3, [sp, #0]
 800c59a:	4620      	mov	r0, r4
 800c59c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c5a0:	4b15      	ldr	r3, [pc, #84]	; (800c5f8 <test_013_001_execute+0x78>)
 800c5a2:	f7f4 ff55 	bl	8001450 <chThdCreateStatic>
 800c5a6:	4602      	mov	r2, r0
 800c5a8:	4b14      	ldr	r3, [pc, #80]	; (800c5fc <test_013_001_execute+0x7c>)
 800c5aa:	601a      	str	r2, [r3, #0]
  }

  /* [13.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800c5ac:	4b10      	ldr	r3, [pc, #64]	; (800c5f0 <test_013_001_execute+0x70>)
 800c5ae:	2202      	movs	r2, #2
 800c5b0:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 800c5b2:	4b12      	ldr	r3, [pc, #72]	; (800c5fc <test_013_001_execute+0x7c>)
 800c5b4:	681b      	ldr	r3, [r3, #0]
 800c5b6:	4618      	mov	r0, r3
 800c5b8:	f7ff ff5a 	bl	800c470 <msg_loop_test>
 800c5bc:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 800c5be:	f7fb faaf 	bl	8007b20 <test_wait_threads>
  }

  /* [13.1.3] Score is printed.*/
  test_set_step(3);
 800c5c2:	4b0b      	ldr	r3, [pc, #44]	; (800c5f0 <test_013_001_execute+0x70>)
 800c5c4:	2203      	movs	r2, #3
 800c5c6:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c5c8:	480d      	ldr	r0, [pc, #52]	; (800c600 <test_013_001_execute+0x80>)
 800c5ca:	f7fb f8b9 	bl	8007740 <test_print>
    test_printn(n);
 800c5ce:	9803      	ldr	r0, [sp, #12]
 800c5d0:	f7fb f86e 	bl	80076b0 <test_printn>
    test_print(" msgs/S, ");
 800c5d4:	480b      	ldr	r0, [pc, #44]	; (800c604 <test_013_001_execute+0x84>)
 800c5d6:	f7fb f8b3 	bl	8007740 <test_print>
    test_printn(n << 1);
 800c5da:	9b03      	ldr	r3, [sp, #12]
 800c5dc:	005b      	lsls	r3, r3, #1
 800c5de:	4618      	mov	r0, r3
 800c5e0:	f7fb f866 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800c5e4:	4808      	ldr	r0, [pc, #32]	; (800c608 <test_013_001_execute+0x88>)
 800c5e6:	f7fb f8cb 	bl	8007780 <test_println>
  }
}
 800c5ea:	b004      	add	sp, #16
 800c5ec:	bd10      	pop	{r4, pc}
 800c5ee:	bf00      	nop
 800c5f0:	20000cac 	.word	0x20000cac
 800c5f4:	0800e298 	.word	0x0800e298
 800c5f8:	0800c441 	.word	0x0800c441
 800c5fc:	20000cb0 	.word	0x20000cb0
 800c600:	0800f744 	.word	0x0800f744
 800c604:	0800f754 	.word	0x0800f754
 800c608:	0800f760 	.word	0x0800f760
 800c60c:	f3af 8000 	nop.w

0800c610 <test_013_002_execute>:
 *   second time window.
 * - [13.2.3] Score is printed.
 * .
 */

static void test_013_002_execute(void) {
 800c610:	b510      	push	{r4, lr}
 800c612:	b084      	sub	sp, #16
  uint32_t n;

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800c614:	4b1a      	ldr	r3, [pc, #104]	; (800c680 <test_013_002_execute+0x70>)
 800c616:	2201      	movs	r2, #1
 800c618:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800c61a:	4b1a      	ldr	r3, [pc, #104]	; (800c684 <test_013_002_execute+0x74>)
 800c61c:	681c      	ldr	r4, [r3, #0]
 800c61e:	f7ff fee7 	bl	800c3f0 <chThdGetPriorityX>
 800c622:	4603      	mov	r3, r0
 800c624:	1c5a      	adds	r2, r3, #1
 800c626:	2300      	movs	r3, #0
 800c628:	9300      	str	r3, [sp, #0]
 800c62a:	4620      	mov	r0, r4
 800c62c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c630:	4b15      	ldr	r3, [pc, #84]	; (800c688 <test_013_002_execute+0x78>)
 800c632:	f7f4 ff0d 	bl	8001450 <chThdCreateStatic>
 800c636:	4602      	mov	r2, r0
 800c638:	4b14      	ldr	r3, [pc, #80]	; (800c68c <test_013_002_execute+0x7c>)
 800c63a:	601a      	str	r2, [r3, #0]
  }

  /* [13.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800c63c:	4b10      	ldr	r3, [pc, #64]	; (800c680 <test_013_002_execute+0x70>)
 800c63e:	2202      	movs	r2, #2
 800c640:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 800c642:	4b12      	ldr	r3, [pc, #72]	; (800c68c <test_013_002_execute+0x7c>)
 800c644:	681b      	ldr	r3, [r3, #0]
 800c646:	4618      	mov	r0, r3
 800c648:	f7ff ff12 	bl	800c470 <msg_loop_test>
 800c64c:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 800c64e:	f7fb fa67 	bl	8007b20 <test_wait_threads>
  }

  /* [13.2.3] Score is printed.*/
  test_set_step(3);
 800c652:	4b0b      	ldr	r3, [pc, #44]	; (800c680 <test_013_002_execute+0x70>)
 800c654:	2203      	movs	r2, #3
 800c656:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c658:	480d      	ldr	r0, [pc, #52]	; (800c690 <test_013_002_execute+0x80>)
 800c65a:	f7fb f871 	bl	8007740 <test_print>
    test_printn(n);
 800c65e:	9803      	ldr	r0, [sp, #12]
 800c660:	f7fb f826 	bl	80076b0 <test_printn>
    test_print(" msgs/S, ");
 800c664:	480b      	ldr	r0, [pc, #44]	; (800c694 <test_013_002_execute+0x84>)
 800c666:	f7fb f86b 	bl	8007740 <test_print>
    test_printn(n << 1);
 800c66a:	9b03      	ldr	r3, [sp, #12]
 800c66c:	005b      	lsls	r3, r3, #1
 800c66e:	4618      	mov	r0, r3
 800c670:	f7fb f81e 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800c674:	4808      	ldr	r0, [pc, #32]	; (800c698 <test_013_002_execute+0x88>)
 800c676:	f7fb f883 	bl	8007780 <test_println>
  }
}
 800c67a:	b004      	add	sp, #16
 800c67c:	bd10      	pop	{r4, pc}
 800c67e:	bf00      	nop
 800c680:	20000cac 	.word	0x20000cac
 800c684:	0800e298 	.word	0x0800e298
 800c688:	0800c441 	.word	0x0800c441
 800c68c:	20000cb0 	.word	0x20000cb0
 800c690:	0800f744 	.word	0x0800f744
 800c694:	0800f754 	.word	0x0800f754
 800c698:	0800f760 	.word	0x0800f760
 800c69c:	f3af 8000 	nop.w

0800c6a0 <test_013_003_execute>:
 *   second time window.
 * - [13.3.4] Score is printed.
 * .
 */

static void test_013_003_execute(void) {
 800c6a0:	b510      	push	{r4, lr}
 800c6a2:	b084      	sub	sp, #16
  uint32_t n;

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800c6a4:	4b3d      	ldr	r3, [pc, #244]	; (800c79c <test_013_003_execute+0xfc>)
 800c6a6:	2201      	movs	r2, #1
 800c6a8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800c6aa:	4b3d      	ldr	r3, [pc, #244]	; (800c7a0 <test_013_003_execute+0x100>)
 800c6ac:	681c      	ldr	r4, [r3, #0]
 800c6ae:	f7ff fe9f 	bl	800c3f0 <chThdGetPriorityX>
 800c6b2:	4603      	mov	r3, r0
 800c6b4:	1c5a      	adds	r2, r3, #1
 800c6b6:	2300      	movs	r3, #0
 800c6b8:	9300      	str	r3, [sp, #0]
 800c6ba:	4620      	mov	r0, r4
 800c6bc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c6c0:	4b38      	ldr	r3, [pc, #224]	; (800c7a4 <test_013_003_execute+0x104>)
 800c6c2:	f7f4 fec5 	bl	8001450 <chThdCreateStatic>
 800c6c6:	4602      	mov	r2, r0
 800c6c8:	4b37      	ldr	r3, [pc, #220]	; (800c7a8 <test_013_003_execute+0x108>)
 800c6ca:	601a      	str	r2, [r3, #0]
  }

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800c6cc:	4b33      	ldr	r3, [pc, #204]	; (800c79c <test_013_003_execute+0xfc>)
 800c6ce:	2202      	movs	r2, #2
 800c6d0:	601a      	str	r2, [r3, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800c6d2:	4b33      	ldr	r3, [pc, #204]	; (800c7a0 <test_013_003_execute+0x100>)
 800c6d4:	685c      	ldr	r4, [r3, #4]
 800c6d6:	f7ff fe8b 	bl	800c3f0 <chThdGetPriorityX>
 800c6da:	4603      	mov	r3, r0
 800c6dc:	1e9a      	subs	r2, r3, #2
 800c6de:	2300      	movs	r3, #0
 800c6e0:	9300      	str	r3, [sp, #0]
 800c6e2:	4620      	mov	r0, r4
 800c6e4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c6e8:	4b30      	ldr	r3, [pc, #192]	; (800c7ac <test_013_003_execute+0x10c>)
 800c6ea:	f7f4 feb1 	bl	8001450 <chThdCreateStatic>
 800c6ee:	4602      	mov	r2, r0
 800c6f0:	4b2d      	ldr	r3, [pc, #180]	; (800c7a8 <test_013_003_execute+0x108>)
 800c6f2:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 800c6f4:	4b2a      	ldr	r3, [pc, #168]	; (800c7a0 <test_013_003_execute+0x100>)
 800c6f6:	689c      	ldr	r4, [r3, #8]
 800c6f8:	f7ff fe7a 	bl	800c3f0 <chThdGetPriorityX>
 800c6fc:	4603      	mov	r3, r0
 800c6fe:	1eda      	subs	r2, r3, #3
 800c700:	2300      	movs	r3, #0
 800c702:	9300      	str	r3, [sp, #0]
 800c704:	4620      	mov	r0, r4
 800c706:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c70a:	4b28      	ldr	r3, [pc, #160]	; (800c7ac <test_013_003_execute+0x10c>)
 800c70c:	f7f4 fea0 	bl	8001450 <chThdCreateStatic>
 800c710:	4602      	mov	r2, r0
 800c712:	4b25      	ldr	r3, [pc, #148]	; (800c7a8 <test_013_003_execute+0x108>)
 800c714:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800c716:	4b22      	ldr	r3, [pc, #136]	; (800c7a0 <test_013_003_execute+0x100>)
 800c718:	68dc      	ldr	r4, [r3, #12]
 800c71a:	f7ff fe69 	bl	800c3f0 <chThdGetPriorityX>
 800c71e:	4603      	mov	r3, r0
 800c720:	1f1a      	subs	r2, r3, #4
 800c722:	2300      	movs	r3, #0
 800c724:	9300      	str	r3, [sp, #0]
 800c726:	4620      	mov	r0, r4
 800c728:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c72c:	4b1f      	ldr	r3, [pc, #124]	; (800c7ac <test_013_003_execute+0x10c>)
 800c72e:	f7f4 fe8f 	bl	8001450 <chThdCreateStatic>
 800c732:	4602      	mov	r2, r0
 800c734:	4b1c      	ldr	r3, [pc, #112]	; (800c7a8 <test_013_003_execute+0x108>)
 800c736:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 800c738:	4b19      	ldr	r3, [pc, #100]	; (800c7a0 <test_013_003_execute+0x100>)
 800c73a:	691c      	ldr	r4, [r3, #16]
 800c73c:	f7ff fe58 	bl	800c3f0 <chThdGetPriorityX>
 800c740:	4603      	mov	r3, r0
 800c742:	1f5a      	subs	r2, r3, #5
 800c744:	2300      	movs	r3, #0
 800c746:	9300      	str	r3, [sp, #0]
 800c748:	4620      	mov	r0, r4
 800c74a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c74e:	4b17      	ldr	r3, [pc, #92]	; (800c7ac <test_013_003_execute+0x10c>)
 800c750:	f7f4 fe7e 	bl	8001450 <chThdCreateStatic>
 800c754:	4602      	mov	r2, r0
 800c756:	4b14      	ldr	r3, [pc, #80]	; (800c7a8 <test_013_003_execute+0x108>)
 800c758:	611a      	str	r2, [r3, #16]
  }

  /* [13.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 800c75a:	4b10      	ldr	r3, [pc, #64]	; (800c79c <test_013_003_execute+0xfc>)
 800c75c:	2203      	movs	r2, #3
 800c75e:	601a      	str	r2, [r3, #0]
  {
    n = msg_loop_test(threads[0]);
 800c760:	4b11      	ldr	r3, [pc, #68]	; (800c7a8 <test_013_003_execute+0x108>)
 800c762:	681b      	ldr	r3, [r3, #0]
 800c764:	4618      	mov	r0, r3
 800c766:	f7ff fe83 	bl	800c470 <msg_loop_test>
 800c76a:	9003      	str	r0, [sp, #12]
    test_wait_threads();
 800c76c:	f7fb f9d8 	bl	8007b20 <test_wait_threads>
  }

  /* [13.3.4] Score is printed.*/
  test_set_step(4);
 800c770:	4b0a      	ldr	r3, [pc, #40]	; (800c79c <test_013_003_execute+0xfc>)
 800c772:	2204      	movs	r2, #4
 800c774:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c776:	480e      	ldr	r0, [pc, #56]	; (800c7b0 <test_013_003_execute+0x110>)
 800c778:	f7fa ffe2 	bl	8007740 <test_print>
    test_printn(n);
 800c77c:	9803      	ldr	r0, [sp, #12]
 800c77e:	f7fa ff97 	bl	80076b0 <test_printn>
    test_print(" msgs/S, ");
 800c782:	480c      	ldr	r0, [pc, #48]	; (800c7b4 <test_013_003_execute+0x114>)
 800c784:	f7fa ffdc 	bl	8007740 <test_print>
    test_printn(n << 1);
 800c788:	9b03      	ldr	r3, [sp, #12]
 800c78a:	005b      	lsls	r3, r3, #1
 800c78c:	4618      	mov	r0, r3
 800c78e:	f7fa ff8f 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800c792:	4809      	ldr	r0, [pc, #36]	; (800c7b8 <test_013_003_execute+0x118>)
 800c794:	f7fa fff4 	bl	8007780 <test_println>
  }
}
 800c798:	b004      	add	sp, #16
 800c79a:	bd10      	pop	{r4, pc}
 800c79c:	20000cac 	.word	0x20000cac
 800c7a0:	0800e298 	.word	0x0800e298
 800c7a4:	0800c441 	.word	0x0800c441
 800c7a8:	20000cb0 	.word	0x20000cb0
 800c7ac:	0800c4c1 	.word	0x0800c4c1
 800c7b0:	0800f744 	.word	0x0800f744
 800c7b4:	0800f754 	.word	0x0800f754
 800c7b8:	0800f760 	.word	0x0800f760
 800c7bc:	f3af 8000 	nop.w

0800c7c0 <test_013_004_execute>:
 * - [13.4.3] Stopping the target thread.
 * - [13.4.4] Score is printed.
 * .
 */

static void test_013_004_execute(void) {
 800c7c0:	b510      	push	{r4, lr}
 800c7c2:	b086      	sub	sp, #24
  thread_t *tp;
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800c7c4:	4b2f      	ldr	r3, [pc, #188]	; (800c884 <test_013_004_execute+0xc4>)
 800c7c6:	2201      	movs	r2, #1
 800c7c8:	601a      	str	r2, [r3, #0]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800c7ca:	4b2f      	ldr	r3, [pc, #188]	; (800c888 <test_013_004_execute+0xc8>)
 800c7cc:	681c      	ldr	r4, [r3, #0]
 800c7ce:	f7ff fe0f 	bl	800c3f0 <chThdGetPriorityX>
 800c7d2:	4603      	mov	r3, r0
 800c7d4:	1c5a      	adds	r2, r3, #1
 800c7d6:	2300      	movs	r3, #0
 800c7d8:	9300      	str	r3, [sp, #0]
 800c7da:	4620      	mov	r0, r4
 800c7dc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c7e0:	4b2a      	ldr	r3, [pc, #168]	; (800c88c <test_013_004_execute+0xcc>)
 800c7e2:	f7f4 fe35 	bl	8001450 <chThdCreateStatic>
 800c7e6:	4602      	mov	r2, r0
 800c7e8:	4b29      	ldr	r3, [pc, #164]	; (800c890 <test_013_004_execute+0xd0>)
 800c7ea:	601a      	str	r2, [r3, #0]
 800c7ec:	4b28      	ldr	r3, [pc, #160]	; (800c890 <test_013_004_execute+0xd0>)
 800c7ee:	681b      	ldr	r3, [r3, #0]
 800c7f0:	9304      	str	r3, [sp, #16]
                                        bmk_thread4, NULL);
  }

  /* [13.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 800c7f2:	4b24      	ldr	r3, [pc, #144]	; (800c884 <test_013_004_execute+0xc4>)
 800c7f4:	2202      	movs	r2, #2
 800c7f6:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800c7f8:	2300      	movs	r3, #0
 800c7fa:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 800c7fc:	f7fb f9b8 	bl	8007b70 <test_wait_tick>
 800c800:	9003      	str	r0, [sp, #12]
    end = start + MS2ST(1000);
 800c802:	9b03      	ldr	r3, [sp, #12]
 800c804:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c808:	3310      	adds	r3, #16
 800c80a:	9302      	str	r3, [sp, #8]
    do {
      chSysLock();
 800c80c:	f7ff fda0 	bl	800c350 <chSysLock>
      chSchWakeupS(tp, MSG_OK);
 800c810:	9804      	ldr	r0, [sp, #16]
 800c812:	2100      	movs	r1, #0
 800c814:	f7f4 fb94 	bl	8000f40 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800c818:	9804      	ldr	r0, [sp, #16]
 800c81a:	2100      	movs	r1, #0
 800c81c:	f7f4 fb90 	bl	8000f40 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800c820:	9804      	ldr	r0, [sp, #16]
 800c822:	2100      	movs	r1, #0
 800c824:	f7f4 fb8c 	bl	8000f40 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800c828:	9804      	ldr	r0, [sp, #16]
 800c82a:	2100      	movs	r1, #0
 800c82c:	f7f4 fb88 	bl	8000f40 <chSchWakeupS>
      chSysUnlock();
 800c830:	f7ff fd96 	bl	800c360 <chSysUnlock>
      n += 4;
 800c834:	9b05      	ldr	r3, [sp, #20]
 800c836:	3304      	adds	r3, #4
 800c838:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800c83a:	9803      	ldr	r0, [sp, #12]
 800c83c:	9902      	ldr	r1, [sp, #8]
 800c83e:	f7ff fdb7 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800c842:	4603      	mov	r3, r0
 800c844:	2b00      	cmp	r3, #0
 800c846:	d1e1      	bne.n	800c80c <test_013_004_execute+0x4c>
  }

  /* [13.4.3] Stopping the target thread.*/
  test_set_step(3);
 800c848:	4b0e      	ldr	r3, [pc, #56]	; (800c884 <test_013_004_execute+0xc4>)
 800c84a:	2203      	movs	r2, #3
 800c84c:	601a      	str	r2, [r3, #0]
  {
    chSysLock();
 800c84e:	f7ff fd7f 	bl	800c350 <chSysLock>
    chSchWakeupS(tp, MSG_TIMEOUT);
 800c852:	9804      	ldr	r0, [sp, #16]
 800c854:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c858:	f7f4 fb72 	bl	8000f40 <chSchWakeupS>
    chSysUnlock();
 800c85c:	f7ff fd80 	bl	800c360 <chSysUnlock>
    test_wait_threads();
 800c860:	f7fb f95e 	bl	8007b20 <test_wait_threads>
  }

  /* [13.4.4] Score is printed.*/
  test_set_step(4);
 800c864:	4b07      	ldr	r3, [pc, #28]	; (800c884 <test_013_004_execute+0xc4>)
 800c866:	2204      	movs	r2, #4
 800c868:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c86a:	480a      	ldr	r0, [pc, #40]	; (800c894 <test_013_004_execute+0xd4>)
 800c86c:	f7fa ff68 	bl	8007740 <test_print>
    test_printn(n * 2);
 800c870:	9b05      	ldr	r3, [sp, #20]
 800c872:	005b      	lsls	r3, r3, #1
 800c874:	4618      	mov	r0, r3
 800c876:	f7fa ff1b 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800c87a:	4807      	ldr	r0, [pc, #28]	; (800c898 <test_013_004_execute+0xd8>)
 800c87c:	f7fa ff80 	bl	8007780 <test_println>
  }
}
 800c880:	b006      	add	sp, #24
 800c882:	bd10      	pop	{r4, pc}
 800c884:	20000cac 	.word	0x20000cac
 800c888:	0800e298 	.word	0x0800e298
 800c88c:	0800c4e1 	.word	0x0800c4e1
 800c890:	20000cb0 	.word	0x20000cb0
 800c894:	0800f744 	.word	0x0800f744
 800c898:	0800f760 	.word	0x0800f760
 800c89c:	f3af 8000 	nop.w

0800c8a0 <test_013_005_execute>:
 *   repeated continuously in a one-second time window.
 * - [13.5.2] Score is printed.
 * .
 */

static void test_013_005_execute(void) {
 800c8a0:	b500      	push	{lr}
 800c8a2:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 800c8a4:	f7ff fda4 	bl	800c3f0 <chThdGetPriorityX>
 800c8a8:	4603      	mov	r3, r0
 800c8aa:	3b01      	subs	r3, #1
 800c8ac:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [13.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 800c8ae:	4b1a      	ldr	r3, [pc, #104]	; (800c918 <test_013_005_execute+0x78>)
 800c8b0:	2201      	movs	r2, #1
 800c8b2:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 800c8b4:	2300      	movs	r3, #0
 800c8b6:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 800c8b8:	f7fb f95a 	bl	8007b70 <test_wait_tick>
 800c8bc:	9003      	str	r0, [sp, #12]
    end = start + MS2ST(1000);
 800c8be:	9b03      	ldr	r3, [sp, #12]
 800c8c0:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c8c4:	3310      	adds	r3, #16
 800c8c6:	9302      	str	r3, [sp, #8]
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800c8c8:	4b14      	ldr	r3, [pc, #80]	; (800c91c <test_013_005_execute+0x7c>)
 800c8ca:	681a      	ldr	r2, [r3, #0]
 800c8cc:	2300      	movs	r3, #0
 800c8ce:	9300      	str	r3, [sp, #0]
 800c8d0:	4610      	mov	r0, r2
 800c8d2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c8d6:	9a04      	ldr	r2, [sp, #16]
 800c8d8:	4b11      	ldr	r3, [pc, #68]	; (800c920 <test_013_005_execute+0x80>)
 800c8da:	f7f4 fdb9 	bl	8001450 <chThdCreateStatic>
 800c8de:	4603      	mov	r3, r0
 800c8e0:	4618      	mov	r0, r3
 800c8e2:	f7f4 fead 	bl	8001640 <chThdWait>
      n++;
 800c8e6:	9b05      	ldr	r3, [sp, #20]
 800c8e8:	3301      	adds	r3, #1
 800c8ea:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800c8ec:	9803      	ldr	r0, [sp, #12]
 800c8ee:	9902      	ldr	r1, [sp, #8]
 800c8f0:	f7ff fd5e 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800c8f4:	4603      	mov	r3, r0
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	d1e6      	bne.n	800c8c8 <test_013_005_execute+0x28>
  }

  /* [13.5.2] Score is printed.*/
  test_set_step(2);
 800c8fa:	4b07      	ldr	r3, [pc, #28]	; (800c918 <test_013_005_execute+0x78>)
 800c8fc:	2202      	movs	r2, #2
 800c8fe:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c900:	4808      	ldr	r0, [pc, #32]	; (800c924 <test_013_005_execute+0x84>)
 800c902:	f7fa ff1d 	bl	8007740 <test_print>
    test_printn(n);
 800c906:	9805      	ldr	r0, [sp, #20]
 800c908:	f7fa fed2 	bl	80076b0 <test_printn>
    test_println(" threads/S");
 800c90c:	4806      	ldr	r0, [pc, #24]	; (800c928 <test_013_005_execute+0x88>)
 800c90e:	f7fa ff37 	bl	8007780 <test_println>
  }
}
 800c912:	b007      	add	sp, #28
 800c914:	f85d fb04 	ldr.w	pc, [sp], #4
 800c918:	20000cac 	.word	0x20000cac
 800c91c:	0800e298 	.word	0x0800e298
 800c920:	0800c4c1 	.word	0x0800c4c1
 800c924:	0800f744 	.word	0x0800f744
 800c928:	0800f810 	.word	0x0800f810
 800c92c:	f3af 8000 	nop.w

0800c930 <test_013_006_execute>:
 *   one-second time window.
 * - [13.6.2] Score is printed.
 * .
 */

static void test_013_006_execute(void) {
 800c930:	b500      	push	{lr}
 800c932:	b087      	sub	sp, #28
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 800c934:	f7ff fd5c 	bl	800c3f0 <chThdGetPriorityX>
 800c938:	4603      	mov	r3, r0
 800c93a:	3301      	adds	r3, #1
 800c93c:	9304      	str	r3, [sp, #16]
  systime_t start, end;

  /* [13.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800c93e:	4b1a      	ldr	r3, [pc, #104]	; (800c9a8 <test_013_006_execute+0x78>)
 800c940:	2201      	movs	r2, #1
 800c942:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 800c944:	2300      	movs	r3, #0
 800c946:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 800c948:	f7fb f912 	bl	8007b70 <test_wait_tick>
 800c94c:	9003      	str	r0, [sp, #12]
    end = start + MS2ST(1000);
 800c94e:	9b03      	ldr	r3, [sp, #12]
 800c950:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800c954:	3310      	adds	r3, #16
 800c956:	9302      	str	r3, [sp, #8]
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800c958:	4b14      	ldr	r3, [pc, #80]	; (800c9ac <test_013_006_execute+0x7c>)
 800c95a:	681a      	ldr	r2, [r3, #0]
 800c95c:	2300      	movs	r3, #0
 800c95e:	9300      	str	r3, [sp, #0]
 800c960:	4610      	mov	r0, r2
 800c962:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c966:	9a04      	ldr	r2, [sp, #16]
 800c968:	4b11      	ldr	r3, [pc, #68]	; (800c9b0 <test_013_006_execute+0x80>)
 800c96a:	f7f4 fd71 	bl	8001450 <chThdCreateStatic>
 800c96e:	4603      	mov	r3, r0
 800c970:	4618      	mov	r0, r3
 800c972:	f7f4 fdcd 	bl	8001510 <chThdRelease>
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 800c976:	9b05      	ldr	r3, [sp, #20]
 800c978:	3301      	adds	r3, #1
 800c97a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800c97c:	9803      	ldr	r0, [sp, #12]
 800c97e:	9902      	ldr	r1, [sp, #8]
 800c980:	f7ff fd16 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800c984:	4603      	mov	r3, r0
 800c986:	2b00      	cmp	r3, #0
 800c988:	d1e6      	bne.n	800c958 <test_013_006_execute+0x28>
  }

  /* [13.6.2] Score is printed.*/
  test_set_step(2);
 800c98a:	4b07      	ldr	r3, [pc, #28]	; (800c9a8 <test_013_006_execute+0x78>)
 800c98c:	2202      	movs	r2, #2
 800c98e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800c990:	4808      	ldr	r0, [pc, #32]	; (800c9b4 <test_013_006_execute+0x84>)
 800c992:	f7fa fed5 	bl	8007740 <test_print>
    test_printn(n);
 800c996:	9805      	ldr	r0, [sp, #20]
 800c998:	f7fa fe8a 	bl	80076b0 <test_printn>
    test_println(" threads/S");
 800c99c:	4806      	ldr	r0, [pc, #24]	; (800c9b8 <test_013_006_execute+0x88>)
 800c99e:	f7fa feef 	bl	8007780 <test_println>
  }
}
 800c9a2:	b007      	add	sp, #28
 800c9a4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9a8:	20000cac 	.word	0x20000cac
 800c9ac:	0800e298 	.word	0x0800e298
 800c9b0:	0800c4c1 	.word	0x0800c4c1
 800c9b4:	0800f744 	.word	0x0800f744
 800c9b8:	0800f810 	.word	0x0800f810
 800c9bc:	f3af 8000 	nop.w

0800c9c0 <test_013_007_setup>:
 * - [13.7.3] The five threads are terminated.
 * - [13.7.4] The score is printed.
 * .
 */

static void test_013_007_setup(void) {
 800c9c0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 800c9c2:	4802      	ldr	r0, [pc, #8]	; (800c9cc <test_013_007_setup+0xc>)
 800c9c4:	2100      	movs	r1, #0
 800c9c6:	f7f5 f9bb 	bl	8001d40 <chSemObjectInit>
}
 800c9ca:	bd08      	pop	{r3, pc}
 800c9cc:	200009dc 	.word	0x200009dc

0800c9d0 <test_013_007_execute>:

static void test_013_007_execute(void) {
 800c9d0:	b510      	push	{r4, lr}
 800c9d2:	b086      	sub	sp, #24
  uint32_t n;

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 800c9d4:	4b4b      	ldr	r3, [pc, #300]	; (800cb04 <test_013_007_execute+0x134>)
 800c9d6:	2201      	movs	r2, #1
 800c9d8:	601a      	str	r2, [r3, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800c9da:	4b4b      	ldr	r3, [pc, #300]	; (800cb08 <test_013_007_execute+0x138>)
 800c9dc:	681c      	ldr	r4, [r3, #0]
 800c9de:	f7ff fd07 	bl	800c3f0 <chThdGetPriorityX>
 800c9e2:	4603      	mov	r3, r0
 800c9e4:	1d5a      	adds	r2, r3, #5
 800c9e6:	2300      	movs	r3, #0
 800c9e8:	9300      	str	r3, [sp, #0]
 800c9ea:	4620      	mov	r0, r4
 800c9ec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c9f0:	4b46      	ldr	r3, [pc, #280]	; (800cb0c <test_013_007_execute+0x13c>)
 800c9f2:	f7f4 fd2d 	bl	8001450 <chThdCreateStatic>
 800c9f6:	4602      	mov	r2, r0
 800c9f8:	4b45      	ldr	r3, [pc, #276]	; (800cb10 <test_013_007_execute+0x140>)
 800c9fa:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 800c9fc:	4b42      	ldr	r3, [pc, #264]	; (800cb08 <test_013_007_execute+0x138>)
 800c9fe:	685c      	ldr	r4, [r3, #4]
 800ca00:	f7ff fcf6 	bl	800c3f0 <chThdGetPriorityX>
 800ca04:	4603      	mov	r3, r0
 800ca06:	1d1a      	adds	r2, r3, #4
 800ca08:	2300      	movs	r3, #0
 800ca0a:	9300      	str	r3, [sp, #0]
 800ca0c:	4620      	mov	r0, r4
 800ca0e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca12:	4b3e      	ldr	r3, [pc, #248]	; (800cb0c <test_013_007_execute+0x13c>)
 800ca14:	f7f4 fd1c 	bl	8001450 <chThdCreateStatic>
 800ca18:	4602      	mov	r2, r0
 800ca1a:	4b3d      	ldr	r3, [pc, #244]	; (800cb10 <test_013_007_execute+0x140>)
 800ca1c:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 800ca1e:	4b3a      	ldr	r3, [pc, #232]	; (800cb08 <test_013_007_execute+0x138>)
 800ca20:	689c      	ldr	r4, [r3, #8]
 800ca22:	f7ff fce5 	bl	800c3f0 <chThdGetPriorityX>
 800ca26:	4603      	mov	r3, r0
 800ca28:	1cda      	adds	r2, r3, #3
 800ca2a:	2300      	movs	r3, #0
 800ca2c:	9300      	str	r3, [sp, #0]
 800ca2e:	4620      	mov	r0, r4
 800ca30:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca34:	4b35      	ldr	r3, [pc, #212]	; (800cb0c <test_013_007_execute+0x13c>)
 800ca36:	f7f4 fd0b 	bl	8001450 <chThdCreateStatic>
 800ca3a:	4602      	mov	r2, r0
 800ca3c:	4b34      	ldr	r3, [pc, #208]	; (800cb10 <test_013_007_execute+0x140>)
 800ca3e:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800ca40:	4b31      	ldr	r3, [pc, #196]	; (800cb08 <test_013_007_execute+0x138>)
 800ca42:	68dc      	ldr	r4, [r3, #12]
 800ca44:	f7ff fcd4 	bl	800c3f0 <chThdGetPriorityX>
 800ca48:	4603      	mov	r3, r0
 800ca4a:	1c9a      	adds	r2, r3, #2
 800ca4c:	2300      	movs	r3, #0
 800ca4e:	9300      	str	r3, [sp, #0]
 800ca50:	4620      	mov	r0, r4
 800ca52:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca56:	4b2d      	ldr	r3, [pc, #180]	; (800cb0c <test_013_007_execute+0x13c>)
 800ca58:	f7f4 fcfa 	bl	8001450 <chThdCreateStatic>
 800ca5c:	4602      	mov	r2, r0
 800ca5e:	4b2c      	ldr	r3, [pc, #176]	; (800cb10 <test_013_007_execute+0x140>)
 800ca60:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800ca62:	4b29      	ldr	r3, [pc, #164]	; (800cb08 <test_013_007_execute+0x138>)
 800ca64:	691c      	ldr	r4, [r3, #16]
 800ca66:	f7ff fcc3 	bl	800c3f0 <chThdGetPriorityX>
 800ca6a:	4603      	mov	r3, r0
 800ca6c:	1c5a      	adds	r2, r3, #1
 800ca6e:	2300      	movs	r3, #0
 800ca70:	9300      	str	r3, [sp, #0]
 800ca72:	4620      	mov	r0, r4
 800ca74:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca78:	4b24      	ldr	r3, [pc, #144]	; (800cb0c <test_013_007_execute+0x13c>)
 800ca7a:	f7f4 fce9 	bl	8001450 <chThdCreateStatic>
 800ca7e:	4602      	mov	r2, r0
 800ca80:	4b23      	ldr	r3, [pc, #140]	; (800cb10 <test_013_007_execute+0x140>)
 800ca82:	611a      	str	r2, [r3, #16]
  }

  /* [13.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 800ca84:	4b1f      	ldr	r3, [pc, #124]	; (800cb04 <test_013_007_execute+0x134>)
 800ca86:	2202      	movs	r2, #2
 800ca88:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800ca8a:	2300      	movs	r3, #0
 800ca8c:	9305      	str	r3, [sp, #20]
    start = test_wait_tick();
 800ca8e:	f7fb f86f 	bl	8007b70 <test_wait_tick>
 800ca92:	9004      	str	r0, [sp, #16]
    end = start + MS2ST(1000);
 800ca94:	9b04      	ldr	r3, [sp, #16]
 800ca96:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800ca9a:	3310      	adds	r3, #16
 800ca9c:	9303      	str	r3, [sp, #12]
    do {
      chSemReset(&sem1, 0);
 800ca9e:	481d      	ldr	r0, [pc, #116]	; (800cb14 <test_013_007_execute+0x144>)
 800caa0:	2100      	movs	r1, #0
 800caa2:	f7f5 f95d 	bl	8001d60 <chSemReset>
      n++;
 800caa6:	9b05      	ldr	r3, [sp, #20]
 800caa8:	3301      	adds	r3, #1
 800caaa:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800caac:	9804      	ldr	r0, [sp, #16]
 800caae:	9903      	ldr	r1, [sp, #12]
 800cab0:	f7ff fc7e 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800cab4:	4603      	mov	r3, r0
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	d1f1      	bne.n	800ca9e <test_013_007_execute+0xce>
  }

  /* [13.7.3] The five threads are terminated.*/
  test_set_step(3);
 800caba:	4b12      	ldr	r3, [pc, #72]	; (800cb04 <test_013_007_execute+0x134>)
 800cabc:	2203      	movs	r2, #3
 800cabe:	601a      	str	r2, [r3, #0]
  {
    test_terminate_threads();
 800cac0:	f7fb f80e 	bl	8007ae0 <test_terminate_threads>
    chSemReset(&sem1, 0);
 800cac4:	4813      	ldr	r0, [pc, #76]	; (800cb14 <test_013_007_execute+0x144>)
 800cac6:	2100      	movs	r1, #0
 800cac8:	f7f5 f94a 	bl	8001d60 <chSemReset>
    test_wait_threads();
 800cacc:	f7fb f828 	bl	8007b20 <test_wait_threads>
  }

  /* [13.7.4] The score is printed.*/
  test_set_step(4);
 800cad0:	4b0c      	ldr	r3, [pc, #48]	; (800cb04 <test_013_007_execute+0x134>)
 800cad2:	2204      	movs	r2, #4
 800cad4:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800cad6:	4810      	ldr	r0, [pc, #64]	; (800cb18 <test_013_007_execute+0x148>)
 800cad8:	f7fa fe32 	bl	8007740 <test_print>
    test_printn(n);
 800cadc:	9805      	ldr	r0, [sp, #20]
 800cade:	f7fa fde7 	bl	80076b0 <test_printn>
    test_print(" reschedules/S, ");
 800cae2:	480e      	ldr	r0, [pc, #56]	; (800cb1c <test_013_007_execute+0x14c>)
 800cae4:	f7fa fe2c 	bl	8007740 <test_print>
    test_printn(n * 6);
 800cae8:	9a05      	ldr	r2, [sp, #20]
 800caea:	4613      	mov	r3, r2
 800caec:	005b      	lsls	r3, r3, #1
 800caee:	4413      	add	r3, r2
 800caf0:	005b      	lsls	r3, r3, #1
 800caf2:	4618      	mov	r0, r3
 800caf4:	f7fa fddc 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800caf8:	4809      	ldr	r0, [pc, #36]	; (800cb20 <test_013_007_execute+0x150>)
 800cafa:	f7fa fe41 	bl	8007780 <test_println>
  }
}
 800cafe:	b006      	add	sp, #24
 800cb00:	bd10      	pop	{r4, pc}
 800cb02:	bf00      	nop
 800cb04:	20000cac 	.word	0x20000cac
 800cb08:	0800e298 	.word	0x0800e298
 800cb0c:	0800c511 	.word	0x0800c511
 800cb10:	20000cb0 	.word	0x20000cb0
 800cb14:	200009dc 	.word	0x200009dc
 800cb18:	0800f744 	.word	0x0800f744
 800cb1c:	0800f884 	.word	0x0800f884
 800cb20:	0800f760 	.word	0x0800f760
 800cb24:	f3af 8000 	nop.w
 800cb28:	f3af 8000 	nop.w
 800cb2c:	f3af 8000 	nop.w

0800cb30 <test_013_008_execute>:
 * - [13.8.2] Waiting one second then terminating the 5 threads.
 * - [13.8.3] The score is printed.
 * .
 */

static void test_013_008_execute(void) {
 800cb30:	b510      	push	{r4, lr}
 800cb32:	b084      	sub	sp, #16
  uint32_t n;

  /* [13.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 800cb34:	4b3a      	ldr	r3, [pc, #232]	; (800cc20 <test_013_008_execute+0xf0>)
 800cb36:	2201      	movs	r2, #1
 800cb38:	601a      	str	r2, [r3, #0]
  {
    n = 0;
 800cb3a:	2300      	movs	r3, #0
 800cb3c:	9303      	str	r3, [sp, #12]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800cb3e:	f7fb f817 	bl	8007b70 <test_wait_tick>
 800cb42:	4b38      	ldr	r3, [pc, #224]	; (800cc24 <test_013_008_execute+0xf4>)
 800cb44:	681c      	ldr	r4, [r3, #0]
 800cb46:	f7ff fc53 	bl	800c3f0 <chThdGetPriorityX>
 800cb4a:	4603      	mov	r3, r0
 800cb4c:	1e5a      	subs	r2, r3, #1
 800cb4e:	ab03      	add	r3, sp, #12
 800cb50:	9300      	str	r3, [sp, #0]
 800cb52:	4620      	mov	r0, r4
 800cb54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb58:	4b33      	ldr	r3, [pc, #204]	; (800cc28 <test_013_008_execute+0xf8>)
 800cb5a:	f7f4 fc79 	bl	8001450 <chThdCreateStatic>
 800cb5e:	4602      	mov	r2, r0
 800cb60:	4b32      	ldr	r3, [pc, #200]	; (800cc2c <test_013_008_execute+0xfc>)
 800cb62:	601a      	str	r2, [r3, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800cb64:	4b2f      	ldr	r3, [pc, #188]	; (800cc24 <test_013_008_execute+0xf4>)
 800cb66:	685c      	ldr	r4, [r3, #4]
 800cb68:	f7ff fc42 	bl	800c3f0 <chThdGetPriorityX>
 800cb6c:	4603      	mov	r3, r0
 800cb6e:	1e5a      	subs	r2, r3, #1
 800cb70:	ab03      	add	r3, sp, #12
 800cb72:	9300      	str	r3, [sp, #0]
 800cb74:	4620      	mov	r0, r4
 800cb76:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb7a:	4b2b      	ldr	r3, [pc, #172]	; (800cc28 <test_013_008_execute+0xf8>)
 800cb7c:	f7f4 fc68 	bl	8001450 <chThdCreateStatic>
 800cb80:	4602      	mov	r2, r0
 800cb82:	4b2a      	ldr	r3, [pc, #168]	; (800cc2c <test_013_008_execute+0xfc>)
 800cb84:	605a      	str	r2, [r3, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800cb86:	4b27      	ldr	r3, [pc, #156]	; (800cc24 <test_013_008_execute+0xf4>)
 800cb88:	689c      	ldr	r4, [r3, #8]
 800cb8a:	f7ff fc31 	bl	800c3f0 <chThdGetPriorityX>
 800cb8e:	4603      	mov	r3, r0
 800cb90:	1e5a      	subs	r2, r3, #1
 800cb92:	ab03      	add	r3, sp, #12
 800cb94:	9300      	str	r3, [sp, #0]
 800cb96:	4620      	mov	r0, r4
 800cb98:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb9c:	4b22      	ldr	r3, [pc, #136]	; (800cc28 <test_013_008_execute+0xf8>)
 800cb9e:	f7f4 fc57 	bl	8001450 <chThdCreateStatic>
 800cba2:	4602      	mov	r2, r0
 800cba4:	4b21      	ldr	r3, [pc, #132]	; (800cc2c <test_013_008_execute+0xfc>)
 800cba6:	609a      	str	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800cba8:	4b1e      	ldr	r3, [pc, #120]	; (800cc24 <test_013_008_execute+0xf4>)
 800cbaa:	68dc      	ldr	r4, [r3, #12]
 800cbac:	f7ff fc20 	bl	800c3f0 <chThdGetPriorityX>
 800cbb0:	4603      	mov	r3, r0
 800cbb2:	1e5a      	subs	r2, r3, #1
 800cbb4:	ab03      	add	r3, sp, #12
 800cbb6:	9300      	str	r3, [sp, #0]
 800cbb8:	4620      	mov	r0, r4
 800cbba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbbe:	4b1a      	ldr	r3, [pc, #104]	; (800cc28 <test_013_008_execute+0xf8>)
 800cbc0:	f7f4 fc46 	bl	8001450 <chThdCreateStatic>
 800cbc4:	4602      	mov	r2, r0
 800cbc6:	4b19      	ldr	r3, [pc, #100]	; (800cc2c <test_013_008_execute+0xfc>)
 800cbc8:	60da      	str	r2, [r3, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800cbca:	4b16      	ldr	r3, [pc, #88]	; (800cc24 <test_013_008_execute+0xf4>)
 800cbcc:	691c      	ldr	r4, [r3, #16]
 800cbce:	f7ff fc0f 	bl	800c3f0 <chThdGetPriorityX>
 800cbd2:	4603      	mov	r3, r0
 800cbd4:	1e5a      	subs	r2, r3, #1
 800cbd6:	ab03      	add	r3, sp, #12
 800cbd8:	9300      	str	r3, [sp, #0]
 800cbda:	4620      	mov	r0, r4
 800cbdc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cbe0:	4b11      	ldr	r3, [pc, #68]	; (800cc28 <test_013_008_execute+0xf8>)
 800cbe2:	f7f4 fc35 	bl	8001450 <chThdCreateStatic>
 800cbe6:	4602      	mov	r2, r0
 800cbe8:	4b10      	ldr	r3, [pc, #64]	; (800cc2c <test_013_008_execute+0xfc>)
 800cbea:	611a      	str	r2, [r3, #16]
  }

  /* [13.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 800cbec:	4b0c      	ldr	r3, [pc, #48]	; (800cc20 <test_013_008_execute+0xf0>)
 800cbee:	2202      	movs	r2, #2
 800cbf0:	601a      	str	r2, [r3, #0]
  {
    chThdSleepSeconds(1);
 800cbf2:	f242 7010 	movw	r0, #10000	; 0x2710
 800cbf6:	f7f4 fd93 	bl	8001720 <chThdSleep>
    test_terminate_threads();
 800cbfa:	f7fa ff71 	bl	8007ae0 <test_terminate_threads>
    test_wait_threads();
 800cbfe:	f7fa ff8f 	bl	8007b20 <test_wait_threads>
  }

  /* [13.8.3] The score is printed.*/
  test_set_step(3);
 800cc02:	4b07      	ldr	r3, [pc, #28]	; (800cc20 <test_013_008_execute+0xf0>)
 800cc04:	2203      	movs	r2, #3
 800cc06:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800cc08:	4809      	ldr	r0, [pc, #36]	; (800cc30 <test_013_008_execute+0x100>)
 800cc0a:	f7fa fd99 	bl	8007740 <test_print>
    test_printn(n);
 800cc0e:	9b03      	ldr	r3, [sp, #12]
 800cc10:	4618      	mov	r0, r3
 800cc12:	f7fa fd4d 	bl	80076b0 <test_printn>
    test_println(" ctxswc/S");
 800cc16:	4807      	ldr	r0, [pc, #28]	; (800cc34 <test_013_008_execute+0x104>)
 800cc18:	f7fa fdb2 	bl	8007780 <test_println>
  }
}
 800cc1c:	b004      	add	sp, #16
 800cc1e:	bd10      	pop	{r4, pc}
 800cc20:	20000cac 	.word	0x20000cac
 800cc24:	0800e298 	.word	0x0800e298
 800cc28:	0800c541 	.word	0x0800c541
 800cc2c:	20000cb0 	.word	0x20000cb0
 800cc30:	0800f744 	.word	0x0800f744
 800cc34:	0800f760 	.word	0x0800f760
 800cc38:	f3af 8000 	nop.w
 800cc3c:	f3af 8000 	nop.w

0800cc40 <test_013_009_execute>:
 *   one-second time window.
 * - [13.9.2] The score is printed.
 * .
 */

static void test_013_009_execute(void) {
 800cc40:	b500      	push	{lr}
 800cc42:	b085      	sub	sp, #20
  uint32_t n;

  /* [13.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800cc44:	4b1f      	ldr	r3, [pc, #124]	; (800ccc4 <test_013_009_execute+0x84>)
 800cc46:	2201      	movs	r2, #1
 800cc48:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800cc4a:	2300      	movs	r3, #0
 800cc4c:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 800cc4e:	f7fa ff8f 	bl	8007b70 <test_wait_tick>
 800cc52:	9002      	str	r0, [sp, #8]
    end = start + MS2ST(1000);
 800cc54:	9b02      	ldr	r3, [sp, #8]
 800cc56:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800cc5a:	3310      	adds	r3, #16
 800cc5c:	9301      	str	r3, [sp, #4]
    do {
      chSysLock();
 800cc5e:	f7ff fb77 	bl	800c350 <chSysLock>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 800cc62:	4819      	ldr	r0, [pc, #100]	; (800ccc8 <test_013_009_execute+0x88>)
 800cc64:	2101      	movs	r1, #1
 800cc66:	4a19      	ldr	r2, [pc, #100]	; (800cccc <test_013_009_execute+0x8c>)
 800cc68:	2300      	movs	r3, #0
 800cc6a:	f7f3 fed1 	bl	8000a10 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 800cc6e:	4818      	ldr	r0, [pc, #96]	; (800ccd0 <test_013_009_execute+0x90>)
 800cc70:	f242 7110 	movw	r1, #10000	; 0x2710
 800cc74:	4a15      	ldr	r2, [pc, #84]	; (800cccc <test_013_009_execute+0x8c>)
 800cc76:	2300      	movs	r3, #0
 800cc78:	f7f3 feca 	bl	8000a10 <chVTDoSetI>
      chVTDoResetI(&vt1);
 800cc7c:	4812      	ldr	r0, [pc, #72]	; (800ccc8 <test_013_009_execute+0x88>)
 800cc7e:	f7f3 ff57 	bl	8000b30 <chVTDoResetI>
      chVTDoResetI(&vt2);
 800cc82:	4813      	ldr	r0, [pc, #76]	; (800ccd0 <test_013_009_execute+0x90>)
 800cc84:	f7f3 ff54 	bl	8000b30 <chVTDoResetI>
      chSysUnlock();
 800cc88:	f7ff fb6a 	bl	800c360 <chSysUnlock>
      n++;
 800cc8c:	9b03      	ldr	r3, [sp, #12]
 800cc8e:	3301      	adds	r3, #1
 800cc90:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800cc92:	9802      	ldr	r0, [sp, #8]
 800cc94:	9901      	ldr	r1, [sp, #4]
 800cc96:	f7ff fb8b 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800cc9a:	4603      	mov	r3, r0
 800cc9c:	2b00      	cmp	r3, #0
 800cc9e:	d1de      	bne.n	800cc5e <test_013_009_execute+0x1e>
  }

  /* [13.9.2] The score is printed.*/
  test_set_step(2);
 800cca0:	4b08      	ldr	r3, [pc, #32]	; (800ccc4 <test_013_009_execute+0x84>)
 800cca2:	2202      	movs	r2, #2
 800cca4:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800cca6:	480b      	ldr	r0, [pc, #44]	; (800ccd4 <test_013_009_execute+0x94>)
 800cca8:	f7fa fd4a 	bl	8007740 <test_print>
    test_printn(n * 2);
 800ccac:	9b03      	ldr	r3, [sp, #12]
 800ccae:	005b      	lsls	r3, r3, #1
 800ccb0:	4618      	mov	r0, r3
 800ccb2:	f7fa fcfd 	bl	80076b0 <test_printn>
    test_println(" timers/S");
 800ccb6:	4808      	ldr	r0, [pc, #32]	; (800ccd8 <test_013_009_execute+0x98>)
 800ccb8:	f7fa fd62 	bl	8007780 <test_println>
  }
}
 800ccbc:	b005      	add	sp, #20
 800ccbe:	f85d fb04 	ldr.w	pc, [sp], #4
 800ccc2:	bf00      	nop
 800ccc4:	20000cac 	.word	0x20000cac
 800ccc8:	200009f8 	.word	0x200009f8
 800cccc:	0800c431 	.word	0x0800c431
 800ccd0:	20000a0c 	.word	0x20000a0c
 800ccd4:	0800f744 	.word	0x0800f744
 800ccd8:	0800f8f8 	.word	0x0800f8f8
 800ccdc:	f3af 8000 	nop.w

0800cce0 <test_013_010_setup>:
 *   repeated continuously in a one-second time window.
 * - [13.10.2] The score is printed.
 * .
 */

static void test_013_010_setup(void) {
 800cce0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 800cce2:	4802      	ldr	r0, [pc, #8]	; (800ccec <test_013_010_setup+0xc>)
 800cce4:	2101      	movs	r1, #1
 800cce6:	f7f5 f82b 	bl	8001d40 <chSemObjectInit>
}
 800ccea:	bd08      	pop	{r3, pc}
 800ccec:	200009dc 	.word	0x200009dc

0800ccf0 <test_013_010_execute>:

static void test_013_010_execute(void) {
 800ccf0:	b500      	push	{lr}
 800ccf2:	b085      	sub	sp, #20
  uint32_t n;

  /* [13.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 800ccf4:	4b1f      	ldr	r3, [pc, #124]	; (800cd74 <test_013_010_execute+0x84>)
 800ccf6:	2201      	movs	r2, #1
 800ccf8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800ccfa:	2300      	movs	r3, #0
 800ccfc:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 800ccfe:	f7fa ff37 	bl	8007b70 <test_wait_tick>
 800cd02:	9002      	str	r0, [sp, #8]
    end = start + MS2ST(1000);
 800cd04:	9b02      	ldr	r3, [sp, #8]
 800cd06:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800cd0a:	3310      	adds	r3, #16
 800cd0c:	9301      	str	r3, [sp, #4]
    do {
      chSemWait(&sem1);
 800cd0e:	481a      	ldr	r0, [pc, #104]	; (800cd78 <test_013_010_execute+0x88>)
 800cd10:	f7f5 f85e 	bl	8001dd0 <chSemWait>
      chSemSignal(&sem1);
 800cd14:	4818      	ldr	r0, [pc, #96]	; (800cd78 <test_013_010_execute+0x88>)
 800cd16:	f7f5 f8db 	bl	8001ed0 <chSemSignal>
      chSemWait(&sem1);
 800cd1a:	4817      	ldr	r0, [pc, #92]	; (800cd78 <test_013_010_execute+0x88>)
 800cd1c:	f7f5 f858 	bl	8001dd0 <chSemWait>
      chSemSignal(&sem1);
 800cd20:	4815      	ldr	r0, [pc, #84]	; (800cd78 <test_013_010_execute+0x88>)
 800cd22:	f7f5 f8d5 	bl	8001ed0 <chSemSignal>
      chSemWait(&sem1);
 800cd26:	4814      	ldr	r0, [pc, #80]	; (800cd78 <test_013_010_execute+0x88>)
 800cd28:	f7f5 f852 	bl	8001dd0 <chSemWait>
      chSemSignal(&sem1);
 800cd2c:	4812      	ldr	r0, [pc, #72]	; (800cd78 <test_013_010_execute+0x88>)
 800cd2e:	f7f5 f8cf 	bl	8001ed0 <chSemSignal>
      chSemWait(&sem1);
 800cd32:	4811      	ldr	r0, [pc, #68]	; (800cd78 <test_013_010_execute+0x88>)
 800cd34:	f7f5 f84c 	bl	8001dd0 <chSemWait>
      chSemSignal(&sem1);
 800cd38:	480f      	ldr	r0, [pc, #60]	; (800cd78 <test_013_010_execute+0x88>)
 800cd3a:	f7f5 f8c9 	bl	8001ed0 <chSemSignal>
      n++;
 800cd3e:	9b03      	ldr	r3, [sp, #12]
 800cd40:	3301      	adds	r3, #1
 800cd42:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800cd44:	9802      	ldr	r0, [sp, #8]
 800cd46:	9901      	ldr	r1, [sp, #4]
 800cd48:	f7ff fb32 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800cd4c:	4603      	mov	r3, r0
 800cd4e:	2b00      	cmp	r3, #0
 800cd50:	d1dd      	bne.n	800cd0e <test_013_010_execute+0x1e>
  }

  /* [13.10.2] The score is printed.*/
  test_set_step(2);
 800cd52:	4b08      	ldr	r3, [pc, #32]	; (800cd74 <test_013_010_execute+0x84>)
 800cd54:	2202      	movs	r2, #2
 800cd56:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800cd58:	4808      	ldr	r0, [pc, #32]	; (800cd7c <test_013_010_execute+0x8c>)
 800cd5a:	f7fa fcf1 	bl	8007740 <test_print>
    test_printn(n * 4);
 800cd5e:	9b03      	ldr	r3, [sp, #12]
 800cd60:	009b      	lsls	r3, r3, #2
 800cd62:	4618      	mov	r0, r3
 800cd64:	f7fa fca4 	bl	80076b0 <test_printn>
    test_println(" wait+signal/S");
 800cd68:	4805      	ldr	r0, [pc, #20]	; (800cd80 <test_013_010_execute+0x90>)
 800cd6a:	f7fa fd09 	bl	8007780 <test_println>
  }
}
 800cd6e:	b005      	add	sp, #20
 800cd70:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd74:	20000cac 	.word	0x20000cac
 800cd78:	200009dc 	.word	0x200009dc
 800cd7c:	0800f744 	.word	0x0800f744
 800cd80:	0800f93c 	.word	0x0800f93c
 800cd84:	f3af 8000 	nop.w
 800cd88:	f3af 8000 	nop.w
 800cd8c:	f3af 8000 	nop.w

0800cd90 <test_013_011_setup>:
 *   repeated continuously in a one-second time window.
 * - [13.11.2] The score is printed.
 * .
 */

static void test_013_011_setup(void) {
 800cd90:	b508      	push	{r3, lr}
  chMtxObjectInit(&mtx1);
 800cd92:	4802      	ldr	r0, [pc, #8]	; (800cd9c <test_013_011_setup+0xc>)
 800cd94:	f7f5 f9ec 	bl	8002170 <chMtxObjectInit>
}
 800cd98:	bd08      	pop	{r3, pc}
 800cd9a:	bf00      	nop
 800cd9c:	200009e8 	.word	0x200009e8

0800cda0 <test_013_011_execute>:

static void test_013_011_execute(void) {
 800cda0:	b500      	push	{lr}
 800cda2:	b085      	sub	sp, #20
  uint32_t n;

  /* [13.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 800cda4:	4b1f      	ldr	r3, [pc, #124]	; (800ce24 <test_013_011_execute+0x84>)
 800cda6:	2201      	movs	r2, #1
 800cda8:	601a      	str	r2, [r3, #0]
  {
    systime_t start, end;

    n = 0;
 800cdaa:	2300      	movs	r3, #0
 800cdac:	9303      	str	r3, [sp, #12]
    start = test_wait_tick();
 800cdae:	f7fa fedf 	bl	8007b70 <test_wait_tick>
 800cdb2:	9002      	str	r0, [sp, #8]
    end = start + MS2ST(1000);
 800cdb4:	9b02      	ldr	r3, [sp, #8]
 800cdb6:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 800cdba:	3310      	adds	r3, #16
 800cdbc:	9301      	str	r3, [sp, #4]
    do {
      chMtxLock(&mtx1);
 800cdbe:	481a      	ldr	r0, [pc, #104]	; (800ce28 <test_013_011_execute+0x88>)
 800cdc0:	f7f5 f9e6 	bl	8002190 <chMtxLock>
      chMtxUnlock(&mtx1);
 800cdc4:	4818      	ldr	r0, [pc, #96]	; (800ce28 <test_013_011_execute+0x88>)
 800cdc6:	f7f5 fa8b 	bl	80022e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 800cdca:	4817      	ldr	r0, [pc, #92]	; (800ce28 <test_013_011_execute+0x88>)
 800cdcc:	f7f5 f9e0 	bl	8002190 <chMtxLock>
      chMtxUnlock(&mtx1);
 800cdd0:	4815      	ldr	r0, [pc, #84]	; (800ce28 <test_013_011_execute+0x88>)
 800cdd2:	f7f5 fa85 	bl	80022e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 800cdd6:	4814      	ldr	r0, [pc, #80]	; (800ce28 <test_013_011_execute+0x88>)
 800cdd8:	f7f5 f9da 	bl	8002190 <chMtxLock>
      chMtxUnlock(&mtx1);
 800cddc:	4812      	ldr	r0, [pc, #72]	; (800ce28 <test_013_011_execute+0x88>)
 800cdde:	f7f5 fa7f 	bl	80022e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 800cde2:	4811      	ldr	r0, [pc, #68]	; (800ce28 <test_013_011_execute+0x88>)
 800cde4:	f7f5 f9d4 	bl	8002190 <chMtxLock>
      chMtxUnlock(&mtx1);
 800cde8:	480f      	ldr	r0, [pc, #60]	; (800ce28 <test_013_011_execute+0x88>)
 800cdea:	f7f5 fa79 	bl	80022e0 <chMtxUnlock>
      n++;
 800cdee:	9b03      	ldr	r3, [sp, #12]
 800cdf0:	3301      	adds	r3, #1
 800cdf2:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800cdf4:	9802      	ldr	r0, [sp, #8]
 800cdf6:	9901      	ldr	r1, [sp, #4]
 800cdf8:	f7ff fada 	bl	800c3b0 <chVTIsSystemTimeWithinX>
 800cdfc:	4603      	mov	r3, r0
 800cdfe:	2b00      	cmp	r3, #0
 800ce00:	d1dd      	bne.n	800cdbe <test_013_011_execute+0x1e>
  }

  /* [13.11.2] The score is printed.*/
  test_set_step(2);
 800ce02:	4b08      	ldr	r3, [pc, #32]	; (800ce24 <test_013_011_execute+0x84>)
 800ce04:	2202      	movs	r2, #2
 800ce06:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 800ce08:	4808      	ldr	r0, [pc, #32]	; (800ce2c <test_013_011_execute+0x8c>)
 800ce0a:	f7fa fc99 	bl	8007740 <test_print>
    test_printn(n * 4);
 800ce0e:	9b03      	ldr	r3, [sp, #12]
 800ce10:	009b      	lsls	r3, r3, #2
 800ce12:	4618      	mov	r0, r3
 800ce14:	f7fa fc4c 	bl	80076b0 <test_printn>
    test_println(" lock+unlock/S");
 800ce18:	4805      	ldr	r0, [pc, #20]	; (800ce30 <test_013_011_execute+0x90>)
 800ce1a:	f7fa fcb1 	bl	8007780 <test_println>
  }
}
 800ce1e:	b005      	add	sp, #20
 800ce20:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce24:	20000cac 	.word	0x20000cac
 800ce28:	200009e8 	.word	0x200009e8
 800ce2c:	0800f744 	.word	0x0800f744
 800ce30:	0800f980 	.word	0x0800f980
 800ce34:	f3af 8000 	nop.w
 800ce38:	f3af 8000 	nop.w
 800ce3c:	f3af 8000 	nop.w

0800ce40 <test_013_012_execute>:
 * - [13.12.8] The size of an event listener is printed.
 * - [13.12.9] The size of a mailbox is printed.
 * .
 */

static void test_013_012_execute(void) {
 800ce40:	b508      	push	{r3, lr}

  /* [13.12.1] The size of the system area is printed.*/
  test_set_step(1);
 800ce42:	4b36      	ldr	r3, [pc, #216]	; (800cf1c <test_013_012_execute+0xdc>)
 800ce44:	2201      	movs	r2, #1
 800ce46:	601a      	str	r2, [r3, #0]
  {
    test_print("--- System: ");
 800ce48:	4835      	ldr	r0, [pc, #212]	; (800cf20 <test_013_012_execute+0xe0>)
 800ce4a:	f7fa fc79 	bl	8007740 <test_print>
    test_printn(sizeof(ch_system_t));
 800ce4e:	2078      	movs	r0, #120	; 0x78
 800ce50:	f7fa fc2e 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800ce54:	4833      	ldr	r0, [pc, #204]	; (800cf24 <test_013_012_execute+0xe4>)
 800ce56:	f7fa fc93 	bl	8007780 <test_println>
  }

  /* [13.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 800ce5a:	4b30      	ldr	r3, [pc, #192]	; (800cf1c <test_013_012_execute+0xdc>)
 800ce5c:	2202      	movs	r2, #2
 800ce5e:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Thread: ");
 800ce60:	4831      	ldr	r0, [pc, #196]	; (800cf28 <test_013_012_execute+0xe8>)
 800ce62:	f7fa fc6d 	bl	8007740 <test_print>
    test_printn(sizeof(thread_t));
 800ce66:	2044      	movs	r0, #68	; 0x44
 800ce68:	f7fa fc22 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800ce6c:	482d      	ldr	r0, [pc, #180]	; (800cf24 <test_013_012_execute+0xe4>)
 800ce6e:	f7fa fc87 	bl	8007780 <test_println>
  }

  /* [13.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 800ce72:	4b2a      	ldr	r3, [pc, #168]	; (800cf1c <test_013_012_execute+0xdc>)
 800ce74:	2203      	movs	r2, #3
 800ce76:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Timer : ");
 800ce78:	482c      	ldr	r0, [pc, #176]	; (800cf2c <test_013_012_execute+0xec>)
 800ce7a:	f7fa fc61 	bl	8007740 <test_print>
    test_printn(sizeof(virtual_timer_t));
 800ce7e:	2014      	movs	r0, #20
 800ce80:	f7fa fc16 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800ce84:	4827      	ldr	r0, [pc, #156]	; (800cf24 <test_013_012_execute+0xe4>)
 800ce86:	f7fa fc7b 	bl	8007780 <test_println>
  }

  /* [13.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 800ce8a:	4b24      	ldr	r3, [pc, #144]	; (800cf1c <test_013_012_execute+0xdc>)
 800ce8c:	2204      	movs	r2, #4
 800ce8e:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800ce90:	4827      	ldr	r0, [pc, #156]	; (800cf30 <test_013_012_execute+0xf0>)
 800ce92:	f7fa fc55 	bl	8007740 <test_print>
    test_printn(sizeof(semaphore_t));
 800ce96:	200c      	movs	r0, #12
 800ce98:	f7fa fc0a 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800ce9c:	4821      	ldr	r0, [pc, #132]	; (800cf24 <test_013_012_execute+0xe4>)
 800ce9e:	f7fa fc6f 	bl	8007780 <test_println>
#endif
  }

  /* [13.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 800cea2:	4b1e      	ldr	r3, [pc, #120]	; (800cf1c <test_013_012_execute+0xdc>)
 800cea4:	2205      	movs	r2, #5
 800cea6:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 800cea8:	4822      	ldr	r0, [pc, #136]	; (800cf34 <test_013_012_execute+0xf4>)
 800ceaa:	f7fa fc49 	bl	8007740 <test_print>
    test_printn(sizeof(mutex_t));
 800ceae:	2010      	movs	r0, #16
 800ceb0:	f7fa fbfe 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800ceb4:	481b      	ldr	r0, [pc, #108]	; (800cf24 <test_013_012_execute+0xe4>)
 800ceb6:	f7fa fc63 	bl	8007780 <test_println>
#endif
  }

  /* [13.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 800ceba:	4b18      	ldr	r3, [pc, #96]	; (800cf1c <test_013_012_execute+0xdc>)
 800cebc:	2206      	movs	r2, #6
 800cebe:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 800cec0:	481d      	ldr	r0, [pc, #116]	; (800cf38 <test_013_012_execute+0xf8>)
 800cec2:	f7fa fc3d 	bl	8007740 <test_print>
    test_printn(sizeof(condition_variable_t));
 800cec6:	2008      	movs	r0, #8
 800cec8:	f7fa fbf2 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800cecc:	4815      	ldr	r0, [pc, #84]	; (800cf24 <test_013_012_execute+0xe4>)
 800cece:	f7fa fc57 	bl	8007780 <test_println>
#endif
  }

  /* [13.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800ced2:	4b12      	ldr	r3, [pc, #72]	; (800cf1c <test_013_012_execute+0xdc>)
 800ced4:	2207      	movs	r2, #7
 800ced6:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 800ced8:	4818      	ldr	r0, [pc, #96]	; (800cf3c <test_013_012_execute+0xfc>)
 800ceda:	f7fa fc31 	bl	8007740 <test_print>
    test_printn(sizeof(event_source_t));
 800cede:	2004      	movs	r0, #4
 800cee0:	f7fa fbe6 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800cee4:	480f      	ldr	r0, [pc, #60]	; (800cf24 <test_013_012_execute+0xe4>)
 800cee6:	f7fa fc4b 	bl	8007780 <test_println>
#endif
  }

  /* [13.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 800ceea:	4b0c      	ldr	r3, [pc, #48]	; (800cf1c <test_013_012_execute+0xdc>)
 800ceec:	2208      	movs	r2, #8
 800ceee:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 800cef0:	4813      	ldr	r0, [pc, #76]	; (800cf40 <test_013_012_execute+0x100>)
 800cef2:	f7fa fc25 	bl	8007740 <test_print>
    test_printn(sizeof(event_listener_t));
 800cef6:	2014      	movs	r0, #20
 800cef8:	f7fa fbda 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800cefc:	4809      	ldr	r0, [pc, #36]	; (800cf24 <test_013_012_execute+0xe4>)
 800cefe:	f7fa fc3f 	bl	8007780 <test_println>
#endif
  }

  /* [13.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 800cf02:	4b06      	ldr	r3, [pc, #24]	; (800cf1c <test_013_012_execute+0xdc>)
 800cf04:	2209      	movs	r2, #9
 800cf06:	601a      	str	r2, [r3, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 800cf08:	480e      	ldr	r0, [pc, #56]	; (800cf44 <test_013_012_execute+0x104>)
 800cf0a:	f7fa fc19 	bl	8007740 <test_print>
    test_printn(sizeof(mailbox_t));
 800cf0e:	2028      	movs	r0, #40	; 0x28
 800cf10:	f7fa fbce 	bl	80076b0 <test_printn>
    test_println(" bytes");
 800cf14:	4803      	ldr	r0, [pc, #12]	; (800cf24 <test_013_012_execute+0xe4>)
 800cf16:	f7fa fc33 	bl	8007780 <test_println>
#endif
  }
}
 800cf1a:	bd08      	pop	{r3, pc}
 800cf1c:	20000cac 	.word	0x20000cac
 800cf20:	0800f9c0 	.word	0x0800f9c0
 800cf24:	0800f9d0 	.word	0x0800f9d0
 800cf28:	0800f9d8 	.word	0x0800f9d8
 800cf2c:	0800f9e8 	.word	0x0800f9e8
 800cf30:	0800f9f8 	.word	0x0800f9f8
 800cf34:	0800fa08 	.word	0x0800fa08
 800cf38:	0800fa18 	.word	0x0800fa18
 800cf3c:	0800fa28 	.word	0x0800fa28
 800cf40:	0800fa38 	.word	0x0800fa38
 800cf44:	0800fa48 	.word	0x0800fa48
	...

0800cf50 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 800cf50:	b088      	sub	sp, #32
 800cf52:	9003      	str	r0, [sp, #12]
 800cf54:	9102      	str	r1, [sp, #8]
 800cf56:	9201      	str	r2, [sp, #4]
 800cf58:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 800cf5a:	9b02      	ldr	r3, [sp, #8]
 800cf5c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 800cf5e:	9b00      	ldr	r3, [sp, #0]
 800cf60:	2b00      	cmp	r3, #0
 800cf62:	d102      	bne.n	800cf6a <long_to_string_with_divisor+0x1a>
    ll = num;
 800cf64:	9b02      	ldr	r3, [sp, #8]
 800cf66:	9304      	str	r3, [sp, #16]
 800cf68:	e001      	b.n	800cf6e <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 800cf6a:	9b00      	ldr	r3, [sp, #0]
 800cf6c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 800cf6e:	9b03      	ldr	r3, [sp, #12]
 800cf70:	330b      	adds	r3, #11
 800cf72:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 800cf74:	9b05      	ldr	r3, [sp, #20]
 800cf76:	9a01      	ldr	r2, [sp, #4]
 800cf78:	fbb3 f2f2 	udiv	r2, r3, r2
 800cf7c:	9901      	ldr	r1, [sp, #4]
 800cf7e:	fb01 f202 	mul.w	r2, r1, r2
 800cf82:	1a9b      	subs	r3, r3, r2
 800cf84:	9307      	str	r3, [sp, #28]
    i += '0';
 800cf86:	9b07      	ldr	r3, [sp, #28]
 800cf88:	3330      	adds	r3, #48	; 0x30
 800cf8a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 800cf8c:	9b07      	ldr	r3, [sp, #28]
 800cf8e:	2b39      	cmp	r3, #57	; 0x39
 800cf90:	dd02      	ble.n	800cf98 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 800cf92:	9b07      	ldr	r3, [sp, #28]
 800cf94:	3307      	adds	r3, #7
 800cf96:	9307      	str	r3, [sp, #28]
    *--q = i;
 800cf98:	9b06      	ldr	r3, [sp, #24]
 800cf9a:	3b01      	subs	r3, #1
 800cf9c:	9306      	str	r3, [sp, #24]
 800cf9e:	9b07      	ldr	r3, [sp, #28]
 800cfa0:	b2da      	uxtb	r2, r3
 800cfa2:	9b06      	ldr	r3, [sp, #24]
 800cfa4:	701a      	strb	r2, [r3, #0]
    l /= radix;
 800cfa6:	9a05      	ldr	r2, [sp, #20]
 800cfa8:	9b01      	ldr	r3, [sp, #4]
 800cfaa:	fbb2 f3f3 	udiv	r3, r2, r3
 800cfae:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 800cfb0:	9a04      	ldr	r2, [sp, #16]
 800cfb2:	9b01      	ldr	r3, [sp, #4]
 800cfb4:	fbb2 f3f3 	udiv	r3, r2, r3
 800cfb8:	9304      	str	r3, [sp, #16]
 800cfba:	9b04      	ldr	r3, [sp, #16]
 800cfbc:	2b00      	cmp	r3, #0
 800cfbe:	d1d9      	bne.n	800cf74 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 800cfc0:	9b03      	ldr	r3, [sp, #12]
 800cfc2:	330b      	adds	r3, #11
 800cfc4:	461a      	mov	r2, r3
 800cfc6:	9b06      	ldr	r3, [sp, #24]
 800cfc8:	1ad3      	subs	r3, r2, r3
 800cfca:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 800cfcc:	9b03      	ldr	r3, [sp, #12]
 800cfce:	1c5a      	adds	r2, r3, #1
 800cfd0:	9203      	str	r2, [sp, #12]
 800cfd2:	9a06      	ldr	r2, [sp, #24]
 800cfd4:	1c51      	adds	r1, r2, #1
 800cfd6:	9106      	str	r1, [sp, #24]
 800cfd8:	7812      	ldrb	r2, [r2, #0]
 800cfda:	701a      	strb	r2, [r3, #0]
  while (--i);
 800cfdc:	9b07      	ldr	r3, [sp, #28]
 800cfde:	3b01      	subs	r3, #1
 800cfe0:	9307      	str	r3, [sp, #28]
 800cfe2:	9b07      	ldr	r3, [sp, #28]
 800cfe4:	2b00      	cmp	r3, #0
 800cfe6:	d1f1      	bne.n	800cfcc <long_to_string_with_divisor+0x7c>

  return p;
 800cfe8:	9b03      	ldr	r3, [sp, #12]
}
 800cfea:	4618      	mov	r0, r3
 800cfec:	b008      	add	sp, #32
 800cfee:	4770      	bx	lr

0800cff0 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 800cff0:	b500      	push	{lr}
 800cff2:	b085      	sub	sp, #20
 800cff4:	9003      	str	r0, [sp, #12]
 800cff6:	9102      	str	r1, [sp, #8]
 800cff8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800cffa:	9803      	ldr	r0, [sp, #12]
 800cffc:	9902      	ldr	r1, [sp, #8]
 800cffe:	9a01      	ldr	r2, [sp, #4]
 800d000:	2300      	movs	r3, #0
 800d002:	f7ff ffa5 	bl	800cf50 <long_to_string_with_divisor>
 800d006:	4603      	mov	r3, r0
}
 800d008:	4618      	mov	r0, r3
 800d00a:	b005      	add	sp, #20
 800d00c:	f85d fb04 	ldr.w	pc, [sp], #4

0800d010 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800d010:	b500      	push	{lr}
 800d012:	b091      	sub	sp, #68	; 0x44
 800d014:	9003      	str	r0, [sp, #12]
 800d016:	9102      	str	r1, [sp, #8]
 800d018:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800d01a:	2300      	movs	r3, #0
 800d01c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800d01e:	9b02      	ldr	r3, [sp, #8]
 800d020:	1c5a      	adds	r2, r3, #1
 800d022:	9202      	str	r2, [sp, #8]
 800d024:	781b      	ldrb	r3, [r3, #0]
 800d026:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 800d02a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d02e:	2b00      	cmp	r3, #0
 800d030:	d101      	bne.n	800d036 <chvprintf+0x26>
      return n;
 800d032:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d034:	e210      	b.n	800d458 <chvprintf+0x448>
    if (c != '%') {
 800d036:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d03a:	2b25      	cmp	r3, #37	; 0x25
 800d03c:	d00b      	beq.n	800d056 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 800d03e:	9b03      	ldr	r3, [sp, #12]
 800d040:	681b      	ldr	r3, [r3, #0]
 800d042:	689b      	ldr	r3, [r3, #8]
 800d044:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 800d048:	9803      	ldr	r0, [sp, #12]
 800d04a:	4611      	mov	r1, r2
 800d04c:	4798      	blx	r3
      n++;
 800d04e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d050:	3301      	adds	r3, #1
 800d052:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 800d054:	e1ff      	b.n	800d456 <chvprintf+0x446>
    }
    p = tmpbuf;
 800d056:	ab04      	add	r3, sp, #16
 800d058:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 800d05a:	ab04      	add	r3, sp, #16
 800d05c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 800d05e:	2300      	movs	r3, #0
 800d060:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 800d064:	9b02      	ldr	r3, [sp, #8]
 800d066:	781b      	ldrb	r3, [r3, #0]
 800d068:	2b2d      	cmp	r3, #45	; 0x2d
 800d06a:	d105      	bne.n	800d078 <chvprintf+0x68>
      fmt++;
 800d06c:	9b02      	ldr	r3, [sp, #8]
 800d06e:	3301      	adds	r3, #1
 800d070:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 800d072:	2301      	movs	r3, #1
 800d074:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 800d078:	2320      	movs	r3, #32
 800d07a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 800d07e:	9b02      	ldr	r3, [sp, #8]
 800d080:	781b      	ldrb	r3, [r3, #0]
 800d082:	2b30      	cmp	r3, #48	; 0x30
 800d084:	d105      	bne.n	800d092 <chvprintf+0x82>
      fmt++;
 800d086:	9b02      	ldr	r3, [sp, #8]
 800d088:	3301      	adds	r3, #1
 800d08a:	9302      	str	r3, [sp, #8]
      filler = '0';
 800d08c:	2330      	movs	r3, #48	; 0x30
 800d08e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 800d092:	2300      	movs	r3, #0
 800d094:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 800d096:	9b02      	ldr	r3, [sp, #8]
 800d098:	1c5a      	adds	r2, r3, #1
 800d09a:	9202      	str	r2, [sp, #8]
 800d09c:	781b      	ldrb	r3, [r3, #0]
 800d09e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 800d0a2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0a6:	2b2f      	cmp	r3, #47	; 0x2f
 800d0a8:	d909      	bls.n	800d0be <chvprintf+0xae>
 800d0aa:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0ae:	2b39      	cmp	r3, #57	; 0x39
 800d0b0:	d805      	bhi.n	800d0be <chvprintf+0xae>
        c -= '0';
 800d0b2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0b6:	3b30      	subs	r3, #48	; 0x30
 800d0b8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800d0bc:	e012      	b.n	800d0e4 <chvprintf+0xd4>
      else if (c == '*')
 800d0be:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0c2:	2b2a      	cmp	r3, #42	; 0x2a
 800d0c4:	d106      	bne.n	800d0d4 <chvprintf+0xc4>
        c = va_arg(ap, int);
 800d0c6:	9b01      	ldr	r3, [sp, #4]
 800d0c8:	1d1a      	adds	r2, r3, #4
 800d0ca:	9201      	str	r2, [sp, #4]
 800d0cc:	681b      	ldr	r3, [r3, #0]
 800d0ce:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800d0d2:	e007      	b.n	800d0e4 <chvprintf+0xd4>
      else
        break;
 800d0d4:	bf00      	nop
      width = width * 10 + c;
    }
    precision = 0;
 800d0d6:	2300      	movs	r3, #0
 800d0d8:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 800d0da:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0de:	2b2e      	cmp	r3, #46	; 0x2e
 800d0e0:	d137      	bne.n	800d152 <chvprintf+0x142>
 800d0e2:	e00a      	b.n	800d0fa <chvprintf+0xea>
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 800d0e4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d0e6:	4613      	mov	r3, r2
 800d0e8:	009b      	lsls	r3, r3, #2
 800d0ea:	4413      	add	r3, r2
 800d0ec:	005b      	lsls	r3, r3, #1
 800d0ee:	461a      	mov	r2, r3
 800d0f0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d0f4:	4413      	add	r3, r2
 800d0f6:	930a      	str	r3, [sp, #40]	; 0x28
    }
 800d0f8:	e7cd      	b.n	800d096 <chvprintf+0x86>
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800d0fa:	9b02      	ldr	r3, [sp, #8]
 800d0fc:	1c5a      	adds	r2, r3, #1
 800d0fe:	9202      	str	r2, [sp, #8]
 800d100:	781b      	ldrb	r3, [r3, #0]
 800d102:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 800d106:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d10a:	2b2f      	cmp	r3, #47	; 0x2f
 800d10c:	d909      	bls.n	800d122 <chvprintf+0x112>
 800d10e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d112:	2b39      	cmp	r3, #57	; 0x39
 800d114:	d805      	bhi.n	800d122 <chvprintf+0x112>
          c -= '0';
 800d116:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d11a:	3b30      	subs	r3, #48	; 0x30
 800d11c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800d120:	e00b      	b.n	800d13a <chvprintf+0x12a>
        else if (c == '*')
 800d122:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d126:	2b2a      	cmp	r3, #42	; 0x2a
 800d128:	d106      	bne.n	800d138 <chvprintf+0x128>
          c = va_arg(ap, int);
 800d12a:	9b01      	ldr	r3, [sp, #4]
 800d12c:	1d1a      	adds	r2, r3, #4
 800d12e:	9201      	str	r2, [sp, #4]
 800d130:	681b      	ldr	r3, [r3, #0]
 800d132:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800d136:	e000      	b.n	800d13a <chvprintf+0x12a>
        else
          break;
 800d138:	e00b      	b.n	800d152 <chvprintf+0x142>
        precision *= 10;
 800d13a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d13c:	4613      	mov	r3, r2
 800d13e:	009b      	lsls	r3, r3, #2
 800d140:	4413      	add	r3, r2
 800d142:	005b      	lsls	r3, r3, #1
 800d144:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 800d146:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d14a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d14c:	4413      	add	r3, r2
 800d14e:	930b      	str	r3, [sp, #44]	; 0x2c
      }
 800d150:	e7d3      	b.n	800d0fa <chvprintf+0xea>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800d152:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d156:	2b6c      	cmp	r3, #108	; 0x6c
 800d158:	d003      	beq.n	800d162 <chvprintf+0x152>
 800d15a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d15e:	2b4c      	cmp	r3, #76	; 0x4c
 800d160:	d10e      	bne.n	800d180 <chvprintf+0x170>
      is_long = TRUE;
 800d162:	2301      	movs	r3, #1
 800d164:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 800d168:	9b02      	ldr	r3, [sp, #8]
 800d16a:	781b      	ldrb	r3, [r3, #0]
 800d16c:	2b00      	cmp	r3, #0
 800d16e:	d006      	beq.n	800d17e <chvprintf+0x16e>
        c = *fmt++;
 800d170:	9b02      	ldr	r3, [sp, #8]
 800d172:	1c5a      	adds	r2, r3, #1
 800d174:	9202      	str	r2, [sp, #8]
 800d176:	781b      	ldrb	r3, [r3, #0]
 800d178:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 800d17c:	e013      	b.n	800d1a6 <chvprintf+0x196>
 800d17e:	e012      	b.n	800d1a6 <chvprintf+0x196>
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 800d180:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d184:	2b40      	cmp	r3, #64	; 0x40
 800d186:	d905      	bls.n	800d194 <chvprintf+0x184>
 800d188:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d18c:	2b5a      	cmp	r3, #90	; 0x5a
 800d18e:	d801      	bhi.n	800d194 <chvprintf+0x184>
 800d190:	2301      	movs	r3, #1
 800d192:	e000      	b.n	800d196 <chvprintf+0x186>
 800d194:	2300      	movs	r3, #0
 800d196:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800d19a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800d19e:	f003 0301 	and.w	r3, r3, #1
 800d1a2:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    /* Command decoding.*/
    switch (c) {
 800d1a6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d1aa:	3b44      	subs	r3, #68	; 0x44
 800d1ac:	2b34      	cmp	r3, #52	; 0x34
 800d1ae:	f200 80e2 	bhi.w	800d376 <chvprintf+0x366>
 800d1b2:	a201      	add	r2, pc, #4	; (adr r2, 800d1b8 <chvprintf+0x1a8>)
 800d1b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d1b8:	0800d2ef 	.word	0x0800d2ef
 800d1bc:	0800d377 	.word	0x0800d377
 800d1c0:	0800d377 	.word	0x0800d377
 800d1c4:	0800d377 	.word	0x0800d377
 800d1c8:	0800d377 	.word	0x0800d377
 800d1cc:	0800d2ef 	.word	0x0800d2ef
 800d1d0:	0800d377 	.word	0x0800d377
 800d1d4:	0800d377 	.word	0x0800d377
 800d1d8:	0800d377 	.word	0x0800d377
 800d1dc:	0800d377 	.word	0x0800d377
 800d1e0:	0800d377 	.word	0x0800d377
 800d1e4:	0800d341 	.word	0x0800d341
 800d1e8:	0800d377 	.word	0x0800d377
 800d1ec:	0800d377 	.word	0x0800d377
 800d1f0:	0800d377 	.word	0x0800d377
 800d1f4:	0800d377 	.word	0x0800d377
 800d1f8:	0800d377 	.word	0x0800d377
 800d1fc:	0800d339 	.word	0x0800d339
 800d200:	0800d377 	.word	0x0800d377
 800d204:	0800d377 	.word	0x0800d377
 800d208:	0800d331 	.word	0x0800d331
 800d20c:	0800d377 	.word	0x0800d377
 800d210:	0800d377 	.word	0x0800d377
 800d214:	0800d377 	.word	0x0800d377
 800d218:	0800d377 	.word	0x0800d377
 800d21c:	0800d377 	.word	0x0800d377
 800d220:	0800d377 	.word	0x0800d377
 800d224:	0800d377 	.word	0x0800d377
 800d228:	0800d377 	.word	0x0800d377
 800d22c:	0800d377 	.word	0x0800d377
 800d230:	0800d377 	.word	0x0800d377
 800d234:	0800d28d 	.word	0x0800d28d
 800d238:	0800d2ef 	.word	0x0800d2ef
 800d23c:	0800d377 	.word	0x0800d377
 800d240:	0800d377 	.word	0x0800d377
 800d244:	0800d377 	.word	0x0800d377
 800d248:	0800d377 	.word	0x0800d377
 800d24c:	0800d2ef 	.word	0x0800d2ef
 800d250:	0800d377 	.word	0x0800d377
 800d254:	0800d377 	.word	0x0800d377
 800d258:	0800d377 	.word	0x0800d377
 800d25c:	0800d377 	.word	0x0800d377
 800d260:	0800d377 	.word	0x0800d377
 800d264:	0800d341 	.word	0x0800d341
 800d268:	0800d377 	.word	0x0800d377
 800d26c:	0800d377 	.word	0x0800d377
 800d270:	0800d377 	.word	0x0800d377
 800d274:	0800d2a7 	.word	0x0800d2a7
 800d278:	0800d377 	.word	0x0800d377
 800d27c:	0800d339 	.word	0x0800d339
 800d280:	0800d377 	.word	0x0800d377
 800d284:	0800d377 	.word	0x0800d377
 800d288:	0800d331 	.word	0x0800d331
    case 'c':
      filler = ' ';
 800d28c:	2320      	movs	r3, #32
 800d28e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 800d292:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d294:	1c5a      	adds	r2, r3, #1
 800d296:	920f      	str	r2, [sp, #60]	; 0x3c
 800d298:	9a01      	ldr	r2, [sp, #4]
 800d29a:	1d11      	adds	r1, r2, #4
 800d29c:	9101      	str	r1, [sp, #4]
 800d29e:	6812      	ldr	r2, [r2, #0]
 800d2a0:	b2d2      	uxtb	r2, r2
 800d2a2:	701a      	strb	r2, [r3, #0]
      break;
 800d2a4:	e06e      	b.n	800d384 <chvprintf+0x374>
    case 's':
      filler = ' ';
 800d2a6:	2320      	movs	r3, #32
 800d2a8:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 800d2ac:	9b01      	ldr	r3, [sp, #4]
 800d2ae:	1d1a      	adds	r2, r3, #4
 800d2b0:	9201      	str	r2, [sp, #4]
 800d2b2:	681b      	ldr	r3, [r3, #0]
 800d2b4:	930e      	str	r3, [sp, #56]	; 0x38
 800d2b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d2b8:	2b00      	cmp	r3, #0
 800d2ba:	d101      	bne.n	800d2c0 <chvprintf+0x2b0>
        s = "(null)";
 800d2bc:	4b68      	ldr	r3, [pc, #416]	; (800d460 <chvprintf+0x450>)
 800d2be:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 800d2c0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d2c2:	2b00      	cmp	r3, #0
 800d2c4:	d102      	bne.n	800d2cc <chvprintf+0x2bc>
        precision = 32767;
 800d2c6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800d2ca:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 800d2cc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d2ce:	930f      	str	r3, [sp, #60]	; 0x3c
 800d2d0:	e002      	b.n	800d2d8 <chvprintf+0x2c8>
 800d2d2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d2d4:	3301      	adds	r3, #1
 800d2d6:	930f      	str	r3, [sp, #60]	; 0x3c
 800d2d8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d2da:	781b      	ldrb	r3, [r3, #0]
 800d2dc:	2b00      	cmp	r3, #0
 800d2de:	d005      	beq.n	800d2ec <chvprintf+0x2dc>
 800d2e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d2e2:	3b01      	subs	r3, #1
 800d2e4:	930b      	str	r3, [sp, #44]	; 0x2c
 800d2e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d2e8:	2b00      	cmp	r3, #0
 800d2ea:	daf2      	bge.n	800d2d2 <chvprintf+0x2c2>
        ;
      break;
 800d2ec:	e04a      	b.n	800d384 <chvprintf+0x374>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 800d2ee:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800d2f2:	2b00      	cmp	r3, #0
 800d2f4:	d005      	beq.n	800d302 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 800d2f6:	9b01      	ldr	r3, [sp, #4]
 800d2f8:	1d1a      	adds	r2, r3, #4
 800d2fa:	9201      	str	r2, [sp, #4]
 800d2fc:	681b      	ldr	r3, [r3, #0]
 800d2fe:	9307      	str	r3, [sp, #28]
 800d300:	e004      	b.n	800d30c <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 800d302:	9b01      	ldr	r3, [sp, #4]
 800d304:	1d1a      	adds	r2, r3, #4
 800d306:	9201      	str	r2, [sp, #4]
 800d308:	681b      	ldr	r3, [r3, #0]
 800d30a:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 800d30c:	9b07      	ldr	r3, [sp, #28]
 800d30e:	2b00      	cmp	r3, #0
 800d310:	da07      	bge.n	800d322 <chvprintf+0x312>
        *p++ = '-';
 800d312:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d314:	1c5a      	adds	r2, r3, #1
 800d316:	920f      	str	r2, [sp, #60]	; 0x3c
 800d318:	222d      	movs	r2, #45	; 0x2d
 800d31a:	701a      	strb	r2, [r3, #0]
        l = -l;
 800d31c:	9b07      	ldr	r3, [sp, #28]
 800d31e:	425b      	negs	r3, r3
 800d320:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 800d322:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800d324:	9907      	ldr	r1, [sp, #28]
 800d326:	220a      	movs	r2, #10
 800d328:	f7ff fe62 	bl	800cff0 <ch_ltoa>
 800d32c:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 800d32e:	e029      	b.n	800d384 <chvprintf+0x374>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 800d330:	2310      	movs	r3, #16
 800d332:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 800d336:	e006      	b.n	800d346 <chvprintf+0x336>
    case 'U':
    case 'u':
      c = 10;
 800d338:	230a      	movs	r3, #10
 800d33a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 800d33e:	e002      	b.n	800d346 <chvprintf+0x336>
    case 'O':
    case 'o':
      c = 8;
 800d340:	2308      	movs	r3, #8
 800d342:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 800d346:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800d34a:	2b00      	cmp	r3, #0
 800d34c:	d005      	beq.n	800d35a <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 800d34e:	9b01      	ldr	r3, [sp, #4]
 800d350:	1d1a      	adds	r2, r3, #4
 800d352:	9201      	str	r2, [sp, #4]
 800d354:	681b      	ldr	r3, [r3, #0]
 800d356:	9307      	str	r3, [sp, #28]
 800d358:	e004      	b.n	800d364 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 800d35a:	9b01      	ldr	r3, [sp, #4]
 800d35c:	1d1a      	adds	r2, r3, #4
 800d35e:	9201      	str	r2, [sp, #4]
 800d360:	681b      	ldr	r3, [r3, #0]
 800d362:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 800d364:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800d368:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800d36a:	9907      	ldr	r1, [sp, #28]
 800d36c:	461a      	mov	r2, r3
 800d36e:	f7ff fe3f 	bl	800cff0 <ch_ltoa>
 800d372:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 800d374:	e006      	b.n	800d384 <chvprintf+0x374>
    default:
      *p++ = c;
 800d376:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d378:	1c5a      	adds	r2, r3, #1
 800d37a:	920f      	str	r2, [sp, #60]	; 0x3c
 800d37c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 800d380:	701a      	strb	r2, [r3, #0]
      break;
 800d382:	bf00      	nop
    }
    i = (int)(p - s);
 800d384:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d386:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d388:	1ad3      	subs	r3, r2, r3
 800d38a:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 800d38c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d38e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d390:	1ad3      	subs	r3, r2, r3
 800d392:	930a      	str	r3, [sp, #40]	; 0x28
 800d394:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d396:	2b00      	cmp	r3, #0
 800d398:	da01      	bge.n	800d39e <chvprintf+0x38e>
      width = 0;
 800d39a:	2300      	movs	r3, #0
 800d39c:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 800d39e:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 800d3a2:	f083 0301 	eor.w	r3, r3, #1
 800d3a6:	b2db      	uxtb	r3, r3
 800d3a8:	2b00      	cmp	r3, #0
 800d3aa:	d002      	beq.n	800d3b2 <chvprintf+0x3a2>
      width = -width;
 800d3ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d3ae:	425b      	negs	r3, r3
 800d3b0:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 800d3b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d3b4:	2b00      	cmp	r3, #0
 800d3b6:	da28      	bge.n	800d40a <chvprintf+0x3fa>
      if (*s == '-' && filler == '0') {
 800d3b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d3ba:	781b      	ldrb	r3, [r3, #0]
 800d3bc:	2b2d      	cmp	r3, #45	; 0x2d
 800d3be:	d113      	bne.n	800d3e8 <chvprintf+0x3d8>
 800d3c0:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800d3c4:	2b30      	cmp	r3, #48	; 0x30
 800d3c6:	d10f      	bne.n	800d3e8 <chvprintf+0x3d8>
        streamPut(chp, (uint8_t)*s++);
 800d3c8:	9b03      	ldr	r3, [sp, #12]
 800d3ca:	681b      	ldr	r3, [r3, #0]
 800d3cc:	689a      	ldr	r2, [r3, #8]
 800d3ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d3d0:	1c59      	adds	r1, r3, #1
 800d3d2:	910e      	str	r1, [sp, #56]	; 0x38
 800d3d4:	781b      	ldrb	r3, [r3, #0]
 800d3d6:	9803      	ldr	r0, [sp, #12]
 800d3d8:	4619      	mov	r1, r3
 800d3da:	4790      	blx	r2
        n++;
 800d3dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d3de:	3301      	adds	r3, #1
 800d3e0:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 800d3e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d3e4:	3b01      	subs	r3, #1
 800d3e6:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800d3e8:	9b03      	ldr	r3, [sp, #12]
 800d3ea:	681b      	ldr	r3, [r3, #0]
 800d3ec:	689b      	ldr	r3, [r3, #8]
 800d3ee:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 800d3f2:	9803      	ldr	r0, [sp, #12]
 800d3f4:	4611      	mov	r1, r2
 800d3f6:	4798      	blx	r3
        n++;
 800d3f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d3fa:	3301      	adds	r3, #1
 800d3fc:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 800d3fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d400:	3301      	adds	r3, #1
 800d402:	930a      	str	r3, [sp, #40]	; 0x28
 800d404:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d406:	2b00      	cmp	r3, #0
 800d408:	d1ee      	bne.n	800d3e8 <chvprintf+0x3d8>
    }
    while (--i >= 0) {
 800d40a:	e00c      	b.n	800d426 <chvprintf+0x416>
      streamPut(chp, (uint8_t)*s++);
 800d40c:	9b03      	ldr	r3, [sp, #12]
 800d40e:	681b      	ldr	r3, [r3, #0]
 800d410:	689a      	ldr	r2, [r3, #8]
 800d412:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d414:	1c59      	adds	r1, r3, #1
 800d416:	910e      	str	r1, [sp, #56]	; 0x38
 800d418:	781b      	ldrb	r3, [r3, #0]
 800d41a:	9803      	ldr	r0, [sp, #12]
 800d41c:	4619      	mov	r1, r3
 800d41e:	4790      	blx	r2
      n++;
 800d420:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d422:	3301      	adds	r3, #1
 800d424:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800d426:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d428:	3b01      	subs	r3, #1
 800d42a:	930c      	str	r3, [sp, #48]	; 0x30
 800d42c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d42e:	2b00      	cmp	r3, #0
 800d430:	daec      	bge.n	800d40c <chvprintf+0x3fc>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800d432:	e00d      	b.n	800d450 <chvprintf+0x440>
      streamPut(chp, (uint8_t)filler);
 800d434:	9b03      	ldr	r3, [sp, #12]
 800d436:	681b      	ldr	r3, [r3, #0]
 800d438:	689b      	ldr	r3, [r3, #8]
 800d43a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 800d43e:	9803      	ldr	r0, [sp, #12]
 800d440:	4611      	mov	r1, r2
 800d442:	4798      	blx	r3
      n++;
 800d444:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d446:	3301      	adds	r3, #1
 800d448:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 800d44a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d44c:	3b01      	subs	r3, #1
 800d44e:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800d450:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d452:	2b00      	cmp	r3, #0
 800d454:	d1ee      	bne.n	800d434 <chvprintf+0x424>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
 800d456:	e5e2      	b.n	800d01e <chvprintf+0xe>
}
 800d458:	4618      	mov	r0, r3
 800d45a:	b011      	add	sp, #68	; 0x44
 800d45c:	f85d fb04 	ldr.w	pc, [sp], #4
 800d460:	0800faac 	.word	0x0800faac
 800d464:	f3af 8000 	nop.w
 800d468:	f3af 8000 	nop.w
 800d46c:	f3af 8000 	nop.w

0800d470 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800d470:	b40e      	push	{r1, r2, r3}
 800d472:	b500      	push	{lr}
 800d474:	b084      	sub	sp, #16
 800d476:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800d478:	ab06      	add	r3, sp, #24
 800d47a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800d47c:	9801      	ldr	r0, [sp, #4]
 800d47e:	9905      	ldr	r1, [sp, #20]
 800d480:	9a02      	ldr	r2, [sp, #8]
 800d482:	f7ff fdc5 	bl	800d010 <chvprintf>
 800d486:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 800d488:	9b03      	ldr	r3, [sp, #12]
}
 800d48a:	4618      	mov	r0, r3
 800d48c:	b004      	add	sp, #16
 800d48e:	f85d eb04 	ldr.w	lr, [sp], #4
 800d492:	b003      	add	sp, #12
 800d494:	4770      	bx	lr
 800d496:	bf00      	nop
 800d498:	f3af 8000 	nop.w
 800d49c:	f3af 8000 	nop.w

0800d4a0 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 800d4a0:	b40c      	push	{r2, r3}
 800d4a2:	b500      	push	{lr}
 800d4a4:	b08d      	sub	sp, #52	; 0x34
 800d4a6:	9001      	str	r0, [sp, #4]
 800d4a8:	9100      	str	r1, [sp, #0]
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800d4aa:	9b00      	ldr	r3, [sp, #0]
 800d4ac:	2b00      	cmp	r3, #0
 800d4ae:	d003      	beq.n	800d4b8 <chsnprintf+0x18>
    size_wo_nul = size - 1;
 800d4b0:	9b00      	ldr	r3, [sp, #0]
 800d4b2:	3b01      	subs	r3, #1
 800d4b4:	930b      	str	r3, [sp, #44]	; 0x2c
 800d4b6:	e001      	b.n	800d4bc <chsnprintf+0x1c>
  else
    size_wo_nul = 0;
 800d4b8:	2300      	movs	r3, #0
 800d4ba:	930b      	str	r3, [sp, #44]	; 0x2c

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 800d4bc:	ab03      	add	r3, sp, #12
 800d4be:	4618      	mov	r0, r3
 800d4c0:	9901      	ldr	r1, [sp, #4]
 800d4c2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d4c4:	2300      	movs	r3, #0
 800d4c6:	f000 f8c3 	bl	800d650 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
 800d4ca:	ab03      	add	r3, sp, #12
 800d4cc:	930a      	str	r3, [sp, #40]	; 0x28
  va_start(ap, fmt);
 800d4ce:	ab0f      	add	r3, sp, #60	; 0x3c
 800d4d0:	9308      	str	r3, [sp, #32]
  retval = chvprintf(chp, fmt, ap);
 800d4d2:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d4d4:	990e      	ldr	r1, [sp, #56]	; 0x38
 800d4d6:	9a08      	ldr	r2, [sp, #32]
 800d4d8:	f7ff fd9a 	bl	800d010 <chvprintf>
 800d4dc:	9009      	str	r0, [sp, #36]	; 0x24
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 800d4de:	9a06      	ldr	r2, [sp, #24]
 800d4e0:	9b00      	ldr	r3, [sp, #0]
 800d4e2:	429a      	cmp	r2, r3
 800d4e4:	d204      	bcs.n	800d4f0 <chsnprintf+0x50>
      str[ms.eos] = 0;
 800d4e6:	9b06      	ldr	r3, [sp, #24]
 800d4e8:	9a01      	ldr	r2, [sp, #4]
 800d4ea:	4413      	add	r3, r2
 800d4ec:	2200      	movs	r2, #0
 800d4ee:	701a      	strb	r2, [r3, #0]

  /* Return number of bytes that would have been written.*/
  return retval;
 800d4f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 800d4f2:	4618      	mov	r0, r3
 800d4f4:	b00d      	add	sp, #52	; 0x34
 800d4f6:	f85d eb04 	ldr.w	lr, [sp], #4
 800d4fa:	b002      	add	sp, #8
 800d4fc:	4770      	bx	lr
 800d4fe:	bf00      	nop

0800d500 <_writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 800d500:	b500      	push	{lr}
 800d502:	b087      	sub	sp, #28
 800d504:	9003      	str	r0, [sp, #12]
 800d506:	9102      	str	r1, [sp, #8]
 800d508:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 800d50a:	9b03      	ldr	r3, [sp, #12]
 800d50c:	9305      	str	r3, [sp, #20]

  if (msp->size - msp->eos < n)
 800d50e:	9b05      	ldr	r3, [sp, #20]
 800d510:	689a      	ldr	r2, [r3, #8]
 800d512:	9b05      	ldr	r3, [sp, #20]
 800d514:	68db      	ldr	r3, [r3, #12]
 800d516:	1ad2      	subs	r2, r2, r3
 800d518:	9b01      	ldr	r3, [sp, #4]
 800d51a:	429a      	cmp	r2, r3
 800d51c:	d205      	bcs.n	800d52a <_writes+0x2a>
    n = msp->size - msp->eos;
 800d51e:	9b05      	ldr	r3, [sp, #20]
 800d520:	689a      	ldr	r2, [r3, #8]
 800d522:	9b05      	ldr	r3, [sp, #20]
 800d524:	68db      	ldr	r3, [r3, #12]
 800d526:	1ad3      	subs	r3, r2, r3
 800d528:	9301      	str	r3, [sp, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 800d52a:	9b05      	ldr	r3, [sp, #20]
 800d52c:	685a      	ldr	r2, [r3, #4]
 800d52e:	9b05      	ldr	r3, [sp, #20]
 800d530:	68db      	ldr	r3, [r3, #12]
 800d532:	4413      	add	r3, r2
 800d534:	4618      	mov	r0, r3
 800d536:	9902      	ldr	r1, [sp, #8]
 800d538:	9a01      	ldr	r2, [sp, #4]
 800d53a:	f000 fa51 	bl	800d9e0 <memcpy>
  msp->eos += n;
 800d53e:	9b05      	ldr	r3, [sp, #20]
 800d540:	68da      	ldr	r2, [r3, #12]
 800d542:	9b01      	ldr	r3, [sp, #4]
 800d544:	441a      	add	r2, r3
 800d546:	9b05      	ldr	r3, [sp, #20]
 800d548:	60da      	str	r2, [r3, #12]
  return n;
 800d54a:	9b01      	ldr	r3, [sp, #4]
}
 800d54c:	4618      	mov	r0, r3
 800d54e:	b007      	add	sp, #28
 800d550:	f85d fb04 	ldr.w	pc, [sp], #4
 800d554:	f3af 8000 	nop.w
 800d558:	f3af 8000 	nop.w
 800d55c:	f3af 8000 	nop.w

0800d560 <_reads>:

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 800d560:	b500      	push	{lr}
 800d562:	b087      	sub	sp, #28
 800d564:	9003      	str	r0, [sp, #12]
 800d566:	9102      	str	r1, [sp, #8]
 800d568:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 800d56a:	9b03      	ldr	r3, [sp, #12]
 800d56c:	9305      	str	r3, [sp, #20]

  if (msp->eos - msp->offset < n)
 800d56e:	9b05      	ldr	r3, [sp, #20]
 800d570:	68da      	ldr	r2, [r3, #12]
 800d572:	9b05      	ldr	r3, [sp, #20]
 800d574:	691b      	ldr	r3, [r3, #16]
 800d576:	1ad2      	subs	r2, r2, r3
 800d578:	9b01      	ldr	r3, [sp, #4]
 800d57a:	429a      	cmp	r2, r3
 800d57c:	d205      	bcs.n	800d58a <_reads+0x2a>
    n = msp->eos - msp->offset;
 800d57e:	9b05      	ldr	r3, [sp, #20]
 800d580:	68da      	ldr	r2, [r3, #12]
 800d582:	9b05      	ldr	r3, [sp, #20]
 800d584:	691b      	ldr	r3, [r3, #16]
 800d586:	1ad3      	subs	r3, r2, r3
 800d588:	9301      	str	r3, [sp, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 800d58a:	9b05      	ldr	r3, [sp, #20]
 800d58c:	685a      	ldr	r2, [r3, #4]
 800d58e:	9b05      	ldr	r3, [sp, #20]
 800d590:	691b      	ldr	r3, [r3, #16]
 800d592:	4413      	add	r3, r2
 800d594:	9802      	ldr	r0, [sp, #8]
 800d596:	4619      	mov	r1, r3
 800d598:	9a01      	ldr	r2, [sp, #4]
 800d59a:	f000 fa21 	bl	800d9e0 <memcpy>
  msp->offset += n;
 800d59e:	9b05      	ldr	r3, [sp, #20]
 800d5a0:	691a      	ldr	r2, [r3, #16]
 800d5a2:	9b01      	ldr	r3, [sp, #4]
 800d5a4:	441a      	add	r2, r3
 800d5a6:	9b05      	ldr	r3, [sp, #20]
 800d5a8:	611a      	str	r2, [r3, #16]
  return n;
 800d5aa:	9b01      	ldr	r3, [sp, #4]
}
 800d5ac:	4618      	mov	r0, r3
 800d5ae:	b007      	add	sp, #28
 800d5b0:	f85d fb04 	ldr.w	pc, [sp], #4
 800d5b4:	f3af 8000 	nop.w
 800d5b8:	f3af 8000 	nop.w
 800d5bc:	f3af 8000 	nop.w

0800d5c0 <_put>:

static msg_t _put(void *ip, uint8_t b) {
 800d5c0:	b084      	sub	sp, #16
 800d5c2:	9001      	str	r0, [sp, #4]
 800d5c4:	460b      	mov	r3, r1
 800d5c6:	f88d 3003 	strb.w	r3, [sp, #3]
  MemoryStream *msp = ip;
 800d5ca:	9b01      	ldr	r3, [sp, #4]
 800d5cc:	9303      	str	r3, [sp, #12]

  if (msp->size - msp->eos <= 0)
 800d5ce:	9b03      	ldr	r3, [sp, #12]
 800d5d0:	689a      	ldr	r2, [r3, #8]
 800d5d2:	9b03      	ldr	r3, [sp, #12]
 800d5d4:	68db      	ldr	r3, [r3, #12]
 800d5d6:	429a      	cmp	r2, r3
 800d5d8:	d102      	bne.n	800d5e0 <_put+0x20>
    return MSG_RESET;
 800d5da:	f06f 0301 	mvn.w	r3, #1
 800d5de:	e00d      	b.n	800d5fc <_put+0x3c>
  *(msp->buffer + msp->eos) = b;
 800d5e0:	9b03      	ldr	r3, [sp, #12]
 800d5e2:	685a      	ldr	r2, [r3, #4]
 800d5e4:	9b03      	ldr	r3, [sp, #12]
 800d5e6:	68db      	ldr	r3, [r3, #12]
 800d5e8:	4413      	add	r3, r2
 800d5ea:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800d5ee:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 800d5f0:	9b03      	ldr	r3, [sp, #12]
 800d5f2:	68db      	ldr	r3, [r3, #12]
 800d5f4:	1c5a      	adds	r2, r3, #1
 800d5f6:	9b03      	ldr	r3, [sp, #12]
 800d5f8:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 800d5fa:	2300      	movs	r3, #0
}
 800d5fc:	4618      	mov	r0, r3
 800d5fe:	b004      	add	sp, #16
 800d600:	4770      	bx	lr
 800d602:	bf00      	nop
 800d604:	f3af 8000 	nop.w
 800d608:	f3af 8000 	nop.w
 800d60c:	f3af 8000 	nop.w

0800d610 <_get>:

static msg_t _get(void *ip) {
 800d610:	b084      	sub	sp, #16
 800d612:	9001      	str	r0, [sp, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 800d614:	9b01      	ldr	r3, [sp, #4]
 800d616:	9303      	str	r3, [sp, #12]

  if (msp->eos - msp->offset <= 0)
 800d618:	9b03      	ldr	r3, [sp, #12]
 800d61a:	68da      	ldr	r2, [r3, #12]
 800d61c:	9b03      	ldr	r3, [sp, #12]
 800d61e:	691b      	ldr	r3, [r3, #16]
 800d620:	429a      	cmp	r2, r3
 800d622:	d102      	bne.n	800d62a <_get+0x1a>
    return MSG_RESET;
 800d624:	f06f 0301 	mvn.w	r3, #1
 800d628:	e00e      	b.n	800d648 <_get+0x38>
  b = *(msp->buffer + msp->offset);
 800d62a:	9b03      	ldr	r3, [sp, #12]
 800d62c:	685a      	ldr	r2, [r3, #4]
 800d62e:	9b03      	ldr	r3, [sp, #12]
 800d630:	691b      	ldr	r3, [r3, #16]
 800d632:	4413      	add	r3, r2
 800d634:	781b      	ldrb	r3, [r3, #0]
 800d636:	f88d 300b 	strb.w	r3, [sp, #11]
  msp->offset += 1;
 800d63a:	9b03      	ldr	r3, [sp, #12]
 800d63c:	691b      	ldr	r3, [r3, #16]
 800d63e:	1c5a      	adds	r2, r3, #1
 800d640:	9b03      	ldr	r3, [sp, #12]
 800d642:	611a      	str	r2, [r3, #16]
  return b;
 800d644:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800d648:	4618      	mov	r0, r3
 800d64a:	b004      	add	sp, #16
 800d64c:	4770      	bx	lr
 800d64e:	bf00      	nop

0800d650 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 800d650:	b084      	sub	sp, #16
 800d652:	9003      	str	r0, [sp, #12]
 800d654:	9102      	str	r1, [sp, #8]
 800d656:	9201      	str	r2, [sp, #4]
 800d658:	9300      	str	r3, [sp, #0]

  msp->vmt    = &vmt;
 800d65a:	9b03      	ldr	r3, [sp, #12]
 800d65c:	4a07      	ldr	r2, [pc, #28]	; (800d67c <msObjectInit+0x2c>)
 800d65e:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 800d660:	9b03      	ldr	r3, [sp, #12]
 800d662:	9a02      	ldr	r2, [sp, #8]
 800d664:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 800d666:	9b03      	ldr	r3, [sp, #12]
 800d668:	9a01      	ldr	r2, [sp, #4]
 800d66a:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 800d66c:	9b03      	ldr	r3, [sp, #12]
 800d66e:	9a00      	ldr	r2, [sp, #0]
 800d670:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 800d672:	9b03      	ldr	r3, [sp, #12]
 800d674:	2200      	movs	r2, #0
 800d676:	611a      	str	r2, [r3, #16]
}
 800d678:	b004      	add	sp, #16
 800d67a:	4770      	bx	lr
 800d67c:	0800fab4 	.word	0x0800fab4

0800d680 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 800d680:	b084      	sub	sp, #16
 800d682:	9003      	str	r0, [sp, #12]
 800d684:	9102      	str	r1, [sp, #8]
 800d686:	9201      	str	r2, [sp, #4]

  (void)ip;
  (void)bp;

  return n;
 800d688:	9b01      	ldr	r3, [sp, #4]
}
 800d68a:	4618      	mov	r0, r3
 800d68c:	b004      	add	sp, #16
 800d68e:	4770      	bx	lr

0800d690 <reads>:

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 800d690:	b084      	sub	sp, #16
 800d692:	9003      	str	r0, [sp, #12]
 800d694:	9102      	str	r1, [sp, #8]
 800d696:	9201      	str	r2, [sp, #4]

  (void)ip;
  (void)bp;
  (void)n;

  return 0;
 800d698:	2300      	movs	r3, #0
}
 800d69a:	4618      	mov	r0, r3
 800d69c:	b004      	add	sp, #16
 800d69e:	4770      	bx	lr

0800d6a0 <put>:

static msg_t put(void *ip, uint8_t b) {
 800d6a0:	b082      	sub	sp, #8
 800d6a2:	9001      	str	r0, [sp, #4]
 800d6a4:	460b      	mov	r3, r1
 800d6a6:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ip;
  (void)b;

  return MSG_OK;
 800d6aa:	2300      	movs	r3, #0
}
 800d6ac:	4618      	mov	r0, r3
 800d6ae:	b002      	add	sp, #8
 800d6b0:	4770      	bx	lr
 800d6b2:	bf00      	nop
 800d6b4:	f3af 8000 	nop.w
 800d6b8:	f3af 8000 	nop.w
 800d6bc:	f3af 8000 	nop.w

0800d6c0 <get>:

static msg_t get(void *ip) {
 800d6c0:	b082      	sub	sp, #8
 800d6c2:	9001      	str	r0, [sp, #4]

  (void)ip;

  return 4;
 800d6c4:	2304      	movs	r3, #4
}
 800d6c6:	4618      	mov	r0, r3
 800d6c8:	b002      	add	sp, #8
 800d6ca:	4770      	bx	lr
 800d6cc:	f3af 8000 	nop.w

0800d6d0 <nullObjectInit>:
/**
 * @brief   Null stream object initialization.
 *
 * @param[out] nsp      pointer to the @p NullStream object to be initialized
 */
void nullObjectInit(NullStream *nsp) {
 800d6d0:	b082      	sub	sp, #8
 800d6d2:	9001      	str	r0, [sp, #4]

  nsp->vmt = &vmt;
 800d6d4:	9b01      	ldr	r3, [sp, #4]
 800d6d6:	4a02      	ldr	r2, [pc, #8]	; (800d6e0 <nullObjectInit+0x10>)
 800d6d8:	601a      	str	r2, [r3, #0]
}
 800d6da:	b002      	add	sp, #8
 800d6dc:	4770      	bx	lr
 800d6de:	bf00      	nop
 800d6e0:	0800fac4 	.word	0x0800fac4
	...

0800d6f0 <main>:


/*
 * Application entry point.
 */
int main(void) {
 800d6f0:	b510      	push	{r4, lr}
 800d6f2:	b084      	sub	sp, #16
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 800d6f4:	f7f6 fb8c 	bl	8003e10 <halInit>
  chSysInit();
 800d6f8:	f7f2 fff2 	bl	80006e0 <chSysInit>

  int16_t buff[3];

  while(1){

       AccelerometerInit();
 800d6fc:	f000 f828 	bl	800d750 <AccelerometerInit>
       AccelerometerConfig(BW_XL_50 | FS_XL_2 | ODR_XL_104);
 800d700:	2203      	movs	r2, #3
 800d702:	2300      	movs	r3, #0
 800d704:	4313      	orrs	r3, r2
 800d706:	b2db      	uxtb	r3, r3
 800d708:	2240      	movs	r2, #64	; 0x40
 800d70a:	4313      	orrs	r3, r2
 800d70c:	b2db      	uxtb	r3, r3
 800d70e:	4618      	mov	r0, r3
 800d710:	f000 f84e 	bl	800d7b0 <AccelerometerConfig>
       AccelerometerGetValues(buff);
 800d714:	ab02      	add	r3, sp, #8
 800d716:	4618      	mov	r0, r3
 800d718:	f000 f87a 	bl	800d810 <AccelerometerGetValues>



       chprintf((BaseSequentialStream *)&SD3, "%d, %d, %d \r\n",buff[0],buff[1], buff[2]);
 800d71c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 800d720:	b21a      	sxth	r2, r3
 800d722:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 800d726:	b21c      	sxth	r4, r3
 800d728:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 800d72c:	b21b      	sxth	r3, r3
 800d72e:	9300      	str	r3, [sp, #0]
 800d730:	4804      	ldr	r0, [pc, #16]	; (800d744 <main+0x54>)
 800d732:	4905      	ldr	r1, [pc, #20]	; (800d748 <main+0x58>)
 800d734:	4623      	mov	r3, r4
 800d736:	f7ff fe9b 	bl	800d470 <chprintf>
       chThdSleepMilliseconds(100);
 800d73a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d73e:	f7f3 ffef 	bl	8001720 <chThdSleep>

    }
 800d742:	e7db      	b.n	800d6fc <main+0xc>
 800d744:	20000c2c 	.word	0x20000c2c
 800d748:	0800fae8 	.word	0x0800fae8
 800d74c:	00000000 	.word	0x00000000

0800d750 <AccelerometerInit>:

#define device_address 0x6a
#define acceleration_control_1_address 0x10


int AccelerometerInit(){
 800d750:	b508      	push	{r3, lr}
        STD_DUTY_CYCLE,
    };



    palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 800d752:	4813      	ldr	r0, [pc, #76]	; (800d7a0 <AccelerometerInit+0x50>)
 800d754:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d758:	f240 2206 	movw	r2, #518	; 0x206
 800d75c:	f7f8 fc78 	bl	8006050 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 800d760:	480f      	ldr	r0, [pc, #60]	; (800d7a0 <AccelerometerInit+0x50>)
 800d762:	f44f 7100 	mov.w	r1, #512	; 0x200
 800d766:	f240 2206 	movw	r2, #518	; 0x206
 800d76a:	f7f8 fc71 	bl	8006050 <_pal_lld_setgroupmode>

    palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(7) );
 800d76e:	480c      	ldr	r0, [pc, #48]	; (800d7a0 <AccelerometerInit+0x50>)
 800d770:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800d774:	f240 3282 	movw	r2, #898	; 0x382
 800d778:	f7f8 fc6a 	bl	8006050 <_pal_lld_setgroupmode>
     palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(7) );
 800d77c:	4808      	ldr	r0, [pc, #32]	; (800d7a0 <AccelerometerInit+0x50>)
 800d77e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800d782:	f240 3282 	movw	r2, #898	; 0x382
 800d786:	f7f8 fc63 	bl	8006050 <_pal_lld_setgroupmode>

    i2cStart(&I2CD1, &i2ccfg);
 800d78a:	4806      	ldr	r0, [pc, #24]	; (800d7a4 <AccelerometerInit+0x54>)
 800d78c:	4906      	ldr	r1, [pc, #24]	; (800d7a8 <AccelerometerInit+0x58>)
 800d78e:	f7f7 fc6f 	bl	8005070 <i2cStart>
    sdStart(&SD3, NULL);
 800d792:	4806      	ldr	r0, [pc, #24]	; (800d7ac <AccelerometerInit+0x5c>)
 800d794:	2100      	movs	r1, #0
 800d796:	f7f7 fec3 	bl	8005520 <sdStart>

    return 1;
 800d79a:	2301      	movs	r3, #1

}
 800d79c:	4618      	mov	r0, r3
 800d79e:	bd08      	pop	{r3, pc}
 800d7a0:	40020400 	.word	0x40020400
 800d7a4:	20000b78 	.word	0x20000b78
 800d7a8:	0800fb0c 	.word	0x0800fb0c
 800d7ac:	20000c2c 	.word	0x20000c2c

0800d7b0 <AccelerometerConfig>:
    XL_HM_MODE default = 0
    write byte: 0b01000011 normal 104Hz +-2g 50Hz filter (0x43)
    default powered down
 */

int AccelerometerConfig(uint8_t writeByte){
 800d7b0:	b500      	push	{lr}
 800d7b2:	b08b      	sub	sp, #44	; 0x2c
 800d7b4:	4603      	mov	r3, r0
 800d7b6:	f88d 3017 	strb.w	r3, [sp, #23]



    uint8_t control_1_write_byte = writeByte;
 800d7ba:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800d7be:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27

    volatile uint8_t regcontent;

    uint8_t data[2] = {acceleration_control_1_address, control_1_write_byte};
 800d7c2:	2310      	movs	r3, #16
 800d7c4:	f88d 301c 	strb.w	r3, [sp, #28]
 800d7c8:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 800d7cc:	f88d 301d 	strb.w	r3, [sp, #29]
    uint8_t *transmit;
    transmit = data;
 800d7d0:	ab07      	add	r3, sp, #28
 800d7d2:	9308      	str	r3, [sp, #32]
    volatile msg_t err = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 2, (uint8_t *) &regcontent, 0, MS2ST(1000));
 800d7d4:	f10d 031f 	add.w	r3, sp, #31
 800d7d8:	9300      	str	r3, [sp, #0]
 800d7da:	2300      	movs	r3, #0
 800d7dc:	9301      	str	r3, [sp, #4]
 800d7de:	f242 7310 	movw	r3, #10000	; 0x2710
 800d7e2:	9302      	str	r3, [sp, #8]
 800d7e4:	4806      	ldr	r0, [pc, #24]	; (800d800 <AccelerometerConfig+0x50>)
 800d7e6:	216a      	movs	r1, #106	; 0x6a
 800d7e8:	9a08      	ldr	r2, [sp, #32]
 800d7ea:	2302      	movs	r3, #2
 800d7ec:	f7f7 fc78 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d7f0:	4603      	mov	r3, r0
 800d7f2:	9306      	str	r3, [sp, #24]

    (void) err;
 800d7f4:	9b06      	ldr	r3, [sp, #24]

    return 1;
 800d7f6:	2301      	movs	r3, #1

}
 800d7f8:	4618      	mov	r0, r3
 800d7fa:	b00b      	add	sp, #44	; 0x2c
 800d7fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800d800:	20000b78 	.word	0x20000b78
 800d804:	f3af 8000 	nop.w
 800d808:	f3af 8000 	nop.w
 800d80c:	f3af 8000 	nop.w

0800d810 <AccelerometerGetValues>:
 * merges two unsigned bytes into signed 16 bit value
 * (value/32766)*scale if value is positive, or (value/32767)*scale if value is negative
 * that number is in g's where scale is set in accelerometer config
 *
 */
int AccelerometerGetValues(int16_t* buff){
 800d810:	b500      	push	{lr}
 800d812:	b095      	sub	sp, #84	; 0x54
 800d814:	9005      	str	r0, [sp, #20]

    uint8_t z0_data;
    uint8_t z1_data;

    //x axis output LSbyte
    uint8_t x0 = 0x28;
 800d816:	2328      	movs	r3, #40	; 0x28
 800d818:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    //x axis output MSbyte
    uint8_t x1 = 0x29;
 800d81c:	2329      	movs	r3, #41	; 0x29
 800d81e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44

    //y axis output LSbyte
    uint8_t y0 = 0x2A;
 800d822:	232a      	movs	r3, #42	; 0x2a
 800d824:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    //y axis output MSbyte
    uint8_t y1 = 0x2B;
 800d828:	232b      	movs	r3, #43	; 0x2b
 800d82a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42

    //z axis output LSbyte
    uint8_t z0 = 0x2C;
 800d82e:	232c      	movs	r3, #44	; 0x2c
 800d830:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
    //z axis output MSbyte
    uint8_t z1 = 0x2D;
 800d834:	232d      	movs	r3, #45	; 0x2d
 800d836:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40

    volatile uint8_t regcontent;

    uint8_t *transmit;
    transmit = &x0;
 800d83a:	f10d 0345 	add.w	r3, sp, #69	; 0x45
 800d83e:	9313      	str	r3, [sp, #76]	; 0x4c

    volatile msg_t err2 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d840:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d844:	9300      	str	r3, [sp, #0]
 800d846:	2301      	movs	r3, #1
 800d848:	9301      	str	r3, [sp, #4]
 800d84a:	f242 7310 	movw	r3, #10000	; 0x2710
 800d84e:	9302      	str	r3, [sp, #8]
 800d850:	4862      	ldr	r0, [pc, #392]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d852:	216a      	movs	r1, #106	; 0x6a
 800d854:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d856:	2301      	movs	r3, #1
 800d858:	f7f7 fc42 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d85c:	4603      	mov	r3, r0
 800d85e:	930e      	str	r3, [sp, #56]	; 0x38
    x0_data = regcontent;
 800d860:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d864:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b

    transmit = &x1;
 800d868:	ab11      	add	r3, sp, #68	; 0x44
 800d86a:	9313      	str	r3, [sp, #76]	; 0x4c
    volatile msg_t err3 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d86c:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d870:	9300      	str	r3, [sp, #0]
 800d872:	2301      	movs	r3, #1
 800d874:	9301      	str	r3, [sp, #4]
 800d876:	f242 7310 	movw	r3, #10000	; 0x2710
 800d87a:	9302      	str	r3, [sp, #8]
 800d87c:	4857      	ldr	r0, [pc, #348]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d87e:	216a      	movs	r1, #106	; 0x6a
 800d880:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d882:	2301      	movs	r3, #1
 800d884:	f7f7 fc2c 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d888:	4603      	mov	r3, r0
 800d88a:	930d      	str	r3, [sp, #52]	; 0x34
    x1_data = regcontent;
 800d88c:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d890:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a

    transmit = &y0;
 800d894:	f10d 0343 	add.w	r3, sp, #67	; 0x43
 800d898:	9313      	str	r3, [sp, #76]	; 0x4c
    volatile msg_t err4 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d89a:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d89e:	9300      	str	r3, [sp, #0]
 800d8a0:	2301      	movs	r3, #1
 800d8a2:	9301      	str	r3, [sp, #4]
 800d8a4:	f242 7310 	movw	r3, #10000	; 0x2710
 800d8a8:	9302      	str	r3, [sp, #8]
 800d8aa:	484c      	ldr	r0, [pc, #304]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d8ac:	216a      	movs	r1, #106	; 0x6a
 800d8ae:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d8b0:	2301      	movs	r3, #1
 800d8b2:	f7f7 fc15 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d8b6:	4603      	mov	r3, r0
 800d8b8:	930c      	str	r3, [sp, #48]	; 0x30
    y0_data = regcontent;
 800d8ba:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d8be:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49

    transmit = &y1;
 800d8c2:	f10d 0342 	add.w	r3, sp, #66	; 0x42
 800d8c6:	9313      	str	r3, [sp, #76]	; 0x4c
    volatile msg_t err5 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d8c8:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d8cc:	9300      	str	r3, [sp, #0]
 800d8ce:	2301      	movs	r3, #1
 800d8d0:	9301      	str	r3, [sp, #4]
 800d8d2:	f242 7310 	movw	r3, #10000	; 0x2710
 800d8d6:	9302      	str	r3, [sp, #8]
 800d8d8:	4840      	ldr	r0, [pc, #256]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d8da:	216a      	movs	r1, #106	; 0x6a
 800d8dc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d8de:	2301      	movs	r3, #1
 800d8e0:	f7f7 fbfe 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d8e4:	4603      	mov	r3, r0
 800d8e6:	930b      	str	r3, [sp, #44]	; 0x2c
    y1_data = regcontent;
 800d8e8:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d8ec:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48

    transmit = &z0;
 800d8f0:	f10d 0341 	add.w	r3, sp, #65	; 0x41
 800d8f4:	9313      	str	r3, [sp, #76]	; 0x4c
    volatile msg_t err6 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d8f6:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d8fa:	9300      	str	r3, [sp, #0]
 800d8fc:	2301      	movs	r3, #1
 800d8fe:	9301      	str	r3, [sp, #4]
 800d900:	f242 7310 	movw	r3, #10000	; 0x2710
 800d904:	9302      	str	r3, [sp, #8]
 800d906:	4835      	ldr	r0, [pc, #212]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d908:	216a      	movs	r1, #106	; 0x6a
 800d90a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d90c:	2301      	movs	r3, #1
 800d90e:	f7f7 fbe7 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d912:	4603      	mov	r3, r0
 800d914:	930a      	str	r3, [sp, #40]	; 0x28
    z0_data = regcontent;
 800d916:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d91a:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47

    transmit = &z1;
 800d91e:	ab10      	add	r3, sp, #64	; 0x40
 800d920:	9313      	str	r3, [sp, #76]	; 0x4c
    volatile msg_t err7 = i2cMasterTransmitTimeout(&I2CD1, device_address, transmit, 1, (uint8_t *) &regcontent, 1, MS2ST(1000));
 800d922:	f10d 033f 	add.w	r3, sp, #63	; 0x3f
 800d926:	9300      	str	r3, [sp, #0]
 800d928:	2301      	movs	r3, #1
 800d92a:	9301      	str	r3, [sp, #4]
 800d92c:	f242 7310 	movw	r3, #10000	; 0x2710
 800d930:	9302      	str	r3, [sp, #8]
 800d932:	482a      	ldr	r0, [pc, #168]	; (800d9dc <AccelerometerGetValues+0x1cc>)
 800d934:	216a      	movs	r1, #106	; 0x6a
 800d936:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d938:	2301      	movs	r3, #1
 800d93a:	f7f7 fbd1 	bl	80050e0 <i2cMasterTransmitTimeout>
 800d93e:	4603      	mov	r3, r0
 800d940:	9309      	str	r3, [sp, #36]	; 0x24
    z1_data = regcontent;
 800d942:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800d946:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46

    uint16_t u_x_data = (x1_data << 8)|x0_data;
 800d94a:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
 800d94e:	021b      	lsls	r3, r3, #8
 800d950:	b29a      	uxth	r2, r3
 800d952:	f89d 304b 	ldrb.w	r3, [sp, #75]	; 0x4b
 800d956:	b29b      	uxth	r3, r3
 800d958:	4313      	orrs	r3, r2
 800d95a:	b29b      	uxth	r3, r3
 800d95c:	b29b      	uxth	r3, r3
 800d95e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    int16_t x_data;
    memcpy(&x_data, &u_x_data, sizeof(u_x_data));
 800d962:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 800d966:	f8ad 3020 	strh.w	r3, [sp, #32]

    uint16_t u_y_data = (y1_data << 8)|y0_data;
 800d96a:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 800d96e:	021b      	lsls	r3, r3, #8
 800d970:	b29a      	uxth	r2, r3
 800d972:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
 800d976:	b29b      	uxth	r3, r3
 800d978:	4313      	orrs	r3, r2
 800d97a:	b29b      	uxth	r3, r3
 800d97c:	b29b      	uxth	r3, r3
 800d97e:	f8ad 301e 	strh.w	r3, [sp, #30]
    int16_t y_data;
    memcpy(&y_data, &u_y_data, sizeof(u_y_data));
 800d982:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800d986:	f8ad 301c 	strh.w	r3, [sp, #28]

    uint16_t u_z_data = (z1_data << 8)|z0_data;
 800d98a:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
 800d98e:	021b      	lsls	r3, r3, #8
 800d990:	b29a      	uxth	r2, r3
 800d992:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
 800d996:	b29b      	uxth	r3, r3
 800d998:	4313      	orrs	r3, r2
 800d99a:	b29b      	uxth	r3, r3
 800d99c:	b29b      	uxth	r3, r3
 800d99e:	f8ad 301a 	strh.w	r3, [sp, #26]
    int16_t z_data;
    memcpy(&z_data, &u_z_data, sizeof(u_z_data));
 800d9a2:	f8bd 301a 	ldrh.w	r3, [sp, #26]
 800d9a6:	f8ad 3018 	strh.w	r3, [sp, #24]

    buff[0] = x_data;
 800d9aa:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 800d9ae:	9b05      	ldr	r3, [sp, #20]
 800d9b0:	801a      	strh	r2, [r3, #0]
    buff[1] = y_data;
 800d9b2:	9b05      	ldr	r3, [sp, #20]
 800d9b4:	3302      	adds	r3, #2
 800d9b6:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 800d9ba:	801a      	strh	r2, [r3, #0]
    buff[2] = z_data;
 800d9bc:	9b05      	ldr	r3, [sp, #20]
 800d9be:	3304      	adds	r3, #4
 800d9c0:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 800d9c4:	801a      	strh	r2, [r3, #0]

    (void) err2;
 800d9c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    (void) err3;
 800d9c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    (void) err4;
 800d9ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    (void) err5;
 800d9cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    (void) err6;
 800d9ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    (void) err7;
 800d9d0:	9b09      	ldr	r3, [sp, #36]	; 0x24

    return 1;
 800d9d2:	2301      	movs	r3, #1


}
 800d9d4:	4618      	mov	r0, r3
 800d9d6:	b015      	add	sp, #84	; 0x54
 800d9d8:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9dc:	20000b78 	.word	0x20000b78

0800d9e0 <memcpy>:
 800d9e0:	4684      	mov	ip, r0
 800d9e2:	ea41 0300 	orr.w	r3, r1, r0
 800d9e6:	f013 0303 	ands.w	r3, r3, #3
 800d9ea:	d16d      	bne.n	800dac8 <memcpy+0xe8>
 800d9ec:	3a40      	subs	r2, #64	; 0x40
 800d9ee:	d341      	bcc.n	800da74 <memcpy+0x94>
 800d9f0:	f851 3b04 	ldr.w	r3, [r1], #4
 800d9f4:	f840 3b04 	str.w	r3, [r0], #4
 800d9f8:	f851 3b04 	ldr.w	r3, [r1], #4
 800d9fc:	f840 3b04 	str.w	r3, [r0], #4
 800da00:	f851 3b04 	ldr.w	r3, [r1], #4
 800da04:	f840 3b04 	str.w	r3, [r0], #4
 800da08:	f851 3b04 	ldr.w	r3, [r1], #4
 800da0c:	f840 3b04 	str.w	r3, [r0], #4
 800da10:	f851 3b04 	ldr.w	r3, [r1], #4
 800da14:	f840 3b04 	str.w	r3, [r0], #4
 800da18:	f851 3b04 	ldr.w	r3, [r1], #4
 800da1c:	f840 3b04 	str.w	r3, [r0], #4
 800da20:	f851 3b04 	ldr.w	r3, [r1], #4
 800da24:	f840 3b04 	str.w	r3, [r0], #4
 800da28:	f851 3b04 	ldr.w	r3, [r1], #4
 800da2c:	f840 3b04 	str.w	r3, [r0], #4
 800da30:	f851 3b04 	ldr.w	r3, [r1], #4
 800da34:	f840 3b04 	str.w	r3, [r0], #4
 800da38:	f851 3b04 	ldr.w	r3, [r1], #4
 800da3c:	f840 3b04 	str.w	r3, [r0], #4
 800da40:	f851 3b04 	ldr.w	r3, [r1], #4
 800da44:	f840 3b04 	str.w	r3, [r0], #4
 800da48:	f851 3b04 	ldr.w	r3, [r1], #4
 800da4c:	f840 3b04 	str.w	r3, [r0], #4
 800da50:	f851 3b04 	ldr.w	r3, [r1], #4
 800da54:	f840 3b04 	str.w	r3, [r0], #4
 800da58:	f851 3b04 	ldr.w	r3, [r1], #4
 800da5c:	f840 3b04 	str.w	r3, [r0], #4
 800da60:	f851 3b04 	ldr.w	r3, [r1], #4
 800da64:	f840 3b04 	str.w	r3, [r0], #4
 800da68:	f851 3b04 	ldr.w	r3, [r1], #4
 800da6c:	f840 3b04 	str.w	r3, [r0], #4
 800da70:	3a40      	subs	r2, #64	; 0x40
 800da72:	d2bd      	bcs.n	800d9f0 <memcpy+0x10>
 800da74:	3230      	adds	r2, #48	; 0x30
 800da76:	d311      	bcc.n	800da9c <memcpy+0xbc>
 800da78:	f851 3b04 	ldr.w	r3, [r1], #4
 800da7c:	f840 3b04 	str.w	r3, [r0], #4
 800da80:	f851 3b04 	ldr.w	r3, [r1], #4
 800da84:	f840 3b04 	str.w	r3, [r0], #4
 800da88:	f851 3b04 	ldr.w	r3, [r1], #4
 800da8c:	f840 3b04 	str.w	r3, [r0], #4
 800da90:	f851 3b04 	ldr.w	r3, [r1], #4
 800da94:	f840 3b04 	str.w	r3, [r0], #4
 800da98:	3a10      	subs	r2, #16
 800da9a:	d2ed      	bcs.n	800da78 <memcpy+0x98>
 800da9c:	320c      	adds	r2, #12
 800da9e:	d305      	bcc.n	800daac <memcpy+0xcc>
 800daa0:	f851 3b04 	ldr.w	r3, [r1], #4
 800daa4:	f840 3b04 	str.w	r3, [r0], #4
 800daa8:	3a04      	subs	r2, #4
 800daaa:	d2f9      	bcs.n	800daa0 <memcpy+0xc0>
 800daac:	3204      	adds	r2, #4
 800daae:	d008      	beq.n	800dac2 <memcpy+0xe2>
 800dab0:	07d2      	lsls	r2, r2, #31
 800dab2:	bf1c      	itt	ne
 800dab4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800dab8:	f800 3b01 	strbne.w	r3, [r0], #1
 800dabc:	d301      	bcc.n	800dac2 <memcpy+0xe2>
 800dabe:	880b      	ldrh	r3, [r1, #0]
 800dac0:	8003      	strh	r3, [r0, #0]
 800dac2:	4660      	mov	r0, ip
 800dac4:	4770      	bx	lr
 800dac6:	bf00      	nop
 800dac8:	2a08      	cmp	r2, #8
 800daca:	d313      	bcc.n	800daf4 <memcpy+0x114>
 800dacc:	078b      	lsls	r3, r1, #30
 800dace:	d08d      	beq.n	800d9ec <memcpy+0xc>
 800dad0:	f010 0303 	ands.w	r3, r0, #3
 800dad4:	d08a      	beq.n	800d9ec <memcpy+0xc>
 800dad6:	f1c3 0304 	rsb	r3, r3, #4
 800dada:	1ad2      	subs	r2, r2, r3
 800dadc:	07db      	lsls	r3, r3, #31
 800dade:	bf1c      	itt	ne
 800dae0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800dae4:	f800 3b01 	strbne.w	r3, [r0], #1
 800dae8:	d380      	bcc.n	800d9ec <memcpy+0xc>
 800daea:	f831 3b02 	ldrh.w	r3, [r1], #2
 800daee:	f820 3b02 	strh.w	r3, [r0], #2
 800daf2:	e77b      	b.n	800d9ec <memcpy+0xc>
 800daf4:	3a04      	subs	r2, #4
 800daf6:	d3d9      	bcc.n	800daac <memcpy+0xcc>
 800daf8:	3a01      	subs	r2, #1
 800dafa:	f811 3b01 	ldrb.w	r3, [r1], #1
 800dafe:	f800 3b01 	strb.w	r3, [r0], #1
 800db02:	d2f9      	bcs.n	800daf8 <memcpy+0x118>
 800db04:	780b      	ldrb	r3, [r1, #0]
 800db06:	7003      	strb	r3, [r0, #0]
 800db08:	784b      	ldrb	r3, [r1, #1]
 800db0a:	7043      	strb	r3, [r0, #1]
 800db0c:	788b      	ldrb	r3, [r1, #2]
 800db0e:	7083      	strb	r3, [r0, #2]
 800db10:	4660      	mov	r0, ip
 800db12:	4770      	bx	lr
	...
 800db20:	eba2 0003 	sub.w	r0, r2, r3
 800db24:	4770      	bx	lr
 800db26:	bf00      	nop

0800db28 <strcmp>:
 800db28:	7802      	ldrb	r2, [r0, #0]
 800db2a:	780b      	ldrb	r3, [r1, #0]
 800db2c:	2a01      	cmp	r2, #1
 800db2e:	bf28      	it	cs
 800db30:	429a      	cmpcs	r2, r3
 800db32:	d1f5      	bne.n	800db20 <memcpy+0x140>
 800db34:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 800db38:	ea40 0401 	orr.w	r4, r0, r1
 800db3c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 800db40:	f06f 0c00 	mvn.w	ip, #0
 800db44:	ea4f 7244 	mov.w	r2, r4, lsl #29
 800db48:	b312      	cbz	r2, 800db90 <strcmp+0x68>
 800db4a:	ea80 0401 	eor.w	r4, r0, r1
 800db4e:	f014 0f07 	tst.w	r4, #7
 800db52:	d16a      	bne.n	800dc2a <strcmp+0x102>
 800db54:	f000 0407 	and.w	r4, r0, #7
 800db58:	f020 0007 	bic.w	r0, r0, #7
 800db5c:	f004 0503 	and.w	r5, r4, #3
 800db60:	f021 0107 	bic.w	r1, r1, #7
 800db64:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800db68:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800db6c:	f014 0f04 	tst.w	r4, #4
 800db70:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 800db74:	fa0c f405 	lsl.w	r4, ip, r5
 800db78:	ea62 0204 	orn	r2, r2, r4
 800db7c:	ea66 0604 	orn	r6, r6, r4
 800db80:	d00a      	beq.n	800db98 <strcmp+0x70>
 800db82:	ea63 0304 	orn	r3, r3, r4
 800db86:	4662      	mov	r2, ip
 800db88:	ea67 0704 	orn	r7, r7, r4
 800db8c:	4666      	mov	r6, ip
 800db8e:	e003      	b.n	800db98 <strcmp+0x70>
 800db90:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800db94:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 800db98:	fa82 f54c 	uadd8	r5, r2, ip
 800db9c:	ea82 0406 	eor.w	r4, r2, r6
 800dba0:	faa4 f48c 	sel	r4, r4, ip
 800dba4:	bb6c      	cbnz	r4, 800dc02 <strcmp+0xda>
 800dba6:	fa83 f54c 	uadd8	r5, r3, ip
 800dbaa:	ea83 0507 	eor.w	r5, r3, r7
 800dbae:	faa5 f58c 	sel	r5, r5, ip
 800dbb2:	b995      	cbnz	r5, 800dbda <strcmp+0xb2>
 800dbb4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 800dbb8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800dbbc:	fa82 f54c 	uadd8	r5, r2, ip
 800dbc0:	ea82 0406 	eor.w	r4, r2, r6
 800dbc4:	faa4 f48c 	sel	r4, r4, ip
 800dbc8:	fa83 f54c 	uadd8	r5, r3, ip
 800dbcc:	ea83 0507 	eor.w	r5, r3, r7
 800dbd0:	faa5 f58c 	sel	r5, r5, ip
 800dbd4:	4325      	orrs	r5, r4
 800dbd6:	d0db      	beq.n	800db90 <strcmp+0x68>
 800dbd8:	b99c      	cbnz	r4, 800dc02 <strcmp+0xda>
 800dbda:	ba2d      	rev	r5, r5
 800dbdc:	fab5 f485 	clz	r4, r5
 800dbe0:	f024 0407 	bic.w	r4, r4, #7
 800dbe4:	fa27 f104 	lsr.w	r1, r7, r4
 800dbe8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800dbec:	fa23 f304 	lsr.w	r3, r3, r4
 800dbf0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 800dbf4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800dbf8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800dbfc:	eba0 0001 	sub.w	r0, r0, r1
 800dc00:	4770      	bx	lr
 800dc02:	ba24      	rev	r4, r4
 800dc04:	fab4 f484 	clz	r4, r4
 800dc08:	f024 0407 	bic.w	r4, r4, #7
 800dc0c:	fa26 f104 	lsr.w	r1, r6, r4
 800dc10:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800dc14:	fa22 f204 	lsr.w	r2, r2, r4
 800dc18:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800dc1c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800dc20:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800dc24:	eba0 0001 	sub.w	r0, r0, r1
 800dc28:	4770      	bx	lr
 800dc2a:	f014 0f03 	tst.w	r4, #3
 800dc2e:	d13c      	bne.n	800dcaa <strcmp+0x182>
 800dc30:	f010 0403 	ands.w	r4, r0, #3
 800dc34:	d128      	bne.n	800dc88 <strcmp+0x160>
 800dc36:	f850 2b08 	ldr.w	r2, [r0], #8
 800dc3a:	f851 3b08 	ldr.w	r3, [r1], #8
 800dc3e:	fa82 f54c 	uadd8	r5, r2, ip
 800dc42:	ea82 0503 	eor.w	r5, r2, r3
 800dc46:	faa5 f58c 	sel	r5, r5, ip
 800dc4a:	b95d      	cbnz	r5, 800dc64 <strcmp+0x13c>
 800dc4c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800dc50:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800dc54:	fa82 f54c 	uadd8	r5, r2, ip
 800dc58:	ea82 0503 	eor.w	r5, r2, r3
 800dc5c:	faa5 f58c 	sel	r5, r5, ip
 800dc60:	2d00      	cmp	r5, #0
 800dc62:	d0e8      	beq.n	800dc36 <strcmp+0x10e>
 800dc64:	ba2d      	rev	r5, r5
 800dc66:	fab5 f485 	clz	r4, r5
 800dc6a:	f024 0407 	bic.w	r4, r4, #7
 800dc6e:	fa23 f104 	lsr.w	r1, r3, r4
 800dc72:	fa22 f204 	lsr.w	r2, r2, r4
 800dc76:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800dc7a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800dc7e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800dc82:	eba0 0001 	sub.w	r0, r0, r1
 800dc86:	4770      	bx	lr
 800dc88:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800dc8c:	f020 0003 	bic.w	r0, r0, #3
 800dc90:	f850 2b08 	ldr.w	r2, [r0], #8
 800dc94:	f021 0103 	bic.w	r1, r1, #3
 800dc98:	f851 3b08 	ldr.w	r3, [r1], #8
 800dc9c:	fa0c f404 	lsl.w	r4, ip, r4
 800dca0:	ea62 0204 	orn	r2, r2, r4
 800dca4:	ea63 0304 	orn	r3, r3, r4
 800dca8:	e7c9      	b.n	800dc3e <strcmp+0x116>
 800dcaa:	f010 0403 	ands.w	r4, r0, #3
 800dcae:	d01a      	beq.n	800dce6 <strcmp+0x1be>
 800dcb0:	eba1 0104 	sub.w	r1, r1, r4
 800dcb4:	f020 0003 	bic.w	r0, r0, #3
 800dcb8:	07e4      	lsls	r4, r4, #31
 800dcba:	f850 2b04 	ldr.w	r2, [r0], #4
 800dcbe:	d006      	beq.n	800dcce <strcmp+0x1a6>
 800dcc0:	d20f      	bcs.n	800dce2 <strcmp+0x1ba>
 800dcc2:	788b      	ldrb	r3, [r1, #2]
 800dcc4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 800dcc8:	1ae4      	subs	r4, r4, r3
 800dcca:	d106      	bne.n	800dcda <strcmp+0x1b2>
 800dccc:	b12b      	cbz	r3, 800dcda <strcmp+0x1b2>
 800dcce:	78cb      	ldrb	r3, [r1, #3]
 800dcd0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 800dcd4:	1ae4      	subs	r4, r4, r3
 800dcd6:	d100      	bne.n	800dcda <strcmp+0x1b2>
 800dcd8:	b91b      	cbnz	r3, 800dce2 <strcmp+0x1ba>
 800dcda:	4620      	mov	r0, r4
 800dcdc:	f85d 4b10 	ldr.w	r4, [sp], #16
 800dce0:	4770      	bx	lr
 800dce2:	f101 0104 	add.w	r1, r1, #4
 800dce6:	f850 2b04 	ldr.w	r2, [r0], #4
 800dcea:	07cc      	lsls	r4, r1, #31
 800dcec:	f021 0103 	bic.w	r1, r1, #3
 800dcf0:	f851 3b04 	ldr.w	r3, [r1], #4
 800dcf4:	d848      	bhi.n	800dd88 <strcmp+0x260>
 800dcf6:	d224      	bcs.n	800dd42 <strcmp+0x21a>
 800dcf8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800dcfc:	fa82 f54c 	uadd8	r5, r2, ip
 800dd00:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 800dd04:	faa5 f58c 	sel	r5, r5, ip
 800dd08:	d10a      	bne.n	800dd20 <strcmp+0x1f8>
 800dd0a:	b965      	cbnz	r5, 800dd26 <strcmp+0x1fe>
 800dd0c:	f851 3b04 	ldr.w	r3, [r1], #4
 800dd10:	ea84 0402 	eor.w	r4, r4, r2
 800dd14:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 800dd18:	d10e      	bne.n	800dd38 <strcmp+0x210>
 800dd1a:	f850 2b04 	ldr.w	r2, [r0], #4
 800dd1e:	e7eb      	b.n	800dcf8 <strcmp+0x1d0>
 800dd20:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800dd24:	e055      	b.n	800ddd2 <strcmp+0x2aa>
 800dd26:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800dd2a:	d14d      	bne.n	800ddc8 <strcmp+0x2a0>
 800dd2c:	7808      	ldrb	r0, [r1, #0]
 800dd2e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800dd32:	f1c0 0000 	rsb	r0, r0, #0
 800dd36:	4770      	bx	lr
 800dd38:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800dd3c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 800dd40:	e047      	b.n	800ddd2 <strcmp+0x2aa>
 800dd42:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 800dd46:	fa82 f54c 	uadd8	r5, r2, ip
 800dd4a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800dd4e:	faa5 f58c 	sel	r5, r5, ip
 800dd52:	d10a      	bne.n	800dd6a <strcmp+0x242>
 800dd54:	b965      	cbnz	r5, 800dd70 <strcmp+0x248>
 800dd56:	f851 3b04 	ldr.w	r3, [r1], #4
 800dd5a:	ea84 0402 	eor.w	r4, r4, r2
 800dd5e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 800dd62:	d10c      	bne.n	800dd7e <strcmp+0x256>
 800dd64:	f850 2b04 	ldr.w	r2, [r0], #4
 800dd68:	e7eb      	b.n	800dd42 <strcmp+0x21a>
 800dd6a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800dd6e:	e030      	b.n	800ddd2 <strcmp+0x2aa>
 800dd70:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 800dd74:	d128      	bne.n	800ddc8 <strcmp+0x2a0>
 800dd76:	880b      	ldrh	r3, [r1, #0]
 800dd78:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800dd7c:	e029      	b.n	800ddd2 <strcmp+0x2aa>
 800dd7e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800dd82:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 800dd86:	e024      	b.n	800ddd2 <strcmp+0x2aa>
 800dd88:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800dd8c:	fa82 f54c 	uadd8	r5, r2, ip
 800dd90:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 800dd94:	faa5 f58c 	sel	r5, r5, ip
 800dd98:	d10a      	bne.n	800ddb0 <strcmp+0x288>
 800dd9a:	b965      	cbnz	r5, 800ddb6 <strcmp+0x28e>
 800dd9c:	f851 3b04 	ldr.w	r3, [r1], #4
 800dda0:	ea84 0402 	eor.w	r4, r4, r2
 800dda4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 800dda8:	d109      	bne.n	800ddbe <strcmp+0x296>
 800ddaa:	f850 2b04 	ldr.w	r2, [r0], #4
 800ddae:	e7eb      	b.n	800dd88 <strcmp+0x260>
 800ddb0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800ddb4:	e00d      	b.n	800ddd2 <strcmp+0x2aa>
 800ddb6:	f015 0fff 	tst.w	r5, #255	; 0xff
 800ddba:	d105      	bne.n	800ddc8 <strcmp+0x2a0>
 800ddbc:	680b      	ldr	r3, [r1, #0]
 800ddbe:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ddc2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800ddc6:	e004      	b.n	800ddd2 <strcmp+0x2aa>
 800ddc8:	f04f 0000 	mov.w	r0, #0
 800ddcc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800ddd0:	4770      	bx	lr
 800ddd2:	ba12      	rev	r2, r2
 800ddd4:	ba1b      	rev	r3, r3
 800ddd6:	fa82 f44c 	uadd8	r4, r2, ip
 800ddda:	ea82 0403 	eor.w	r4, r2, r3
 800ddde:	faa4 f58c 	sel	r5, r4, ip
 800dde2:	fab5 f485 	clz	r4, r5
 800dde6:	fa02 f204 	lsl.w	r2, r2, r4
 800ddea:	fa03 f304 	lsl.w	r3, r3, r4
 800ddee:	ea4f 6012 	mov.w	r0, r2, lsr #24
 800ddf2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800ddf6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800ddfa:	4770      	bx	lr
 800ddfc:	f3af 8000 	nop.w
